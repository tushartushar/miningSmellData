Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,FloatCompare,The method has 107 lines of code.
Complex Method,Mosa.Platform.x86.Instructions,Mov,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Mov.cs,ComputeOpCode,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Platform.x86.Stages,FinalTweakTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FinalTweakTransformationStage.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Platform.x86.Stages,SimpleDeadCodeRemovalStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\SimpleDeadCodeRemovalStage.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Platform.x86.Stages,SimpleDeadCodeRemovalStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\SimpleDeadCodeRemovalStage.cs,Move,Cyclomatic complexity of the method is 14
Long Parameter List,Mosa.Platform.x86,Architecture,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Architecture.cs,InsertCompoundCopy,The method has 7 parameters. Parameters: compiler' context' destinationBase' destination' sourceBase' source' size
Long Parameter List,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendConditionalREXPrefix,The method has 5 parameters. Parameters: include' w' r' x' b
Long Parameter List,Mosa.Platform.x86.Stages,IRSubstitutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRSubstitutionStage.cs,ReplaceWithDivisionCall,The method has 5 parameters. Parameters: node' methodName' result' operand1' operand2
Long Parameter List,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,CopyCompound,The method has 6 parameters. Parameters: context' type' destinationBase' destination' sourceBase' source
Long Identifier,Mosa.Platform.x86.CompilerStages,Multiboot0695Stage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\Multiboot0695Stage.cs,,The length of the parameter HEADER_MB_FLAG_MODULES_PAGE_ALIGNED is 35.
Long Identifier,Mosa.Platform.x86.CompilerStages,Multiboot0695Stage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\Multiboot0695Stage.cs,,The length of the parameter HEADER_MB_FLAG_MEMORY_INFO_REQUIRED is 35.
Long Identifier,Mosa.Platform.x86.CompilerStages,Multiboot0695Stage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\Multiboot0695Stage.cs,,The length of the parameter HEADER_MB_FLAG_VIDEO_MODES_REQUIRED is 35.
Long Statement,Mosa.Platform.x86,Architecture,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Architecture.cs,CreateArchitecture,The length of the statement  "				architectureFeatures = ArchitectureFeatureFlags.MMX | ArchitectureFeatureFlags.SSE | ArchitectureFeatureFlags.SSE2 | ArchitectureFeatureFlags.SSE3 | ArchitectureFeatureFlags.SSE4; " is 179.
Long Statement,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitFarJumpToNextInstruction,The length of the statement  "			linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.Text' MethodName' (int)codeStream.Position + 6); " is 168.
Long Statement,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteDisplacement,The length of the statement  "				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.ROData' displacement.Name' 0); " is 150.
Long Statement,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteDisplacement,The length of the statement  "				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' section' displacement.Field.FullName' 0); " is 149.
Long Statement,Mosa.Platform.x86.Instructions,MovzxLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\MovzxLoad.cs,MovzxMemoryToReg,The length of the statement  "				.AppendConditionalIntegerValue(node.Operand1.IsConstant && !node.Operand1.IsLinkerResolved' node.Operand1.ConstantUnsignedInteger); // 32:memory " is 144.
Long Statement,Mosa.Platform.x86.Instructions,MovsxLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\MovsxLoad.cs,MovsxMemoryToReg,The length of the statement  "				.AppendConditionalIntegerValue(node.Operand1.IsConstant && !node.Operand1.IsLinkerResolved' node.Operand1.ConstantUnsignedInteger); // 32:memory " is 144.
Long Statement,Mosa.Platform.x86.Instructions,Mov,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Mov.cs,ComputeOpCode,The length of the statement  "				Debug.Assert(!((source.IsByte || destination.IsByte) && (source.Register == GeneralPurposeRegister.ESI || source.Register == GeneralPurposeRegister.EDI))' source.ToString()); " is 174.
Long Statement,Mosa.Platform.x86.Intrinsic,FrameJump,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\FrameJump.cs,ReplaceIntrinsicCall,The length of the statement  "			Operand exceptionRegister = Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.Object' methodCompiler.Architecture.ExceptionRegister); " is 143.
Long Statement,Mosa.Platform.x86.Intrinsic,GetCS,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetCS.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(X86.Mov' v1' Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.U4' SegmentRegister.CS)); " is 121.
Long Statement,Mosa.Platform.x86.Intrinsic,GetFS,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetFS.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(X86.Mov' v1' Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.U4' SegmentRegister.FS)); " is 121.
Long Statement,Mosa.Platform.x86.Intrinsic,GetExceptionRegister,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetExceptionRegister.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(X86.Mov' context.Result' Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.Object' methodCompiler.Architecture.ExceptionRegister)); " is 164.
Long Statement,Mosa.Platform.x86.Intrinsic,GetMethodExceptionLookupTable,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetMethodExceptionLookupTable.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(IRInstruction.MoveInteger' context.Result' Operand.CreateUnmanagedSymbolPointer(Metadata.MethodExceptionLookupTable' methodCompiler.TypeSystem)); " is 168.
Long Statement,Mosa.Platform.x86.Intrinsic,LockSet,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\LockSet.cs,ReplaceIntrinsicCall,The length of the statement  "			var size = BaseMethodCompilerStage.GetInstructionSize(context.Size' context.InvokeMethod.Signature.Parameters[1].ParameterType); " is 128.
Long Statement,Mosa.Platform.x86.Intrinsic,Remainder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\Remainder.cs,ReplaceIntrinsicCall,The length of the statement  "				context.AppendInstruction(X86.Roundsd' size' xmm2' xmm1' Operand.CreateConstant(methodCompiler.TypeSystem.BuiltIn.U1' 0x3)); " is 124.
Long Statement,Mosa.Platform.x86.Intrinsic,Remainder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\Remainder.cs,ReplaceIntrinsicCall,The length of the statement  "				context.AppendInstruction(X86.Roundss' size' xmm2' xmm1' Operand.CreateConstant(methodCompiler.TypeSystem.BuiltIn.U1' 0x3)); " is 124.
Long Statement,Mosa.Platform.x86.Intrinsic,SetFS,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\SetFS.cs,ReplaceIntrinsicCall,The length of the statement  "			context.AppendInstruction(X86.Mov' Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.U4' SegmentRegister.FS)' v1); " is 124.
Long Statement,Mosa.Platform.x86.Intrinsic,GetEBP,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetEBP.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(X86.Mov' context.Result' Operand.CreateCPURegister(methodCompiler.TypeSystem.BuiltIn.U4' GeneralPurposeRegister.EBP)); " is 141.
Long Statement,Mosa.Platform.x86.Intrinsic,GetMethodLookupTable,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetMethodLookupTable.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(IRInstruction.MoveInteger' context.Result' Operand.CreateUnmanagedSymbolPointer(Metadata.MethodLookupTable' methodCompiler.TypeSystem)); " is 159.
Long Statement,Mosa.Platform.x86.Intrinsic,Set,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\Set.cs,ReplaceIntrinsicCall,The length of the statement  "			var size = BaseMethodCompilerStage.GetInstructionSize(context.Size' context.InvokeMethod.Signature.Parameters[1].ParameterType); " is 128.
Long Statement,Mosa.Platform.x86.Intrinsic,GetIDTJumpLocation,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\GetIDTJumpLocation.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(IRInstruction.MoveInteger' context.Result' Operand.CreateSymbolFromMethod(method' methodCompiler.TypeSystem)); " is 133.
Long Statement,Mosa.Platform.x86.Stages,FinalTweakTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FinalTweakTransformationStage.cs,Mov,The length of the statement  "			if (source.IsCPURegister && (source.Register == GeneralPurposeRegister.ESI || source.Register == GeneralPurposeRegister.EDI)) " is 125.
Long Statement,Mosa.Platform.x86.Stages,FinalTweakTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FinalTweakTransformationStage.cs,MovStore,The length of the statement  "			if (value.IsCPURegister && (value.Register == GeneralPurposeRegister.ESI || value.Register == GeneralPurposeRegister.EDI)) " is 122.
Long Statement,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,CopyCompound,The length of the statement  "			Architecture.InsertCompoundCopy(MethodCompiler' context' destinationBase' destination' sourceBase' source' TypeLayout.GetTypeSize(type)); " is 137.
Long Statement,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodLookupTable,The length of the statement  "			var methodtable = Linker.CreateSymbol("<$>methodLookupTable"' SectionKind.ROData' TypeLayout.NativePointerAlignment' size); " is 123.
Long Statement,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodLookupTable,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' PatchType.I4' methodtable' (int)stream.Position' SectionKind.Text' entry.Name' 0); " is 120.
Long Statement,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodLookupTable,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' PatchType.I4' methodtable' (int)stream.Position' SectionKind.ROData' entry.Name + "$mdtable"' 0); " is 135.
Long Statement,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodDescriptionEntries,The length of the statement  "				var section = Linker.CreateSymbol(method.FullName + "$mdtable"' SectionKind.ROData' TypeLayout.NativePointerAlignment' size); " is 125.
Complex Conditional,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteImmediate,The conditional expression  "op.IsU4 || op.IsPointer || op.IsU || !op.IsValueType"  is complex.
Complex Conditional,Mosa.Platform.x86.Instructions,Xchg,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Xchg.cs,ComputeOpCode,The conditional expression  "destination.IsShort && source.IsShort && destination.IsCPURegister && source.IsCPURegister"  is complex.
Complex Conditional,Mosa.Platform.x86.Instructions,Mov,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Mov.cs,ComputeOpCode,The conditional expression  "source.IsChar || destination.IsChar || source.IsShort || destination.IsShort"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,FixedRegisterAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FixedRegisterAssignmentStage.cs,Div,The conditional expression  "context.Result.IsCPURegister  				&& context.Result2.IsCPURegister  				&& context.Operand1.IsCPURegister  				&& context.Result.Register == GeneralPurposeRegister.EDX  				&& context.Result2.Register == GeneralPurposeRegister.EAX  				&& context.Operand1.Register == GeneralPurposeRegister.EDX  				&& context.Operand2.Register == GeneralPurposeRegister.EAX"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,FixedRegisterAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FixedRegisterAssignmentStage.cs,IDiv,The conditional expression  "context.Result.IsCPURegister  				&& context.Result2.IsCPURegister  				&& context.Operand1.IsCPURegister  				&& context.Operand2.IsCPURegister  				&& context.Result.Register == GeneralPurposeRegister.EDX  				&& context.Result2.Register == GeneralPurposeRegister.EAX  				&& context.Operand1.Register == GeneralPurposeRegister.EDX  				&& context.Operand2.Register == GeneralPurposeRegister.EAX"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,FixedRegisterAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FixedRegisterAssignmentStage.cs,In,The conditional expression  "context.Result.IsCPURegister  				&& context.Operand1.IsCPURegister  				&& context.Result.Register == GeneralPurposeRegister.EAX  				&& (context.Operand1.Register == GeneralPurposeRegister.EDX || context.Operand1.IsConstant)"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,FixedRegisterAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FixedRegisterAssignmentStage.cs,Mul,The conditional expression  "context.Result.IsCPURegister  				&& context.Result2.IsCPURegister  				&& context.Operand1.IsCPURegister  				&& !context.Operand2.IsConstant  				&& context.Result.Register == GeneralPurposeRegister.EDX  				&& context.Result2.Register == GeneralPurposeRegister.EAX  				&& context.Operand1.Register == GeneralPurposeRegister.EAX"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,FixedRegisterAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\FixedRegisterAssignmentStage.cs,Out,The conditional expression  "context.Operand1.IsCPURegister  				&& context.Operand2.IsCPURegister  				&& (context.Operand1.Register == GeneralPurposeRegister.EDX || context.Operand1.IsConstant)  				&& context.Operand2.Register == GeneralPurposeRegister.EAX"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandSignedMove,The conditional expression  "op1.IsI4 || op1.IsU4 || op1.IsPointer || op1.IsI || op1.IsU"  is complex.
Complex Conditional,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandUnsignedMove,The conditional expression  "op1.IsBoolean || op1.IsChar || op1.IsU1 || op1.IsU2"  is complex.
Magic Number,Mosa.Platform.x86,Architecture,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Architecture.cs,InsertCompoundCopy,The following statement contains a magic number: const int LargeAlignment = 16;
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitCallSite,The following statement contains a magic number: linker.Link(  				LinkType.RelativeOffset'  				PatchType.I4'  				SectionKind.Text'  				MethodName'  				(int)codeStream.Position'  				SectionKind.Text'  				symbolOperand.Name'  				-4  			);
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitCallSite,The following statement contains a magic number: codeStream.WriteZeroBytes(4);
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitRelativeBranchTarget,The following statement contains a magic number: if (TryGetLabel(label' out position))  			{  				// Yes' calculate the relative offset  				relOffset = position - ((int)codeStream.Position + 4);  			}  			else  			{  				// Forward jump' we can't resolve yet - store a patch  				AddPatch(label' (int)codeStream.Position);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,ResolvePatches,The following statement contains a magic number: foreach (var p in patches)  			{  				int labelPosition;  				if (!TryGetLabel(p.Label' out labelPosition))  				{  					throw new ArgumentException("Missing label while resolving patches."' "label=" + labelPosition.ToString());  				}    				codeStream.Position = p.Position;    				// Compute relative branch offset  				int relOffset = labelPosition - ((int)p.Position + 4);    				// Write relative offset to stream  				var bytes = BitConverter.GetBytes(relOffset);  				codeStream.Write(bytes' 0' bytes.Length);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitFarJumpToNextInstruction,The following statement contains a magic number: linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.Text' MethodName' (int)codeStream.Position + 6);
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,EmitFarJumpToNextInstruction,The following statement contains a magic number: codeStream.WriteZeroBytes(4);
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteDisplacement,The following statement contains a magic number: if (displacement.IsLabel)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);    				// FIXME! remove assertion  				Debug.Assert(displacement.Offset == 0);    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.ROData' displacement.Name' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsStaticField)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = displacement.Field.Data != null ? SectionKind.ROData : SectionKind.BSS;    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' section' displacement.Field.FullName' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsSymbol)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = (displacement.Method != null) ? SectionKind.Text : SectionKind.ROData;    				// First try finding the symbol in the expected section  				var symbol = linker.FindSymbol(displacement.Name' section);    				// If no symbol found' look in all sections  				if (symbol == null)  				{  					symbol = linker.FindSymbol(displacement.Name);  				}    				// Otherwise create the symbol in the expected section  				if (symbol == null)  				{  					symbol = linker.GetSymbol(displacement.Name' section);  				}    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' symbol' 0);  				codeStream.WriteZeroBytes(4);  			}  			else  			{  				codeStream.Write((int)displacement.Offset' Endianness.Little);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteDisplacement,The following statement contains a magic number: if (displacement.IsLabel)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);    				// FIXME! remove assertion  				Debug.Assert(displacement.Offset == 0);    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.ROData' displacement.Name' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsStaticField)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = displacement.Field.Data != null ? SectionKind.ROData : SectionKind.BSS;    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' section' displacement.Field.FullName' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsSymbol)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = (displacement.Method != null) ? SectionKind.Text : SectionKind.ROData;    				// First try finding the symbol in the expected section  				var symbol = linker.FindSymbol(displacement.Name' section);    				// If no symbol found' look in all sections  				if (symbol == null)  				{  					symbol = linker.FindSymbol(displacement.Name);  				}    				// Otherwise create the symbol in the expected section  				if (symbol == null)  				{  					symbol = linker.GetSymbol(displacement.Name' section);  				}    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' symbol' 0);  				codeStream.WriteZeroBytes(4);  			}  			else  			{  				codeStream.Write((int)displacement.Offset' Endianness.Little);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,WriteDisplacement,The following statement contains a magic number: if (displacement.IsLabel)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);    				// FIXME! remove assertion  				Debug.Assert(displacement.Offset == 0);    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' SectionKind.ROData' displacement.Name' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsStaticField)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = displacement.Field.Data != null ? SectionKind.ROData : SectionKind.BSS;    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' section' displacement.Field.FullName' 0);  				codeStream.WriteZeroBytes(4);  			}  			else if (displacement.IsSymbol)  			{  				Debug.Assert(displacement.IsUnresolvedConstant);  				var section = (displacement.Method != null) ? SectionKind.Text : SectionKind.ROData;    				// First try finding the symbol in the expected section  				var symbol = linker.FindSymbol(displacement.Name' section);    				// If no symbol found' look in all sections  				if (symbol == null)  				{  					symbol = linker.FindSymbol(displacement.Name);  				}    				// Otherwise create the symbol in the expected section  				if (symbol == null)  				{  					symbol = linker.GetSymbol(displacement.Name' section);  				}    				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' (int)codeStream.Position' symbol' 0);  				codeStream.WriteZeroBytes(4);  			}  			else  			{  				codeStream.Write((int)displacement.Offset' Endianness.Little);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (regField != null)  				modRM = (byte)(regField.Value << 3);
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (op1IsRegister && op2IsRegister)  			{  				// mod = 11b' reg = rop1' r/m = rop2  				modRM = (byte)((3 << 6) | (op1.Register.RegisterCode << 3) | op2.Register.RegisterCode);  			}  			else if (op1IsRegister)  			{  				modRM = (byte)(modRM.GetValueOrDefault() | (3 << 6) | op1.Register.RegisterCode);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (op1IsRegister && op2IsRegister)  			{  				// mod = 11b' reg = rop1' r/m = rop2  				modRM = (byte)((3 << 6) | (op1.Register.RegisterCode << 3) | op2.Register.RegisterCode);  			}  			else if (op1IsRegister)  			{  				modRM = (byte)(modRM.GetValueOrDefault() | (3 << 6) | op1.Register.RegisterCode);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (op1IsRegister && op2IsRegister)  			{  				// mod = 11b' reg = rop1' r/m = rop2  				modRM = (byte)((3 << 6) | (op1.Register.RegisterCode << 3) | op2.Register.RegisterCode);  			}  			else if (op1IsRegister)  			{  				modRM = (byte)(modRM.GetValueOrDefault() | (3 << 6) | op1.Register.RegisterCode);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (op1IsRegister && op2IsRegister)  			{  				// mod = 11b' reg = rop1' r/m = rop2  				modRM = (byte)((3 << 6) | (op1.Register.RegisterCode << 3) | op2.Register.RegisterCode);  			}  			else if (op1IsRegister)  			{  				modRM = (byte)(modRM.GetValueOrDefault() | (3 << 6) | op1.Register.RegisterCode);  			}
Magic Number,Mosa.Platform.x86,X86CodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\X86CodeEmitter.cs,CalculateModRM,The following statement contains a magic number: if (op1IsRegister && op2IsRegister)  			{  				// mod = 11b' reg = rop1' r/m = rop2  				modRM = (byte)((3 << 6) | (op1.Register.RegisterCode << 3) | op2.Register.RegisterCode);  			}  			else if (op1IsRegister)  			{  				modRM = (byte)(modRM.GetValueOrDefault() | (3 << 6) | op1.Register.RegisterCode);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,WriteTo,The following statement contains a magic number: Debug.Assert(Size % 8 == 0);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,WriteTo,The following statement contains a magic number: for (int i = 0; i < Size / 8; i++)  			{  				writer.WriteByte(GetByte(i));  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendNibble,The following statement contains a magic number: AppendBit((value >> 3) & 0x1);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendNibble,The following statement contains a magic number: AppendBit((value >> 2) & 0x1);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,Append3Bits,The following statement contains a magic number: AppendBit((value >> 2) & 0x1);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendByte,The following statement contains a magic number: return AppendBits(value' 8);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,Append8Bits,The following statement contains a magic number: return AppendBits(value' 8);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,Append16Bits,The following statement contains a magic number: return AppendBits(value' 16);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,Append32Bits,The following statement contains a magic number: return AppendBits(value' 32);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendByteValue,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  			{  				AppendBit((value >> i) & 1);  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 8) & 0xFF));
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 16) & 0xFF));
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 24) & 0xFF));
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendShortValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 8) & 0xFF));
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendConditionalPatchPlaceholder,The following statement contains a magic number: if (include)  			{  				position = (Size / 8);  				return AppendIntegerValue(0x0);  			}  			else  			{  				position = -1;  				return this;  			}
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: Debug.Assert(scale == 1 || scale == 2 || scale == 4 || scale == 8);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: Debug.Assert(scale == 1 || scale == 2 || scale == 4 || scale == 8);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: Debug.Assert(scale == 1 || scale == 2 || scale == 4 || scale == 8);
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: if (scale == 1)  				svalue = 0;  			else if (scale == 2)  				svalue = 1;  			else if (scale == 4)  				svalue = 2;  			else if (scale == 8)  				svalue = 3;
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: if (scale == 1)  				svalue = 0;  			else if (scale == 2)  				svalue = 1;  			else if (scale == 4)  				svalue = 2;  			else if (scale == 8)  				svalue = 3;
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: if (scale == 1)  				svalue = 0;  			else if (scale == 2)  				svalue = 1;  			else if (scale == 4)  				svalue = 2;  			else if (scale == 8)  				svalue = 3;
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: if (scale == 1)  				svalue = 0;  			else if (scale == 2)  				svalue = 1;  			else if (scale == 4)  				svalue = 2;  			else if (scale == 8)  				svalue = 3;
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: if (scale == 1)  				svalue = 0;  			else if (scale == 2)  				svalue = 1;  			else if (scale == 4)  				svalue = 2;  			else if (scale == 8)  				svalue = 3;
Magic Number,Mosa.Platform.x86,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\OpcodeEncoder.cs,AppendSIB,The following statement contains a magic number: AppendBits(svalue' 2);
Magic Number,Mosa.Platform.x86.Instructions,CmpXchgLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\CmpXchgLoad.cs,CmpXchg,The following statement contains a magic number: Debug.Assert(node.GetOperand(3).IsCPURegister);
Magic Number,Mosa.Platform.x86.Instructions,CmpXchgLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\CmpXchgLoad.cs,CmpXchg,The following statement contains a magic number: var opcode = new OpcodeEncoder()  				.AppendConditionalPrefix(node.Size == InstructionSize.Size16' 0x66)  // 8:prefix: 16bit  				.AppendNibble(Bits.b0000)                                       // 4:opcode  				.AppendNibble(Bits.b1111)                                       // 4:opcode  				.AppendNibble(Bits.b1011)                                       // 4:opcode  				.Append3Bits(Bits.b000)                                         // 3:opcode  				.AppendWidthBit(node.Size != InstructionSize.Size8)             // 1:width  				.ModRegRMSIBDisplacement(true' node.GetOperand(3)' node.Operand2' node.Operand3) // Mod-Reg-RM-?SIB-?Displacement  				.AppendConditionalIntegerValue(node.Operand2.IsLinkerResolved' 0);
Magic Number,Mosa.Platform.x86.Instructions,CmpXchgLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\CmpXchgLoad.cs,CmpXchg,The following statement contains a magic number: if (node.Operand2.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand2' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,CmpXchgLoad,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\CmpXchgLoad.cs,CmpXchg,The following statement contains a magic number: if (node.Operand2.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand2' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lea,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lea.cs,LeaAddress,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lea,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lea.cs,LeaAddress,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Movd,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Movd.cs,Emit,The following statement contains a magic number: var opcode = new OpcodeEncoder()  				.AppendNibble(Bits.b0110)                                       // 4:opcode  				.AppendNibble(Bits.b0110)                                       // 4:opcode    				.AppendNibble(Bits.b0000)                                       // 4:opcode  				.AppendNibble(Bits.b1111)                                       // 4:opcode    				.Append3Bits(Bits.b011)                                         // 3:opcode  				.AppendBit(node.Result.Register.Width != 128)                   // 1:direction  				.AppendNibble(Bits.b1110)                                       // 4:opcode    				.Append2Bits(Bits.b11)                                          // 2:opcode  				.AppendRM(node.Operand1)                                        // 3:r/m (source)  				.AppendRegister(node.Result.Register);
Magic Number,Mosa.Platform.x86.Instructions,Invlpg,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Invlpg.cs,InvlpgMemory,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Invlpg,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Invlpg.cs,InvlpgMemory,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lgdt,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lgdt.cs,LgdtMemoryConstant,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lgdt,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lgdt.cs,LgdtMemoryConstant,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lidt,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lidt.cs,LidtMemoryConstant,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Instructions,Lidt,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Instructions\Lidt.cs,LidtMemoryConstant,The following statement contains a magic number: if (node.Operand1.IsLinkerResolved)  				emitter.Emit(opcode' node.Operand1' (opcode.Size - 32) / 8);  			else  				emitter.Emit(opcode);
Magic Number,Mosa.Platform.x86.Intrinsic,FrameJump,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\FrameJump.cs,ReplaceIntrinsicCall,The following statement contains a magic number: Operand v3 = context.GetOperand(3);
Magic Number,Mosa.Platform.x86.Intrinsic,Memclr256,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\Memclr256.cs,ReplaceIntrinsicCall,The following statement contains a magic number: var offset16 = Operand.CreateConstant(16' methodCompiler.TypeSystem);
Magic Number,Mosa.Platform.x86.Intrinsic,Memcpy256,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Intrinsic\Memcpy256.cs,ReplaceIntrinsicCall,The following statement contains a magic number: var offset16 = Operand.CreateConstant(16' methodCompiler.TypeSystem);
Magic Number,Mosa.Platform.x86.Stages,BuildStackStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\BuildStackStage.cs,Run,The following statement contains a magic number: Debug.Assert((MethodCompiler.StackSize % 4) == 0' "Stack size of interrupt can't be divided by 4!!");
Magic Number,Mosa.Platform.x86.Stages,AddressModeConversionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\AddressModeConversionStage.cs,Run,The following statement contains a magic number: foreach (var block in BasicBlocks)  			{  				for (var node = block.First; !node.IsBlockEndInstruction; node = node.Next)  				{  					if (!node.IsEmpty && node.OperandCount == 2 && node.ResultCount == 1)  					{  						ThreeTwoAddressConversion(node);  					}  				}  			}
Magic Number,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,FloatCompare,The following statement contains a magic number: switch (condition)  			{  				case ConditionCode.Equal:  					{  						//  a==b  						//	mov	eax' 1  						//	ucomisd	xmm0' xmm1  						//	jp	L3  						//	jne	L3  						//	ret  						//L3:  						//	mov	eax' 0    						var newBlocks = CreateNewBlockContexts(2);  						var nextBlock = Split(context);    						context.SetInstruction(X86.Mov' result' CreateConstant(1));  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Branch' ConditionCode.Parity' newBlocks[1].Block);  						context.AppendInstruction(X86.Jmp' newBlocks[0].Block);    						newBlocks[0].AppendInstruction(X86.Branch' ConditionCode.NotEqual' newBlocks[1].Block);  						newBlocks[0].AppendInstruction(X86.Jmp' nextBlock.Block);    						newBlocks[1].AppendInstruction(X86.Mov' result' ConstantZero);  						newBlocks[1].AppendInstruction(X86.Jmp' nextBlock.Block);  						break;  					}  				case ConditionCode.NotEqual:  					{  						//  a!=b  						//	mov	eax' 1  						//	ucomisd	xmm0' xmm1  						//	jp	L5  						//	setne	al  						//	movzx	eax' al  						//L5:    						var newBlocks = CreateNewBlockContexts(1);  						var nextBlock = Split(context);    						context.SetInstruction(X86.Mov' result' CreateConstant(1));  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Branch' ConditionCode.Parity' nextBlock.Block);  						context.AppendInstruction(X86.Jmp' newBlocks[0].Block);  						newBlocks[0].AppendInstruction(X86.Setcc' ConditionCode.NotEqual' result);    						//newBlocks[0].AppendInstruction(X86.Movzx' InstructionSize.Size8' result' result);  						newBlocks[0].AppendInstruction(X86.Jmp' nextBlock.Block);  						break;  					}  				case ConditionCode.LessThan:  					{  						//	a<b  						//	mov	eax' 0  						//	ucomisd	xmm1' xmm0  						//	seta	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' right' left);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterThan' result);  						break;  					}  				case ConditionCode.GreaterThan:  					{  						//	a>b  						//	mov	eax' 0  						//	ucomisd	xmm0' xmm1  						//	seta	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterThan' result);  						break;  					}  				case ConditionCode.LessOrEqual:  					{  						//	a<=b  						//	mov	eax' 0  						//	ucomisd	xmm1' xmm0  						//	setae	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' right' left);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterOrEqual' result);  						break;  					}  				case ConditionCode.GreaterOrEqual:  					{  						//	a>=b  						//	mov	eax' 0  						//	ucomisd	xmm0' xmm1  						//	setae	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterOrEqual' result);  						break;  					}  			}
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,Setup,The following statement contains a magic number: ConstantFour = CreateConstant(4);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: var newBlocks = CreateNewBlockContexts(6);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Cmp' null' ecx' CreateConstant(64));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[4].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Cmp' null' ecx' CreateConstant(32));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[3].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Jmp' newBlocks[2].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Shrd' eax' eax' edx' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Sar' edx' edx' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Mov' eax' edx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Sar' edx' edx' CreateConstant(0x1F));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.And' ecx' ecx' CreateConstant(0x1F));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Sar' eax' eax' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Sar' edx' edx' CreateConstant(0x1F));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Mov' eax' edx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Mov' op0H' edx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Mov' op0L' eax);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandArithmeticShiftRight,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandBinaryBranch,The following statement contains a magic number: var newBlocks = CreateNewBlockContexts(2);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: var newBlocks = CreateNewBlockContexts(4);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Branch' conditionCode' newBlocks[2].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Jmp' newBlocks[3].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Branch' conditionCode.GetUnsigned()' newBlocks[2].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Jmp' newBlocks[3].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Mov' op0' CreateConstant(1));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Mov' op0' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandComparison,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: var newBlocks = CreateNewBlockContexts(6);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Cmp' null' ecx' CreateConstant(64));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[4].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Cmp' null' ecx' CreateConstant(32));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[3].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[1].AppendInstruction(X86.Jmp' newBlocks[2].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Shld' edx' edx' eax' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Shl' eax' eax' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Mov' edx' eax);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Mov' eax' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.And' ecx' ecx' CreateConstant(0x1F));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Shl' edx' edx' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Mov' eax' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Mov' edx' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[4].AppendInstruction(X86.Jmp' newBlocks[5].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Mov' op0H' edx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Mov' op0L' eax);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftLeft,The following statement contains a magic number: newBlocks[5].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: var newBlocks = CreateNewBlockContexts(4);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: context.AppendInstruction(X86.Cmp' null' ecx' CreateConstant(64));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: context.AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[3].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Cmp' null' ecx' CreateConstant(32));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[0].AppendInstruction(X86.Branch' ConditionCode.UnsignedGreaterOrEqual' newBlocks[2].Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Mov' op0L' op1H);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: if (!op0H.IsConstantZero)  				newBlocks[2].AppendInstruction(X86.Mov' op0H' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.And' ecx' ecx' CreateConstant(0x1F));
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Sar' op0L' op0L' ecx);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[2].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Mov' op0L' op0H);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: if (!op0H.IsConstantZero)  				newBlocks[3].AppendInstruction(X86.Mov' op0H' ConstantZero);
Magic Number,Mosa.Platform.x86.Stages,LongOperandTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\LongOperandTransformationStage.cs,ExpandShiftRight,The following statement contains a magic number: newBlocks[3].AppendInstruction(X86.Jmp' nextBlock.Block);
Magic Number,Mosa.Platform.x86.CompilerStages,InterruptVectorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\InterruptVectorStage.cs,CreateInterruptVectors,The following statement contains a magic number: for (int i = 0; i <= 255; i++)  			{  				var basicBlocks = new BasicBlocks();  				var block = basicBlocks.CreateBlock();  				basicBlocks.AddHeadBlock(block);  				var ctx = new Context(block);    				ctx.AppendInstruction(X86.Cli);  				if (i <= 7 || (i >= 16 | i == 9)) // For IRQ 8' 10' 11' 12' 13' 14 the cpu will automatically pushed the error code  				{  					ctx.AppendInstruction(X86.Push' null' CreateConstant(0));  				}  				ctx.AppendInstruction(X86.Push' null' CreateConstant(i));  				ctx.AppendInstruction(X86.Pushad);  				ctx.AppendInstruction(X86.Push' null' esp);  				ctx.AppendInstruction(X86.Call' null' interrupt);  				ctx.AppendInstruction(X86.Pop' esp);  				ctx.AppendInstruction(X86.Popad);  				ctx.AppendInstruction(X86.Add' esp' esp' CreateConstant(8));  				ctx.AppendInstruction(X86.Sti);  				ctx.AppendInstruction(X86.IRetd);    				var interruptMethod = Compiler.CreateLinkerMethod("InterruptISR" + i.ToString());  				Compiler.CompileMethod(interruptMethod' basicBlocks);  			}
Magic Number,Mosa.Platform.x86.CompilerStages,InterruptVectorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\InterruptVectorStage.cs,CreateInterruptVectors,The following statement contains a magic number: for (int i = 0; i <= 255; i++)  			{  				var basicBlocks = new BasicBlocks();  				var block = basicBlocks.CreateBlock();  				basicBlocks.AddHeadBlock(block);  				var ctx = new Context(block);    				ctx.AppendInstruction(X86.Cli);  				if (i <= 7 || (i >= 16 | i == 9)) // For IRQ 8' 10' 11' 12' 13' 14 the cpu will automatically pushed the error code  				{  					ctx.AppendInstruction(X86.Push' null' CreateConstant(0));  				}  				ctx.AppendInstruction(X86.Push' null' CreateConstant(i));  				ctx.AppendInstruction(X86.Pushad);  				ctx.AppendInstruction(X86.Push' null' esp);  				ctx.AppendInstruction(X86.Call' null' interrupt);  				ctx.AppendInstruction(X86.Pop' esp);  				ctx.AppendInstruction(X86.Popad);  				ctx.AppendInstruction(X86.Add' esp' esp' CreateConstant(8));  				ctx.AppendInstruction(X86.Sti);  				ctx.AppendInstruction(X86.IRetd);    				var interruptMethod = Compiler.CreateLinkerMethod("InterruptISR" + i.ToString());  				Compiler.CompileMethod(interruptMethod' basicBlocks);  			}
Magic Number,Mosa.Platform.x86.CompilerStages,InterruptVectorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\InterruptVectorStage.cs,CreateInterruptVectors,The following statement contains a magic number: for (int i = 0; i <= 255; i++)  			{  				var basicBlocks = new BasicBlocks();  				var block = basicBlocks.CreateBlock();  				basicBlocks.AddHeadBlock(block);  				var ctx = new Context(block);    				ctx.AppendInstruction(X86.Cli);  				if (i <= 7 || (i >= 16 | i == 9)) // For IRQ 8' 10' 11' 12' 13' 14 the cpu will automatically pushed the error code  				{  					ctx.AppendInstruction(X86.Push' null' CreateConstant(0));  				}  				ctx.AppendInstruction(X86.Push' null' CreateConstant(i));  				ctx.AppendInstruction(X86.Pushad);  				ctx.AppendInstruction(X86.Push' null' esp);  				ctx.AppendInstruction(X86.Call' null' interrupt);  				ctx.AppendInstruction(X86.Pop' esp);  				ctx.AppendInstruction(X86.Popad);  				ctx.AppendInstruction(X86.Add' esp' esp' CreateConstant(8));  				ctx.AppendInstruction(X86.Sti);  				ctx.AppendInstruction(X86.IRetd);    				var interruptMethod = Compiler.CreateLinkerMethod("InterruptISR" + i.ToString());  				Compiler.CompileMethod(interruptMethod' basicBlocks);  			}
Magic Number,Mosa.Platform.x86.CompilerStages,InterruptVectorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\InterruptVectorStage.cs,CreateInterruptVectors,The following statement contains a magic number: for (int i = 0; i <= 255; i++)  			{  				var basicBlocks = new BasicBlocks();  				var block = basicBlocks.CreateBlock();  				basicBlocks.AddHeadBlock(block);  				var ctx = new Context(block);    				ctx.AppendInstruction(X86.Cli);  				if (i <= 7 || (i >= 16 | i == 9)) // For IRQ 8' 10' 11' 12' 13' 14 the cpu will automatically pushed the error code  				{  					ctx.AppendInstruction(X86.Push' null' CreateConstant(0));  				}  				ctx.AppendInstruction(X86.Push' null' CreateConstant(i));  				ctx.AppendInstruction(X86.Pushad);  				ctx.AppendInstruction(X86.Push' null' esp);  				ctx.AppendInstruction(X86.Call' null' interrupt);  				ctx.AppendInstruction(X86.Pop' esp);  				ctx.AppendInstruction(X86.Popad);  				ctx.AppendInstruction(X86.Add' esp' esp' CreateConstant(8));  				ctx.AppendInstruction(X86.Sti);  				ctx.AppendInstruction(X86.IRetd);    				var interruptMethod = Compiler.CreateLinkerMethod("InterruptISR" + i.ToString());  				Compiler.CompileMethod(interruptMethod' basicBlocks);  			}
Magic Number,Mosa.Platform.x86.CompilerStages,InterruptVectorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\InterruptVectorStage.cs,CreateInterruptVectors,The following statement contains a magic number: for (int i = 0; i <= 255; i++)  			{  				var basicBlocks = new BasicBlocks();  				var block = basicBlocks.CreateBlock();  				basicBlocks.AddHeadBlock(block);  				var ctx = new Context(block);    				ctx.AppendInstruction(X86.Cli);  				if (i <= 7 || (i >= 16 | i == 9)) // For IRQ 8' 10' 11' 12' 13' 14 the cpu will automatically pushed the error code  				{  					ctx.AppendInstruction(X86.Push' null' CreateConstant(0));  				}  				ctx.AppendInstruction(X86.Push' null' CreateConstant(i));  				ctx.AppendInstruction(X86.Pushad);  				ctx.AppendInstruction(X86.Push' null' esp);  				ctx.AppendInstruction(X86.Call' null' interrupt);  				ctx.AppendInstruction(X86.Pop' esp);  				ctx.AppendInstruction(X86.Popad);  				ctx.AppendInstruction(X86.Add' esp' esp' CreateConstant(8));  				ctx.AppendInstruction(X86.Sti);  				ctx.AppendInstruction(X86.IRetd);    				var interruptMethod = Compiler.CreateLinkerMethod("InterruptISR" + i.ToString());  				Compiler.CompileMethod(interruptMethod' basicBlocks);  			}
Magic Number,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodLookupTable,The following statement contains a magic number: var size = 3 * table.Count * TypeLayout.NativePointerSize + TypeLayout.NativePointerSize;
Magic Number,Mosa.Platform.x86.CompilerStages,MethodTableBuilderStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\MethodTableBuilderStage.cs,CreateMethodDescriptionEntries,The following statement contains a magic number: foreach (var method in methods)  			{  				int size = 3 * TypeLayout.NativePointerSize;    				var section = Linker.CreateSymbol(method.FullName + "$mdtable"' SectionKind.ROData' TypeLayout.NativePointerAlignment' size);  				var stream = section.Stream;    				// Pointer to Exception Handler Table  				// TODO: If there is no exception clause table' set to 0 and do not involve linker  				Linker.Link(LinkType.AbsoluteAddress' PatchType.I4' section' 0' SectionKind.ROData' method.FullName + "$etable"' 0);  				stream.Position += TypeLayout.NativePointerSize;    				// GC tracking info (not implemented yet)  				stream.WriteZeroBytes(TypeLayout.NativePointerSize);    				// Method's Parameter stack size  				stream.Write(DetermineSizeOfMethodParameters(method)' Endianness.Little); // FIXME  			}
Magic Number,Mosa.Platform.x86.CompilerStages,Multiboot0695Stage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\CompilerStages\Multiboot0695Stage.cs,RunPostCompile,The following statement contains a magic number: var four = CreateConstant(4);
Missing Default,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,FloatCompare,The following switch statement is missing a default case: switch (condition)  			{  				case ConditionCode.Equal: break;  				case ConditionCode.NotEqual: break;  				case ConditionCode.UnsignedGreaterOrEqual: condition = ConditionCode.GreaterOrEqual; break;  				case ConditionCode.UnsignedGreaterThan: condition = ConditionCode.GreaterThan; break;  				case ConditionCode.UnsignedLessOrEqual: condition = ConditionCode.LessOrEqual; break;  				case ConditionCode.UnsignedLessThan: condition = ConditionCode.LessThan; break;  			}
Missing Default,Mosa.Platform.x86.Stages,IRTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Platform.x86\Stages\IRTransformationStage.cs,FloatCompare,The following switch statement is missing a default case: switch (condition)  			{  				case ConditionCode.Equal:  					{  						//  a==b  						//	mov	eax' 1  						//	ucomisd	xmm0' xmm1  						//	jp	L3  						//	jne	L3  						//	ret  						//L3:  						//	mov	eax' 0    						var newBlocks = CreateNewBlockContexts(2);  						var nextBlock = Split(context);    						context.SetInstruction(X86.Mov' result' CreateConstant(1));  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Branch' ConditionCode.Parity' newBlocks[1].Block);  						context.AppendInstruction(X86.Jmp' newBlocks[0].Block);    						newBlocks[0].AppendInstruction(X86.Branch' ConditionCode.NotEqual' newBlocks[1].Block);  						newBlocks[0].AppendInstruction(X86.Jmp' nextBlock.Block);    						newBlocks[1].AppendInstruction(X86.Mov' result' ConstantZero);  						newBlocks[1].AppendInstruction(X86.Jmp' nextBlock.Block);  						break;  					}  				case ConditionCode.NotEqual:  					{  						//  a!=b  						//	mov	eax' 1  						//	ucomisd	xmm0' xmm1  						//	jp	L5  						//	setne	al  						//	movzx	eax' al  						//L5:    						var newBlocks = CreateNewBlockContexts(1);  						var nextBlock = Split(context);    						context.SetInstruction(X86.Mov' result' CreateConstant(1));  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Branch' ConditionCode.Parity' nextBlock.Block);  						context.AppendInstruction(X86.Jmp' newBlocks[0].Block);  						newBlocks[0].AppendInstruction(X86.Setcc' ConditionCode.NotEqual' result);    						//newBlocks[0].AppendInstruction(X86.Movzx' InstructionSize.Size8' result' result);  						newBlocks[0].AppendInstruction(X86.Jmp' nextBlock.Block);  						break;  					}  				case ConditionCode.LessThan:  					{  						//	a<b  						//	mov	eax' 0  						//	ucomisd	xmm1' xmm0  						//	seta	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' right' left);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterThan' result);  						break;  					}  				case ConditionCode.GreaterThan:  					{  						//	a>b  						//	mov	eax' 0  						//	ucomisd	xmm0' xmm1  						//	seta	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterThan' result);  						break;  					}  				case ConditionCode.LessOrEqual:  					{  						//	a<=b  						//	mov	eax' 0  						//	ucomisd	xmm1' xmm0  						//	setae	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' right' left);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterOrEqual' result);  						break;  					}  				case ConditionCode.GreaterOrEqual:  					{  						//	a>=b  						//	mov	eax' 0  						//	ucomisd	xmm0' xmm1  						//	setae	al    						context.SetInstruction(X86.Mov' result' ConstantZero);  						context.AppendInstruction(instruction' size' null' left' right);  						context.AppendInstruction(X86.Setcc' ConditionCode.UnsignedGreaterOrEqual' result);  						break;  					}  			}
