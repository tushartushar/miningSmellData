Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeSubstring,The method has 6 parameters. Parameters: b' parameterTypeString' substringStart' substringStop' genericTypeParameters' genericMethodParameters
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters); " is 120.
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters); " is 120.
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters); " is 120.
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "						// For multi-dimensional arrays' add "0:" default array bounds. Note that non-standard bounds are not possible via C# declaration. " is 130.
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters); " is 120.
Long Statement,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The length of the statement  "			AppendParameterTypeSubstring(b' parameterTypeString' substringStart' parameterTypeString.Length' genericTypeParameters' genericMethodParameters); " is 145.
Long Statement,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,Initialize,The length of the statement  "				CommandID menuCommandID2 = new CommandID(GuidList.guidILSpyAddInCmdSet' (int)PkgCmdIDList.cmdidOpenProjectOutputInILSpy); " is 121.
Long Statement,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,OpenReferenceInILSpyCallback_BeforeQueryStatus,The length of the statement  "				command.Visible = items.OfType<EnvDTE.UIHierarchyItem>().All(i => SupportedItems.Contains(i.Object.GetType().FullName) && HasProperties(((dynamic)i.Object).Properties' "Type"' "Version"' "ResolvedPath")); " is 204.
Long Statement,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,OpenReferenceInILSpyCallback,The length of the statement  "					path = GacInterop.FindAssemblyInNetGac(new AssemblyNameReference(reference.Name' reference.Version) { PublicKeyToken = token }); " is 128.
Long Statement,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,OpenCodeItemInILSpyCallback,The length of the statement  "				EnvDTE.vsCMElement.vsCMElementVariable'		// There is no vsCMElementField' fields are just variables outside of function scope. " is 126.
Long Statement,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,OpenAssembliesInILSpy,The length of the statement  "					ShowMessage("Could not find assembly '{0}'' please ensure the project and all references were built correctly!"' assemblyFileName); " is 131.
Complex Conditional,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,GetKey,The conditional expression  "(member.Kind == EnvDTE.vsCMElement.vsCMElementDelegate) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementEnum) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementInterface) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementStruct) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementClass)"  is complex.
Magic Number,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,GetKey,The following statement contains a magic number: if ((member.Kind == EnvDTE.vsCMElement.vsCMElementDelegate) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementEnum) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementInterface) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementStruct) ||  				(member.Kind == EnvDTE.vsCMElement.vsCMElementClass)) {  				b.Append("T:");  				AppendTypeName(b' member.FullName' true' false);  			}  			else if (member.Kind == EnvDTE.vsCMElement.vsCMElementNamespace){  				b.Append("N:");  				b.Append(member.FullName);  			}  			else {  				if (member.Kind == EnvDTE.vsCMElement.vsCMElementVariable)  					b.Append("F:");  				else if (member.Kind == EnvDTE.vsCMElement.vsCMElementProperty)  					b.Append("P:");  				else if (member.Kind == EnvDTE.vsCMElement.vsCMElementEvent)  					b.Append("E:");  				else if (member.Kind == EnvDTE.vsCMElement.vsCMElementFunction)  					b.Append("M:");    				int nameIndex = member.FullName.LastIndexOf(member.Name);  				string typeName = member.FullName.Substring(0' nameIndex - 1);  				string memberName = member.FullName.Substring(nameIndex);    				// Name substitutions for special cases.  				if (member.Kind == EnvDTE.vsCMElement.vsCMElementFunction) {  					EnvDTE80.CodeFunction2 mr = (EnvDTE80.CodeFunction2)member;  					if (mr.FunctionKind == EnvDTE.vsCMFunction.vsCMFunctionConstructor) {  						memberName = memberName.Replace(member.Name' "#ctor");  					}  					else if (mr.FunctionKind == EnvDTE.vsCMFunction.vsCMFunctionDestructor) {  						memberName = memberName.Replace(member.Name' "Finalize");  					}  					else if (mr.FunctionKind == EnvDTE.vsCMFunction.vsCMFunctionOperator) {  						if (memberName.StartsWith("implicit operator")) {  							memberName = "op_Implicit";  						}  						else if (memberName.StartsWith("explicit operator")) {  							memberName = "op_Explicit";  						}  						else {  							// NRefactory has a handy mapping we can make use of' just need to extract the operator symbol first.  							string[] memberNameWords = member.Name.Split(' ');  							if (memberNameWords.Length >= 2) {  								string operatorSymbol = memberNameWords[1];  								string operatorName = OperatorDeclaration.GetName(OperatorDeclaration.GetOperatorType(operatorSymbol));  								if (operatorName != null) {  									memberName = memberName.Replace(member.Name' operatorName);  								}  							}  						}  					}  				}  				else if (member.Kind == EnvDTE.vsCMElement.vsCMElementProperty) {  					if (member.Name == "this") {  						memberName = memberName.Replace(member.Name' "Item");  					}  				}    				string[] genericTypeParameters = AppendTypeName(b' typeName' true' false);  				b.Append('.');  				string[] genericMethodParameters = AppendTypeName(b' memberName.Replace('.'' '#')' true' true);  				EnvDTE.CodeElements parameters;  				EnvDTE.CodeTypeRef explicitReturnType = null;  				if (member.Kind == EnvDTE.vsCMElement.vsCMElementProperty) {  					parameters = ((EnvDTE.CodeProperty)member).Getter.Parameters;  				}  				else if (member.Kind == EnvDTE.vsCMElement.vsCMElementFunction) {  					EnvDTE80.CodeFunction2 mr = (EnvDTE80.CodeFunction2)member;  					parameters = mr.Parameters;  					if (memberName == "op_Implicit" || memberName == "op_Explicit") {  						explicitReturnType = mr.Type;  					}  				}  				else {  					parameters = null;  				}  				if (parameters != null && parameters.Count > 0) {  					b.Append('(');  					int i = 0;  					foreach (EnvDTE80.CodeParameter2 parameter in parameters) {  						if (i > 0) b.Append(''');  						AppendParameterTypeName(b' parameter' genericTypeParameters' genericMethodParameters);  						++i;  					}  					b.Append(')');  				}  				if (explicitReturnType != null) {  					b.Append('~');  					AppendTypeName(b' explicitReturnType.AsFullName' true' false);  				}  			}
Magic Number,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,GetReference,The following statement contains a magic number: switch (referenceType) {  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAReferenceItem":  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAProjectItem":  					values = GetProperties(projectItem.Properties' "Type"' "FusionName"' "ResolvedPath");  					if (values[0] == "Package") {  						values = GetProperties(projectItem.Properties' "Name"' "Version"' "Path");  						if (values[0] != null && values[1] != null && values[2] != null) {  							return new ReferenceInfo {  								Name = values[0]'  								Path = $"{values[2]}\\{values[0]}.{values[1]}.nupkg"  							};  						}  					} else if (values[2] != null) {  						return new ReferenceInfo { Path = values[2] };  					} else if (!string.IsNullOrWhiteSpace(values[1])) {  						return ReferenceInfo.FromFullName(values[1]);  					}  					return null;  				default:  					dynamic obj = o;    					// C++  					if (referenceType.StartsWith("Microsoft.VisualStudio.PlatformUI"' StringComparison.Ordinal)) {  						return new ReferenceInfo { Path = projectItem.Name };  					}    					// F#  					if (referenceType.StartsWith("Microsoft.VisualStudio.FSharp"' StringComparison.Ordinal)) {  						o = projectItem.Object;  					}    					// C# and VB  					return new ReferenceInfo {  						Name = obj.Identity'  						PublicKeyToken = obj.PublicKeyToken'  						Path = obj.Path'  						Version = new Version(obj.Version)  					};  			}
Magic Number,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,GetReference,The following statement contains a magic number: switch (referenceType) {  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAReferenceItem":  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAProjectItem":  					values = GetProperties(projectItem.Properties' "Type"' "FusionName"' "ResolvedPath");  					if (values[0] == "Package") {  						values = GetProperties(projectItem.Properties' "Name"' "Version"' "Path");  						if (values[0] != null && values[1] != null && values[2] != null) {  							return new ReferenceInfo {  								Name = values[0]'  								Path = $"{values[2]}\\{values[0]}.{values[1]}.nupkg"  							};  						}  					} else if (values[2] != null) {  						return new ReferenceInfo { Path = values[2] };  					} else if (!string.IsNullOrWhiteSpace(values[1])) {  						return ReferenceInfo.FromFullName(values[1]);  					}  					return null;  				default:  					dynamic obj = o;    					// C++  					if (referenceType.StartsWith("Microsoft.VisualStudio.PlatformUI"' StringComparison.Ordinal)) {  						return new ReferenceInfo { Path = projectItem.Name };  					}    					// F#  					if (referenceType.StartsWith("Microsoft.VisualStudio.FSharp"' StringComparison.Ordinal)) {  						o = projectItem.Object;  					}    					// C# and VB  					return new ReferenceInfo {  						Name = obj.Identity'  						PublicKeyToken = obj.PublicKeyToken'  						Path = obj.Path'  						Version = new Version(obj.Version)  					};  			}
Magic Number,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,GetReference,The following statement contains a magic number: switch (referenceType) {  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAReferenceItem":  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAProjectItem":  					values = GetProperties(projectItem.Properties' "Type"' "FusionName"' "ResolvedPath");  					if (values[0] == "Package") {  						values = GetProperties(projectItem.Properties' "Name"' "Version"' "Path");  						if (values[0] != null && values[1] != null && values[2] != null) {  							return new ReferenceInfo {  								Name = values[0]'  								Path = $"{values[2]}\\{values[0]}.{values[1]}.nupkg"  							};  						}  					} else if (values[2] != null) {  						return new ReferenceInfo { Path = values[2] };  					} else if (!string.IsNullOrWhiteSpace(values[1])) {  						return ReferenceInfo.FromFullName(values[1]);  					}  					return null;  				default:  					dynamic obj = o;    					// C++  					if (referenceType.StartsWith("Microsoft.VisualStudio.PlatformUI"' StringComparison.Ordinal)) {  						return new ReferenceInfo { Path = projectItem.Name };  					}    					// F#  					if (referenceType.StartsWith("Microsoft.VisualStudio.FSharp"' StringComparison.Ordinal)) {  						o = projectItem.Object;  					}    					// C# and VB  					return new ReferenceInfo {  						Name = obj.Identity'  						PublicKeyToken = obj.PublicKeyToken'  						Path = obj.Path'  						Version = new Version(obj.Version)  					};  			}
Magic Number,ICSharpCode.ILSpy.AddIn,ILSpyAddInPackage,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,GetReference,The following statement contains a magic number: switch (referenceType) {  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAReferenceItem":  				case "Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.Automation.OAProjectItem":  					values = GetProperties(projectItem.Properties' "Type"' "FusionName"' "ResolvedPath");  					if (values[0] == "Package") {  						values = GetProperties(projectItem.Properties' "Name"' "Version"' "Path");  						if (values[0] != null && values[1] != null && values[2] != null) {  							return new ReferenceInfo {  								Name = values[0]'  								Path = $"{values[2]}\\{values[0]}.{values[1]}.nupkg"  							};  						}  					} else if (values[2] != null) {  						return new ReferenceInfo { Path = values[2] };  					} else if (!string.IsNullOrWhiteSpace(values[1])) {  						return ReferenceInfo.FromFullName(values[1]);  					}  					return null;  				default:  					dynamic obj = o;    					// C++  					if (referenceType.StartsWith("Microsoft.VisualStudio.PlatformUI"' StringComparison.Ordinal)) {  						return new ReferenceInfo { Path = projectItem.Name };  					}    					// F#  					if (referenceType.StartsWith("Microsoft.VisualStudio.FSharp"' StringComparison.Ordinal)) {  						o = projectItem.Object;  					}    					// C# and VB  					return new ReferenceInfo {  						Name = obj.Identity'  						PublicKeyToken = obj.PublicKeyToken'  						Path = obj.Path'  						Version = new Version(obj.Version)  					};  			}
Magic Number,ICSharpCode.ILSpy.AddIn,ReferenceInfo,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\ILSpyAddInPackage.cs,FromFullName,The following statement contains a magic number: return new ReferenceInfo {  					Name = parts[0]'  					Version = new Version(parts[1].Substring("Version=".Length))'  					PublicKeyToken = parts[3].Substring("PublicKeyToken=".Length)  				};
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,AppendArgument,The following statement contains a magic number: if (arg.Length > 0 && arg.IndexOfAny(charsNeedingQuoting) < 0) {  				b.Append(arg);  			} else {  				b.Append('"');  				for (int j = 0; ; j++) {  					int backslashCount = 0;  					while (j < arg.Length && arg[j] == '\\') {  						backslashCount++;  						j++;  					}  					if (j == arg.Length) {  						b.Append('\\'' backslashCount * 2);  						break;  					} else if (arg[j] == '"') {  						b.Append('\\'' backslashCount * 2 + 1);  						b.Append('"');  					} else {  						b.Append('\\'' backslashCount);  						b.Append(arg[j]);  					}  				}  				b.Append('"');  			}
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,AppendArgument,The following statement contains a magic number: if (arg.Length > 0 && arg.IndexOfAny(charsNeedingQuoting) < 0) {  				b.Append(arg);  			} else {  				b.Append('"');  				for (int j = 0; ; j++) {  					int backslashCount = 0;  					while (j < arg.Length && arg[j] == '\\') {  						backslashCount++;  						j++;  					}  					if (j == arg.Length) {  						b.Append('\\'' backslashCount * 2);  						break;  					} else if (arg[j] == '"') {  						b.Append('\\'' backslashCount * 2 + 1);  						b.Append('"');  					} else {  						b.Append('\\'' backslashCount);  						b.Append(arg[j]);  					}  				}  				b.Append('"');  			}
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,HexStringToBytes,The following statement contains a magic number: var result = new byte[hex.Length / 2];
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length / 2; i++) {  				result[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);  			}
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length / 2; i++) {  				result[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);  			}
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length / 2; i++) {  				result[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);  			}
Magic Number,ICSharpCode.ILSpy.AddIn,Utils,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\Utils.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length / 2; i++) {  				result[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);  			}
Missing Default,ICSharpCode.ILSpy.AddIn,CodeElementXmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ILSpy.AddIn\CodeElementXmlDocKeyProvider.cs,AppendParameterTypeName,The following switch statement is missing a default case: switch (ch) {  					case '<':  						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters);  						substringStart = i + 1;  						b.Append('{');  						break;  					case '>':  						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters);  						substringStart = i + 1;  						b.Append('}');  						break;    					case '[':  						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters);  						b.Append('[');    						// Skip ahead to the closing bracket' counting commas to determine array rank.  						int rank = 1;  						do {  							++i;  							ch = parameterTypeString[i];  							if (ch == ''') {  								++rank;  							}  						}  						while (ch != ']');  						substringStart = i + 1;    						// For multi-dimensional arrays' add "0:" default array bounds. Note that non-standard bounds are not possible via C# declaration.  						if (rank > 1) {  							for (int r = 0; r < rank; ++r) {  								if (r != 0) {  									b.Append(''');  								}  								b.Append("0:");  							}  						}    						b.Append(']');  						break;    					case ''':  						AppendParameterTypeSubstring(b' parameterTypeString' substringStart' i' genericTypeParameters' genericMethodParameters);  						substringStart = i + 1;  						// Skip space after comma if present. (e.g. System.Collections.Generic.KeyValuePair`2{System.String'System.String}.)  						if (parameterTypeString[substringStart] == ' ') {  							++substringStart;  						}  						b.Append(''');  						break;  				}
