Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The method has 184 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The method has 116 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,The method has 101 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The method has 278 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,The method has 156 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The method has 120 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitConv,The method has 134 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The method has 107 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The method has 100 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The method has 134 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The method has 154 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The method has 144 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The method has 181 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,The method has 100 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,StateRangeAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\StateRangeAnalysis.cs,AssignStateRanges,The method has 103 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The method has 116 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,FormattingOptionsFactory,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\FormattingOptionsFactory.cs,CreateMono,The method has 150 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,FormattingOptionsFactory,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\FormattingOptionsFactory.cs,CreateKRStyle,The method has 147 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The method has 139 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The method has 153 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The method has 302 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The method has 100 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,The method has 107 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The method has 121 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The method has 249 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The method has 101 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The method has 133 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The method has 116 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInstruction,The method has 144 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeCheck,The method has 105 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,Lift,The method has 134 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The method has 106 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The method has 111 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The method has 171 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The method has 118 lines of code.
Long Method,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The method has 103 lines of code.
Long Method,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The method has 153 lines of code.
Long Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The method has 112 lines of code.
Long Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The method has 212 lines of code.
Long Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The method has 108 lines of code.
Long Method,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetConversionKind,The method has 116 lines of code.
Long Method,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The method has 203 lines of code.
Long Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The method has 465 lines of code.
Long Method,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,ParseReflectionName,The method has 103 lines of code.
Long Method,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The method has 202 lines of code.
Long Method,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The method has 202 lines of code.
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TokenizeFormatString,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildArgumentList,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp,RequiredNamespaceCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\RequiredNamespaceCollector.cs,CollectNamespaces,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp,RequiredNamespaceCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\RequiredNamespaceCollector.cs,CollectNamespacesFromMethodBody,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,Cyclomatic complexity of the method is 50
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,Cyclomatic complexity of the method is 29
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,Cyclomatic complexity of the method is 34
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,Decompile,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DetectBestEnumValueDisplayMode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitBinaryNumericInstruction,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandlePointerArithmetic,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandlePointerSubtraction,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,GetAssignmentOperatorTypeFromMetadataName,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNumericCompoundAssign,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitConv,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateFunction,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,AdjustConstantToType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicBinaryOperatorInstruction,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicUnaryOperatorInstruction,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertBlockContainer,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,CleanUpFileName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Documentation,XmlDocumentationElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs,CreateElements,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,GetIdString,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,AppendTypeName,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseTypeName,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchAfterFinallyBlock,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,Cyclomatic complexity of the method is 44
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchAsyncEnumeratorCreationPattern,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchYieldBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeDisposeAsync,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeStateMachine,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,TransformYieldBreak,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,FindYieldBreakTarget,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeYieldReturn,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,RestoreStack,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanDoFinallyBodies,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,Run,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,Run,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowGraph,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowGraph.cs,CreateEdges,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,StateRangeAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\StateRangeAnalysis.cs,AssignStateRanges,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,SymbolicEvaluationContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SymbolicExecution.cs,Eval,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,MergeCommonBranches,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,CompareBlockExitPriority,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,SimplifyBranchChains,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,CreatePinnedRegion,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,HandleStringToPointer,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,ExtendLoop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,FindExitPoint,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeSwitch,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,UseCSharpSwitch,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,IsSingleCondition,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpModifierToken,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpModifierToken.cs,GetModifierName,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpModifierToken,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpModifierToken.cs,GetModifierLength,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpModifierToken,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpModifierToken.cs,GetModifierValue,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,NegateRelationalOperator,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,DocumentationReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DocumentationReference.cs,DoMatch,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AssignmentExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AssignmentExpression.cs,GetOperatorRole,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AssignmentExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AssignmentExpression.cs,GetCorrespondingBinaryOperator,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AssignmentExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AssignmentExpression.cs,GetLinqNodeType,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AssignmentExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AssignmentExpression.cs,GetAssignmentOperatorTypeFromExpressionType,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,BinaryOperatorExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\BinaryOperatorExpression.cs,GetOperatorRole,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,BinaryOperatorExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\BinaryOperatorExpression.cs,GetLinqNodeType,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,UnaryOperatorExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UnaryOperatorExpression.cs,GetOperatorRole,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,UnaryOperatorExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UnaryOperatorExpression.cs,GetLinqNodeType,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,PrimitiveType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\PrimitiveType.cs,GetTypeCodeForPrimitiveType,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,OperatorDeclaration,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\OperatorDeclaration.cs,GetRole,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertNamespace,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertConstantValue,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertConstantValue,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsSpecialConstant,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,FractionApprox,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertParameter,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEntity,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeDefinition,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertDelegate,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertField,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,GetMemberModifiers,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeParameterConstraint,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching,Pattern,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\PatternMatching\Pattern.cs,DoMatchCollection,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,Cyclomatic complexity of the method is 30
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteMemberDeclarationName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,OpenBrace,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,IsKeyword,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitBinaryOperatorExpression,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitTypeDeclaration,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitParameterDeclaration,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitComposedType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitNodeInPattern,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitDocumentationReference,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertMissingTokensDecorator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs,WriteKeyword,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,Cyclomatic complexity of the method is 28
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,VisitCastExpression,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertRequiredSpacesDecorator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertRequiredSpacesDecorator.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,ConvertChar,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ImplicitConversion,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,StandardImplicitConversion,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsConstraintConvertible,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ExplicitConversion,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ExplicitConversionImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IdentityOrVarianceConversion,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ExplicitReferenceConversion,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ImplicitConstantExpressionConversion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,AnonymousFunctionConversion,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsDelegateCompatible,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpInvocationResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpInvocationResolveResult.cs,GetArgumentsForCall,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,Cyclomatic complexity of the method is 68
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,GetOverloadableOperatorName,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInCurrentType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInCurrentUsingScope,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInUsingScopeNamespace,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveMemberAccess,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,GetExtensionMethods,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,CreateParameters,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveConditional,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,GetDefaultValue,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,IsAccessible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupType,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,Lookup,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddNestedTypes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,RemoveInterfaceMembersHiddenByClassMembers,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,CreateResult,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MapCorrespondingParameters,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,RunTypeInference,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArguments,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArgumentsFromBounds,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,PhaseTwo,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,CalculateDependencyMatrix,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeOutputTypeInference,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeLowerBoundInference,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeUpperBoundInference,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,FixRemainingIncrements,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\FixRemainingIncrements.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,MatchIsEventAssignmentIfInstruction,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsPotentialClosure,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,LegacyPattern,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,TransformDynamic,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,Cyclomatic complexity of the method is 81
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchWhileLoop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileLoop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NamedArgumentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NamedArgumentTransform.cs,CanIntroduceNamedArgument,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NamedArgumentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NamedArgumentTransform.cs,CanExtendNamedArgument,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullPropagationTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullPropagationTransform.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullPropagationTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullPropagationTransform.cs,IsValidAccessChain,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,InlineReturnTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\InlineReturnTransform.cs,CanModifyInstructions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,Run,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ScanHashtableInitializerBlocks,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchCaseBlock,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,Cyclomatic complexity of the method is 35
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FixCasesWithoutValue,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FindHashtableInitBlock,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynCaseBlockHead,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynEmptyStringCaseBlockHead,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ReadParameters,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertField,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertMemberInit,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertUnaryNumericOperator,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertValue,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetMethodFromHandle,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetConstructorFromHandle,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeCheck,Cyclomatic complexity of the method is 35
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformAsyncUsing,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,Run,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,PerformAssignment,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateNameForVariable,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameByType,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,RunStatements,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,Lift,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchThreeValuedLogicConditionPattern,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchCompOrDecimal,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformRefTypes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformThrowExpressionValueTypes,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,StatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\StatementTransform.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,IsUsedAsThisPointerInCall,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,ClassifyExpression,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,NonAggressiveInlineInto,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,FindLoadInNext,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitNewObj,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformSpanTCtorContainingStackAlloc,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDynamicAddAssignOrRemoveAssign,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitDynamicSetIndexInstruction,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformCatchVariable,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDelegateConstruction,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,RemoveDeadVariableInit,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\RemoveDeadVariableInit.cs,Run,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SplitVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SplitVariables.cs,DetermineAddressUse,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SplitVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SplitVariables.cs,HandleCall,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSequentialLocAllocInitializer,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,GetNullExpression,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,MatchingGetterAndSetterCalls,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,Cyclomatic complexity of the method is 29
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentLocal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsImplicitTruncation,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsCompoundStore,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsMatchingCompoundLoad,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorWithInlineStore,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperator,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,ConvertMarshalInfo,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,IgnoreAttribute,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,DecodeSignature,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,GetAttributes,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataProperty,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataProperty.cs,MergePropertyAccessibility,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,MetadataTypeDefinition,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,GetAttributes,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,GetFilteredAccessors,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeParameter.cs,LoadNullabilityConstraint,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractTypeParameter.cs,CalculateEffectiveBaseClass,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetNestedTypesImpl,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetMethodsImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,SpecializedMethod,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,TryRemoveTransparentIdentifier,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,Cyclomatic complexity of the method is 36
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,GetAssignmentOperatorForBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,FindInsertionPoints,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,ResolveCollisions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,FixNameCollisions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\FixNameCollisions.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformFor,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformAutomaticProperty,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,CheckAutomaticEventMatch,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformAutomaticEvents,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResult,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,VisitConstructorDeclaration,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,GetBinaryOperatorTypeFromMetadataName,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler,DecompilerException,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,SetLanguageVersion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentLocalDefinition,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WriteToken,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,EscapeString,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,PrimitiveTypeName,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,ILStructure,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureHeader,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,TryDecodeSecurityDeclaration,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,PrimitiveTypeCodeToString,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,Cyclomatic complexity of the method is 63
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteParameters,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteModuleHeader,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Disassembler,DisassemblerSignatureProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,GetPrimitiveType,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ReduceSwitchNesting,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ComputeStats,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL,DynamicInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,WriteBinderFlags,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,Detect,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL,TupleTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TupleTransform.cs,MatchTupleConstruction,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetOperatorName,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,IsBinaryCompatibleWithType,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetConversionKind,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,Cyclomatic complexity of the method is 33
Complex Method,ICSharpCode.Decompiler.IL,BlockBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateBlocks,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL,BlockBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,ConnectBranches,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,MergeStacks,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,ReadInstructions,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,Cyclomatic complexity of the method is 214
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Cast,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeCall,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Comparison,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeConditionalBranch,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetStackType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,InferType,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.Decompiler.IL,ILVariable,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILVariable.cs,WriteDefinitionTo,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Metadata,CustomAttributeDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\CustomAttributeDecoder.cs,DecodeArgument,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinderExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinderExtensions.cs,DetectTargetFrameworkId,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Metadata,SignatureBlobComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\SignatureBlobComparer.cs,EqualsMethodSignature,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.Metadata,SignatureBlobComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\SignatureBlobComparer.cs,TypesAreEqual,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ParseTargetFramework,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,FindAssemblyFile,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,FindWindowsMetadataFile,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ResolveInternal,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Metadata,MetadataExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\MetadataExtensions.cs,ToPrimitiveTypeCode,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.Metadata,MetadataExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\MetadataExtensions.cs,ToKnownTypeCode,Cyclomatic complexity of the method is 19
Complex Method,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadJsonValue,Cyclomatic complexity of the method is 8
Complex Method,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadString,Cyclomatic complexity of the method is 12
Complex Method,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,Cyclomatic complexity of the method is 17
Complex Method,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadObject,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveMethodReference,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveEntity,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,GetOptions,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,DecompilerTypeSystem,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetDerivedMember,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.TypeSystem,KnownTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\KnownTypeReference.cs,GetCSharpNameByTypeCode,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,ParameterizedType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,ParameterListComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,ToTypeReference,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,ParseReflectionName,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,SkipAheadAndReadAssemblyName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetStackType,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,ToPrimitiveType,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,ToKnownTypeCode,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,ToKnownTypeCode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,ToPrimitiveType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,ResourcesFile,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,LoadObjectV1,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,LoadObjectV2,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,AddResource,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,AddMetadata,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetString,Cyclomatic complexity of the method is 10
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The method has 5 parameters. Parameters: callOpCode' method' callArguments' argumentToParameterMap' constrainedTo
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDictionaryInitializerExpression,The method has 5 parameters. Parameters: callOpCode' method' target' indices' value
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildArgumentList,The method has 6 parameters. Parameters: expectedTargetDetails' target' method' firstParamIndex' callArguments' argumentToParameterMap
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TransformParamsArgument,The method has 7 parameters. Parameters: expectedTargetDetails' targetResolveResult' method' parameter' arg' expectedParameters' arguments
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The method has 6 parameters. Parameters: expectedTargetDetails' method' target' argumentList' allowedTransforms' foundMethod
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The method has 9 parameters. Parameters: expectedTargetDetails' method' target' typeArguments' arguments' argumentNames' firstOptionalArgumentIndex' foundMember' bestCandidateIsExpandedForm
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousAccess,The method has 6 parameters. Parameters: expectedTargetDetails' target' method' arguments' argumentNames' foundMember
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The method has 5 parameters. Parameters: expectedTargetDetails' method' target' arguments' argumentNames
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleDelegateConstruction,The method has 5 parameters. Parameters: delegateType' method' expectedTargetDetails' thisArg' inst
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousMethodReference,The method has 5 parameters. Parameters: expectedTargetDetails' method' target' typeArguments' result
Long Parameter List,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,CastCanBeMadeImplicit,The method has 5 parameters. Parameters: conversions' conversion' inputType' oldTargetType' newTargetType
Long Parameter List,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,The method has 6 parameters. Parameters: module' info' parent' part' connectedMethods' processedNestedTypes
Long Parameter List,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The method has 6 parameters. Parameters: name' source' target' typeSystemAstBuilder' intermediate32' intermediate64
Long Parameter List,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ExpressionBuilder,The method has 6 parameters. Parameters: statementBuilder' typeSystem' decompilationContext' currentFunction' settings' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,GetPointerArithmeticOffset,The method has 5 parameters. Parameters: byteOffsetInst' byteOffsetExpr' pointerElementType' checkForOverflow' unwrapZeroExtension
Long Parameter List,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The method has 5 parameters. Parameters: rr' memberPath' valuePath' values' indexVariables
Long Parameter List,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,StatementBuilder,The method has 5 parameters. Parameters: typeSystem' decompilationContext' currentFunction' settings' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The method has 6 parameters. Parameters: usingContainer' loopBody' enumerator' moveNextUsage' singleGetter' foreachVariable
Long Parameter List,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The method has 5 parameters. Parameters: typeName' pos' allowDottedName' typeParameterCount' typeArguments
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeEnumeratorCtor,The method has 5 parameters. Parameters: ctor' context' builderField' builderType' stateField
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The method has 5 parameters. Parameters: block' awaiter' awaiterField' state' yieldOffset
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The method has 5 parameters. Parameters: block' awaiterVar' awaiterField' completedBlock' stackField
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The method has 7 parameters. Parameters: container' id' identifierVariable' realEntryPoint' nextBlockOrExitContainer' jumpTableEntry' objectVariableStore
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationNewObj,The method has 5 parameters. Parameters: inst' metadata' currentType' enumeratorCtor' enumeratorType
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullBlock,The method has 5 parameters. Parameters: block' v' p' nullOrEmptyBlock' targetBlock
Long Parameter List,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,AddTypeArguments,The method has 5 parameters. Parameters: result' typeParameters' typeArguments' startIndex' endIndex
Long Parameter List,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,TryExtractExpression,The method has 5 parameters. Parameters: mathType' type' literalValue' memberName' isDouble
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,AwaitResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\AwaitResolveResult.cs,AwaitResolveResult,The method has 6 parameters. Parameters: resultType' getAwaiterInvocation' awaiterType' isCompletedProperty' onCompletedMethod' getResultMethod
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The method has 6 parameters. Parameters: mostSpecificSource' mostSpecificTarget' operators' isImplicit' source' target
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpInvocationResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpInvocationResolveResult.cs,CSharpInvocationResolveResult,The method has 10 parameters. Parameters: targetResult' member' arguments' overloadResolutionErrors' isExtensionMethodInvocation' isExpandedForm' isDelegateInvocation' argumentToParameterMap' initializerStatements' returnTypeOverride
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,CSharpResolver,The method has 8 parameters. Parameters: compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryOperatorResolveResult,The method has 5 parameters. Parameters: resultType' lhs' op' rhs' isLifted
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumComparison,The method has 5 parameters. Parameters: op' enumType' isNullable' lhs' rhs
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumOperator,The method has 5 parameters. Parameters: isNullable' enumType' op' lhs' rhs
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,TryConvertEnum,The method has 5 parameters. Parameters: rr' targetType' isNullable' enumRR' allowConversionFromConstantZero
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInUsingScopeNamespace,The method has 5 parameters. Parameters: usingScope' n' identifier' typeArguments' parameterizeResultType
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,CheckForEnumerableInterface,The method has 5 parameters. Parameters: expression' collectionType' enumeratorType' elementType' getEnumeratorInvocation
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,The method has 6 parameters. Parameters: compilation' conversions' targetType' method' useTypeInference' outInferredTypes
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The method has 5 parameters. Parameters: type' arguments' argumentNames' allowProtectedAccess' initializerStatements
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,DecompiledLambdaResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\LambdaResolveResult.cs,DecompiledLambdaResolveResult,The method has 6 parameters. Parameters: function' delegateType' inferredReturnType' hasParameterList' isAnonymousMethod' isImplicitlyTyped
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddNestedTypes,The method has 6 parameters. Parameters: type' nestedTypes' typeArgumentCount' lookupGroups' typeBaseTypes' newNestedTypes
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The method has 8 parameters. Parameters: type' members' allowProtectedAccess' lookupGroups' treatAllParameterizedMembersAsMethods' typeBaseTypes' newMethods' newNonMethod
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,The method has 8 parameters. Parameters: compilation' arguments' argumentNames' allowExtensionMethods' allowExpandingParams' allowOptionalParameters' checkForOverflow' conversions
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,OverloadResolution,The method has 5 parameters. Parameters: compilation' arguments' argumentNames' typeArguments' conversions
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArguments,The method has 5 parameters. Parameters: typeParameters' arguments' parameterTypes' success' classTypeArguments
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArgumentsFromBounds,The method has 5 parameters. Parameters: typeParameters' targetType' lowerBounds' upperBounds' success
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,MatchIsEventAssignmentIfInstruction,The method has 7 parameters. Parameters: ifInst' isEvent' flagVar' getMemberVar' setMemberInst' getMemberVarUse' isEventConditionUse
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,AddOrUpdateDisplayClass,The method has 5 parameters. Parameters: f' v' closureType' inst' localFunctionClosureParameter
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The method has 5 parameters. Parameters: callSiteInitBlock' callSiteCacheField' callSiteDelegateType' callSiteInfo' blockAfterInit
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The method has 5 parameters. Parameters: loop' block' swapBranches' unwrapCondtionBlock' conditionBlock
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The method has 6 parameters. Parameters: block' values' blockAfterInit' dictionaryType' dictionaryField' isHashtablePattern
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The method has 5 parameters. Parameters: dictionaryType' inst' dictVar' index' value
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FindHashtableInitBlock,The method has 6 parameters. Parameters: entryPoint' stringValues' dictField' blockAfterThisInitBlock' thisSwitchInitJumpInst' nextSwitchInitJumpInst
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynCaseBlockHead,The method has 5 parameters. Parameters: target' switchValueVar' bodyOrLeave' defaultOrExitBlock' stringValue
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The method has 5 parameters. Parameters: container' objVar' usingNull' disposeMethodFullName' disposeTypeCode
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeCheck,The method has 7 parameters. Parameters: objVar' checkInst' isReference' usingNull' numObjVarLoadsInCheck' disposeMethodFullName' disposeTypeCode
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The method has 6 parameters. Parameters: exceptionVar' container' entryPoint' exceptionType' exceptionSlot' whenConditionBlock
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The method has 5 parameters. Parameters: instructions' pos' target' rootType' blockKind
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The method has 5 parameters. Parameters: instruction' rootType' settings' resolveContext' possibleIndexVariables
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodApplicable,The method has 5 parameters. Parameters: method' arguments' rootType' resolveContext' settings
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,CopyPropagation,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CopyPropagation.cs,DoPropagate,The method has 5 parameters. Parameters: v' copiedExpr' block' i' context
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,DoInline,The method has 5 parameters. Parameters: v' inlinedExpression' next' options' context
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchSpanTCtorWithPointerAndSize,The method has 5 parameters. Parameters: newObj' context' elementType' field' size
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleCpblkInitializer,The method has 6 parameters. Parameters: block' pos' v' length' blob' elementType
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSequentialLocAllocInitializer,The method has 7 parameters. Parameters: block' pos' store' locAllocInstruction' elementType' values' instructionsToRemove
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The method has 8 parameters. Parameters: function' block' pos' store' elementType' arrayLength' values' elementCount
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ShouldTransformToInitializer,The method has 5 parameters. Parameters: function' block' startPos' elementCount' length
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The method has 8 parameters. Parameters: block' pos' store' elementType' length' finalStore' values' instructionsToRemove
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The method has 6 parameters. Parameters: block' pos' store' index' initializer' type
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleRuntimeHelpersInitializeArray,The method has 7 parameters. Parameters: body' pos' array' arrayType' arrayLength' values' foundPos
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The method has 5 parameters. Parameters: initialValue' arrayLength' output' elementType' decoder
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsMatchingCompoundLoad,The method has 7 parameters. Parameters: load' store' target' targetKind' finalizeMatch' forbiddenVariable' previousInstruction
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,DefaultTypeParameter,The method has 10 parameters. Parameters: owner' index' name' variance' attributes' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints' nullabilityConstraint
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,DefaultTypeParameter,The method has 11 parameters. Parameters: compilation' ownerType' index' name' variance' attributes' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints' nullabilityConstraint
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,DecodeSignature,The method has 5 parameters. Parameters: module' owner' signature' parameterHandles' nullableContext
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeParameter.cs,MetadataTypeParameter,The method has 6 parameters. Parameters: module' owner' index' name' handle' attr
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractTypeParameter.cs,AbstractTypeParameter,The method has 5 parameters. Parameters: compilation' ownerType' index' name' variance
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultParameter.cs,DefaultParameter,The method has 8 parameters. Parameters: type' name' owner' attributes' referenceKind' isParams' isOptional' defaultValue
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,GetClassTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetClassTypeReference.cs,GetClassTypeReference,The method has 5 parameters. Parameters: module' namespaceName' name' typeParameterCount' isReferenceType
Long Parameter List,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,CanTransformToExtensionMethodCall,The method has 6 parameters. Parameters: resolver' method' typeArguments' target' arguments' argumentNames
Long Parameter List,ICSharpCode.Decompiler.CSharp.Transforms,VariableToDeclare,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,VariableToDeclare,The method has 5 parameters. Parameters: variable' defaultInitialization' insertionPoint' firstUse' sourceOrder
Long Parameter List,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,MatchForeachOnMultiDimArray,The method has 6 parameters. Parameters: upperBounds' collection' firstInitializerStatement' foreachVariable' statements' lowerBounds
Long Parameter List,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,CSharpTypeResolveContext,The method has 5 parameters. Parameters: module' usingScope' typeDefinition' member' methodTypeParameterNames
Long Parameter List,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The method has 5 parameters. Parameters: file' decompiler' settings' targetStream' noLogo
Long Parameter List,ICSharpCode.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,ILStructure,The method has 7 parameters. Parameters: module' handle' genericContext' type' startOffset' endOffset' handler
Long Parameter List,ICSharpCode.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,ILStructure,The method has 7 parameters. Parameters: module' handle' genericContext' type' startOffset' endOffset' loopEntryPoint
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicInvokeMemberInstruction,The method has 6 parameters. Parameters: binderFlags' name' typeArguments' context' argumentInfo' arguments
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicGetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicGetMemberInstruction,The method has 5 parameters. Parameters: binderFlags' name' context' targetArgumentInfo' target
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicSetMemberInstruction,The method has 7 parameters. Parameters: binderFlags' name' context' targetArgumentInfo' target' valueArgumentInfo' value
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicInvokeConstructorInstruction,The method has 5 parameters. Parameters: binderFlags' type' context' argumentInfo' arguments
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicBinaryOperatorInstruction,The method has 7 parameters. Parameters: binderFlags' operation' context' leftArgumentInfo' left' rightArgumentInfo' right
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicLogicOperatorInstruction,The method has 7 parameters. Parameters: binderFlags' operation' context' leftArgumentInfo' left' rightArgumentInfo' right
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicUnaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,DynamicUnaryOperatorInstruction,The method has 5 parameters. Parameters: binderFlags' operation' context' operandArgumentInfo' operand
Long Parameter List,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,CallIndirect,The method has 7 parameters. Parameters: isInstance' hasExplicitThis' callingConvention' returnType' parameterTypes' arguments' functionPointer
Long Parameter List,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CompoundAssignmentInstruction,The method has 5 parameters. Parameters: opCode' evalMode' target' targetKind' value
Long Parameter List,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ILFunction,The method has 5 parameters. Parameters: method' codeSize' genericContext' body' kind
Long Parameter List,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,BinaryNumericInstruction,The method has 5 parameters. Parameters: op' left' right' checkForOverflow' sign
Long Parameter List,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,BinaryNumericInstruction,The method has 8 parameters. Parameters: op' left' right' leftInputType' rightInputType' checkForOverflow' sign' isLifted
Long Parameter List,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,NumericCompoundAssign,The method has 6 parameters. Parameters: binary' target' targetKind' value' type' evalMode
Long Parameter List,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,UserDefinedCompoundAssign,The method has 5 parameters. Parameters: method' evalMode' target' targetKind' value
Long Parameter List,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,DynamicCompoundAssign,The method has 7 parameters. Parameters: op' binderFlags' target' targetArgumentInfo' value' valueArgumentInfo' targetKind
Long Parameter List,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,Comp,The method has 6 parameters. Parameters: kind' lifting' inputType' sign' left' right
Long Parameter List,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,Conv,The method has 6 parameters. Parameters: argument' inputType' inputSign' targetType' checkForOverflow' isLifted
Long Parameter List,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The method has 5 parameters. Parameters: entity' module' output' genericContext' syntax
Long Parameter List,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteParent,The method has 6 parameters. Parameters: output' module' metadata' parentHandle' genericContext' syntax
Long Parameter List,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,WriteTypedIL,The method has 5 parameters. Parameters: method' body' output' genericContext' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,ReadIL,The method has 5 parameters. Parameters: method' body' genericContext' kind' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.Metadata,SignatureBlobComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\SignatureBlobComparer.cs,TypesAreEqual,The method has 5 parameters. Parameters: a' b' contextForA' contextForB' typeCode
Long Parameter List,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,UniversalAssemblyResolver,The method has 5 parameters. Parameters: mainAssemblyFileName' throwOnError' targetFramework' streamOptions' metadataOptions
Long Parameter List,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The method has 6 parameters. Parameters: operatorMethod' isImplicit' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The method has 6 parameters. Parameters: isImplicit' method' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.Decompiler.Semantics,ForEachResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\ForEachResolveResult.cs,ForEachResolveResult,The method has 7 parameters. Parameters: getEnumeratorCall' collectionType' enumeratorType' elementType' currentProperty' moveNextMethod' voidType
Long Parameter List,ICSharpCode.Decompiler.Semantics,InvocationResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\InvocationResolveResult.cs,InvocationResolveResult,The method has 5 parameters. Parameters: targetResult' member' arguments' initializerStatements' returnTypeOverride
Long Parameter List,ICSharpCode.Decompiler.Semantics,MemberResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 5 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue
Long Parameter List,ICSharpCode.Decompiler.Semantics,MemberResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 6 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue' isVirtualCall
Long Parameter List,ICSharpCode.Decompiler.Semantics,OperatorResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\OperatorResolveResult.cs,OperatorResolveResult,The method has 5 parameters. Parameters: resultType' operatorType' userDefinedOperatorMethod' isLiftedOperator' operands
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,The method has 7 parameters. Parameters: inputType' compilation' attributes' metadata' options' nullableContext' typeChildrenOnly
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributeTypeVisitor,The method has 7 parameters. Parameters: compilation' hasDynamicAttribute' dynamicAttributeData' options' tupleElementNames' defaultNullability' nullableAttributeData
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveType,The method has 5 parameters. Parameters: typeRefDefSpec' context' customOptions' typeAttributes' nullableContext
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,KnownTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\KnownTypeReference.cs,KnownTypeReference,The method has 6 parameters. Parameters: knownTypeCode' typeKind' namespaceName' name' typeParameterCount' baseType
Long Parameter List,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,WriteBytes,The method has 6 parameters. Parameters: name' type' value' offset' length' comment
Long Identifier,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the parameter appliedRequireTypeArgumentsShortcut is 35.
Long Identifier,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,EarlyILTransforms,The length of the parameter aggressivelyDuplicateReturnBlocks is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateFunction,The length of the parameter parameterReferencingIdentifiers is 31.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchAfterFinallyBlock,The length of the parameter removeFirstInstructionInAfterFinally is 36.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowGraph,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowGraph.cs,,The length of the parameter nodeHasDirectExitOutOfContainer is 31.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,,The length of the parameter aggressivelyDuplicateReturnBlocks is 33.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,DetectExitPoints,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ExitPoints.cs,,The length of the parameter blocksPotentiallyMadeUnreachable is 32.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,The length of the parameter multipleNodesTreatedAsExitNodes is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,DepthFirstAstVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DepthFirstAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,DepthFirstAstVisitor<T>,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DepthFirstAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,DepthFirstAstVisitor<T;S>,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DepthFirstAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,DocumentationReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DocumentationReference.cs,,The length of the parameter ConversionOperatorReturnTypeRole is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,IAstVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\IAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,IAstVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\IAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,IAstVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\IAstVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpFormattingOptions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpFormattingOptions.cs,,The length of the parameter allowOneLinedArrayInitialziers is 30.
Long Identifier,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the parameter localFunctionDeclarationStatement is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitIdentifierExpressionBackreference,The length of the parameter identifierExpressionBackreference is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the parameter operatorsWithSourceEncompassingFromType is 39.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,,The length of the parameter implicitNumericConversionLookup is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,TryConvertEnum,The length of the parameter allowConversionFromConstantZero is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,TypeDefinitionCache,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,,The length of the parameter SimpleNameLookupCacheExpression is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,TypeDefinitionCache,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,,The length of the parameter SimpleNameLookupCacheInvocationTarget is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The length of the parameter treatAllParameterizedMembersAsMethods is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The length of the parameter replacedVirtualMemberWithOverride is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,The length of the parameter foundApplicableCandidateInCurrentList is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,IsApplicable,The length of the parameter errorsThatDoNotMatterForApplicability is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,The length of the parameter bestCandidateForNamedArguments is 30.
Long Identifier,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsPotentialClosure,The length of the parameter allowTypeImplementingInterfaces is 31.
Long Identifier,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateNameForVariable,The length of the parameter proposedNameForStoresFromNewObj is 31.
Long Identifier,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,The length of the parameter isNullCoalescingWithNonNullableFallback is 39.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,LocalFunctionMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\LocalFunctionMethod.cs,LocalFunctionMethod,The length of the parameter numberOfCompilerGeneratedParameters is 35.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,,The length of the parameter substitutionWithoutSpecializedTypeParameters is 44.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,,The length of the parameter selectTransparentIdentifierPattern is 34.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,NormalizeBlockStatements,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\NormalizeBlockStatements.cs,,The length of the parameter CalculatedGetterOnlyPropertyPattern is 35.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,NormalizeBlockStatements,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\NormalizeBlockStatements.cs,,The length of the parameter CalculatedGetterOnlyIndexerPattern is 34.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter variableAssignUpperBoundPattern is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter variableAssignLowerBoundPattern is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter foreachVariableOnMultArrayAssignPattern is 39.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter automaticReadonlyPropertyPattern is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter attributeTypesToRemoveFromAutoEvents is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter attributeTypesToRemoveFromAutoProperties is 40.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costCheckedContextUncheckedBlockOpen is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesCheckedContextUncheckedBlockOpen is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costUncheckedContextCheckedBlockOpen is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesUncheckedContextCheckedBlockOpen is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,Result,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,,The length of the parameter NodesToInsertInUncheckedContext is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the parameter instanceCtorsNotChainingWithThis is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,,The length of the parameter getMethodOrConstructorFromHandlePattern is 39.
Long Identifier,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,,The length of the parameter MethodSteppingInformationBlobId is 31.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter useImplicitMethodGroupConversion is 32.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter alwaysCastTargetsOfExplicitInterfaceImplementationCalls is 55.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter extensionMethodsInCollectionInitializers is 40.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter useExpressionBodyForCalculatedGetterOnlyProperties is 50.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter introduceRefModifiersOnStructs is 30.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter introduceReadonlyAndInModifiers is 31.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter assumeArrayLengthFitsIntoInt32 is 30.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter introduceIncrementAndDecrement is 30.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter applyWindowsRuntimeProjections is 30.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ImplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ExplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ImplicitConstantExpressionConversion is 36.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ImplicitInterpolatedStringConversion is 36.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,NormalizeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\NormalizeTypeVisitor.cs,,The length of the parameter ReplaceClassTypeParametersWithDummy is 35.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,NormalizeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\NormalizeTypeVisitor.cs,,The length of the parameter ReplaceMethodTypeParametersWithDummy is 36.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,TypeClassificationVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,,The length of the parameter typeParameterOwnerNestingLevel is 30.
Long Identifier,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,,The length of the parameter ByteArraySerializedObjectMimeType is 33.
Long Identifier,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,,The length of the parameter DefaultSerializedObjectMimeType is 31.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DataFlowVisitor<State>,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DataFlowVisitor.cs,VisitTryFinally,The length of the parameter branchesTriggeringFinallyOldCount is 33.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DataFlowVisitor<State>,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DataFlowVisitor.cs,ProcessBranchesLeavingTryFinally,The length of the parameter branchesTriggeringFinallyOldCount is 33.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DefiniteAssignmentVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DefiniteAssignmentVisitor.cs,VisitILFunction,The length of the parameter stateOnExceptionBeforeFunction is 30.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DefiniteAssignmentVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DefiniteAssignmentVisitor.cs,,The length of the parameter variablesWithUninitializedUsage is 31.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "			if (settings.TupleTypes && TupleTransform.MatchTupleConstruction(inst as NewObj' out var tupleElements) && tupleElements.Length >= 2) { " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				if (method.DeclaringTypeDefinition?.Kind == TypeKind.Class && method.DeclaringTypeDefinition.IsSealed && interfaceMembers.Count == 1) { " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				argListArg.Arguments.AddRange(argumentList.Arguments.Skip(regularParameterCount).Select(arg => arg.ConvertTo(argumentList.ExpectedParameters[paramIndex++].Type' builder).Expression)); " is 183.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "						argumentList.GetArgumentResolveResults().ToList()' isExpandedForm: argumentList.IsExpandedForm' isDelegateInvocation: true)); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "			if (method.IsAccessor && (method.AccessorOwner.SymbolKind == SymbolKind.Indexer || argumentList.ExpectedParameters.Length == allowedParamCount)) { " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				return HandleAccessorCall(expectedTargetDetails' method' target' argumentList.Arguments.ToList()' argumentList.ArgumentNames);  " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				// HACK : convert this.Dispose() to ((IDisposable)this).Dispose()' if Dispose is an explicitly implemented interface method. " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				// settings.AlwaysCastTargetsOfExplicitInterfaceImplementationCalls == true is used in Windows Forms' InitializeComponent methods. " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				if (method.IsExplicitInterfaceImplementation && (target.Expression is ThisReferenceExpression || settings.AlwaysCastTargetsOfExplicitInterfaceImplementationCalls)) { " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "					var castExpression = new CastExpression(expressionBuilder.ConvertType(interfaceMember.DeclaringType)' target.Expression.Detach()); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "			if ((transform & CallTransformation.RequireTypeArguments) != 0 && (!settings.AnonymousTypes || !method.TypeArguments.Any(a => a.ContainsAnonymousType()))) " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TryGetStringInterpolationTokens,The length of the statement  "			if (!(arguments[(int)0].ResolveResult is ConstantResolveResult crr && crr.Type.IsKnownType((KnownTypeCode)KnownTypeCode.String))) " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TryGetStringInterpolationTokens,The length of the statement  "			if (!arguments.Skip(1).All(a => !a.Expression.DescendantsAndSelf.OfType<PrimitiveExpression>().Any(p => p.Value is string))) " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildArgumentList,The length of the statement  "			list.AddNamesToPrimitiveValues = expressionBuilder.settings.NamedArguments && expressionBuilder.settings.NonTrailingNamedArguments; " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the statement  "						requireTarget = !expressionBuilder.IsCurrentOrContainingType(method.DeclaringTypeDefinition) || method.Name == ".cctor"; " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the statement  "				if (!CanInferTypeArgumentsFromParameters(method' argumentList.Arguments.SelectArray(a => a.ResolveResult)' expressionBuilder.typeInference)) { " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the statement  "				out var bestCandidateIsExpandedForm)) != OverloadResolutionErrors.None || bestCandidateIsExpandedForm != argumentList.IsExpandedForm) " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the statement  "						// TODO : implement some more intelligent algorithm that decides which of these fixes (cast args' add target' cast target' add type args) " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetRequiredTransformationsForCall,The length of the statement  "						// is best in this case. Additionally we should not cast all arguments at once' but step-by-step try to add only a minimal number of casts. " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "				firstOptionalArgumentIndex < 0 ? arguments.SelectArray(a => a.ResolveResult) : arguments.Take(firstOptionalArgumentIndex).Select(a => a.ResolveResult).ToArray()' " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "				argumentNames: firstOptionalArgumentIndex < 0 || argumentNames == null ? argumentNames : argumentNames.Take(firstOptionalArgumentIndex).ToArray()' " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "					if (lookup.IsAccessible(ctor' allowProtectedAccess: resolver.CurrentTypeDefinition == method.DeclaringTypeDefinition)) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "				var result = resolver.ResolveSimpleName(method.Name' typeArguments' isInvocationTarget: true) as MethodGroupResolveResult; " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "			if (method.AccessorOwner.SymbolKind == SymbolKind.Indexer || expressionBuilder.HidesVariableWithName(method.AccessorOwner.Name)) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "			while (!IsUnambiguousAccess(expectedTargetDetails' targetResolveResult' method' arguments' argumentNames' out foundMember)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "					expr = new IndexerExpression(target.ResolveResult is InitializedObjectResolveResult ? null : target.Expression' arguments.Select(a => a.Expression)) " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "				return new AssignmentExpression(expr' op' value.Expression).WithRR(new TypeResolveResult(method.AccessorOwner.ReturnType)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleConstructorCall,The length of the statement  "				Debug.Assert(argumentList.ArgumentToParameterMap == null && argumentList.ArgumentNames == null && argumentList.FirstOptionalArgumentIndex < 0); " is 143.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleConstructorCall,The length of the statement  "					out var bestCandidateIsExpandedForm) != OverloadResolutionErrors.None || bestCandidateIsExpandedForm != argumentList.IsExpandedForm) " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleDelegateConstruction,The length of the statement  "				return HandleConstructorCall(new ExpectedTargetDetails { CallOpCode = OpCode.NewObj }' null' inst.Method' argumentList).WithILInstruction(inst); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "			return HandleDelegateConstruction(inst.Type' inst.Method' new ExpectedTargetDetails { CallOpCode = OpCode.CallVirt }' inst.Argument' inst); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildMethodReference,The length of the statement  "			var expr = BuildDelegateReference(method' invokeMethod: null' new ExpectedTargetDetails { CallOpCode = isVirtual ? OpCode.CallVirt : OpCode.Call }' thisArg: null); " is 163.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,The length of the statement  "			} else if (method.IsExtensionMethod && invokeMethod != null && method.Parameters.Count - 1 == invokeMethod.Parameters.Count) { " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,The length of the statement  "					|| (method.IsStatic ? !expressionBuilder.IsCurrentOrContainingType(method.DeclaringTypeDefinition) : !(target.Expression is ThisReferenceExpression)); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,The length of the statement  "					bool success = IsUnambiguousMethodReference(expectedTargetDetails' method' targetResolveResult' typeArguments' out var newResult); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousMethodReference,The length of the statement  "				arguments: method.Parameters.SelectReadOnlyArray(p => new TypeResolveResult(p.Type))' // there are no arguments' use parameter types " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "							if (Expression is ObjectCreateExpression oce && oce.Arguments.Count == 1 && invocation.Type.IsKnownType(KnownTypeCode.NullableOfT)) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "			if (Expression is UnaryOperatorExpression uoe && uoe.Operator == UnaryOperatorType.NullConditional && targetType.IsReferenceType == true) { " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "				if (!(targetType.IsKnownType(KnownTypeCode.Int64) || checkForOverflow && targetType.IsKnownType(KnownTypeCode.Int32))) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "				if (!(targetType.IsKnownType(KnownTypeCode.UInt64) || checkForOverflow && targetType.IsKnownType(KnownTypeCode.UInt32))) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "			if (targetType.Kind == TypeKind.Pointer && (0.Equals(ResolveResult.ConstantValue) || 0u.Equals(ResolveResult.ConstantValue))) { " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "				if (targetType.Kind != TypeKind.Dynamic && type.Kind != TypeKind.Dynamic && NormalizeTypeVisitor.TypeErasure.EquivalentTypes(type' targetType)) { " is 145.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "						if (settings.Dynamic && type.IsDelegate(metadata) && (name.StartsWith("<>A"' StringComparison.Ordinal) || name.StartsWith("<>F"' StringComparison.Ordinal))) " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "					if (settings.ArrayInitializers && settings.SwitchStatementOnString && name.StartsWith("<PrivateImplementationDetails>"' StringComparison.Ordinal)) " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "					if (settings.AutomaticEvents && metadata.GetTypeDefinition(field.GetDeclaringType()).GetEvents().Any(ev => metadata.GetEventDefinition(ev).Name == field.Name)) " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "					if (settings.ArrayInitializers && metadata.GetString(metadata.GetTypeDefinition(field.GetDeclaringType()).Name).StartsWith("<PrivateImplementationDetails>"' StringComparison.Ordinal)) { " is 185.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "						if (field.DecodeSignature(new Metadata.FullTypeNameSignatureDecoder(metadata)' default).ToString().StartsWith("__StaticArrayInit"' StringComparison.Ordinal)) " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsClosureType,The length of the statement  "			return type.BaseType.GetFullTypeName(metadata).ToString() == "System.Object" && !type.GetInterfaceImplementations().Any(); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,LoadPEFile,The length of the statement  "				metadataOptions: settings.ApplyWindowsRuntimeProjections ? MetadataReaderOptions.ApplyWindowsRuntimeProjections : MetadataReaderOptions.None " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,CreateTypeSystemFromFile,The length of the statement  "				settings.ApplyWindowsRuntimeProjections ? MetadataReaderOptions.ApplyWindowsRuntimeProjections : MetadataReaderOptions.None); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompileModuleAndAssemblyAttributes,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompileModuleAndAssemblyAttributes,The length of the statement  "				throw new DecompilerException(module' null' innerException' "Error decompiling module and assembly attributes of " + module.AssemblyName); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,Decompile,The length of the statement  "			RunTransforms(syntaxTree' decompileRun' parentTypeDef != null ? new SimpleTypeResolveContext(parentTypeDef) : new SimpleTypeResolveContext(typeSystem.MainModule)); " is 163.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,AddInterfaceImplHelpers,The length of the statement  "				var forwardingCall = new InvocationExpression(new MemberReferenceExpression(new ThisReferenceExpression()' memberDecl.Name' " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "			// A constant' field' property' event' or type introduced in a class or struct hides all base class members with the same name. " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "						if (baseType.GetMembers(m => m.Name == entity.Name && m.SymbolKind != SymbolKind.Indexer && lookup.IsAccessible(m' true)' options).Any()) " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "							// An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types). " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "							if (baseType.GetMembers(m => m.SymbolKind != SymbolKind.Indexer && m.Name == entity.Name && lookup.IsAccessible(m' true)) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "									.Any(m => m.SymbolKind != SymbolKind.Method || (((IMethod)entity).TypeParameters.Count == ((IMethod)m).TypeParameters.Count " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The length of the statement  "			method.Parameters.Add(new ParameterDeclaration(typeSystemAstBuilder.ConvertType(typeSystem.FindType(source))' "input")); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The length of the statement  "						Left = new MemberReferenceExpression(new TypeReferenceExpression(typeSystemAstBuilder.ConvertType(typeSystem.FindType(KnownTypeCode.IntPtr)))' "Size")' " is 151.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			if (!settings.LocalFunctions && LocalFunctionDecompiler.IsLocalFunctionMethod(method.ParentModule.PEFile' (MethodDefinitionHandle)method.MetadataToken)) { " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				// Note: removing and then adding the static modifier again is necessary to set the private modifier before all other modifiers. " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			if (method.SymbolKind == SymbolKind.Method && !method.IsExplicitInterfaceImplementation && methodDefinition.HasFlag(System.Reflection.MethodAttributes.Virtual) == methodDefinition.HasFlag(System.Reflection.MethodAttributes.NewSlot)) { " is 234.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsWindowsFormsInitializeComponentMethod,The length of the statement  "			return method.ReturnType.Kind == TypeKind.Void && method.Name == "InitializeComponent" && method.DeclaringTypeDefinition.GetNonInterfaceBaseTypes().Any(t => t.FullName == "System.Windows.Forms.Control"); " is 203.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,The length of the statement  "				var function = ilReader.ReadIL((MethodDefinitionHandle)method.MetadataToken' methodBody' cancellationToken: CancellationToken); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,The length of the statement  "					var statementBuilder = new StatementBuilder(typeSystem' decompilationContext' function' localSettings' CancellationToken); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,The length of the statement  "					if (localSettings.DecompileMemberBodies && !body.Descendants.Any(d => d is YieldReturnStatement || d is YieldBreakStatement)) { " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,AddDefinesForConditionalAttributes,The length of the statement  "				syntaxTree.InsertChildAfter(null' new PreProcessorDirective(PreProcessorDirectiveType.Define' symbolName)' Roles.PreProcessorDirective); " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "						enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' constantValue); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "					enumDec.Attributes.AddRange(field.GetAttributes().Select(a => new AttributeSection(typeSystemAstBuilder.ConvertAttribute(a)))); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				bool isMathPIOrE = ((field.Name == "PI" || field.Name == "E") && (field.DeclaringType.FullName == "System.Math" || field.DeclaringType.FullName == "System.MathF")); " is 164.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "						message = string.Format(" Not supported: data({0}) "' BitConverter.ToString(initVal.ReadBytes(initVal.RemainingBytes)).Replace('-'' ' ')); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				if (!accessorHandle.GetMethodImplementations(metadata).Any() && accessor.HasFlag(System.Reflection.MethodAttributes.Virtual) == accessor.HasFlag(System.Reflection.MethodAttributes.NewSlot)) " is 189.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "					DecompileBody(ev.RemoveAccessor' ((CustomEventDeclaration)eventDecl).RemoveAccessor' decompileRun' decompilationContext); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				var accessor = metadata.GetMethodDefinition((MethodDefinitionHandle)(ev.AddAccessor ?? ev.RemoveAccessor).MetadataToken); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				if (accessor.HasFlag(System.Reflection.MethodAttributes.Virtual) == accessor.HasFlag(System.Reflection.MethodAttributes.NewSlot)) { " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertConstantValue,The length of the statement  "							expr = new CastExpression(new PrimitiveType(KnownTypeReference.GetCSharpNameByTypeCode(rr.Type.GetDefinition().KnownTypeCode))' expr); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The length of the statement  "			if (inst.ResultType != StackType.Void && cexpr.Type.Kind != TypeKind.Unknown && inst.ResultType != StackType.Unknown && cexpr.Type.Kind != TypeKind.None) { " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The length of the statement  "					Debug.Assert(cexpr.Type.GetStackType().IsIntegerType()' "IL instructions of integer type must convert into C# expressions of integer type"); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The length of the statement  "						Debug.Assert(underlying.GetStackType().IsIntegerType()' "IL instructions of integer type must convert into C# expressions of integer type"); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "			// If this is a reference to the backing field of an automatic property and we're going to transform automatic properties " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "			// in PatternStatementTransform' then we have to do the "requires qualifier"-check based on the property instead of the field. " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "			// It is easier to solve this special case here than in PatternStatementTransform' because here we perform all resolver checks. " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "			if (settings.AutomaticProperties && PatternStatementTransform.IsBackingFieldOfAutomaticProperty(field' out var property)) { " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "					result = resolver.ResolveSimpleName(field.Name' EmptyList<IType>.Instance' isInvocationTarget: false) as MemberResolveResult; " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNewArr,The length of the statement  "				.WithRR(new ArrayCreateResolveResult(new ArrayType(compilation' inst.Type' dimensions)' args.Select(a => a.ResolveResult).ToList()' Empty<ResolveResult>.Array)); " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,LogicNot,The length of the statement  "			expr = expr.UnwrapImplicitBoolConversion(type => !type.GetMethods(m => m.IsOperator && m.Name == "op_LogicalNot").Any()); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,LogicNot,The length of the statement  "				.WithRR(new OperatorResolveResult(compilation.FindType(KnownTypeCode.Boolean)' ExpressionType.Not' expr.ResolveResult)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleThreeValuedLogic,The length of the statement  "				.WithRR(new OperatorResolveResult(nullableBoolType' eop' null' true' new[] { left.ResolveResult' right.ResolveResult })) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedLogicOperator,The length of the statement  "				.WithRR(new InvocationResolveResult(null' inst.Method' new ResolveResult[] { left.ResolveResult' right.ResolveResult })) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandlePointerArithmetic,The length of the statement  "			TranslatedExpression offsetExpr = GetPointerArithmeticOffset(byteOffsetInst' byteOffsetExpr' pointerType.ElementType' inst.CheckForOverflow) " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,The length of the statement  "			if (inst.Operator == BinaryNumericOperator.Sub && inst.LeftInputType == StackType.Ref && inst.RightInputType == StackType.Ref) { " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,The length of the statement  "				return CallUnsafeIntrinsic("ByteOffset"' new[] { left.Expression' right.Expression }' compilation.FindType(KnownTypeCode.IntPtr)' inst); " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,The length of the statement  "						&& ldFlda.Target is LdFlda nestedLdFlda && CSharpDecompiler.IsFixedField(nestedLdFlda.Field' out var elementType' out _)) { " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				if (rightUType.IsKnownType(KnownTypeCode.Int32) || rightUType.IsKnownType(KnownTypeCode.Int64) || rightUType.IsCSharpSmallIntegerType()) { " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				left = left.ConvertTo(NullableType.IsNullable(left.Type) ? NullableType.Create(compilation' targetType) : targetType' this); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				right = right.ConvertTo(NullableType.IsNullable(right.Type) ? NullableType.Create(compilation' targetType) : targetType' this); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				resultExpr.Expression.AddAnnotation(inst.CheckForOverflow ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation); " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The length of the statement  "				var valueExpr = ReplaceMethodCallsWithOperators.RemoveRedundantToStringInConcat(value' inst.Method' isLastArgument: true).Detach(); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The length of the statement  "					.WithRR(new OperatorResolveResult(inst.Method.ReturnType' ExpressionType.AddAssign' inst.Method' inst.IsLifted' new[] { target.ResolveResult' value.ResolveResult })); " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The length of the statement  "					.WithRR(new OperatorResolveResult(inst.Method.ReturnType' AssignmentExpression.GetLinqNodeType(op.Value' false)' inst.Method' inst.IsLifted' new[] { target.ResolveResult' value.ResolveResult })); " is 195.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The length of the statement  "				UnaryOperatorType? op = GetUnaryOperatorTypeFromMetadataName(inst.Method.Name' inst.EvalMode == CompoundEvalMode.EvaluatesToOldValue); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The length of the statement  "					.WithRR(new OperatorResolveResult(inst.Method.ReturnType' UnaryOperatorExpression.GetLinqNodeType(op.Value' false)' inst.Method' inst.IsLifted' new[] { target.ResolveResult })); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The length of the statement  "								value.Expression.AddChild(new Comment("ILSpy Error: GetPointerArithmeticOffset() failed"' CommentType.MultiLine)' Roles.Comment); " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The length of the statement  "					.WithRR(new OperatorResolveResult(target.Type' AssignmentExpression.GetLinqNodeType(op' inst.CheckForOverflow)' target.ResolveResult' value.ResolveResult)); " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The length of the statement  "				resultExpr.Expression.AddAnnotation(inst.CheckForOverflow ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation); " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateFunction,The length of the statement  "			StatementBuilder builder = new StatementBuilder(typeSystem' this.decompilationContext' function' settings' cancellationToken); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeParameters,The length of the statement  "					if (settings.LocalFunctions && function.Kind == ILFunctionKind.LocalFunction && IL.Transforms.LocalFunctionDecompiler.IsClosureParameter(parameter' decompilationContext)) " is 170.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitBlockContainer,The length of the statement  "					.WithRR(new CSharpInvocationResolveResult(new ResolveResult(delegateType)' delegateType.GetDelegateInvokeMethod()' EmptyList<ResolveResult>.Instance)); " is 151.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateTarget,The length of the statement  "				if (nonVirtualInvocation && target.MatchLdThis() && memberDeclaringType.GetDefinition() != resolver.CurrentTypeDefinition) { " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateTarget,The length of the statement  "						if (!(translatedTarget.Type is ByReferenceType brt && NormalizeTypeVisitor.TypeErasure.EquivalentTypes(brt.ElementType' memberDeclaringType))) { " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitStObj,The length of the statement  "			if (pointer.Expression is DirectionExpression && TypeUtils.IsCompatiblePointerTypeForMemoryAccess(pointer.Type' inst.Type)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitLdFlda,The length of the statement  "				if (translatedTarget.Type is TupleType tupleType && NormalizeTypeVisitor.TypeErasure.EquivalentTypes(tupleType' underlyingTupleType) && position <= tupleType.ElementNames.Length) { " is 180.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The length of the statement  "									.BuildDictionaryInitializerExpression(lastElement.OpCode' property.Setter' initObjRR' GetIndices(lastElement.Indices' indexVariables).ToList()' info.Values.Single()) " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The length of the statement  "			} else if (values.Count == 1 && !(values[0].Expression is AssignmentExpression || values[0].Expression is NamedExpression)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The length of the statement  "						.BuildDictionaryInitializerExpression(valuePath.OpCode' property.Setter' rr' GetIndices(valuePath.Indices' indexVariables).ToList()); " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The length of the statement  "					index = new IndexerExpression(null' GetIndices(valuePath.Indices' indexVariables).Select(i => Translate(i).Expression)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The length of the statement  "			if (stloc == null || final == null || !stloc.Value.MatchNewArr(out type) || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget) " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The length of the statement  "				.WithRR(new ArrayCreateResolveResult(new ArrayType(compilation' type' dimensions)' newArr.Indices.Select(i => Translate(i).ResolveResult).ToArray()' elementResolveResults)); " is 173.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,The length of the statement  "			if (stloc == null || final == null || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,The length of the statement  "				if (!block.Instructions[i].MatchStObj(out var target' out var value' out t) || !TypeUtils.IsCompatibleTypeForMemoryAccess(elementType' t)) " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,The length of the statement  "					initializer.Elements.Add(Translate(IL.Transforms.TransformArrayInitializers.GetNullExpression(elementType)' typeHint: elementType)); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,AdjustConstantToType,The length of the statement  "			} else if (typeHint.Kind == TypeKind.Enum || typeHint.IsKnownType(KnownTypeCode.Char) || typeHint.IsCSharpSmallIntegerType()) { " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNullCoalescingInstruction,The length of the statement  "			var rr = resolver.ResolveBinaryOperator(BinaryOperatorType.NullCoalescing' value.ResolveResult' fallback.ResolveResult); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNullCoalescingInstruction,The length of the statement  "				} else if (!value.Type.Equals(SpecialType.NullType) && !fallback.Type.Equals(SpecialType.NullType) && !value.Type.Equals(fallback.Type)) { " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "			if (op != BinaryOperatorType.Any && (rhs.Type.IsKnownType(KnownTypeCode.Boolean) || IfInstruction.IsInConditionSlot(inst))) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "				if (!trueBranch.Type.Equals(SpecialType.NullType) && !falseBranch.Type.Equals(SpecialType.NullType) && !trueBranch.Type.Equals(falseBranch.Type)) { " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "					targetType = typeInference.GetBestCommonType(new[] { trueBranch.ResolveResult' falseBranch.ResolveResult }' out bool success); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicConvertInstruction,The length of the statement  "			result.Expression.AddAnnotation(inst.IsChecked ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicGetIndexInstruction,The length of the statement  "				.WithRR(new DynamicInvocationResolveResult(target.ResolveResult' DynamicInvocationType.Indexing' arguments.Select(a => a.ResolveResult).ToArray())); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicInvokeConstructorInstruction,The length of the statement  "			if (!(inst.ArgumentInfo[0].HasFlag(CSharpArgumentInfoFlags.IsStaticType) && IL.Transforms.TransformExpressionTrees.MatchGetTypeFromHandle(inst.Arguments[0]' out var constructorType))) " is 183.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicInvokeMemberInstruction,The length of the statement  "			return new InvocationExpression(new MemberReferenceExpression(target' inst.Name' inst.TypeArguments.Select(ConvertType))' arguments.Select(a => a.Expression)) " is 158.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicInvokeMemberInstruction,The length of the statement  "				.WithRR(new DynamicInvocationResolveResult(target.ResolveResult' DynamicInvocationType.Invocation' arguments.Select(a => a.ResolveResult).ToArray())); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicInvokeInstruction,The length of the statement  "				.WithRR(new DynamicInvocationResolveResult(target.ResolveResult' DynamicInvocationType.Invocation' arguments.Select(a => a.ResolveResult).ToArray())); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateDynamicTarget,The length of the statement  "			if (argumentInfo.HasFlag(CSharpArgumentInfoFlags.IsStaticType) && IL.Transforms.TransformExpressionTrees.MatchGetTypeFromHandle(inst' out var callTargetType)) { " is 160.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateDynamicArgument,The length of the statement  "				translatedExpression = new TranslatedExpression(new NamedArgumentExpression(info.Name' translatedExpression.Expression)); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicSetIndexInstruction,The length of the statement  "				.WithRR(new DynamicInvocationResolveResult(target.ResolveResult' DynamicInvocationType.Indexing' arguments.SkipLast(1).Select(a => a.ResolveResult).ToArray())); " is 160.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicBinaryOperatorInstruction,The length of the statement  "					return CreateBinaryOperator(BinaryOperatorType.Add' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicBinaryOperatorInstruction,The length of the statement  "					return CreateBinaryOperator(BinaryOperatorType.Subtract' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicBinaryOperatorInstruction,The length of the statement  "					return CreateBinaryOperator(BinaryOperatorType.Multiply' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicUnaryOperatorInstruction,The length of the statement  "					return CreateUnaryOperator(UnaryOperatorType.Decrement' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicUnaryOperatorInstruction,The length of the statement  "					return CreateUnaryOperator(UnaryOperatorType.Increment' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicUnaryOperatorInstruction,The length of the statement  "					return CreateUnaryOperator(UnaryOperatorType.Minus' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicUnaryOperatorInstruction,The length of the statement  "					return CreateUnaryOperator(UnaryOperatorType.Plus' isChecked: inst.BinderFlags.HasFlag(CSharpBinderFlags.CheckedContext)); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicCompoundAssign,The length of the statement  "			var ae = new AssignmentExpression(target' AssignmentExpression.GetAssignmentOperatorTypeFromExpressionType(inst.Operation).Value' value); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicCompoundAssign,The length of the statement  "				.WithRR(new OperatorResolveResult(SpecialType.Dynamic' inst.Operation' new[] { target.ResolveResult' value.ResolveResult })); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitLdFtn,The length of the statement  "			ExpressionWithResolveResult delegateRef = new CallBuilder(this' typeSystem' settings).BuildMethodReference(inst.Method' isVirtual: false); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitLdVirtFtn,The length of the statement  "			ExpressionWithResolveResult delegateRef = new CallBuilder(this' typeSystem' settings).BuildMethodReference(inst.Method' isVirtual: true); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "			Dictionary<IL.SwitchSection' Syntax.SwitchSection> translationDictionary = new Dictionary<IL.SwitchSection' Syntax.SwitchSection>(); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "					astSection.CaseLabels.AddRange(values.Select(label => new CaseLabel(exprBuilder.ConvertConstantValue(label' allowImplicitConversion: true)))); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (br.TargetContainer == switchContainer && switchContainer.Descendants.OfType<Branch>().Where(b => b.TargetBlock == br.TargetBlock).All(b => BlockContainer.FindClosestSwitchContainer(b) == switchContainer)) " is 208.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (br.TargetContainer == switchContainer && switchContainer.Descendants.OfType<Branch>().Where(b => b.TargetBlock == br.TargetBlock).All(b => BlockContainer.FindClosestSwitchContainer(b) == switchContainer)) " is 208.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (astSection.CaseLabels.Count == 1 && astSection.CaseLabels.First().Expression.IsNull && leave.TargetContainer == switchContainer) { " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitBranch,The length of the statement  "				return new GotoCaseStatement() { LabelExpression = exprBuilder.ConvertConstantValue(label' allowImplicitConversion: true) }; " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "			if (!inst.ResourceExpression.MatchLdNull() && !NullableType.GetUnderlyingType(var.Type).GetAllBaseTypes().Any(b => b.IsKnownType(knownTypeCode))) { " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "				Expression disposeInvocation = new InvocationExpression(new MemberReferenceExpression(exprBuilder.ConvertVariable(disposeVariable).Expression' disposeTypeMethodName)); " is 167.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "							new ExpressionStatement(new AssignmentExpression(exprBuilder.ConvertVariable(disposeVariable).Expression' new AsExpression(exprBuilder.ConvertVariable(var).Expression' exprBuilder.ConvertType(disposeType))))' " is 208.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "								Condition = new BinaryOperatorExpression(exprBuilder.ConvertVariable(disposeVariable)' BinaryOperatorType.InEquality' new NullReferenceExpression())' " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "					var type = settings.AnonymousTypes && var.Type.ContainsAnonymousType() ? new SimpleType("var") : exprBuilder.ConvertType(var.Type); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "			var transformation = DetectGetCurrentTransformation(container' body' enumeratorVar' conditionInst' out var singleGetter' out var foreachVariable); " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "			if (foreachVariable != null && !(foreachVariable.CaptureScope == null || foreachVariable.CaptureScope == loopContainer)) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "					foreachVariable.Name = AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>()' foreachVariable); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The length of the statement  "			var loads = (enumerator.LoadInstructions.OfType<ILInstruction>().Concat(enumerator.AddressInstructions.OfType<ILInstruction>())).Where(ld => !ld.IsDescendantOf(moveNextUsage)).ToArray(); " is 186.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The length of the statement  "			if (!(singleGetter.IsDescendantOf(loopBody.Instructions[0]) && ILInlining.CanUninline(singleGetter' loopBody.Instructions[0]))) " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The length of the statement  "			if (inst.Parent is StLoc stloc && (stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.StackSlot)) { " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitBlockContainer,The length of the statement  "			} else if (container.EntryPoint.Instructions.Count == 1 && container.EntryPoint.Instructions[0] is SwitchInstruction switchInst) { " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The length of the statement  "					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.Skip(1).Except(new[] { loopBody })' true); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The length of the statement  "					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.SkipLast(1).Skip(1).Except(new[] { loopBody })' true); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DeclareLocalFunctions,The length of the statement  "				var nestedBuilder = new StatementBuilder(typeSystem' exprBuilder.decompilationContext' function' settings' cancellationToken); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkIdentifier = frameworkParts.FirstOrDefault(a => !a.StartsWith("Version="' StringComparison.OrdinalIgnoreCase) && !a.StartsWith("Profile="' StringComparison.OrdinalIgnoreCase)); " is 192.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkVersion = frameworkParts.FirstOrDefault(a => a.StartsWith("Version="' StringComparison.OrdinalIgnoreCase)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkProfile = frameworkParts.FirstOrDefault(a => a.StartsWith("Profile="' StringComparison.OrdinalIgnoreCase)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "				if (frameworkVersionNumber > 400 && platformName == "AnyCPU" && (module.Reader.PEHeaders.CorHeader.Flags & CorFlags.Prefers32Bit) == 0) { " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "						w.WriteAttributeString("Project"' "$(MSBuildExtensionsPath32)\\Microsoft\\Portable\\$(TargetFrameworkVersion)\\Microsoft.Portable.CSharp.targets"); " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,IncludeTypeWhenDecompilingProject,The length of the statement  "			if (metadata.GetString(typeDef.Namespace) == "XamlGeneratedNamespace" && metadata.GetString(typeDef.Name) == "GeneratedInternalTypeHelper") " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteCodeFilesInProject,The length of the statement  "			var files = module.Metadata.GetTopLevelTypeDefinitions().Where(td => IncludeTypeWhenDecompilingProject(module' td)).GroupBy( " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteCodeFilesInProject,The length of the statement  "						} catch (Exception innerException) when (!(innerException is OperationCanceledException || innerException is DecompilerException)) { " is 132.
Long Statement,ICSharpCode.Decompiler.Documentation,XmlDocumentationElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs,CreateElements,The length of the statement  "							foreach (IMember baseMember in InheritanceHelper.GetBaseMembers((IMember)declaringEntity' includeImplementedInterfaces: true)) { " is 128.
Long Statement,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,GetIdString,The length of the statement  "			if (member.IsExplicitInterfaceImplementation && member.Name.IndexOf('.') < 0 && member.ExplicitlyImplementedInterfaceMembers.Count() == 1) { " is 140.
Long Statement,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The length of the statement  "			while (pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')) " is 120.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The length of the statement  "				if (tryCatch.Handlers.Count != 1 || !(tryCatch.Handlers[0].Body is BlockContainer catchBlockContainer) || !tryCatch.Handlers[0].Variable.Type.IsKnownType(KnownTypeCode.Object)) " is 176.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The length of the statement  "				if (block.Instructions.Count < 2 || !block.Instructions[0].MatchStLoc(out var globalCopyVar' out var value) || !value.MatchLdLoc(tryCatch.Handlers[0].Variable)) " is 160.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The length of the statement  "				if (tempStore == null || !MatchExceptionCaptureBlock(tempStore' out var exitOfFinally' out var afterFinally' out var blocksToRemove)) " is 133.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The length of the statement  "				|| !cast.MatchIsInst(out var arg' out var type) || !type.IsKnownType(KnownTypeCode.Exception) || !arg.MatchLdLoc(tempStore.Variable)) " is 133.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The length of the statement  "			if (throwBlock.Instructions.Count != 1 || !throwBlock.Instructions[0].MatchThrow(out arg) || !arg.MatchLdLoc(tempStore.Variable)) " is 129.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The length of the statement  "			if (!(captureBlock.Instructions[0] is CallVirt callVirt) || callVirt.Method.FullName != "System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw" || callVirt.Arguments.Count != 1) " is 184.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The length of the statement  "			if (!(callVirt.Arguments[0] is Call call) || call.Method.FullName != "System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture" || call.Arguments.Count != 1) " is 163.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchAfterFinallyBlock,The length of the statement  "					if (ifInst.Condition.MatchCompEquals(out var load' out var ldone) && ldone.MatchLdcI4(1) && load.MatchLdLoc(out var variable)) { " is 128.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchAfterFinallyBlock,The length of the statement  "					} else if (ifInst.Condition.MatchCompNotEquals(out load' out ldone) && ldone.MatchLdcI4(1) && load.MatchLdLoc(out variable)) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,IsCompilerGeneratedStateMachine,The length of the statement  "				if (!tr.IsNested && tr.TopLevelTypeName.Namespace == "System.Runtime.CompilerServices" && tr.TopLevelTypeName.Name == "IAsyncStateMachine") " is 139.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,IsCompilerGeneratedMainMethod,The length of the statement  "			var entrypoint = System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(module.Reader.PEHeaders.CorHeader.EntryPointTokenOrRelativeVirtualAddress); " is 165.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanUpBodyOfMoveNext,The length of the statement  "			foreach (var stloc in function.Descendants.OfType<StLoc>().Where(s => s.Variable.Kind == VariableKind.StackSlot && s.Variable.IsSingleDefinition && s.Value is LdLoca).ToList()) { " is 178.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanUpBodyOfMoveNext,The length of the statement  "			foreach (var stloc in function.Descendants.OfType<StLoc>().Where(s => s.Variable.IsSingleDefinition && s.Value.MatchLdThis()).ToList()) { " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "					stloc V_1(ldobj System.Runtime.CompilerServices.AsyncVoidMethodBuilder(ldflda [Field Async+<AwaitYield>d__3.<>t__builder](ldloc V_0))) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "			if (!(loadStateMachineForBuilderExpr.MatchLdLocRef(stateMachineVar) || loadStateMachineForBuilderExpr.MatchLdLoc(stateMachineVar))) " is 131.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "				if (!(init is NewObj newobj && newobj.Arguments.Count == 0 && newobj.Method.DeclaringTypeDefinition == stateMachineType)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,IsCompilerGeneratorAsyncEnumerator,The length of the statement  "			if (type.IsNil || !type.IsCompilerGeneratedOrIsInCompilerGeneratedClass(metadata) || (td = metadata.GetTypeDefinition(type)).GetDeclaringType().IsNil) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,IsCompilerGeneratorAsyncEnumerator,The length of the statement  "				if (!tr.IsNested && tr.TopLevelTypeName.Namespace == "System.Collections.Generic" && tr.TopLevelTypeName.Name == "IAsyncEnumerator" && tr.TopLevelTypeName.TypeParameterCount == 1) " is 179.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ResolveIEnumerableIEnumeratorFieldMapping,The length of the statement  "			var getAsyncEnumerator = stateMachineType.Methods.FirstOrDefault(m => m.Name.EndsWith(".GetAsyncEnumerator"' StringComparison.Ordinal)); " is 136.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ResolveIEnumerableIEnumeratorFieldMapping,The length of the statement  "			YieldReturnDecompiler.ResolveIEnumerableIEnumeratorFieldMapping((MethodDefinitionHandle)getAsyncEnumerator.MetadataToken' context' fieldToParameterMap); " is 152.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The length of the statement  "			// stobj System.Int32(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<SimpleBoolTaskMethod>d__7.<>1__state](ldloc this)' ldc.i4 -2) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The length of the statement  "			// call SetResult(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<SimpleBoolTaskMethod>d__7.<>t__builder](ldloc this)' ldloc result) " is 151.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeDisposeAsync,The length of the statement  "			var disposeAsync = stateMachineType.Methods.FirstOrDefault(m => m.Name.EndsWith(".DisposeAsync"' StringComparison.Ordinal)); " is 124.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,InlineBodyOfMoveNext,The length of the statement  "					branch.ReplaceWith(new Leave((BlockContainer)function.Body' resultVar == null ? null : new LdLoc(resultVar)).WithILRange(branch)); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,InlineBodyOfMoveNext,The length of the statement  "			function.Variables.AddRange(function.Descendants.OfType<IInstructionWithVariableOperand>().Select(inst => inst.Variable).Distinct()); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The length of the statement  "			if (!(getAwaiterCall.Method.Name == "GetAwaiter" && (!getAwaiterCall.Method.IsStatic || getAwaiterCall.Method.IsExtensionMethod))) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The length of the statement  "				// {stobj System.Runtime.CompilerServices.TaskAwaiter`1[[System.Int32]](ldflda <>u__$awaiter4(ldloc this)' ldloc V_6) at IL_0163} " is 129.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The length of the statement  "			if (block.Instructions[pos] is StLoc stlocM1 && stlocM1.Value.MatchLdcI4(initialState) && stlocM1.Variable.Kind == VariableKind.StackSlot) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanDoFinallyBodies,The length of the statement  "			if (entryPoint != null && entryPoint.Instructions[0].MatchStLoc(doFinallyBodies' out var value) && value.MatchLdcI4(1)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,GetBodyEntryPoint,The length of the statement  "			while (entryPoint.Instructions[0].MatchBranch(out var targetBlock) && targetBlock.IncomingEdgeCount == 1 && targetBlock.Parent == body) { " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,AnalyzeHandlers,The length of the statement  "			transformableCatchBlocks = new List<(int Id' TryCatchHandler Handler' Block RealCatchBlockEntryPoint' ILInstruction NextBlockOrExitContainer' IfInstruction JumpTableEntry' StLoc ObjectVariableStore)>(); " is 202.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,AnalyzeHandlers,The length of the statement  "				if (!MatchAwaitCatchHandler((BlockContainer)handler.Body' out int id' out var identifierVariable' out var realEntryPoint' out var nextBlockOrExitContainer' out var jumpTableEntry' out var objectVariableStore)) " is 209.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,AnalyzeHandlers,The length of the statement  "				transformableCatchBlocks.Add((id' handler' realEntryPoint' nextBlockOrExitContainer' jumpTableEntry' objectVariableStore)); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The length of the statement  "				if (!jumpTableStartBlock.Instructions[0].MatchStLoc(out identifierVariableCopy' out var identifierVariableLoad) || !identifierVariableLoad.MatchLdLoc(identifierVariable)) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,Run,The length of the statement  "			this.currentType = metadata.GetMethodDefinition((MethodDefinitionHandle)context.Function.Method.MetadataToken).GetDeclaringType(); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,Run,The length of the statement  "			function.Variables.AddRange(newBody.Descendants.OfType<IInstructionWithVariableOperand>().Select(inst => inst.Variable).Distinct()); " is 132.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,IsCompilerGeneratorEnumerator,The length of the statement  "			if (type.IsNil || !type.IsCompilerGeneratedOrIsInCompilerGeneratedClass(metadata) || (td = metadata.GetTypeDefinition(type)).GetDeclaringType().IsNil) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The length of the statement  "				m => metadata.GetString(metadata.GetMethodDefinition(m).Name).StartsWith("System.Collections.Generic.IEnumerator"' StringComparison.Ordinal) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ResolveIEnumerableIEnumeratorFieldMapping,The length of the statement  "				m => metadata.GetString(metadata.GetMethodDefinition(m).Name).StartsWith("System.Collections.Generic.IEnumerable"' StringComparison.Ordinal) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConstructExceptionTable,The length of the statement  "				disposeMethod = metadata.GetTypeDefinition(enumeratorType).GetMethods().FirstOrDefault(m => metadata.GetString(metadata.GetMethodDefinition(m).Name) == "Dispose"); " is 163.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConstructExceptionTable,The length of the statement  "				disposeMethod = metadata.GetTypeDefinition(enumeratorType).GetMethods().FirstOrDefault(m => metadata.GetString(metadata.GetMethodDefinition(m).Name) == "System.IDisposable.Dispose"); " is 182.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			MethodDefinitionHandle moveNextMethod = metadata.GetTypeDefinition(enumeratorType).GetMethods().FirstOrDefault(m => metadata.GetString(metadata.GetMethodDefinition(m).Name) == "MoveNext"); " is 188.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			foreach (var stloc in moveNextFunction.Descendants.OfType<StLoc>().Where(s => s.Variable.IsSingleDefinition && s.Value.MatchLdThis()).ToList()) { " is 145.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			if (body.Blocks.Count == 1 && body.Blocks[0].Instructions.Count == 1 && body.Blocks[0].Instructions[0] is TryFault tryFault) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "						if (ifInst.Condition.MatchLogicNot(out var arg) && arg.MatchLdLoc(out var v) && v.Type.IsKnownType(KnownTypeCode.Boolean)) { " is 124.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,PropagateCopiesOfFields,The length of the statement  "			var mutableFields = body.Descendants.OfType<LdFlda>().Where(ldflda => ldflda.Parent.OpCode != OpCode.LdObj).Select(ldflda => ldflda.Field).ToHashSet(); " is 151.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,The length of the statement  "						Debug.Assert(blockState[branch.TargetBlock.ChildIndex] == stateAfterBranch || blockState[branch.TargetBlock.ChildIndex] == 0); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,RemoveDeadStackStores,The length of the statement  "				if (block.Instructions[i] is StLoc stloc && stloc.Variable.IsSingleDefinition && stloc.Variable.LoadCount == 0 && stloc.Variable.Kind == VariableKind.StackSlot) { " is 162.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,SimplifyBranchChains,The length of the statement  "				} else if (targetBlock.Instructions.Count == 1 && targetBlock.Instructions[0] is Leave leave && leave.Value.MatchNop()) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The length of the statement  "			if (block.Instructions.Count > 1 && block.Instructions[block.Instructions.Count - 2].HasFlag(InstructionFlags.MayBranch)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The length of the statement  "			if (!(block.Instructions.SecondToLastOrDefault() is StLoc deadStore && block.Instructions[block.Instructions.Count - 3] is StLoc tempStore)) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The length of the statement  "			if (!(deadStore.Value.MatchLdLoc(tempStore.Variable) && tempStore.Variable.IsSingleDefinition && tempStore.Variable.LoadCount == 1)) " is 132.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,Run,The length of the statement  "					if (stloc != null && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,SplitBlocksAtWritesToPinnedLocals,The length of the statement  "					if (inst.MatchStLoc(out v) && v.Kind == VariableKind.PinnedLocal && block.Instructions[j + 1].OpCode != OpCode.Branch) { " is 120.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The length of the statement  "			if (!(condition != null && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull())) " is 139.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The length of the statement  "			if (inst is Conv conv && conv.Kind == ConversionKind.StopGCTracking && conv.Argument.MatchLdLoc(oldVar) && conv.ResultType == newVar.StackType) { " is 145.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The length of the statement  "				if ((inst is LdLoc || inst is StLoc) && !IsSlotAcceptingBothManagedAndUnmanagedPointers(inst.SlotInfo) && oldVar.StackType != StackType.I) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,The length of the statement  "			// stloc nativeVar(add(ldloc nativeVar' conv i4->i <sign extend>(call [Accessor System.Runtime.CompilerServices.RuntimeHelpers.get_OffsetToStringData():System.Int32]()))) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,The length of the statement  "			while (entryPoint.IncomingEdgeCount == 1 && entryPoint.Instructions.Count == 1 && entryPoint.Instructions[0].MatchBranch(out var targetBlock)) { " is 144.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeSwitch,The length of the statement  "				if (matchValues.Count() > 1 && section.Body.MatchBranch(out var targetBlock) && AnalyzeBlock(targetBlock' matchValues)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,SortSwitchSections,The length of the statement  "			sw.Sections.ReplaceList(sw.Sections.OrderBy(s => (s.Body as Branch)?.TargetILOffset).ThenBy(s => s.Labels.Values.FirstOrDefault())); " is 132.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,UseCSharpSwitch,The length of the statement  "			// These goto statements may be "goto case x" or "goto default"' but these are a hint that the original code was not a switch' " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,UseCSharpSwitch,The length of the statement  "			return breakBlock.StartILOffset >= analysis.Sections.Select(s => s.Value.MatchBranch(out var b) ? b.StartILOffset : -1).Max(); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,MatchRoslynSwitchOnString,The length of the statement  "			return insns.Count >= 3 && SwitchOnStringTransform.MatchComputeStringHashCall(insns[insns.Count - 3]' analysis.SwitchVariable' out var switchLdLoc); " is 148.
Long Statement,ICSharpCode.Decompiler.Solution,SolutionCreator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Solution\SolutionCreator.cs,WriteProjects,The length of the statement  "				writer.WriteLine($"Project(\"{solutionGuid}\") = \"{project.ProjectName}\"' \"{projectRelativePath}\"' \"{projectGuid}\""); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,The length of the statement  "				throw new ArgumentException(string.Format("The new node '{0}' is not valid in the role {1}"' newNode.GetType().Name' this.Role.ToString())' nameof(newNode)); " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,The length of the statement  "					throw new InvalidOperationException(string.Format("The new node '{0}' is not valid in the role {1}"' replacement.GetType().Name' oldRole.ToString())); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstType.cs,GetNameLookupMode,The length of the statement  "				if (outermostType.Parent is TypeDeclaration || (outermostType.Parent is Constraint && outermostType.Parent.Parent is TypeDeclaration)) " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The length of the statement  "					return new BinaryOperatorExpression(InvertCondition(bOp.Left)' NegateConditionOperator(bOp.Operator)' InvertCondition(bOp.Right)); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The length of the statement  "				} else if ((bOp.Operator == BinaryOperatorType.Equality) || (bOp.Operator == BinaryOperatorType.InEquality) || (bOp.Operator == BinaryOperatorType.GreaterThan) " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ConditionalExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ConditionalExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.TrueExpression.DoMatch(o.TrueExpression' match) && this.FalseExpression.DoMatch(o.FalseExpression' match); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,LambdaExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\LambdaExpression.cs,DoMatch,The length of the statement  "			return o != null && this.IsAsync == o.IsAsync && this.Parameters.DoMatch(o.Parameters' match) && this.Body.DoMatch(o.Body' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,MemberReferenceExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\MemberReferenceExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Target.DoMatch(o.Target' match) && MatchString(this.MemberName' o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments' match); " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ObjectCreateExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ObjectCreateExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && this.Arguments.DoMatch(o.Arguments' match) && this.Initializer.DoMatch(o.Initializer' match); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,UndocumentedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UndocumentedExpression.cs,DoMatch,The length of the statement  "			return o != null && this.UndocumentedExpressionType == o.UndocumentedExpressionType && this.Arguments.DoMatch(o.Arguments' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AttributeSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\AttributeSection.cs,DoMatch,The length of the statement  "			return o != null && MatchString(this.AttributeTarget' o.AttributeTarget) && this.Attributes.DoMatch(o.Attributes' match); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeParameterDeclaration,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\TypeParameterDeclaration.cs,DoMatch,The length of the statement  "			return o != null && this.Variance == o.Variance && MatchString(this.Name' o.Name) && this.Attributes.DoMatch(o.Attributes' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,Identifier,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Identifier.cs,Create,The length of the statement  "				return new Identifier (name.Substring (1)' new TextLocation (location.Line' location.Column + 1)) { IsVerbatim = true }; " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,MemberType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\MemberType.cs,ToTypeReference,The length of the statement  "			return interningProvider.Intern(new MemberTypeOrNamespaceReference(t' memberName' interningProvider.InternList(typeArguments)' lookupMode)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,DoWhileStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\DoWhileStatement.cs,DoMatch,The length of the statement  "			return o != null && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match) && this.Condition.DoMatch(o.Condition' match); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,FixedStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\FixedStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && this.Variables.DoMatch(o.Variables' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,IfElseStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\IfElseStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.TrueStatement.DoMatch(o.TrueStatement' match) && this.FalseStatement.DoMatch(o.FalseStatement' match); " is 173.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,LockStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\LockStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Expression.DoMatch(o.Expression' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,SwitchStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\SwitchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Expression.DoMatch(o.Expression' match) && this.SwitchSections.DoMatch(o.SwitchSections' match); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TryCatchStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.TryBlock.DoMatch(o.TryBlock' match) && this.CatchClauses.DoMatch(o.CatchClauses' match) && this.FinallyBlock.DoMatch(o.FinallyBlock' match); " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CatchClause,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && MatchString(this.VariableName' o.VariableName) && this.Body.DoMatch(o.Body' match); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,UsingStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\UsingStatement.cs,DoMatch,The length of the statement  "			return o != null && this.IsAsync == o.IsAsync && this.ResourceAcquisition.DoMatch(o.ResourceAcquisition' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 174.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,VariableDeclarationStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\VariableDeclarationStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Modifiers == o.Modifiers && this.Type.DoMatch(o.Type' match) && this.Variables.DoMatch(o.Variables' match); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,WhileStatement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\WhileStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,SyntaxTree,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxTree.cs,GetTypes,The length of the statement  "					    (child.Role != Roles.TypeMemberRole || ((child is TypeDeclaration || child is DelegateDeclaration) && includeInnerTypes))) " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ConstructorInitializer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\ConstructorDeclaration.cs,DoMatch,The length of the statement  "				&& (this.ConstructorInitializerType == ConstructorInitializerType.Any || this.ConstructorInitializerType == o.ConstructorInitializerType) " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,EntityDeclaration,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\EntityDeclaration.cs,MatchAttributesAndModifiers,The length of the statement  "			return (this.Modifiers == Modifiers.Any || this.Modifiers == o.Modifiers) && this.Attributes.DoMatch (o.Attributes' match); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,The length of the statement  "				if (trr != null || (localTypeArguments.Length == 0 && resolver.IsVariableReferenceWithSameType(rr' typeDef.Name' out trr))) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,The length of the statement  "						AddTypeArguments(shortResult' typeDef.TypeParameters' typeArguments' outerTypeParameterCount' typeDef.TypeParameterCount); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,The length of the statement  "				AddTypeArguments(shortResult' genericType.TypeParameters' typeArguments' outerTypeParameterCount' genericType.TypeParameterCount); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,The length of the statement  "			AddTypeArguments(result' genericType.TypeParameters' typeArguments' outerTypeParameterCount' genericType.TypeParameterCount); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,TypeDefMatches,The length of the statement  "			if (type == null || type.Name != typeDef.Name || type.Namespace != typeDef.Namespace || type.TypeParameterCount != typeDef.TypeParameterCount) " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The length of the statement  "					NamedExpression namedArgument = new NamedExpression(namedArg.Name' ConvertConstantValue(namedArg.Type' namedArg.Value)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,The length of the statement  "					ResolveResult withExtraAttrSuffix = resolver.LookupSimpleNameOrTypeName(type.Name + "Attribute"' EmptyList<IType>.Instance' NameLookupMode.Type); " is 145.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,The length of the statement  "						// typeName + "Attribute" is an attribute type -> we cannot use long type name' add '@' to disable implicit "Attribute" suffix. " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,The length of the statement  "							if (shortName != null && !declaringTypeDef.GetNestedTypes(t => t.TypeParameterCount == 0 && t.Name == shortName).Any(IsAttributeType)) { " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,The length of the statement  "							} else if (declaringTypeDef.GetNestedTypes(t => t.TypeParameterCount == 0 && t.Name == type.Name + "Attribute").Any(IsAttributeType)) { " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsSpecialConstant,The length of the statement  "							var left = new PrimitiveExpression(-1.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' -1.0f)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,The length of the statement  "					MemberReferenceExpression mre = new MemberReferenceExpression(new TypeReferenceExpression(ConvertType(type))' field.Name); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,The length of the statement  "			return new CastExpression(ConvertType(type)' new PrimitiveExpression(CSharpPrimitiveCast.Cast(enumBaseTypeCode' val' false))); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The length of the statement  "					if (mathType == null || !mathType.GetFields(f => f.Name == "PI" && f.IsConst).Any() || !mathType.GetFields(f => f.Name == "E" && f.IsConst).Any()) " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The length of the statement  "				if (IsValidFraction(num' den) && IsEqual(num' den' constantValue' isDouble) && Math.Abs(num) != 1 && Math.Abs(den) != 1) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEntity,The length of the statement  "					return ConvertAccessor(accessor' accessor.AccessorOwner != null ? accessor.AccessorOwner.Accessibility : Accessibility.None' false); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeDefinition,The length of the statement  "			int outerTypeParameterCount = (typeDefinition.DeclaringTypeDefinition == null) ? 0 : typeDefinition.DeclaringTypeDefinition.TypeParameterCount; " is 143.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,GenerateBodyBlock,The length of the statement  "					new ThrowStatement(new ObjectCreateExpression(ConvertType(new TopLevelTypeName("System"' "NotImplementedException"' 0)))) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The length of the statement  "			if (this.ShowTypeParameters && this.ShowTypeParameterConstraints && !method.IsOverride && !method.IsExplicitInterfaceImplementation) { " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,GetMemberModifiers,The length of the statement  "						if (!member.IsVirtual && !member.IsAbstract && !member.IsOverride && member.Accessibility != Accessibility.Private && member is IMethod method2 && method2.HasBody) " is 163.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeParameterConstraint,The length of the statement  "			if (!tp.HasDefaultConstructorConstraint && !tp.HasReferenceTypeConstraint && !tp.HasValueTypeConstraint && tp.NullabilityConstraint != Nullability.NotNullable && tp.DirectBaseTypes.All(IsObjectOrValueType)) { " is 208.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching,Repeat,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\PatternMatching\Repeat.cs,DoMatchCollection,The length of the statement  "			return false; // never do a normal (single-element) match; always make the caller look at the results on the back-tracking stack. " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "			if ((ConversionFlags & ConversionFlags.PlaceReturnTypeAfterParameterList) != ConversionFlags.PlaceReturnTypeAfterParameterList " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "			if ((ConversionFlags & ConversionFlags.ShowParameterList) == ConversionFlags.ShowParameterList && HasParameters(symbol)) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "				writer.WriteToken(symbol.SymbolKind == SymbolKind.Indexer ? Roles.LBracket : Roles.LPar' symbol.SymbolKind == SymbolKind.Indexer ? "[" : "("); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "				writer.WriteToken(symbol.SymbolKind == SymbolKind.Indexer ? Roles.RBracket : Roles.RPar' symbol.SymbolKind == SymbolKind.Indexer ? "]" : ")"); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "			if ((ConversionFlags & ConversionFlags.PlaceReturnTypeAfterParameterList) == ConversionFlags.PlaceReturnTypeAfterParameterList " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "						new IndexerExpression(new TypeReferenceExpression(rt)' astBuilder.ConvertConstantValue(f.Compilation.FindType(KnownTypeCode.Int32)' elementCount)) " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.ShowAccessibility = (ConversionFlags & ConversionFlags.ShowAccessibility) == ConversionFlags.ShowAccessibility; " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedTypeNames) != ConversionFlags.UseFullyQualifiedTypeNames; " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.ShowParameterNames = (ConversionFlags & ConversionFlags.ShowParameterNames) == ConversionFlags.ShowParameterNames; " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteTypeDeclarationName,The length of the statement  "			} else if ((ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) == ConversionFlags.UseFullyQualifiedEntityNames) { " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteMemberDeclarationName,The length of the statement  "			if ((ConversionFlags & ConversionFlags.ShowDeclaringType) == ConversionFlags.ShowDeclaringType && member.DeclaringType != null) { " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertType,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) != ConversionFlags.UseFullyQualifiedEntityNames; " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertType,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) != ConversionFlags.UseFullyQualifiedEntityNames; " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,StartNode,The length of the statement  "			Debug.Assert(containerStack.Count == 0 || node.Parent == containerStack.Peek() || containerStack.Peek().NodeType == NodeType.Pattern); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,Semicolon,The length of the statement  "			if (!(role == ForStatement.InitializerRole || role == ForStatement.IteratorRole || role == UsingStatement.ResourceAcquisitionRole)) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,GetCallChainLengthLimited,The length of the statement  "			while (node.Target is InvocationExpression invocation && invocation.Target is MemberReferenceExpression mre && callChainLength < 4) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,InsertNewLineWhenInMethodCallChain,The length of the statement  "			if (expr.GetParent(n => n is Statement || n is LambdaExpression || n is InterpolatedStringContent) is InterpolatedStringContent) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitAnonymousMethodExpression,The length of the statement  "				WriteCommaSeparatedListInParenthesis(anonymousMethodExpression.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitLocalFunctionDeclarationStatement,The length of the statement  "			WriteCommaSeparatedListInParenthesis(localFunctionDeclarationStatement.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitConstructorDeclaration,The length of the statement  "			WriteCommaSeparatedListInParenthesis(constructorDeclaration.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitOperatorDeclaration,The length of the statement  "				WriteToken(OperatorDeclaration.GetToken(operatorDeclaration.OperatorType)' OperatorDeclaration.GetRole(operatorDeclaration.OperatorType)); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,MaybeNewLinesAfterUsings,The length of the statement  "			if ((node is UsingDeclaration || node is UsingAliasDeclaration) && !(nextSibling is UsingDeclaration || nextSibling is UsingAliasDeclaration)) { " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitDocumentationReference,The length of the statement  "					WriteCommaSeparatedListInParenthesis(documentationReference.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,TokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\ITokenWriter.cs,Create,The length of the statement  "			return new InsertSpecialsDecorator(new InsertRequiredSpacesDecorator(new TextWriterTokenWriter(writer) { IndentationString = indentation })); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,TokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\ITokenWriter.cs,CreateWriterThatSetsLocationsInAST,The length of the statement  "			return new InsertSpecialsDecorator(new InsertRequiredSpacesDecorator(new InsertMissingTokensDecorator(target' target))); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "			var selected = operators.Where(op => op.SourceType.Equals(mostSpecificSource) && op.TargetType.Equals(mostSpecificTarget)).ToList(); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "				return Conversion.UserDefinedConversion(selected[0].Method' isLifted: selected[0].IsLifted' isImplicit: isImplicit' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 285.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "				return Conversion.UserDefinedConversion(op.Method' isLifted: op.IsLifted' isImplicit: isImplicit' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 267.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "			return Conversion.UserDefinedConversion(selected[0].Method' isLifted: selected[0].IsLifted' isImplicit: isImplicit' isAmbiguous: true' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 304.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "				var mostSpecificSource = operators.Any(op => op.SourceType.Equals(fromType)) ? fromType : FindMostEncompassedType(operators.Select(op => op.SourceType)); " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "					return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: true' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 238.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "				var mostSpecificTarget = operators.Any(op => op.TargetType.Equals(toType)) ? toType : FindMostEncompassingType(operators.Select(op => op.TargetType)); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "						return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: true' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 238.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					var operatorsWithSourceEncompassingFromType = operators.Where(op => IsEncompassedBy(fromType' op.SourceType) || ImplicitConstantExpressionConversion(fromResult' NullableType.GetUnderlyingType(op.SourceType))).ToList(); " is 218.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: false' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 239.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					mostSpecificTarget = FindMostEncompassingType(operators.Where(op => IsEncompassedBy(op.TargetType' toType)).Select(op => op.TargetType)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "						return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: false' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 239.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "				opFilter = m => m.IsStatic && m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1; " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "					isApplicable = (IsEncompassingOrEncompassedBy(fromType' sourceType) || ImplicitConstantExpressionConversion(fromResult' sourceType)) " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "					IType liftedTargetType = NullableType.IsNonNullableValueType(targetType) ? NullableType.Create(compilation' targetType) : targetType; " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,MethodGroupConversion,The length of the statement  "			var or = rr.PerformOverloadResolution(compilation' args' allowExpandingParams: false' allowOptionalParameters: false' conversions: this); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithContext,The length of the statement  "			return new CSharpResolver(compilation' conversions' newContext' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 180.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithCheckForOverflow,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithIsWithinLambdaExpression,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithLocalVariableStack,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' stack' objectInitializerStack); " is 164.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithObjectInitializerStack,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' stack); " is 160.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "					return new AwaitResolveResult(SpecialType.Dynamic' new DynamicInvocationResolveResult(new DynamicMemberResolveResult(expression' "GetAwaiter")' DynamicInvocationType.Invocation' EmptyList<ResolveResult>.Instance)' SpecialType.Dynamic' null' null' null); " is 253.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						ResolveResult getAwaiterMethodGroup = ResolveMemberAccess(expression' "GetAwaiter"' EmptyList<IType>.Instance' NameLookupMode.InvocationTarget); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						ResolveResult getAwaiterInvocation = ResolveInvocation(getAwaiterMethodGroup' Empty<ResolveResult>.Array' argumentNames: null' allowOptionalParameters: false); " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var getResultMethodGroup = lookup.Lookup(getAwaiterInvocation' "GetResult"' EmptyList<IType>.Instance' true) as MethodGroupResolveResult; " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							var getResultOR = getResultMethodGroup.PerformOverloadResolution(compilation' Empty<ResolveResult>.Array' allowExtensionMethods: false' conversions: conversions); " is 162.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							getResultMethod = getResultOR.FoundApplicableCandidate ? getResultOR.GetBestCandidateWithSubstitutedTypeArguments() as IMethod : null; " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var isCompletedProperty = (isCompletedRR is MemberResolveResult ? ((MemberResolveResult)isCompletedRR).Member as IProperty : null); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						if (isCompletedProperty != null && (!isCompletedProperty.ReturnType.IsKnownType(KnownTypeCode.Boolean) || !isCompletedProperty.CanGet)) " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var interfaceOnCompleted = compilation.FindType(KnownTypeCode.INotifyCompletion).GetMethods().FirstOrDefault(x => x.Name == "OnCompleted"); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var interfaceUnsafeOnCompleted = compilation.FindType(KnownTypeCode.ICriticalNotifyCompletion).GetMethods().FirstOrDefault(x => x.Name == "UnsafeOnCompleted"); " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var candidates = getAwaiterInvocation.Type.GetMethods().Where(x => x.ImplementedInterfaceMembers.Select(y => y.MemberDefinition).Contains(interfaceUnsafeOnCompleted)).ToList(); " is 176.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							candidates = getAwaiterInvocation.Type.GetMethods().Where(x => x.ImplementedInterfaceMembers.Select(y => y.MemberDefinition).Contains(interfaceOnCompleted)).ToList(); " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						return new AwaitResolveResult(awaitResultType' getAwaiterInvocation' getAwaiterInvocation.Type' isCompletedProperty' onCompletedMethod' getResultMethod); " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "				return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' UnaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "					return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' UnaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "				// - If inputs aren't compile-time constants' we don't evaluate anything' so again it doesn't matter that we don't short-circuit " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "				return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' BinaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "					return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' BinaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumSubtraction,The length of the statement  "				var rr = ResolveBinaryOperator(BinaryOperatorType.Subtract' ResolveCast(elementType' lhs)' ResolveCast(elementType' rhs)); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumOperator,The length of the statement  "					if (rr.IsCompileTimeConstant) // only report result if it's a constant; use the regular OperatorResolveResult codepath otherwise " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The length of the statement  "			} else if (isNullable && rhs.Type.Kind == TypeKind.Null && lhsCode >= TypeCode.Boolean && lhsCode <= TypeCode.Decimal) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The length of the statement  "			bool parameterizeResultType = !(typeArguments.Count != 0 && typeArguments.All(t => t.Kind == TypeKind.UnboundTypeArgument)); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The length of the statement  "					r = LookInCurrentUsingScope(identifier' typeArguments' lookupMode == NameLookupMode.TypeInUsingDeclaration' parameterizeResultType); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveMemberAccess,The length of the statement  "			bool parameterizeResultType = !(typeArguments.Count != 0 && typeArguments.All(t => t.Kind == TypeKind.UnboundTypeArgument)); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveMemberAccess,The length of the statement  "					return new MethodGroupResolveResult(target' identifier' EmptyList<MethodListWithDeclaringType>.Instance' typeArguments) { " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "				getEnumeratorInvocation = ResolveMemberAccess(getEnumeratorInvocation' "GetEnumerator"' EmptyList<IType>.Instance' NameLookupMode.InvocationTarget); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "				var getEnumeratorMethodGroup = memberLookup.Lookup(expression' "GetEnumerator"' EmptyList<IType>.Instance' true) as MethodGroupResolveResult; " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "					if (or.FoundApplicableCandidate && !or.IsAmbiguous && !or.BestCandidate.IsStatic && or.BestCandidate.Accessibility == Accessibility.Public) { " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "						CheckForEnumerableInterface(expression' out collectionType' out enumeratorType' out elementType' out getEnumeratorInvocation); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "					CheckForEnumerableInterface(expression' out collectionType' out enumeratorType' out elementType' out getEnumeratorInvocation); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The length of the statement  "			var moveNextMethodGroup = memberLookup.Lookup(new ResolveResult(enumeratorType)' "MoveNext"' EmptyList<IType>.Instance' false) as MethodGroupResolveResult; " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,CheckForEnumerableInterface,The length of the statement  "			getEnumeratorInvocation = ResolveMemberAccess(getEnumeratorInvocation' "GetEnumerator"' EmptyList<IType>.Instance' NameLookupMode.InvocationTarget); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,The length of the statement  "			return IsEligibleExtensionMethod(compilation' CSharpConversions.Get(compilation)' targetType' method' useTypeInference' out outInferredTypes); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new DynamicInvocationResolveResult(target' DynamicInvocationType.Invocation' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "					// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable method. " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "					var applicableMethods = mgrr.MethodsGroupedByDeclaringType.SelectMany(m => m' (x' m) => new { x.DeclaringType' Method = m }).Where(x => OverloadResolution.IsApplicable(or2.AddCandidate(x.Method))).ToList(); " is 206.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "						return new DynamicInvocationResolveResult(new MethodGroupResolveResult(actualTarget' mgrr.MethodName' l' mgrr.TypeArguments)' DynamicInvocationType.Invocation' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 215.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				OverloadResolution or = mgrr.PerformOverloadResolution(compilation' arguments' argumentNames' checkForOverflow: checkForOverflow' conversions: conversions' allowOptionalParameters: allowOptionalParameters); " is 206.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "						return or.CreateResolveResult(new TypeResolveResult(mgrr.TargetType)' returnTypeOverride: isDynamic ? SpecialType.Dynamic : null); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new UnknownMethodResolveResult(umrr.TargetType' umrr.MemberName' umrr.TypeArguments' CreateParameters(arguments' argumentNames)); " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new UnknownMethodResolveResult(CurrentTypeDefinition' uirr.Identifier' EmptyList<IType>.Instance' CreateParameters(arguments' argumentNames)); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "				// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable indexer. " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "				var applicableIndexers = indexers.SelectMany(x => x).Where(m => OverloadResolution.IsApplicable(or2.AddCandidate(m))).ToList(); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The length of the statement  "				// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable constructor. " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The length of the statement  "				return new DynamicInvocationResolveResult(new MethodGroupResolveResult(null' allApplicable[0].Name' new[] { new MethodListWithDeclaringType(type' allApplicable) }' null)' DynamicInvocationType.ObjectCreation' AddArgumentNamesIfNecessary(arguments' argumentNames)' initializerStatements); " is 287.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveCondition,The length of the statement  "					c = Conversion.UserDefinedConversion(opTrue' isImplicit: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 170.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveConditionFalse,The length of the statement  "					c = Conversion.UserDefinedConversion(opFalse' isImplicit: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 171.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,The length of the statement  "					var nestedTypes = type.GetNestedTypes(options: GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,The length of the statement  "					AddMembers(type' entityGroup.OfType<IMember>()' allowProtectedAccess' lookupGroups' false' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupType,The length of the statement  "						nestedTypes = type.GetNestedTypes(filter' GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,Lookup,The length of the statement  "				AddMembers(type' members' allowProtectedAccess' lookupGroups' false' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupIndexers,The length of the statement  "				AddMembers(type' members' allowProtectedAccess' lookupGroups' true' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,The length of the statement  "			Log.WriteLine("Overload resolution finished' best candidate is {0}."' or.GetBestCandidateWithSubstitutedTypeArguments()); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,The length of the statement  "					Log.WriteLine("  Skipping methods in {0} because they are hidden by an applicable method in a derived type"' methodLists[i].DeclaringType); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,RunTypeInference,The length of the statement  "				candidate.InferredTypes = ti.InferTypeArguments(candidate.TypeParameters' arguments' candidate.ParameterTypes' out success' classTypeArguments); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,The length of the statement  "			return ValidateConstraints(typeParameter' typeArgument' substitution' CSharpConversions.Get(typeParameter.Owner.Compilation)); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The length of the statement  "					if (!(c == Conversion.IdentityConversion || c == Conversion.ImplicitReferenceConversion || c == Conversion.BoxingConversion)) " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,The length of the statement  "						argument = new NamedArgumentResolveResult(bestCandidateForNamedArguments.Parameters[parameterIndex]' argument' bestCandidateForNamedArguments); " is 143.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CreateResolveResult,The length of the statement  "				this.IsExtensionMethodInvocation ? new TypeResolveResult(member.DeclaringType ?? SpecialType.UnknownType) : targetResolveResult' " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,The length of the statement  "			if (candidateTypes.Count == 1 || !(algorithm == TypeInferenceAlgorithm.Improved || algorithm == TypeInferenceAlgorithm.ImprovedReturnAllResults)) " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CombineExitsTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CombineExitsTransform.cs,CombineExits,The length of the statement  "			if (!(block.Instructions.SecondToLastOrDefault() is IfInstruction ifInst && block.Instructions.LastOrDefault() is Leave leaveElse)) " is 131.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The length of the statement  "			if (!(pos + 3 < block.Instructions.Count && block.Instructions[pos].MatchStLoc(out var flagVar' out var inst) && inst is DynamicIsEventInstruction isEvent)) " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The length of the statement  "			if (!(dynamicGetMemberStore.MatchStLoc(out var getMemberVar' out inst) && inst is DynamicGetMemberInstruction getMemberInst)) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The length of the statement  "				if (!MatchIsEventAssignmentIfInstruction(descendant' isEvent' flagVar' getMemberVar' out var setMemberInst' out var getMemberVarUse' out var isEventConditionUse)) " is 162.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,MatchIsEventAssignmentIfInstruction,The length of the statement  "			if (!(Block.Unwrap(falseInst) is DynamicInvokeMemberInstruction invokeMemberInst && invokeMemberInst.Arguments.Count == 2)) " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,Run,The length of the statement  "			// Find all local functions declared inside this method' including nested local functions or local functions declared in lambdas. " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,Run,The length of the statement  "					} else if (localFunction.DeclarationScope != function.Body && localFunction.DeclarationScope.Parent is ILFunction declaringFunction) { " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,FindUseSites,The length of the statement  "				} else if (inst is LdFtn ldftn && !ldftn.Method.IsLocalFunction && ldftn.Parent is NewObj newObj && IsLocalFunctionMethod(ldftn.Method' context) && DelegateConstruction.IsDelegateConstruction(newObj)) { " is 202.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,ReadLocalFunctionDefinition,The length of the statement  "			var function = ilReader.ReadIL((MethodDefinitionHandle)targetMethod.MetadataToken' body' genericContext.Value' ILFunctionKind.LocalFunction' context.CancellationToken); " is 168.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,ReadLocalFunctionDefinition,The length of the statement  "			function.RunTransforms(CSharpDecompiler.GetILTransforms().TakeWhile(t => !(t is LocalFunctionDecompiler))' nestedContext); " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,DetermineCaptureAndDeclarationScope,The length of the statement  "					Debug.Assert(i - firstArgumentIndex < function.Method.Parameters.Count && IsClosureParameter(function.Method.Parameters[i - firstArgumentIndex]' resolveContext)); " is 162.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,DetermineCaptureAndDeclarationScope,The length of the statement  "				else if (!IsInNestedLocalFunction(function.DeclarationScope' closureVar.CaptureScope.Ancestors.OfType<ILFunction>().First())) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,DetermineCaptureAndDeclarationScope,The length of the statement  "					function.DeclarationScope = FindCommonAncestorInstruction<BlockContainer>(function.DeclarationScope' closureVar.CaptureScope); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,IsLocalFunctionMethod,The length of the statement  "			if ((method.Attributes & MethodAttributes.Assembly) == 0 || !(method.IsCompilerGenerated(metadata) || declaringType.IsCompilerGenerated(metadata))) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,Run,The length of the statement  "						if ((context.Settings.AnonymousMethods || context.Settings.ExpressionTrees) && IsClosure(v' out ITypeDefinition closureType' out var inst)) { " is 141.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,Run,The length of the statement  "						if (context.Settings.LocalFunctions && f.Kind == ILFunctionKind.LocalFunction && v.Kind == VariableKind.Parameter && v.Index > -1 && f.Method.Parameters[v.Index.Value] is IParameter p && LocalFunctionDecompiler.IsClosureParameter(p' decompilationContext)) { " is 257.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,Run,The length of the statement  "							AddOrUpdateDisplayClass(f' v' ((ByReferenceType)p.Type).ElementType.GetDefinition()' f.Body' localFunctionClosureParameter: true); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,AddOrUpdateDisplayClass,The length of the statement  "					CaptureScope = (isMono && IsMonoNestedCaptureScope(closureType)) || localFunctionClosureParameter ? null : v.CaptureScope' " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsClosure,The length of the statement  "			if (context.Settings.LocalFunctions && closureType?.Kind == TypeKind.Struct && variable.HasInitialValue && IsPotentialClosure(this.context' closureType)) { " is 155.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsMonoNestedCaptureScope,The length of the statement  "			return closureType.Fields.Any(f => IsPotentialClosure(decompilationContext.CurrentTypeDefinition' f.ReturnType.GetDefinition())); " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,HandleMonoStateMachine,The length of the statement  "				if (stateMachineVariable.StateMachineField == null || displayClass.Variables.ContainsKey(stateMachineVariable.StateMachineField)) " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,HandleMonoStateMachine,The length of the statement  "				foreach (var field in closureType.GetFields(f2 => !f2.IsStatic && !displayClass.Variables.ContainsKey(f2) && f2.Type.GetDefinition() == decompilationContext.CurrentTypeDefinition)) { " is 182.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,VisitStLoc,The length of the statement  "			if (inst.Variable.Kind == VariableKind.Local && inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 0 && inst.Value is StLoc) { " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsParameterAssignment,The length of the statement  "			if (!(inst.Value.MatchLdLoc(out var v) && v.Kind == VariableKind.Parameter && v.Function == currentFunction && v.Type.Equals(field.Type))) " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,RoslynOptimized,The length of the statement  "			if (!block.Instructions[pos].MatchIfInstructionPositiveCondition(out var condition' out var trueInst' out var falseInst)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,TransformDynamic,The length of the statement  "				// if (dynamic.unary.operator IsFalse(ldloc lhsVar)) ldloc lhsVar else dynamic.binary.operator.logic And(ldloc lhsVar' rhsInst) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "				if (!MatchCallSiteCacheNullCheck(ifInst.Condition' out var callSiteCacheField' out var callSiteDelegate' out bool invertBranches)) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "				if (!ScanCallSiteInitBlock(callSiteInitBlock' callSiteCacheField' callSiteDelegate' out var callSiteInfo' out var blockAfterInit)) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "				if (invokeCall.Method.DeclaringType.Kind != TypeKind.Delegate || invokeCall.Method.Name != "Invoke" || invokeCall.Arguments.Count == 0) " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "				if (firstArgument.MatchLdLoc(out var stackSlot) && stackSlot.Kind == VariableKind.StackSlot && stackSlot.IsSingleDefinition) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "					if (arg.MatchLdLoc(out var temporary) && temporary.Kind == VariableKind.StackSlot && temporary.IsSingleDefinition && temporary.LoadCount == 0) { " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The length of the statement  "							if (value.MatchLdFld(out cacheFieldLoad' out var targetFieldCopy) && cacheFieldLoad.MatchLdsFld(out cacheFieldCopy) && cacheField.Equals(cacheFieldCopy) && targetField.Equals(targetFieldCopy)) " is 192.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The length of the statement  "						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore)) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "			if (!callSiteInitBlock.Instructions[instCount - 2].MatchStsFld(out var field' out var value) || !field.Equals(callSiteCacheField)) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "			if (!(value is Call createBinderCall) || createBinderCall.Method.TypeArguments.Count != 0 || createBinderCall.Arguments.Count != 1 || createBinderCall.Method.Name != "Create" || createBinderCall.Method.DeclaringType.FullName != CallSiteTypeName || createBinderCall.Method.DeclaringType.TypeArguments.Count != 1) " is 311.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "			if (!(createBinderCall.Arguments[0] is Call binderCall) || binderCall.Method.DeclaringType.FullName != CSharpBinderTypeName || binderCall.Method.DeclaringType.TypeParameterCount != 0) " is 183.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) { " is 196.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _)) " is 206.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The length of the statement  "					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation; " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The length of the statement  "			if (!(value is NewArr newArr2 && newArr2.Type.FullName == "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo" && newArr2.Indices.Count == 1 && newArr2.Indices[0].MatchLdcI4(out var numberOfArguments))) " is 201.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The length of the statement  "			if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInfo.InitBlock' instructionOffset' variable' newArr2.Type' new[] { numberOfArguments }' out var arguments' out _)) " is 201.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The length of the statement  "				if (!(createCall.Method.Name == "Create" && createCall.Method.DeclaringType.FullName == "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo" && createCall.Arguments.Count == 2)) " is 176.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The length of the statement  "				callSiteInfo.ArgumentInfos[i] = new CSharpArgumentInfo { Flags = (CSharpArgumentInfoFlags)argumentInfoFlags' Name = argumentName' CompileTimeType = compileTimeTypes[i + 1] }; " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MatchCallSiteCacheNullCheck,The length of the statement  "			if (!argument.MatchLdsFld(out callSiteCacheField) || callSiteCacheField.ReturnType.TypeArguments.Count != 1 || callSiteCacheField.ReturnType.FullName != CallSiteTypeName) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileLoop,The length of the statement  "			(List<IfInstruction> conditions' ILInstruction exit' bool swap' bool split' bool unwrap) = AnalyzeDoWhileConditions(loop); " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,AnalyzeDoWhileConditions,The length of the statement  "					var split = conditionBlock == loop.EntryPoint || conditionBlock.Instructions.Count > conditions.Count + 1; // + 1 is the final leave/branch. " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The length of the statement  "			if (!(block.Instructions.SecondToLastOrDefault() is IfInstruction ifInstruction) || !ifInstruction.FalseInst.MatchNop()) " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullPropagationTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullPropagationTransform.cs,IsValidAccessChain,The length of the statement  "					if ((call.ConstrainedTo ?? call.Method.DeclaringType).IsReferenceType == false && inst.MatchAddressOf(out var arg' out _)) { " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,The length of the statement  "			var proxyFunction = ilReader.ReadIL(handle' body' genericContext' ILFunctionKind.TopLevelFunction' context.CancellationToken); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The length of the statement  "			if (!condition.MatchLogicNot(out var getHasValue) || !NullableLiftingTransform.MatchHasValueCall(getHasValue' out ILInstruction target) || !SemanticHelper.IsPure(target.Flags)) " is 176.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The length of the statement  "					if (!(NullableLiftingTransform.MatchGetValueOrDefault(getValueOrDefault' out ILInstruction target2) && target2.Match(target).Success)) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The length of the statement  "					if (!(NullableLiftingTransform.MatchGetValueOrDefault(si.Value' out ILInstruction target2) && target2.Match(target).Success)) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,Run,The length of the statement  "			if (hashtableInitializers.Count > 0 && omittedBlocks.Count == hashtableInitializers.Count && body.EntryPoint.Instructions.Count == 2) { " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ScanHashtableInitializerBlocks,The length of the statement  "				if (!ExtractStringValuesFromInitBlock(tableInitBlock' out var stringValues' out var blockAfterThisInitBlock' dictionaryType' dictField' true)) " is 142.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ScanHashtableInitializerBlocks,The length of the statement  "				hashtables.Add(dictField' (stringValues' nextHashtableInitHead' tableInitBlock' previousBlock' blockAfterThisInitBlock' false)); " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The length of the statement  "				if (i >= 2 && switchValue.MatchLdLoc(out var otherSwitchValueVar) && otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 1 " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The length of the statement  "			var sections = new List<SwitchSection>(values.Skip(offset).SelectWithIndex((index' b) => new SwitchSection { Labels = new LongSet(index)' Body = new Branch((Block)b.Item2) })); " is 176.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The length of the statement  "			sections.Add(new SwitchSection { Labels = new LongSet(new LongInterval(0' sections.Count)).Invert()' Body = currentCaseBlock != null ? (ILInstruction)new Branch(currentCaseBlock) : new Leave((BlockContainer)nextCaseBlock) }); " is 225.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The length of the statement  "			if (!(isInternedBlock.Instructions[0].MatchStLoc(out var switchValueVarCopy' out var arg) && IsIsInternedCall(arg as Call' out arg) && arg.MatchLdLoc(switchValueVar))) " is 167.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The length of the statement  "				if (!(caseBlockJump.MatchBranch(out var caseBlock) || caseBlockJump.MatchLeave((BlockContainer)currentCaseBlock.Parent))) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The length of the statement  "			var sections = new List<SwitchSection>(values.SelectWithIndex((index' b) => new SwitchSection { Labels = new LongSet(index)' Body = b.Item2 })); " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The length of the statement  "			sections.Add(new SwitchSection { Labels = new LongSet(new LongInterval(0' sections.Count)).Invert()' Body = new Branch(currentCaseBlock) }); " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// The initial store can be omitted in some cases. If there is no initial store or the switch value variable is reused later' " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "				if (!(switchValueVar.IsSingleDefinition && ((SemanticHelper.IsPure(switchValue.Flags) && left.Match(switchValue).Success) || left.MatchLdLoc(switchValueVar)))) " is 159.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// if (comp(volatile.ldobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600000c-1) != ldnull)) br caseNullBlock " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			if (nextBlock.Instructions.Count != 2 || !nextBlock.Instructions[0].MatchIfInstruction(out condition' out var tryGetValueBlockJump)) " is 132.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// volatile.stobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600003f-1' ldloc dict) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			if (!ExtractStringValuesFromInitBlock(dictInitBlock' out var stringValues' out var blockAfterInit' dictionaryType' dictField' false)) " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// if (logic.not(call TryGetValue(volatile.ldobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600000c-1)' ldloc switchValueVar' ldloca switchIndexVar))) br defaultBlock " is 213.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			if (!defaultBlockJump.MatchBranch(out var defaultBlock) && !((leaveContainer != null && defaultBlockJump.MatchLeave(leaveContainer)) || defaultBlockJump.MatchLeave(out _))) " is 172.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "				MatchDictionaryFieldLoad(c.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField))) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "					sections.Add(new SwitchSection() { Body = switchBlock.Instructions[1]' Labels = new LongSet(0).Invert() }.WithILRange(switchBlock.Instructions[1])); " is 148.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchDictionaryFieldLoad,The length of the statement  "				(dictField.IsCompilerGeneratedOrIsInCompilerGeneratedClass() || dictField.Name.StartsWith("$$method"' StringComparison.Ordinal)); " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The length of the statement  "				if (c.Arguments[1].MatchLdsFld(out var field) && field.DeclaringType.IsKnownType(KnownTypeCode.String) && field.Name == "Empty") { " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The length of the statement  "			return (c.Arguments[2].MatchLdcI4(out index) || (c.Arguments[2].MatchBox(out var arg' out _) && arg.MatchLdcI4(out index))); " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!block.Instructions[i + 3].MatchBranch(out var getItemBlock) || !(nullCaseBlockBranch.MatchBranch(out var nullCaseBlock) || nullCaseBlockBranch is Leave)) " is 158.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			// stloc tmp2(call get_Item(volatile.ldobj System.Collections.Hashtable(ldsflda $$method0x600003f - 1)' ldloc switchVariable)) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(getItemBlock.Instructions[0].MatchStLoc(out var tmp2' out var getItem) && getItem is Call getItemCall && getItemCall.Method.Name == "get_Item")) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!getItemBlock.Instructions[3].MatchBranch(out var switchBlock) || !(defaultBlockBranch.MatchBranch(out var defaultBlock) || defaultBlockBranch is Leave)) " is 157.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(getItemCall.Arguments.Count == 2 && MatchDictionaryFieldLoad(getItemCall.Arguments[0]' IsNonGenericHashtable' out var dictField' out _) && getItemCall.Arguments[1].MatchLdLoc(switchVariable))) " is 198.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(switchBlock.Instructions[0] is SwitchInstruction switchInst && switchInst.Value.MatchLdObj(out var target' out var ldobjType) && " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "				target.MatchUnbox(out var arg' out var unboxType) && arg.MatchLdLoc(switchVariable2) && ldobjType.IsKnownType(KnownTypeCode.Int32) && unboxType.Equals(ldobjType))) " is 163.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FindHashtableInitBlock,The length of the statement  "			if (!ExtractStringValuesFromInitBlock(tableInitBlock' out stringValues' out blockAfterThisInitBlock' dictionaryType' dictField' true)) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "			if (!(switchBlockInstructionsOffset + 1 < switchBlockInstructions.Count && switchBlockInstructions[switchBlockInstructionsOffset + 1] is SwitchInstruction switchInst && switchInst.Value.MatchLdLoc(out var switchValueVar) && " is 223.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "				MatchComputeStringHashCall(switchBlockInstructions[switchBlockInstructionsOffset]' switchValueVar' out LdLoc switchValueLoad))) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "				if (MatchRoslynEmptyStringCaseBlockHead(target' switchValueLoad.Variable' out ILInstruction targetOrLeave' out Block currentExitBlock)) { " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "				} else if (!MatchRoslynCaseBlockHead(target' switchValueLoad.Variable' out targetOrLeave' out currentExitBlock' out stringValue)) { " is 131.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "				if (i >= 2 && instructions[i - 2].MatchStLoc(out var temporary' out var temporaryValue) && instructions[i - 1].MatchStLoc(switchValueLoad.Variable' out var tempLoad) && tempLoad.MatchLdLoc(temporary)) { " is 202.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchComputeStringHashCall,The length of the statement  "			if (!(value is Call c && c.Arguments.Count == 1 && c.Method.Name == "ComputeStringHash" && c.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass())) " is 151.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MightBeExpressionTree,The length of the statement  "			if (!(IsEmptyParameterList(call.Arguments[1]) || (call.Arguments[1] is Block block && block.Kind == BlockKind.ArrayInitializer))) " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,IsEmptyParameterList,The length of the statement  "			if (inst is CallInstruction emptyCall && emptyCall.Method.FullNameIs("System.Array"' "Empty") && emptyCall.Arguments.Count == 0) " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,The length of the statement  "			if (parameterReferenceVar.Type == null || parameterReferenceVar.Type.FullName != "System.Linq.Expressions.ParameterExpression") " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The length of the statement  "			if (instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1) " is 216.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The length of the statement  "			if (!ReadParameters(instruction.Arguments[1]' parameterList' parameterVariablesList' new SimpleTypeResolveContext(context.Function.Method))) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,UnwrapExpressionTree,The length of the statement  "			if (delegateType is ParameterizedType pt && pt.FullName == "System.Linq.Expressions.Expression" && pt.TypeArguments.Count == 1) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The length of the statement  "			if (NullableType.IsNullable(trueInstType) && conversions.ImplicitConversion(fallbackInstType' trueInstTypeNonNullable).IsValid) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The length of the statement  "				kind = NullableType.IsNullable(fallbackInstType) ? NullCoalescingKind.Nullable : NullCoalescingKind.NullableWithValueFallback; " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "			if (invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)) { " is 163.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "			var rr = resolver.ResolveBinaryOperator(kind.ToBinaryOperatorType()' new ResolveResult(leftType)' new ResolveResult(rightType)) as OperatorResolveResult; " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "				return (new Call(rr.UserDefinedOperatorMethod) { Arguments = { left' right } }' rr.UserDefinedOperatorMethod.ReturnType); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String)); " is 244.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String)); " is 246.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The length of the statement  "				if (arguments[i] is CallInstruction elementInit && elementInit.Method.FullName == "System.Linq.Expressions.Expression.ElementInit") { " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNotOperator,The length of the statement  "					return (argumentType.IsKnownType(KnownTypeCode.Boolean) ? Comp.LogicNot(argument) : (ILInstruction)new BitNot(argument)' argumentType); " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(tryFinally) || (la.IsDescendantOf(tryFinally.TryBlock) && !ILInlining.IsUsedAsThisPointerInCall(la)))) " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			if (!(tryFinally.FinallyBlock is BlockContainer container) || !MatchDisposeBlock(container' storeInst.Variable' storeInst.Value.MatchLdNull())) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			block.Instructions[i - 1] = new UsingInstruction(storeInst.Variable' storeInst.Value' tryFinally.TryBlock).WithILRange(storeInst); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (!(tryFinally.TryBlock is BlockContainer tryContainer && tryContainer.EntryPoint.Instructions.FirstOrDefault() is StLoc storeInst)) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(tryFinally) || (la.IsDescendantOf(tryFinally.TryBlock) && !ILInlining.IsUsedAsThisPointerInCall(la)))) " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (!(tryFinally.FinallyBlock is BlockContainer container) || !MatchDisposeBlock(container' storeInst.Variable' storeInst.Value.MatchLdNull())) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,CheckResourceType,The length of the statement  "			if (type.IsKnownType(KnownTypeCode.IEnumerator) || type.GetAllBaseTypes().Any(b => b.IsKnownType(KnownTypeCode.IEnumerator))) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,CheckResourceType,The length of the statement  "			if (!type.GetMethods(m => m.Name == "GetEnumerator" && m.TypeParameters.Count == 0 && m.Parameters.Count == 0).Any(m => ImplementsForeachPattern(m.ReturnType))) " is 160.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,ImplementsForeachPattern,The length of the statement  "			if (!type.GetMethods(m => m.Name == "MoveNext" && m.TypeParameters.Count == 0 && m.Parameters.Count == 0).Any(m => m.ReturnType.IsKnownType(KnownTypeCode.Boolean))) " is 164.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The length of the statement  "				if (!isinst.MatchIsInst(out var load' out var disposableType) || !load.MatchLdLoc(objVar) || !disposableType.IsKnownType(disposeTypeCode)) " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The length of the statement  "				if (!MatchDisposeCheck(tempVar' checkInst' isReference' usingNull' out int numObjVarLoadsInCheck' disposeMethodFullName' disposeTypeCode)) " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformAsyncUsing,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(tryFinally) || (la.IsDescendantOf(tryFinally.TryBlock) && !ILInlining.IsUsedAsThisPointerInCall(la)))) " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformAsyncUsing,The length of the statement  "			if (!(tryFinally.FinallyBlock is BlockContainer container) || !MatchDisposeBlock(container' storeInst.Variable' usingNull: false' "System.IAsyncDisposable.DisposeAsync"' KnownTypeCode.IAsyncDisposable)) " is 202.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformAsyncUsing,The length of the statement  "			block.Instructions[i - 1] = new UsingInstruction(storeInst.Variable' storeInst.Value' tryFinally.TryBlock) { IsAsync = true } " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,PerformAssignment,The length of the statement  "				if (!LocalFunctionDecompiler.ParseLocalFunctionName(localFunction.Name' out _' out var newName) || !IsValidName(newName)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateNameForVariable,The length of the statement  "			if (CSharp.CSharpDecompiler.IsWindowsFormsInitializeComponentMethod(context.Function.Method) && variable.Type.FullName == "System.ComponentModel.ComponentResourceManager") { " is 173.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The length of the statement  "					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) { " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The length of the statement  "						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) { " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The length of the statement  "			string baseName = valueContext != null ? GetNameFromInstruction(valueContext) ?? GetNameByType(type) : GetNameByType(type); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The length of the statement  "				if (!entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock)) " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The length of the statement  "				if (!entryPoint.Instructions[1].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock)) " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || tryContainer.EntryPoint.Instructions.Count == 0 || tryContainer.EntryPoint.IncomingEdgeCount != 1) " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' null' objectStore.Variable)) " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || tryContainer.EntryPoint.Instructions.Count == 0 || tryContainer.EntryPoint.IncomingEdgeCount != 1) " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' null' objectStore.Variable)) " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV4,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || !MatchLockEntryPoint(tryContainer.EntryPoint' flagStore.Variable' out StLoc objectStore)) " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV4,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 1] is StLoc flagStore) || !(block.Instructions[i - 2] is StLoc objectStore)) " is 152.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!objectStore.Variable.IsSingleDefinition || !flagStore.Variable.Type.IsKnownType(KnownTypeCode.Boolean) || !flagStore.Value.MatchLdcI4(0)) " is 142.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || !MatchLockEntryPoint(tryContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The length of the statement  "				if (!(cond.MatchLdLoc(flag) || (cond.MatchCompNotEquals(out var left' out var right) && left.MatchLdLoc(flag) && right.MatchLdcI4(0))) || !MatchExitBlock(trueBlock' obj)) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The length of the statement  "			} else if (newComparisonKind == ComparisonKind.Equality && !hasValueTestNegated && MatchHasValueCall(hasValueTest' out ILVariable v)) { " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The length of the statement  "			} else if (newComparisonKind == ComparisonKind.Inequality && hasValueTestNegated && MatchHasValueCall(hasValueTest' out v)) { " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The length of the statement  "					var newInst = new Conv(arg' conv.InputType' conv.InputSign' conv.TargetType' conv.CheckForOverflow' isLifted: true).WithILRange(conv); " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The length of the statement  "				var newInst = new Comp(comp.Kind' ComparisonLiftingKind.ThreeValuedLogic' comp.InputType' comp.Sign' arg' comp.Right.Clone()).WithILRange(comp); " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CompOrDecimal,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MakeLifted,The length of the statement  "					return new Comp(newComparisonKind' ComparisonLiftingKind.CSharp' comp.InputType' comp.Sign' left' right).WithILRange(Instruction); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformRefTypes,The length of the statement  "			if (!(condition.MatchCompEquals(out var left' out var right) && left.MatchLdLoc(stloc.Variable) && right.MatchLdNull())) " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The length of the statement  "			if (inst.MatchStLoc(out var v' out var initInst) && (v.Kind == VariableKind.Local || v.Kind == VariableKind.StackSlot)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The length of the statement  "						if (newObjInst.ILStackWasEmpty && v.Kind == VariableKind.Local && !context.Function.Method.IsConstructor && !context.Function.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass()) { " is 185.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The length of the statement  "						if (DelegateConstruction.IsDelegateConstruction(newObjInst) || TransformDisplayClassUsage.IsPotentialClosure(context' newObjInst)) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodCallOnVariable,The length of the statement  "			if (inst.MatchLdFld(out var target' out _) || inst.MatchStFld(out target' out _' out _) || inst.MatchLdFlda(out target' out _)) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "			if (instructions[pos] is StLoc stloc && stloc.Variable.Kind == VariableKind.Local && stloc.Variable.IsSingleDefinition) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "				if (stloc.Value.Descendants.OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))) " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "			(var kind' var newPath' var values' var targetVariable) = AccessPathElement.GetAccessPath(instructions[pos]' rootType' context.Settings' resolveContext' possibleIndexVariables); " is 177.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The length of the statement  "						if (resolveContext != null && !IsMethodApplicable(method' call.Arguments' rootType' resolveContext' settings)) goto default; " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The length of the statement  "			if (kind != AccessPathKind.Invalid && values.SelectMany(v => v.Descendants).OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))) " is 184.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,CanBeUsedInInitializer,The length of the statement  "			if (property.CanSet && (property.Accessibility == property.Setter.Accessibility || IsAccessorAccessible(property.Setter' resolveContext))) " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsAccessorAccessible,The length of the statement  "			return lookup.IsAccessible(setter' allowProtectedAccess: setter.DeclaringTypeDefinition == resolveContext.CurrentTypeDefinition); " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodApplicable,The length of the statement  "					&& CSharp.Transforms.IntroduceExtensionMethods.CanTransformToExtensionMethodCall(method' resolveContext' ignoreTypeArguments: true); " is 132.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodApplicable,The length of the statement  "			if (!targetType.GetAllBaseTypes().Any(i => i.IsKnownType(KnownTypeCode.IEnumerable) || i.IsKnownType(KnownTypeCode.IEnumerableOfT))) " is 132.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,BlockILTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\BlockTransform.cs,ToString,The length of the statement  "			return $"{nameof(BlockILTransform)} ({string.Join("' "' PreOrderTransforms.Concat(PostOrderTransforms).Select(t => t.GetType().Name))})"; " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,BlockILTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\BlockTransform.cs,Run,The length of the statement  "				throw new InvalidOperationException("Reentrancy detected. Transforms (and the CSharpDecompiler) are neither thread-safe nor re-entrant."); " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithField,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdsFld(out IField field) || !right.MatchLdNull()) " is 148.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithField,The length of the statement  "			if (!storeInst.MatchStsFld(out IField field2' out ILInstruction value) || !field.Equals(field2) || !field.IsCompilerGeneratedOrIsInCompilerGeneratedClass()) " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable v) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable s) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable s) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The length of the statement  "			if (!stobj.Target.MatchLdFlda(out var _' out var field1) || !ldobj.Target.MatchLdFlda(out var __' out var field2) || !field1.Equals(field2)) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,FindLoadInNext,The length of the statement  "					if (r.Type == FindResultType.Stop && (options & InliningOptions.IntroduceNamedArguments) != 0 && expr is CallInstruction call) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,RunOnSingleStatement,The length of the statement  "			new ExpressionTransforms().Run(parent' statement.ChildIndex' new StatementTransformContext(new BlockTransformContext(context))); " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitConv,The length of the statement  "				inst.ReplaceWith(new Conv(conv.Argument' conv.InputType' conv.InputSign' inst.TargetType' inst.CheckForOverflow' inst.IsLifted | conv.IsLifted)); " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformSpanTCtorContainingStackAlloc,The length of the statement  "			if (newObj.Arguments[0].MatchLocAlloc(out var sizeInBytes) && MatchesElementCount(sizeInBytes' elementType' newObj.Arguments[1])) { " is 131.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,MatchesElementCount,The length of the statement  "			var elementCountInstr = PointerArithmeticOffset.Detect(sizeInBytesInstr' pointerType.ElementType' checkForOverflow: true' unwrapZeroExtension: true); " is 149.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDynamicAddAssignOrRemoveAssign,The length of the statement  "			if (!(invokeMember.BinderFlags.HasFlag(CSharpBinderFlags.InvokeSpecialName) && invokeMember.BinderFlags.HasFlag(CSharpBinderFlags.ResultDiscarded))) " is 148.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDynamicSetMemberInstruction,The length of the statement  "			inst.ReplaceWith(new DynamicCompoundAssign(binaryOp.Operation' binaryOp.BinderFlags' binaryOp.Left' binaryOp.LeftArgumentInfo' binaryOp.Right' binaryOp.RightArgumentInfo)); " is 172.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitDynamicSetIndexInstruction,The length of the statement  "			inst.ReplaceWith(new DynamicCompoundAssign(binaryOp.Operation' binaryOp.BinderFlags' binaryOp.Left' binaryOp.LeftArgumentInfo' binaryOp.Right' binaryOp.RightArgumentInfo)); " is 172.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,Run,The length of the statement  "						if (instWithVar.Variable.IsSingleDefinition && instWithVar.Variable.StoreInstructions.SingleOrDefault() is StLoc store) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDelegateConstruction,The length of the statement  "			var function = ilReader.ReadIL((MethodDefinitionHandle)targetMethod.MetadataToken' body' genericContext.Value' ILFunctionKind.Delegate' context.CancellationToken); " is 163.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDelegateConstruction,The length of the statement  "			function.RunTransforms(CSharpDecompiler.GetILTransforms().TakeWhile(t => !(t is DelegateConstruction)).Concat(GetTransforms())' nestedContext); " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDelegateConstruction,The length of the statement  "			function.AcceptVisitor(new ReplaceDelegateTargetVisitor(target' function.Variables.SingleOrDefault(v => v.Index == -1 && v.Kind == VariableKind.Parameter))); " is 157.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,GroupStores,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SplitVariables.cs,GetNewVariable,The length of the statement  "				if (inst.Variable.HasInitialValue && uninitVariableUsage.TryGetValue(inst.Variable' out var uninitLoad) && uninitLoad == inst) { " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "			if (inst.MatchStLoc(out var v' out var newarrExpr) && MatchNewArr(newarrExpr' out var elementType' out var arrayLength)) { " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "				if (HandleRuntimeHelpersInitializeArray(body' pos + 1' v' elementType' arrayLength' out var values' out var initArrayPos)) { " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "					if (HandleSimpleArrayInitializer(function' body' pos + 1' v' elementType' arrayLength' out var arrayValues' out var instructionsToRemove)) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "					if (HandleJaggedArrayInitializer(body' pos + 1' v' elementType' arrayLength[0]' out ILVariable finalStore' out values' out instructionsToRemove)) { " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "						block.Instructions.AddRange(values.SelectWithIndex((i' value) => StElem(new LdLoc(tempStore)' new[] { new LdcI4(i) }' value' elementType))); " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,TransformSpanTArrayInitialization,The length of the statement  "						var tempStore = context.Function.RegisterVariable(VariableKind.InitializerTarget' new ArrayType(context.TypeSystem' elementType)); " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformMultiDim,The length of the statement  "				if (HandleSimpleArrayInitializer(function' body' pos + 1' v' elementType' length' out var arrayValues' out var instructionsToRemove)) { " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformStackAllocInitializer,The length of the statement  "				if (lengthInst.MatchLdcI(out var lengthInBytes) && HandleCpblkInitializer(body' pos + 1' v' lengthInBytes' out var blob' out var elementType)) { " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformStackAllocInitializer,The length of the statement  "				if (HandleSequentialLocAllocInitializer(body' pos + 1' v' locallocExpr' out elementType' out StObj[] values' out int instructionsToRemove)) { " is 141.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformStackAllocInitializer,The length of the statement  "					block.Instructions.AddRange(values.Where(value => value != null).Select(value => RewrapStore(tempStore' value' elementType))); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSequentialLocAllocInitializer,The length of the statement  "					var offsetInst = PointerArithmeticOffset.Detect(right' elementType' ((BinaryNumericInstruction)target).CheckForOverflow); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,RewrapStore,The length of the statement  "			else if (storeInstruction.Target.MatchBinaryNumericInstruction(BinaryNumericOperator.Add' out var left' out var right)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ShouldTransformToInitializer,The length of the statement  "			if (ILInlining.IsCatchWhenBlock(block) || ILInlining.IsInConstructorInitializer(function' block.Instructions[startPos])) " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The length of the statement  "				bool hasTemporaryCopy = block.Instructions[pos].MatchStLoc(out var temp' out var storeLoad) && storeLoad.MatchLdLoc(store); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleRuntimeHelpersInitializeArray,The length of the statement  "			if (MatchInitializeArrayCall(body.Instructions[pos]' out var arrayInst' out var field) && arrayInst.MatchLdLoc(array)) { " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformInlineRuntimeHelpersInitializeArray,The length of the statement  "			var tempStore = context.Function.RegisterVariable(VariableKind.InitializerTarget' new ArrayType(context.TypeSystem' elementType' arrayLength.Length)); " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI4(r.ReadByte())); " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI4(r.ReadSByte())); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI4(r.ReadInt16())); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI4(r.ReadUInt16())); " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI4(r.ReadInt32())); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcI8(r.ReadInt64())); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcF4(r.ReadSingle())); " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' arrayLength' output' typeCode' (ref BlobReader r) => new LdcF8(r.ReadDouble())); " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,ValidateCompoundAssign,The length of the statement  "			if (conv != null && !(conv.TargetType == targetType.ToPrimitiveType() && conv.CheckForOverflow == binary.CheckForOverflow)) " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,MatchingGetterAndSetterCalls,The length of the statement  "			if (getterCall == null || setterCall == null || !IsSameMember(getterCall.Method.AccessorOwner' setterCall.Method.AccessorOwner)) " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The length of the statement  "				if (!IsMatchingCompoundLoad(binary.Left' compoundStore' out var target' out var targetKind' out var finalizeMatch' forbiddenVariable: storeInSetter?.Variable)) " is 159.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The length of the statement  "				if (!IsMatchingCompoundLoad(operatorCall.Arguments[0]' compoundStore' out var target' out var targetKind' out var finalizeMatch' forbiddenVariable: storeInSetter?.Variable)) " is 173.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The length of the statement  "				if (!IsMatchingCompoundLoad(dynamicBinaryOp.Left' compoundStore' out var target' out var targetKind' out var finalizeMatch' forbiddenVariable: storeInSetter?.Variable)) " is 168.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The length of the statement  "				newInst = new DynamicCompoundAssign(dynamicBinaryOp.Operation' dynamicBinaryOp.BinderFlags' target' dynamicBinaryOp.LeftArgumentInfo' dynamicBinaryOp.Right' dynamicBinaryOp.RightArgumentInfo' targetKind); " is 204.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCompoundAssign,The length of the statement  "				if (!IsMatchingCompoundLoad(concatCall.Arguments[0]' compoundStore' out var target' out var targetKind' out var finalizeMatch' forbiddenVariable: storeInSetter?.Variable)) " is 171.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsCompoundStore,The length of the statement  "			} else if (inst is StLoc stloc && (stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.Parameter)) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsMatchingCompoundLoad,The length of the statement  "			} else if (load is LdLoc ldloc && store is StLoc stloc && ILVariableEqualityComparer.Instance.Equals(ldloc.Variable' stloc.Variable)) { " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorWithInlineStore,The length of the statement  "			if (!IsMatchingCompoundLoad(stloc.Value' store' out var target' out var targetKind' out var finalizeMatch' forbiddenVariable: stloc.Variable)) " is 142.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperator,The length of the statement  "				if (!binary.Left.MatchLdLoc(tmpVar) || !(binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1))) " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,LocalFunctionMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\LocalFunctionMethod.cs,ToString,The length of the statement  "			return string.Format("[LocalFunctionMethod: ReducedFrom={0}' NumberOfGeneratedParameters={1}]"' ReducedFrom' NumberOfCompilerGeneratedParameters); " is 146.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,Add,The length of the statement  "			Add(type' ImmutableArray.Create(new CustomAttributeTypedArgument<IType>(module.Compilation.FindType(argType)' argValue))); " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,Add,The length of the statement  "			Add(type' ImmutableArray.Create(new CustomAttributeTypedArgument<IType>(module.Compilation.FindType(argType)' argValue))); " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,IgnoreAttribute,The length of the statement  "							return (options & TypeSystemOptions.DecimalConstants) != 0 && (target == SymbolKind.Field || target == SymbolKind.Parameter); " is 125.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,IgnoreAttribute,The length of the statement  "							return (options & TypeSystemOptions.NullabilityAnnotations) != 0 && (target == SymbolKind.TypeDefinition || target == SymbolKind.Method); " is 137.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,AddSecurityAttributes,The length of the statement  "			var securityActionType = module.Compilation.FindType(new TopLevelTypeName("System.Security.Permissions"' "SecurityAction")); " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The length of the statement  "			// DecimalConstantAttribute has the arguments (byte scale' byte sign' uint hi' uint mid' uint low) or (byte scale' byte sign' int hi' int mid' int low) " is 151.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The length of the statement  "			// Both of these invoke the Decimal constructor (int lo' int mid' int hi' bool isNegative' byte scale) with explicit argument conversions if required. " is 150.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultTypeParameter.cs,MakeConstraints,The length of the statement  "				result.Add(new TypeConstraint(this.Compilation.FindType(this.HasValueTypeConstraint ? KnownTypeCode.ValueType : KnownTypeCode.Object))); " is 136.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataField,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataField.cs,DecodeTypeAndVolatileFlag,The length of the statement  "				if (ty is ModifiedType mod && mod.Modifier.Name == "IsVolatile" && mod.Modifier.Namespace == "System.Runtime.CompilerServices") { " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,DecodeSignature,The length of the statement  "				var nullableContext = methodDef.GetCustomAttributes().GetNullableContext(module.metadata) ?? DeclaringTypeDefinition.NullableContext; " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,GetAttributes,The length of the statement  "				if ((info.Attributes & MethodImportAttributes.ThrowOnUnmappableCharDisable) == MethodImportAttributes.ThrowOnUnmappableCharDisable) " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,GetAttributes,The length of the statement  "				if ((info.Attributes & MethodImportAttributes.ThrowOnUnmappableCharEnable) == MethodImportAttributes.ThrowOnUnmappableCharEnable) " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,CurrentModuleReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultAssemblyReference.cs,Resolve,The length of the statement  "					throw new ArgumentException("A reference to the current assembly cannot be resolved in the compilation's global type resolve context."); " is 136.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetNestedTypesImpl,The length of the statement  "				if (totalTypeParameterCount == 0 || (options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions) { " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SimpleCompilation,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SimpleCompilation.cs,Init,The length of the statement  "					throw new InvalidOperationException("Tried to initialize compilation with an invalid assembly reference. (Forgot to load the assembly reference ? - see CecilLoader)"); " is 167.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "				&& this.substitutionWithoutSpecializedTypeParameters.Equals(other.substitutionWithoutSpecializedTypeParameters' typeNormalization); " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "			return this.baseMember.Equals(other.baseMember) && this.substitutionWithoutSpecializedTypeParameters.Equals(other.substitutionWithoutSpecializedTypeParameters); " is 160.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "				// Compare the owner' not the substitution' because the substitution may contain this specialized type parameter recursively " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedProperty,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedProperty.cs,Create,The length of the statement  "			if (TypeParameterSubstitution.Identity.Equals(substitution) || propertyDefinition.DeclaringType.TypeParameterCount == 0) { " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The length of the statement  "				TypeParameterReference[] arr = (ownerType == SymbolKind.TypeDefinition) ? classTypeParameterReferences : methodTypeParameterReferences; " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,UnknownType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnknownType.cs,Equals,The length of the statement  "			return this.namespaceKnown == o.namespaceKnown && this.fullTypeName == o.fullTypeName && this.isReferenceType == o.isReferenceType; " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,IsTransparentIdentifier,The length of the statement  "			return identifier.StartsWith("<>"' StringComparison.Ordinal) && (identifier.Contains("TransparentIdentifier") || identifier.Contains("TranspIdent")); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,TryRemoveTransparentIdentifier,The length of the statement  "						if (namedExpression.Expression is IdentifierExpression identifierExpression && namedExpression.Name == identifierExpression.Identifier) { " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,RemoveTransparentIdentifierReferences,The length of the statement  "					newIdent.RemoveAnnotations<Semantics.MemberResolveResult>(); // remove the reference to the property of the anonymous type " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,FlattenSwitchBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\FlattenSwitchBlocks.cs,Run,The length of the statement  "				if (node is VariableDeclarationStatement || node is LocalFunctionDeclarationStatement || node is OutVarDeclarationExpression) " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,InitializeContext,The length of the statement  "			var currentContext = new CSharpTypeResolveContext(context.TypeSystem.MainModule' usingScope.Resolve(context.TypeSystem)' context.CurrentTypeDefinition); " is 152.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitNamespaceDeclaration,The length of the statement  "			var currentContext = new CSharpTypeResolveContext(previousContext.CurrentModule' usingScope.Resolve(previousContext.Compilation)); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "				firstArgument = firstArgument.ReplaceWith(expr => new CastExpression(context.TypeSystemAstBuilder.ConvertType(method.Parameters[0].Type)' expr.Detach())); " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "				memberRefExpr = new MemberReferenceExpression(firstArgument.Detach()' method.Name' identifierExpression.TypeArguments.Detach()); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,CanTransformToExtensionMethodCall,The length of the statement  "			var rr = resolver.ResolveMemberAccess(target' method.Name' typeArguments' NameLookupMode.InvocationTarget) as MethodGroupResolveResult; " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,CanTransformToExtensionMethodCall,The length of the statement  "			var or = rr.PerformOverloadResolution(resolver.CurrentTypeResolveContext.Compilation' arguments' argumentNames' allowExtensionMethods: true); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,CanTransformToExtensionMethodCall,The length of the statement  "			return CanTransformToExtensionMethodCall(resolver' method' typeArgs' targetType' paramTypes' argumentNames: paramNames); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,Run,The length of the statement  "			// After all queries were decompiled' detect degenerate queries (queries not property terminated with 'select' or 'group') " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,Run,The length of the statement  "					query.Clauses.Add(new QuerySelectClause { Expression = new IdentifierExpression(fromClause.Identifier).CopyAnnotationsFrom(fromClause) }); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) }); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() }); " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) }); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,IsComplexQuery,The length of the statement  "			return ((mre.Target is InvocationExpression && mre.Parent is InvocationExpression) || mre.Parent?.Parent is QueryClause); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,NormalizeBlockStatements,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\NormalizeBlockStatements.cs,DoTransform,The length of the statement  "				if (statement is BlockStatement b && b.Statements.Count == 1 && IsAllowedAsEmbeddedStatement(b.Statements.First()' parent)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,The length of the statement  "			if (context.Settings.IntroduceIncrementAndDecrement && assignment.Operator == AssignmentOperatorType.Add || assignment.Operator == AssignmentOperatorType.Subtract) { " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,The length of the statement  "				if (rr.IsCompileTimeConstant && rr.Type.IsCSharpPrimitiveIntegerType() && CSharpPrimitiveCast.Cast(rr.Type.GetTypeCode()' 1' false).Equals(rr.ConstantValue)) { " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,The length of the statement  "					if (assignment.Annotation<IL.CallInstruction>() == null && assignment.Annotation<IL.UserDefinedCompoundAssign>() == null && assignment.Annotation<IL.DynamicCompoundAssign>() == null) { " is 184.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,The length of the statement  "							type = (assignment.Operator == AssignmentOperatorType.Add) ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement; " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,IsWithoutSideEffects,The length of the statement  "			return left is ThisReferenceExpression || left is IdentifierExpression || left is TypeReferenceExpression || left is BaseReferenceExpression; " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DecimalConstantTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DecimalConstantTransform.cs,VisitFieldDeclaration,The length of the statement  "			if ((fieldDeclaration.Modifiers & staticReadOnly) == staticReadOnly && decimalType.IsMatch(fieldDeclaration.ReturnType)) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,EnsureExpressionStatementsAreValid,The length of the statement  "							AssignVariableNames.GenerateVariableName(function' type' stmt.Expression.Annotations.OfType<ILInstruction>().Where(AssignVariableNames.IsSupportedInstruction).FirstOrDefault()) " is 176.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,ResolveCollisions,The length of the statement  "					if (v.InsertionPoint.nextNode.Parent is ForStatement f && v.InsertionPoint.nextNode == f.Initializers.FirstOrDefault() && IsMatchingAssignment(v' out _)) { " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,ResolveCollisions,The length of the statement  "				// resulting variable is not restricted to the parent node of the insertion point' but extends to the whole BlockStatement. " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,InsertVariableDeclarations,The length of the statement  "					if (context.Settings.Discards && v.ILVariable.LoadCount == 0 && v.ILVariable.StoreCount == 0 && v.ILVariable.AddressCount == 1) { " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceUsingDeclarations,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUsingDeclarations.cs,Run,The length of the statement  "				var insertionPoint = rootNode.Children.LastOrDefault(n => n is PreProcessorDirective p && p.Type == PreProcessorDirectiveType.Define); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceUsingDeclarations,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUsingDeclarations.cs,Run,The length of the statement  "					Debug.Assert(context.RequiredNamespacesSuperset.Contains(ns)' $"Should not insert using declaration for namespace that is missing from the superset: {ns}"); " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUsingDeclarations.cs,VisitNamespaceDeclaration,The length of the statement  "				var currentContext = new CSharpTypeResolveContext(previousContext.CurrentModule' usingScope.Resolve(previousContext.Compilation)); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ForStatementUsesVariable,The length of the statement  "			if (statement.Iterators.Any(i => i.DescendantsAndSelf.OfType<IdentifierExpression>().Any(ie => ie.GetILVariable() == variable))) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The length of the statement  "				VariableType = context.Settings.AnonymousTypes && itemVariable.Type.ContainsAnonymousType() ? new SimpleType("var") : context.TypeSystemAstBuilder.ConvertType(itemVariable.Type)' " is 178.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The length of the statement  "			if (!MatchForeachOnMultiDimArray(upperBounds' collection' stmt' out var foreachVariable' out var statements' out var lowerBounds)) " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The length of the statement  "				VariableType = context.Settings.AnonymousTypes && itemVariable.Type.ContainsAnonymousType() ? new SimpleType("var") : context.TypeSystemAstBuilder.ConvertType(itemVariable.Type)' " is 178.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ReplaceEventFieldAnnotation,The length of the statement  "			var @event = field.DeclaringType.GetEvents(ev => ev.Name == field.Name' GetMemberOptions.IgnoreInheritedMembers).SingleOrDefault(); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformAutomaticEvents,The length of the statement  "				IField field = eventDef.DeclaringType.GetFields(f => f.Name == ev.Name' GetMemberOptions.IgnoreInheritedMembers).SingleOrDefault(); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,VisitConstructorDeclaration,The length of the statement  "					if (!(assignment.Right is ObjectCreateExpression oce && oce.GetSymbol() is IMethod ctor2 && ctor2.DeclaringTypeDefinition == currentCtor.DeclaringTypeDefinition)) " is 162.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtorsNotChainingWithThis = instanceCtors.Where(ctor => !thisCallPattern.IsMatch(ctor.Body.Statements.FirstOrDefault())).ToArray(); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "					if (!(fieldOrPropertyOrEvent is IField) && !(fieldOrPropertyOrEvent is IProperty) && !(fieldOrPropertyOrEvent is IEvent)) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "					var fieldOrPropertyOrEventDecl = members.FirstOrDefault(f => f.GetSymbol() == fieldOrPropertyOrEvent) as EntityDeclaration; " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "			var staticCtor = members.OfType<ConstructorDeclaration>().FirstOrDefault(c => (c.Modifiers & Modifiers.Static) == Modifiers.Static); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "					SRM.MethodDefinition ctorMethodDef = metadata.GetMethodDefinition((SRM.MethodDefinitionHandle)ctorMethod.MetadataToken); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,TypePattern,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs,DoMatch,The length of the statement  "			if (ct != null && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any()) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "									oldArg.ReplaceWith(new MemberReferenceExpression(new TypeReferenceExpression(declaringType)' field.Name).CopyAnnotationsFrom(oldArg)); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "						invocationExpression.ReplaceWith(new ObjectCreateExpression(context.TypeSystemAstBuilder.ConvertType(method.TypeArguments.First()))); " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "					new UnaryOperatorExpression(uop.Value' arguments[0].UnwrapInDirectionExpression()).CopyAnnotationsFrom(invocationExpression) " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "					new CastExpression(context.TypeSystemAstBuilder.ConvertType(method.ReturnType)' arguments[0].UnwrapInDirectionExpression()) " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,RemoveRedundantToStringInConcat,The length of the statement  "			if (!ToStringIsKnownEffectFree(type) && toStringMethod != null && IL.Transforms.ILInlining.MethodRequiresCopyForReadonlyLValue(toStringMethod)) { " is 145.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "					Expression newNode = new MemberReferenceExpression(new TypeReferenceExpression(m.Get<AstType>("declaringType").Single().Detach())' method.Name); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "					newNode = new InvocationExpression(newNode' method.Parameters.Select(p => new TypeReferenceExpression(context.TypeSystemAstBuilder.ConvertType(p.Type)))); " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,AddXmlDocumentationTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddXmlDocumentationTransform.cs,Run,The length of the statement  "				string[] msg = (" Exception while reading XmlDoc: " + ex).Split(new[] { '\r'' '\n' }' StringSplitOptions.RemoveEmptyEntries); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithCurrentTypeDefinition,The length of the statement  "			return new CSharpTypeResolveContext(module' currentUsingScope' typeDefinition' currentMember' methodTypeParameterNames); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithCurrentMember,The length of the statement  "			return new CSharpTypeResolveContext(module' currentUsingScope' currentTypeDefinition' member' methodTypeParameterNames); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithUsingScope,The length of the statement  "			return new CSharpTypeResolveContext(module' usingScope' currentTypeDefinition' currentMember' methodTypeParameterNames); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,TypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\TypeOrNamespaceReference.cs,Resolve,The length of the statement  "				ctx = new CSharpTypeResolveContext(context.CurrentModule ?? context.Compilation.MainModule' null' context.CurrentTypeDefinition' context.CurrentMember); " is 152.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,UsingScope,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\UsingScope.cs,Resolve,The length of the statement  "				var csContext = new CSharpTypeResolveContext(compilation.MainModule' parent != null ? parent.Resolve(compilation) : null); " is 122.
Long Statement,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The length of the statement  "			var entrypointHandle = MetadataTokens.MethodDefinitionHandle(file.Reader.PEHeaders.CorHeader.EntryPointTokenOrRelativeVirtualAddress); " is 134.
Long Statement,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The length of the statement  "			var sequencePointBlobs = new Dictionary<MethodDefinitionHandle' (DocumentHandle Document' BlobHandle SequencePoints)>(); " is 120.
Long Statement,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The length of the statement  "					syntaxTree.InsertChildAfter(null' new Comment(" PDB and source generated by ICSharpCode.Decompiler " + decompilerVersion.FileVersion)' Roles.Comment); " is 150.
Long Statement,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The length of the statement  "					var name = metadata.GetOrAddDocumentName(type.GetFullTypeName(reader).ReflectionName.Replace('.'' Path.DirectorySeparatorChar) + ".cs"); " is 136.
Long Statement,ICSharpCode.Decompiler.DebugInfo,PortablePdbWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DebugInfo\PortablePdbWriter.cs,WritePdb,The length of the statement  "			PortablePdbBuilder serializer = new PortablePdbBuilder(metadata' GetRowCounts(reader)' entrypointHandle' blobs => contentId); " is 125.
Long Statement,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The length of the statement  "			if (introduceRefModifiersOnStructs || introduceReadonlyAndInModifiers || nonTrailingNamedArguments || refExtensionMethods) " is 122.
Long Statement,ICSharpCode.Decompiler,DecompileRun,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompileRun.cs,CreateUsingScope,The length of the statement  "				var reference = nsType.ToTypeReference(CSharp.Resolver.NameLookupMode.TypeInUsingDeclaration) as CSharp.TypeSystem.TypeOrNamespaceReference; " is 140.
Long Statement,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentMemberReference,The length of the statement  "			if (node is IdentifierExpression && node.Role == Roles.TargetExpression && node.Parent is InvocationExpression && symbol is IMember member) { " is 141.
Long Statement,ICSharpCode.Decompiler,SRMExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetFullTypeName,The length of the statement  "			string name = ReflectionHelper.SplitTypeParameterCountFromReflectionName(reader.GetString(td.Name)' out var typeParameterCount); " is 128.
Long Statement,ICSharpCode.Decompiler,SRMExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetFullTypeName,The length of the statement  "			string name = ReflectionHelper.SplitTypeParameterCountFromReflectionName(metadata.GetString(type.Name)' out int typeParameterCount); " is 132.
Long Statement,ICSharpCode.Decompiler,SRMExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,IsAnonymousType,The length of the statement  "			if (type.Namespace.IsNil && type.HasGeneratedName(metadata) && (name.Contains("AnonType") || name.Contains("AnonymousType"))) { " is 127.
Long Statement,ICSharpCode.Decompiler,NRExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,IsAnonymousType,The length of the statement  "			if (string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))) { " is 145.
Long Statement,ICSharpCode.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,The length of the statement  "			if (this.Type == ILStructureType.Loop && newStructure.Type == ILStructureType.Loop && newStructure.StartOffset == this.StartOffset) " is 131.
Long Statement,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,Disassemble,The length of the statement  "			var entrypointHandle = MetadataTokens.MethodDefinitionHandle(module.Reader.PEHeaders.CorHeader.EntryPointTokenOrRelativeVirtualAddress); " is 136.
Long Statement,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The length of the statement  "				if (childIndex < s.Children.Count && s.Children[childIndex].StartOffset <= offset && offset < s.Children[childIndex].EndOffset) { " is 129.
Long Statement,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The length of the statement  "						output.WriteLine($"(line {sp.StartLine}' col {sp.StartColumn}) to (line {sp.EndLine}' col {sp.EndColumn}) in {sp.DocumentUrl}"); " is 128.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The length of the statement  "			bool isCompilerControlled = (methodDefinition.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope; " is 127.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The length of the statement  "				output.Write(DisassemblerHelpers.Escape(metadata.GetString(methodDefinition.Name) + "$PST" + MetadataTokens.GetToken(handle).ToString("X8"))); " is 142.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The length of the statement  "			WriteFlags(methodDefinition.ImplAttributes & ~(MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask)' methodImpl); " is 130.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodBlock,The length of the statement  "			CloseBlock("end of method " + DisassemblerHelpers.Escape(metadata.GetString(declaringType.Name)) + "::" + DisassemblerHelpers.Escape(metadata.GetString(methodDefinition.Name))); " is 177.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,TryDecodeSecurityDeclaration,The length of the statement  "				var decoder = new CustomAttributeDecoder<(PrimitiveTypeCode Code' string Name)>(new SecurityDeclarationDecoder(output' AssemblyResolver' module)' module.Metadata' provideBoxingTypeInfo: true); " is 192.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteParameters,The length of the statement  "				output.WriteLocalReference(DisassemblerHelpers.Escape(metadata.GetString(p.Name))' "param_" + (i + offset)' isDefinition: true); " is 128.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,The length of the statement  "			const FieldAttributes hasXAttributes = FieldAttributes.HasDefault | FieldAttributes.HasFieldMarshal | FieldAttributes.HasFieldRVA; " is 130.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,The length of the statement  "			var signature = fieldDefinition.DecodeSignature(new DisassemblerSignatureProvider(module' output)' new GenericContext(fieldDefinition.GetDeclaringType()' module)); " is 163.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleProperty,The length of the statement  "			var signature = propertyDefinition.DecodeSignature(new DisassemblerSignatureProvider(module' output)' new GenericContext(declaringType' module)); " is 145.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "			const TypeAttributes masks = TypeAttributes.ClassSemanticsMask | TypeAttributes.VisibilityMask | TypeAttributes.LayoutMask | TypeAttributes.StringFormatMask; " is 157.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "			output.Write(typeDefinition.GetDeclaringType().IsNil ? typeDefinition.GetFullTypeName(module.Metadata).ToILNameString() : DisassemblerHelpers.Escape(module.Metadata.GetString(typeDefinition.Name))); " is 198.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "			CloseBlock("end of class " + (!typeDefinition.GetDeclaringType().IsNil ? module.Metadata.GetString(typeDefinition.Name) : typeDefinition.GetFullTypeName(module.Metadata).ToString())); " is 183.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,The length of the statement  "					if ((gp.Attributes & GenericParameterAttributes.ReferenceTypeConstraint) == GenericParameterAttributes.ReferenceTypeConstraint) { " is 129.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,The length of the statement  "					} else if ((gp.Attributes & GenericParameterAttributes.NotNullableValueTypeConstraint) == GenericParameterAttributes.NotNullableValueTypeConstraint) { " is 150.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,The length of the statement  "					if ((gp.Attributes & GenericParameterAttributes.DefaultConstructorConstraint) == GenericParameterAttributes.DefaultConstructorConstraint) { " is 139.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteAssemblyReferences,The length of the statement  "					output.WriteLine(".ver {0}:{1}:{2}:{3}"' aref.Version.Major' aref.Version.Minor' aref.Version.Build' aref.Version.Revision); " is 124.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteModuleHeader,The length of the statement  "						throw new BadImageFormatException("Implementation must either be an index into the File' ExportedType or AssemblyRef table."); " is 126.
Long Statement,ICSharpCode.Decompiler.Disassembler,SecurityDeclarationDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,ResolveType,The length of the statement  "							var next = currentNamespace.NamespaceDefinitions.FirstOrDefault(ns => metadata.StringComparer.Equals(metadata.GetNamespaceDefinition(ns).Name' identifier)); " is 156.
Long Statement,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,Visit,The length of the statement  "				//  Transformations may be applied to the current and following instructions but already processed instructions will not be changed " is 131.
Long Statement,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,Visit,The length of the statement  "				// the next instruction to be executed. Transformations will change the next instruction' so this is a method instead of a variable " is 131.
Long Statement,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ImproveILOrdering,The length of the statement  "			var falseRangeStart = ConditionDetection.GetStartILOffset(block.Instructions[block.Instructions.IndexOf(ifInst)+1]' out bool falseRangeIsEmpty); " is 144.
Long Statement,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ReduceNesting,The length of the statement  "				// a separate heuristic tp ShouldReduceNesting as there is visual balancing to be performed based on number of statments " is 120.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicGetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicSetIndexInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeConstructorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,DynamicInvokeInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,ComputeFlags,The length of the statement  "			return base.ComputeFlags() | InstructionFlags.MayThrow | InstructionFlags.SideEffect | Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,Detect,The length of the statement  "			} else if (byteOffsetInst.UnwrapConv(ConversionKind.SignExtend) is SizeOf sizeOf && sizeOf.Type.Equals(pointerElementType)) { " is 125.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field); " is 131.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,TupleTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TupleTransform.cs,MatchTupleFieldAccess,The length of the statement  "			while (target is LdFlda ldflda && ldflda.Field.Name == "Rest" && TupleType.IsTupleCompatible(ldflda.Field.DeclaringType' out _)) { " is 130.
Long Statement,ICSharpCode.Decompiler.IL,ILVariableCollection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ILVariableCollection.cs,RemoveDead,The length of the statement  "				if (v.StoreCount == deadStoreCount && v.LoadCount == 0 && v.AddressCount == 0 && v.Kind != VariableKind.DisplayClassLocal) { " is 124.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,PerformMatch,The length of the statement  "			return o != null && method.Equals(o.method) && this.left.PerformMatch(o.left' ref match) && this.right.PerformMatch(o.right' ref match); " is 136.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckValidTarget,The length of the statement  "					Debug.Assert(target.OpCode == OpCode.DynamicGetMemberInstruction || target.OpCode == OpCode.DynamicGetIndexInstruction); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions' o.LocalFunctions' ref match); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "					Debug.Assert(!(DelegateType?.FullName == "System.Linq.Expressions.Expression" && DelegateType.TypeParameterCount == 1)); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(Blocks.All(b => b.Kind == BlockKind.ControlFlow)); // this also implies that the blocks don't use FinalInstruction " is 127.
Long Statement,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(TopologicalSort(deleteUnreachableBlocks: true).Count == Blocks.Count' "Container should not have any unreachable blocks"); " is 135.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,NumericCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 278.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,UserDefinedCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 201.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,DynamicCompoundAssign,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target' ref match) && Value.PerformMatch(o.Value' ref match); " is 169.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,Leave,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(phase <= ILPhase.InILReader || phase == ILPhase.InAsyncAwait || value.ResultType == targetContainer.ResultType); " is 125.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.ControlFlow | condition.Flags | SemanticHelper.CombineBranches(trueInst.Flags' falseInst.Flags); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,IsInConditionSlot,The length of the statement  "			if (slot == IfInstruction.TrueInstSlot || slot == IfInstruction.FalseInstSlot || slot == NullCoalescingInstruction.FallbackInstSlot) " is 132.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(this.IsLifted ? (value.ResultType == StackType.O) : (value.ResultType == StackType.I4 || value.ResultType == StackType.I8)); " is 137.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdVirtDelegate,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && method.Equals(o.method); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly; " is 223.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "						signature = fd.DecodeSignature(new DisassemblerSignatureProvider(module' output)' new Metadata.GenericContext(fd.GetDeclaringType()' module)); " is 142.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "						methodSignature = md.DecodeSignature(new DisassemblerSignatureProvider(module' output)' new Metadata.GenericContext((MethodDefinitionHandle)entity' module)); " is 157.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "							output.WriteReference(module' entity' DisassemblerHelpers.Escape(metadata.GetString(md.Name) + "$PST" + MetadataTokens.GetToken(entity).ToString("X8"))); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "								if ((gp.Attributes & GenericParameterAttributes.ReferenceTypeConstraint) == GenericParameterAttributes.ReferenceTypeConstraint) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "								} else if ((gp.Attributes & GenericParameterAttributes.NotNullableValueTypeConstraint) == GenericParameterAttributes.NotNullableValueTypeConstraint) { " is 150.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "								if ((gp.Attributes & GenericParameterAttributes.DefaultConstructorConstraint) == GenericParameterAttributes.DefaultConstructorConstraint) { " is 139.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "										constraint.Type.WriteTo(module' output' new Metadata.GenericContext((MethodDefinitionHandle)entity' module)' ILNameSyntax.TypeName); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "							bool isCompilerControlled = (methodDefinition.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope; " is 127.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "							methodSignature = memberReference.DecodeMethodSignature(new DisassemblerSignatureProvider(module' output)' genericContext); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The length of the statement  "							methodSignature = standaloneSig.DecodeMethodSignature(new DisassemblerSignatureProvider(module' output)' genericContext); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateContainerStructure,The length of the statement  "				tryInstructionList = tryInstructionList.OrderBy(tc => tc.TryBlock.StartILOffset).ThenByDescending(tc => tc.TryBlock.EndILOffset).ToList(); " is 138.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,FinalizeCurrentBlock,The length of the statement  "				if (currentBlock.Instructions.LastOrDefault() is SwitchInstruction switchInst && switchInst.Sections.Last().Body.MatchNop()) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,CreateILVariable,The length of the statement  "			if (!UseDebugSymbols || DebugInfo == null || !DebugInfo.TryGetName((MethodDefinitionHandle)method.MetadataToken' index' out string name)) { " is 139.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,ReadInstructions,The length of the statement  "				if (decodedInstruction.ResultType == StackType.Unknown && decodedInstruction.OpCode != OpCode.InvalidBranch && UnpackPush(decodedInstruction).OpCode != OpCode.InvalidExpression) " is 177.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcI4(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 177.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcI8(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcF4(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcF8(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The length of the statement  "						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type); " is 151.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeConditionalBranch,The length of the statement  "						Sign.None' new Conv(condition' PrimitiveType.I' false' Sign.None)' new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None)); " is 126.
Long Statement,ICSharpCode.Decompiler.Metadata,GenericContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\Dom.cs,GetGenericTypeParameterHandleOrNull,The length of the statement  "			if (declaringType.IsNil || index < 0 || index >= (genericParameters = module.Metadata.GetTypeDefinition(declaringType).GetGenericParameters()).Count) " is 149.
Long Statement,ICSharpCode.Decompiler.Metadata,GenericContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\Dom.cs,GetGenericMethodTypeParameterHandleOrNull,The length of the statement  "			if (method.IsNil || index < 0 || index >= (genericParameters = module.Metadata.GetMethodDefinition(method).GetGenericParameters()).Count) " is 137.
Long Statement,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinder.cs,GetClosestVersionFolder,The length of the statement  "			foreach (var folder in new DirectoryInfo(basePath).GetDirectories().Select(d => ConvertToVersion(d.Name)).Where(v => v.Item1 != null).OrderByDescending(v => v.Item1)) { " is 168.
Long Statement,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinderExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinderExtensions.cs,DetectTargetFrameworkId,The length of the statement  "				 * - .NETCore      -> C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Console.dll " is 133.
Long Statement,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinderExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinderExtensions.cs,DetectTargetFrameworkId,The length of the statement  "				 * - .NETStandard  -> C:\Program Files\dotnet\sdk\NuGetFallbackFolder\netstandard.library\2.0.3\build\netstandard2.0\ref\netstandard.dll " is 135.
Long Statement,ICSharpCode.Decompiler.Metadata,PEFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\PEFile.cs,GetTypeDefinition,The length of the statement  "					string name = ReflectionHelper.SplitTypeParameterCountFromReflectionName(Metadata.GetString(td.Name)' out int typeParameterCount); " is 130.
Long Statement,ICSharpCode.Decompiler.Metadata,SignatureBlobComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\SignatureBlobComparer.cs,IsSameCompressedSignedInteger,The length of the statement  "			return a.TryReadCompressedSignedInteger(out value) && b.TryReadCompressedSignedInteger(out int otherValue) && value == otherValue; " is 130.
Long Statement,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ResolveModule,The length of the statement  "			return new PEFile(moduleFileName' new FileStream(moduleFileName' FileMode.Open' FileAccess.Read)' streamOptions' metadataOptions); " is 130.
Long Statement,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,FindWindowsMetadataFile,The length of the statement  "			string basePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)' "Windows Kits"' "10"' "References"); " is 137.
Long Statement,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ResolveSilverlight,The length of the statement  "			AddTargetFrameworkSearchPathIfExists(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles)' "Microsoft Silverlight")); " is 143.
Long Statement,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ResolveSilverlight,The length of the statement  "			AddTargetFrameworkSearchPathIfExists(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)' "Microsoft Silverlight")); " is 146.
Long Statement,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,FindClosestVersionDirectory,The length of the statement  "			foreach (var folder in new DirectoryInfo(basePath).GetDirectories().Select(d => DotNetCorePathFinder.ConvertToVersion(d.Name)) " is 126.
Long Statement,ICSharpCode.Decompiler.Semantics,ByReferenceResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\ByReferenceResolveResult.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} {1} {2}]"' GetType().Name' ReferenceKind.ToString().ToLowerInvariant()' ElementType); " is 142.
Long Statement,ICSharpCode.Decompiler.Semantics,Conversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the statement  "			return new UserDefinedConv(isImplicit' operatorMethod' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous); " is 151.
Long Statement,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,Equals,The length of the statement  "				return o != null && isLifted == o.isLifted && isImplicit == o.isImplicit && isValid == o.isValid && method.Equals(o.method); " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,The length of the statement  "			const TypeSystemOptions relevantOptions = TypeSystemOptions.Dynamic | TypeSystemOptions.Tuple | TypeSystemOptions.NullabilityAnnotations; " is 137.
Long Statement,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,The length of the statement  "					} else if ((options & TypeSystemOptions.Tuple) != 0 && attrType.IsKnownType(metadata' KnownAttribute.TupleElementNames)) { " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,The length of the statement  "					} else if ((options & TypeSystemOptions.NullabilityAnnotations) != 0 && attrType.IsKnownType(metadata' KnownAttribute.Nullable)) { " is 130.
Long Statement,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveType,The length of the statement  "			ty = ApplyAttributeTypeVisitor.ApplyAttributesToType(ty' Compilation' typeAttributes' metadata' customOptions' nullableContext); " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveDeclaringType,The length of the statement  "			ty = ApplyAttributeTypeVisitor.ApplyAttributesToType(ty' Compilation' null' metadata' options' Nullability.Oblivious' typeChildrenOnly: true); " is 142.
Long Statement,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,IntroduceTupleTypes,The length of the statement  "			return ApplyAttributeTypeVisitor.ApplyAttributesToType(ty' Compilation' null' metadata' options' Nullability.Oblivious); " is 120.
Long Statement,ICSharpCode.Decompiler.TypeSystem,MetadataModule,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\MetadataModule.cs,ResolveForwardedType,The length of the statement  "						throw new BadImageFormatException("Expected implementation to be either an AssemblyFile' ExportedType or AssemblyReference."); " is 126.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeProvider.cs,GetTypeFromReference,The length of the statement  "			var gctr = new GetClassTypeReference(handle.GetFullTypeName(reader)' handle.GetDeclaringModule(reader)' isReferenceType); " is 121.
Long Statement,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetAccessors(m => m.Name == member.Name && m.Accessibility > Accessibility.Private' GetMemberOptions.IgnoreInheritedMembers); " is 148.
Long Statement,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetMembers(m => m.Name == member.Name && m.Accessibility > Accessibility.Private' GetMemberOptions.IgnoreInheritedMembers); " is 146.
Long Statement,ICSharpCode.Decompiler.TypeSystem,SpecialType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\SpecialType.cs,Equals,The length of the statement  "			// However' an unknown type with additional information is not considered to be equal to the SpecialType with TypeKind.Unknown. " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TopLevelTypeName,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TopLevelTypeName.cs,Equals,The length of the statement  "			return this.namespaceName == other.namespaceName && this.name == other.name && this.typeParameterCount == other.typeParameterCount; " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TopLevelTypeName,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TopLevelTypeName.cs,GetHashCode,The length of the statement  "			return (name != null ? name.GetHashCode() : 0) ^ (namespaceName != null ? namespaceName.GetHashCode() : 0) ^ typeParameterCount; " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var classTypeArguments = f.classTypeArguments != null ? GetComposedTypeArguments(f.classTypeArguments' g) : g.classTypeArguments; " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var methodTypeArguments = f.methodTypeArguments != null ? GetComposedTypeArguments(f.methodTypeArguments' g) : g.methodTypeArguments; " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,IsCompatibleTypeForMemoryAccess,The length of the statement  "			if (memoryStackType == accessStackType && memoryStackType.IsIntegerType() && GetSize(memoryType) == GetSize(accessType)) " is 120.
Long Statement,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,LoadObjectV2,The length of the statement  "					return new ResourceSerializedObject(FindType(typeCode - ResourceTypeCode.StartOfUserTypes)' this' reader.BaseStream.Position); " is 126.
Long Statement,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,AddResource,The length of the statement  "				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable."' name' value.GetType().Name)); " is 135.
Long Statement,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,AddMetadata,The length of the statement  "				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable."' name' value.GetType().Name)); " is 135.
Long Statement,ICSharpCode.Decompiler.FlowAnalysis,Dominance,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The length of the statement  "						for (var runner = p; runner != j.ImmediateDominator && runner != j && runner != null; runner = runner.ImmediateDominator) { " is 123.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The conditional expression  "constrainedTo == null  					&& target.Expression is CastExpression cast  					&& target.ResolveResult is ConversionResolveResult conversion  					&& target.Type.IsKnownType(KnownTypeCode.Object)  					&& conversion.Conversion.IsBoxingConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TransformParamsArgument,The conditional expression  "arg.ResolveResult is CSharpInvocationResolveResult csirr &&   					csirr.Arguments.Count == 0 && csirr.Member is IMethod emptyMethod &&   					emptyMethod.IsStatic &&  					"System.Array.Empty" == emptyMethod.FullName &&  					emptyMethod.TypeArguments.Count == 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TransformParamsArgument,The conditional expression  "arg.ResolveResult is ArrayCreateResolveResult acrr &&  					acrr.SizeArguments.Count == 1 &&  					acrr.SizeArguments[0].IsCompileTimeConstant &&  					acrr.SizeArguments[0].ConstantValue is int l"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ArgumentList,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,GetArgumentExpressions,The conditional expression  "AddNamesToPrimitiveValues && IsPrimitiveValue.Any() && !IsExpandedForm  					&& !ParameterNames.Any(p => string.IsNullOrEmpty(p))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "Expression is ObjectCreateExpression oce && conversion.Conversion.IsMethodGroupConversion  									&& oce.Arguments.Count == 1 && expressionBuilder.settings.UseImplicitMethodGroupConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "ResolveResult is ConversionResolveResult conv && Expression is CastExpression cast2  				&& !conv.Conversion.IsUserDefined  				&& CastCanBeMadeImplicit(conversions' conv.Conversion' conv.Input.Type' type' targetType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "targetType.Kind == TypeKind.Pointer && type.IsKnownType(KnownTypeCode.Char)  			   || targetUType.IsKnownType(KnownTypeCode.Char) && type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "this.ResolveResult.IsCompileTimeConstant && this.ResolveResult.ConstantValue != null  				&& NullableType.IsNullable(targetType) && !utype.Equals(targetUType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The conditional expression  "settings.Dynamic && type.IsDelegate(metadata) && (name.StartsWith("<>A"' StringComparison.Ordinal) || name.StartsWith("<>F"' StringComparison.Ordinal))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The conditional expression  "baseType.GetMembers(m => m.SymbolKind != SymbolKind.Indexer && m.Name == entity.Name && lookup.IsAccessible(m' true))  									.Any(m => m.SymbolKind != SymbolKind.Method || (((IMethod)entity).TypeParameters.Count == ((IMethod)m).TypeParameters.Count  																					&& parameterListComparer.Equals(((IMethod)entity).Parameters' ((IMethod)m).Parameters)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The conditional expression  "enumDec.Initializer is PrimitiveExpression primitive  							&& initValue >= 0 && (decompilationContext.CurrentTypeDefinition.HasAttribute(KnownAttribute.Flags)  								|| (initValue > 9 && (unchecked(initValue & (initValue - 1)) == 0 || unchecked(initValue & (initValue + 1)) == 0)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The conditional expression  "inst.ResultType != StackType.Void && cexpr.Type.Kind != TypeKind.Unknown && inst.ResultType != StackType.Unknown && cexpr.Type.Kind != TypeKind.None"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,UnwrapBoxingConversion,The conditional expression  "arg.Expression is CastExpression cast  					&& arg.Type.IsKnownType(KnownTypeCode.Object)  					&& arg.ResolveResult is ConversionResolveResult crr  					&& crr.Conversion.IsBoxingConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitBitNot,The conditional expression  "argUType.GetStackType().GetSize() < inst.UnderlyingResultType.GetSize()  				|| argUType.Kind == TypeKind.Enum && argUType.IsSmallIntegerType()  				|| argUType.GetStackType() == StackType.I  				|| argUType.IsKnownType(KnownTypeCode.Boolean)  				|| argUType.IsKnownType(KnownTypeCode.Char)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The conditional expression  "rr == null || rr.IsError || rr.UserDefinedOperatorMethod != null  			    || NullableType.GetUnderlyingType(rr.Operands[0].Type).GetStackType() != inst.InputType  			    || !rr.Type.IsKnownType(KnownTypeCode.Boolean)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The conditional expression  "rr == null || rr.IsError || rr.UserDefinedOperatorMethod != null  					|| NullableType.GetUnderlyingType(rr.Operands[0].Type).GetStackType() != inst.InputType  					|| !rr.Type.IsKnownType(KnownTypeCode.Boolean)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TryUniteEqualityOperandType,The conditional expression  "left.ResolveResult.IsCompileTimeConstant &&  				left.ResolveResult.Type.IsCSharpPrimitiveIntegerType() &&  				(left.ResolveResult.ConstantValue as int?) == 0 &&  				NullableType.GetUnderlyingType(right.Type).Kind == TypeKind.Enum &&  				right.Expression is BinaryOperatorExpression binaryExpr &&  				binaryExpr.Operator == BinaryOperatorType.BitwiseAnd"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,The conditional expression  "settings.FixedBuffers && inst.Operator == BinaryNumericOperator.Add && inst.Left is LdFlda ldFlda  						&& ldFlda.Target is LdFlda nestedLdFlda && CSharpDecompiler.IsFixedField(nestedLdFlda.Field' out var elementType' out _)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleManagedPointerArithmetic,The conditional expression  "inst.LeftInputType == StackType.I && inst.RightInputType == StackType.Ref && brt != null  				&& inst.Operator == BinaryNumericOperator.Add"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The conditional expression  "op.IsBitwise()   				&& left.Type.IsKnownType(KnownTypeCode.Boolean)   				&& right.Type.IsKnownType(KnownTypeCode.Boolean)  				&& SemanticHelper.IsPure(inst.Right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The conditional expression  "rr.IsError || NullableType.GetUnderlyingType(rr.Type).GetStackType() != inst.UnderlyingResultType  			    || !IsCompatibleWithSign(left.Type' inst.Sign) || !IsCompatibleWithSign(right.Type' inst.Sign)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ValueMightBeOversized,The conditional expression  "stackType == StackType.I && orr.OperatorType == ExpressionType.Subtract  					&& orr.Operands.Count == 2  					&& orr.Operands[0].Type.Kind == TypeKind.Pointer  					&& orr.Operands[1].Type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitLdFlda,The conditional expression  "settings.FixedBuffers && inst.Field.Name == "FixedElementField"  				&& inst.Target is LdFlda nestedLdFlda  				&& CSharpDecompiler.IsFixedField(nestedLdFlda.Field' out var elementType' out _)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The conditional expression  "stloc == null || final == null || stloc.Variable != final.Variable  				|| stloc.Variable.Kind != VariableKind.InitializerTarget"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The conditional expression  "stloc == null || final == null || !stloc.Value.MatchNewArr(out type) || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,The conditional expression  "stloc == null || final == null || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The conditional expression  "pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The conditional expression  "!typeCheckBlock.Instructions[0].MatchStLoc(out var castStore' out var cast)  				|| !cast.MatchIsInst(out var arg' out var type) || !type.IsKnownType(KnownTypeCode.Exception) || !arg.MatchLdLoc(tempStore.Variable)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchCall,The conditional expression  "inst is CallInstruction call && (call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt)  				&& call.Method.Name == name && !call.Method.IsStatic"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,IsCompilerGeneratorAsyncEnumerator,The conditional expression  "!tr.IsNested && tr.TopLevelTypeName.Namespace == "System.Collections.Generic" && tr.TopLevelTypeName.Name == "IAsyncEnumerator" && tr.TopLevelTypeName.TypeParameterCount == 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeEnumeratorCtor,The conditional expression  "inst.MatchStFld(out var target' out var field' out var value)  				&& target.MatchLdThis()  				&& value.MatchLdLoc(out var arg)  				&& arg.Kind == VariableKind.Parameter && arg.Index == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeEnumeratorCtor,The conditional expression  "inst.MatchStFld(out target' out field' out value)  					&& target.MatchLdThis()  					&& value is Call call && call.Method.Name == "Create""  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The conditional expression  "((BlockContainer)mainTryCatch.TryBlock).EntryPoint.Instructions[0] is StLoc initDoFinallyBodies  				&& initDoFinallyBodies.Variable.Kind == VariableKind.Local  				&& initDoFinallyBodies.Variable.Type.IsKnownType(KnownTypeCode.Boolean)  				&& initDoFinallyBodies.Value.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchStateAssignment,The conditional expression  "inst.MatchStFld(out var target' out var field' out var value)  				&& StackSlotValue(target).MatchLdThis()  				&& field.MemberDefinition == stateField  				&& StackSlotValue(value).MatchLdcI4(out newState)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,FinalizeInlineMoveNext,The conditional expression  "block.Instructions[i].MatchStLoc(out var v' out var value)  						&& v.IsSingleDefinition && v.LoadCount == 0  						&& value.MatchLdLoc(cachedStateVar)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The conditional expression  "pos > 0 && block.Instructions[pos - 1] is StLoc stloc  				&& stloc.Variable.Kind == VariableKind.Local && stloc.Variable.Index == cachedStateVar.Index  				&& StackSlotValue(stloc.Value).MatchLdcI4(state)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The conditional expression  "pos > 0 && block.Instructions[pos - 1] is StLoc stloc2  				&& stloc2.Variable.IsSingleDefinition && stloc2.Variable.LoadCount == 0  				&& stloc2.Variable.Kind == VariableKind.StackSlot  				&& SemanticHelper.IsPure(stloc2.Value.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The conditional expression  "block.Instructions[pos].MatchStFld(out target' out field' out value)  				&& target.MatchLdThis()  				&& field.Equals(awaiterField)  				&& (value.OpCode == OpCode.DefaultValue || value.OpCode == OpCode.LdNull)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The conditional expression  "block.Instructions[pos].MatchStLoc(out var variable' out value) && value.OpCode == OpCode.DefaultValue  					&& block.Instructions[pos + 1].MatchStFld(out target' out field' out value)  					&& field.Equals(awaiterField)  					&& value.MatchLdLoc(variable)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,The conditional expression  "body.Instructions[pos].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdLoc(var2 ?? var1)  					&& (value.MatchLdcI4(-2) || value.MatchLdcI4(0))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCtor,The conditional expression  "inst.MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdThis()  					&& value.MatchLdLoc(out var arg)  					&& arg.Kind == VariableKind.Parameter && arg.Index == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The conditional expression  "body.Instructions[0].MatchStLoc(out var v' out var ldfld)  					&& ldfld.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis()  					&& body.Instructions[1].MatchReturn(out var retVal)  					&& retVal.MatchLdLoc(v)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConstructExceptionTable,The conditional expression  "body.EntryPoint.Instructions[i] is StObj stobj  						&& stobj.MatchStFld(out var target' out var field' out var value)  						&& target.MatchLdThis()  						&& field.Type.IsKnownType(KnownTypeCode.Boolean)  						&& value.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "!(faultBlock.Instructions.Count == 2  					&& faultBlock.Instructions[0] is Call call  					&& call.Method.MetadataToken == disposeMethod  					&& call.Arguments.Count == 1  					&& call.Arguments[0].MatchLdThis()  					&& faultBlock.Instructions[1].MatchLeave(faultBlockContainer))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "body.EntryPoint.Instructions[0] is StLoc stloc  					&& stloc.Value.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis() && field.Type.IsKnownType(KnownTypeCode.Int32)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,PropagateCopiesOfFields,The conditional expression  "body.EntryPoint.Instructions[i] is StLoc store  					&& store.Variable.IsSingleDefinition  					&& store.Value is LdObj ldobj  					&& ldobj.Target is LdFlda ldflda  					&& ldflda.Target.MatchLdThis()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "oldInst is Call call && call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  						&& finallyMethodToStateRange.ContainsKey((IMethod)call.Method.MemberDefinition)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "oldBlock.Instructions[pos].MatchIfInstruction(out var condition' out _)  						&& condition.MatchLdFld(out var condTarget' out var condField)  						&& condTarget.MatchLdThis() && condField.MemberDefinition.Equals(disposingField)  						&& oldBlock.Instructions[pos + 1].MatchBranch(out targetBlock)  						&& targetBlock.Parent == oldBlock.Parent"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "oldBlock.Instructions[pos].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdThis()  					&& field.MemberDefinition == stateField  					&& value.MatchLdcI4(out int newState)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "value.MatchLdLoc(out var v)  								&& (v.Kind == VariableKind.Local || v.Kind == VariableKind.StackSlot)  								&& v.StoreInstructions.All(store => store is StLoc stloc && stloc.Value.MatchLdcI4(0))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,The conditional expression  "Block.GetPredecessor(branch) is Call call  							&& call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  							&& call.Method.Name == "System.IDisposable.Dispose""  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,GetNewState,The conditional expression  "block.Instructions[0].MatchStFld(out var target' out var field' out var value)  				&& target.MatchLdThis()  				&& field.MemberDefinition.Equals(stateField)  				&& value.MatchLdcI4(out int newState)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,GetNewState,The conditional expression  "block.Instructions[0] is Call call  				&& call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  				&& decompiledFinallyMethods.TryGetValue((IMethod)call.Method.MemberDefinition' out var finallyMethod)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,StateRangeAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\StateRangeAnalysis.cs,AssignStateRanges,The conditional expression  "stobj.MatchStFld(out var target' out var field' out var value)  							&& target.MatchLdThis() && field.MemberDefinition == stateField && value.MatchLdcI4(-1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,IntroduceShortCircuit,The conditional expression  "IsEmpty(ifInst.FalseInst)   					&& ifInst.TrueInst is Block trueBlock   					&& trueBlock.Instructions.Count == 1  					&& trueBlock.FinalInstruction is Nop  					&& trueBlock.Instructions[0].MatchIfInstruction(out var nestedCondition' out var nestedTrueInst)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,RemoveDeadStackStores,The conditional expression  "block.Instructions[i] is StLoc stloc && stloc.Variable.IsSingleDefinition && stloc.Variable.LoadCount == 0 && stloc.Variable.Kind == VariableKind.StackSlot"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,InlineVariableInReturnBlock,The conditional expression  "value.MatchLdLoc(out ILVariable v)  					&& v.IsSingleDefinition && v.LoadCount == 1 && block.Instructions[0].MatchStLoc(v' out ILInstruction inst)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,Run,The conditional expression  "stloc != null && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The conditional expression  "!(condition != null && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull())"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The conditional expression  "inst is Conv conv && conv.Kind == ConversionKind.StopGCTracking && conv.Argument.MatchLdLoc(oldVar) && conv.ResultType == newVar.StackType"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The conditional expression  "(inst is LdLoc || inst is StLoc) && !IsSlotAcceptingBothManagedAndUnmanagedPointers(inst.SlotInfo) && oldVar.StackType != StackType.I"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,HandleStringToPointer,The conditional expression  "nativeVar.Kind == VariableKind.StackSlot && nativeVar.LoadCount == 1  				&& body.EntryPoint.Instructions[0].MatchStLoc(out otherVar' out otherVarInit)  				&& otherVarInit.MatchLdLoc(nativeVar)  				&& otherVar.IsSingleDefinition"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectExitPoints,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ExitPoints.cs,GetExit,The conditional expression  "slot == TryInstruction.TryBlockSlot  				|| slot == TryCatchHandler.BodySlot  				|| slot == TryCatch.HandlerSlot  				|| slot == PinnedRegion.BodySlot"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,The conditional expression  "!loopHead.Dominates(cfg[i]) || isSwitch && cfg[i] != loopHead && loopContext.MatchContinue(cfg[i])"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,DetectSwitchBody,The conditional expression  "exitPoint != null && h.Dominates(exitPoint) && exitPoint.Predecessors.Count == 1 && !HasReachableExit(exitPoint)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,MatchSwitchVar,The conditional expression  "inst is BinaryNumericInstruction bn  				&& bn.Operator == BinaryNumericOperator.Sub  				&& !bn.CheckForOverflow && !bn.IsLifted  				&& bn.Right.MatchLdcI(out sub)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,AddNullCase,The conditional expression  "nullableBlock == null ||  			    nullableBlock.Instructions.Count < 2 ||  			    !nullableBlock.Instructions.Last().MatchBranch(analysis.RootBlock) ||  			    !nullableBlock.Instructions.SecondToLastOrDefault().MatchIfInstruction(out var cond' out var trueInst) ||  			    !cond.MatchLogicNot(out var getHasValue) ||  			    !NullableLiftingTransform.MatchHasValueCall(getHasValue' out ILInstruction nullableInst)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The conditional expression  "(bOp.Operator == BinaryOperatorType.Equality) || (bOp.Operator == BinaryOperatorType.InEquality) || (bOp.Operator == BinaryOperatorType.GreaterThan)  					|| (bOp.Operator == BinaryOperatorType.GreaterThanOrEqual) || (bOp.Operator == BinaryOperatorType.LessThan) ||   					(bOp.Operator == BinaryOperatorType.LessThanOrEqual)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,AddParensForUnaryExpressionIfRequired,The conditional expression  "(expression is BinaryOperatorExpression) ||  			    (expression is AssignmentExpression) ||  			    (expression is CastExpression) ||  			    (expression is AsExpression) ||  			    (expression is IsExpression) ||  			    (expression is LambdaExpression) ||  			    (expression is ConditionalExpression)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,SyntaxTree,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxTree.cs,GetTypes,The conditional expression  "!(child is Statement || child is Expression) &&  					    (child.Role != Roles.TypeMemberRole || ((child is TypeDeclaration || child is DelegateDeclaration) && includeInnerTypes))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,TypeDefMatches,The conditional expression  "type == null || type.Name != typeDef.Name || type.Namespace != typeDef.Namespace || type.TypeParameterCount != typeDef.TypeParameterCount"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The conditional expression  "mathType == null || !mathType.GetFields(f => f.Name == "PI" && f.IsConst).Any() || !mathType.GetFields(f => f.Name == "E" && f.IsConst).Any()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The conditional expression  "IsValidFraction(num' den) && IsEqual(num' den' constantValue' isDouble) && Math.Abs(num) != 1 && Math.Abs(den) != 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The conditional expression  "this.ShowTypeParameters && this.ShowTypeParameterConstraints && !method.IsOverride && !method.IsExplicitInterfaceImplementation"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,GetMemberModifiers,The conditional expression  "!member.IsVirtual && !member.IsAbstract && !member.IsOverride && member.Accessibility != Accessibility.Private && member is IMethod method2 && method2.HasBody"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeParameterConstraint,The conditional expression  "!tp.HasDefaultConstructorConstraint && !tp.HasReferenceTypeConstraint && !tp.HasValueTypeConstraint && tp.NullabilityConstraint != Nullability.NotNullable && tp.DirectBaseTypes.All(IsObjectOrValueType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,MaybeNewLinesAfterUsings,The conditional expression  "(node is UsingDeclaration || node is UsingAliasDeclaration) && !(nextSibling is UsingDeclaration || nextSibling is UsingAliasDeclaration)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertRequiredSpacesDecorator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertRequiredSpacesDecorator.cs,WriteToken,The conditional expression  "lastWritten == LastWritten.Plus && token[0] == '+' ||  			    lastWritten == LastWritten.Minus && token[0] == '-' ||  			    lastWritten == LastWritten.Ampersand && token[0] == '&' ||  			    lastWritten == LastWritten.QuestionMark && token[0] == '?' ||  			    lastWritten == LastWritten.Division && token[0] == '*'"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackExpressionTreeType,The conditional expression  "pt != null && pt.TypeParameterCount == 1 && pt.Name == "Expression" && pt.Namespace == "System.Linq.Expressions""  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackTask,The conditional expression  "pt != null && pt.TypeParameterCount == 1 && pt.Name == "Task" && pt.Namespace == "System.Threading.Tasks""  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The conditional expression  "(code >= TypeCode.Char && code <= TypeCode.Decimal) || type.Kind == TypeKind.Enum || type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The conditional expression  "lhsType.Kind == TypeKind.Null && rhsType.IsReferenceType == false  			    || lhsType.IsReferenceType == false && rhsType.Kind == TypeKind.Null"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The conditional expression  "lhsType.Kind == TypeKind.Null && IsNullableTypeOrNonValueType(rhs.Type)  							           || IsNullableTypeOrNonValueType(lhs.Type) && rhsType.Kind == TypeKind.Null"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumComparison,The conditional expression  "lhs.IsCompileTimeConstant && rhs.IsCompileTimeConstant && !isNullable && elementType.Kind != TypeKind.Enum"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumSubtraction,The conditional expression  "lhs.IsCompileTimeConstant && rhs.IsCompileTimeConstant && !isNullable && elementType.Kind != TypeKind.Enum"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "isNullable && lhs.Type.Kind == TypeKind.Null && rhsCode >= TypeCode.Boolean && rhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "isNullable && rhs.Type.Kind == TypeKind.Null && lhsCode >= TypeCode.Boolean && lhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "lhsCode >= TypeCode.Char && lhsCode <= TypeCode.Decimal  			    && rhsCode >= TypeCode.Char && rhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveForeach,The conditional expression  "or.FoundApplicableCandidate && !or.IsAmbiguous && !or.BestCandidate.IsStatic && or.BestCandidate.Accessibility == Accessibility.Public"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,AdjustArrayAccessArguments,The conditional expression  "!(TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.Int32)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.UInt32)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.Int64)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.UInt64)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The conditional expression  "(!c.IsValid && !c.IsUserDefined && !c.IsMethodGroupConversion) && parameterType.Kind != TypeKind.Unknown"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeExactInference,The conditional expression  "pU != null && pV != null  			    && object.Equals(pU.GenericType' pV.GenericType)  			    && pU.TypeParameterCount == pV.TypeParameterCount"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The conditional expression  "block.Instructions[pos + offset].MatchStLoc(out var valueVariable)  				&& pos + 4 < block.Instructions.Count && valueVariable.IsSingleDefinition && valueVariable.LoadCount == 2  				&& valueVariable.LoadInstructions.All(ld => ld.Parent is DynamicInstruction)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,FindUseSites,The conditional expression  "inst is LdFtn ldftn && !ldftn.Method.IsLocalFunction && ldftn.Parent is NewObj newObj && IsLocalFunctionMethod(ldftn.Method' context) && DelegateConstruction.IsDelegateConstruction(newObj)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,Run,The conditional expression  "context.Settings.LocalFunctions && f.Kind == ILFunctionKind.LocalFunction && v.Kind == VariableKind.Parameter && v.Index > -1 && f.Method.Parameters[v.Index.Value] is IParameter p && LocalFunctionDecompiler.IsClosureParameter(p' decompilationContext)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsClosure,The conditional expression  "context.Settings.LocalFunctions && closureType?.Kind == TypeKind.Struct && variable.HasInitialValue && IsPotentialClosure(this.context' closureType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,VisitStLoc,The conditional expression  "inst.Variable.Kind == VariableKind.Local && inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 0 && inst.Value is StLoc"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsage,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformDisplayClassUsage.cs,IsParameterAssignment,The conditional expression  "!(inst.Value.MatchLdLoc(out var v) && v.Kind == VariableKind.Parameter && v.Function == currentFunction && v.Type.Equals(field.Type))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,MatchCondition,The conditional expression  "!(condition is Call call && call.Method.IsOperator && call.Arguments.Count == 1 && !call.IsLifted)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,MatchBitwiseCall,The conditional expression  "!(call != null && call.Method.IsOperator && call.Arguments.Count == 2 && !call.IsLifted)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The conditional expression  "arg.MatchLdLoc(out var temporary) && temporary.Kind == VariableKind.StackSlot && temporary.IsSingleDefinition && temporary.LoadCount == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The conditional expression  "value.MatchLdFld(out cacheFieldLoad' out var targetFieldCopy) && cacheFieldLoad.MatchLdsFld(out cacheFieldCopy) && cacheField.Equals(cacheFieldCopy) && targetField.Equals(targetFieldCopy)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The conditional expression  "!(value is Call createBinderCall) || createBinderCall.Method.TypeArguments.Count != 0 || createBinderCall.Arguments.Count != 1 || createBinderCall.Method.Name != "Create" || createBinderCall.Method.DeclaringType.FullName != CallSiteTypeName || createBinderCall.Method.DeclaringType.TypeArguments.Count != 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The conditional expression  "value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The conditional expression  "!(value is NewArr newArr2 && newArr2.Type.FullName == "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo" && newArr2.Indices.Count == 1 && newArr2.Indices[0].MatchLdcI4(out var numberOfArguments))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,EarlyExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\EarlyExpressionTransforms.cs,StObjToStLoc,The conditional expression  "inst.Target.MatchLdLoca(out ILVariable v)  				&& TypeUtils.IsCompatibleTypeForMemoryAccess(v.Type' inst.Type)  				&& inst.UnalignedPrefix == 0  				&& !inst.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,EarlyExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\EarlyExpressionTransforms.cs,LdObjToLdLoc,The conditional expression  "inst.Target.MatchLdLoca(out ILVariable v)  				&& TypeUtils.IsCompatibleTypeForMemoryAccess(v.Type' inst.Type)  				&& inst.UnalignedPrefix == 0  				&& !inst.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullPropagationTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullPropagationTransform.cs,RunStatements,The conditional expression  "ifInst.Condition is Comp comp && comp.Kind == ComparisonKind.Inequality  				&& comp.Left.MatchLdLoc(out var testedVar) && comp.Right.MatchLdNull()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The conditional expression  "i >= 2 && switchValue.MatchLdLoc(out var otherSwitchValueVar) && otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 1  					&& instructions[i - 2].MatchStLoc(otherSwitchValueVar' out var newSwitchValue)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The conditional expression  "i >= 2 && instructions[i - 2].MatchStLoc(otherSwitchValueVar' out switchValue)  						&& otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,IsIsInternedCall,The conditional expression  "call != null  				&& call.Method.DeclaringType.IsKnownType(KnownTypeCode.String)  				&& call.Method.IsStatic  				&& call.Method.Name == "IsInterned"  				&& call.Arguments.Count == 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The conditional expression  "!(switchValueVar.IsSingleDefinition && ((SemanticHelper.IsPure(switchValue.Flags) && left.Match(switchValue).Success) || left.MatchLdLoc(switchValueVar)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The conditional expression  "!defaultBlockJump.MatchBranch(out var defaultBlock) && !((leaveContainer != null && defaultBlockJump.MatchLeave(leaveContainer)) || defaultBlockJump.MatchLeave(out _))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The conditional expression  "!(condition.MatchLogicNot(out var arg) && arg is CallInstruction c && c.Method.Name == "TryGetValue" &&  				MatchDictionaryFieldLoad(c.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The conditional expression  "!(block.Instructions[i + 1].MatchStObj(out var loadField' out var dictVarLoad' out var dictType) &&  				dictType.Equals(dictionaryType) && loadField.MatchLdsFlda(out var dictField) && dictField.Equals(dictionaryField) &&  				dictVarLoad.MatchLdLoc(dictVar))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The conditional expression  "!(switchBlock.Instructions[0] is SwitchInstruction switchInst && switchInst.Value.MatchLdObj(out var target' out var ldobjType) &&  				target.MatchUnbox(out var arg' out var unboxType) && arg.MatchLdLoc(switchVariable2) && ldobjType.IsKnownType(KnownTypeCode.Int32) && unboxType.Equals(ldobjType))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The conditional expression  "!(switchBlockInstructionsOffset + 1 < switchBlockInstructions.Count && switchBlockInstructions[switchBlockInstructionsOffset + 1] is SwitchInstruction switchInst && switchInst.Value.MatchLdLoc(out var switchValueVar) &&  				MatchComputeStringHashCall(switchBlockInstructions[switchBlockInstructionsOffset]' switchValueVar' out LdLoc switchValueLoad))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The conditional expression  "i >= 1 && instructions[i - 1].MatchStLoc(switchValueLoad.Variable' out var switchValueTmp) &&  					switchValueLoad.Variable.IsSingleDefinition && switchValueLoad.Variable.LoadCount == switchInst.Sections.Count"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The conditional expression  "i >= 2 && instructions[i - 2].MatchStLoc(out var temporary' out var temporaryValue) && instructions[i - 1].MatchStLoc(switchValueLoad.Variable' out var tempLoad) && tempLoad.MatchLdLoc(temporary)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchComputeStringHashCall,The conditional expression  "!(value is Call c && c.Arguments.Count == 1 && c.Method.Name == "ComputeStringHash" && c.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass())"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchStringEqualityComparison,The conditional expression  "condition is Call c && c.Method.IsOperator && c.Method.Name == "op_Equality"  				&& c.Method.DeclaringType.IsKnownType(KnownTypeCode.String) && c.Arguments.Count == 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The conditional expression  "instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameByType,The conditional expression  "name.Length >= 3 && name[0] == 'I' && char.IsUpper(name[1]) && char.IsLower(name[2])"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The conditional expression  "name.Length > 1 && name[0] == '_' && (char.IsLetter(name[1]) || name[1] == '_')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The conditional expression  "(left.MatchLdNull() && right.MatchLdLoc(temp)) || (right.MatchLdNull() && left.MatchLdLoc(temp))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The conditional expression  "!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 2] is StLoc objectStore) ||  				!objectStore.Value.MatchLdLoc(out var tempVar) || !MatchCall(block.Instructions[i - 1] as Call' "Enter"' tempVar)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The conditional expression  "!(cond.MatchLdLoc(flag) || (cond.MatchCompNotEquals(out var left' out var right) && left.MatchLdLoc(flag) && right.MatchLdcI4(0))) || !MatchExitBlock(trueBlock' obj)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The conditional expression  "call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The conditional expression  "call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != variables.Length"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchCompOrDecimal,The conditional expression  "inst is Call call && call.Method.IsOperator && call.Arguments.Count == 2 && !call.IsLifted"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The conditional expression  "left != null && right != null && leftBits[0] && rightBits[0]  					&& SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpComparison,The conditional expression  "left != null && right != null && SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,The conditional expression  "left != null && right != null && leftBits[0] && rightBits[0]  				&& SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,The conditional expression  "trueInst is Call call && !call.IsLifted  					&& CSharp.Resolver.CSharpOperators.IsComparisonOperator(call.Method)  					&& falseInst.MatchLdcI4(call.Method.Name == "op_Inequality" ? 1 : 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The conditional expression  "inst is Comp comp && !comp.IsLifted && comp.Kind == ComparisonKind.Equality  				&& MatchGetValueOrDefault(comp.Left' out ILVariable v) && nullableVars.Contains(v)  				&& NullableType.GetUnderlyingType(v.Type).IsKnownType(KnownTypeCode.Boolean)  				&& comp.Right.MatchLdcI4(0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformRefTypes,The conditional expression  "trueInst is Block trueBlock && trueBlock.Instructions.Count == 2  				&& trueBlock.Instructions[0].MatchStLoc(out var temporary' out fallbackValue)  				&& temporary.IsSingleDefinition && temporary.LoadCount == 1  				&& trueBlock.Instructions[1].MatchStLoc(stloc.Variable' out var useOfTemporary)  				&& useOfTemporary.MatchLdLoc(temporary)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The conditional expression  "newObjInst.ILStackWasEmpty && v.Kind == VariableKind.Local && !context.Function.Method.IsConstructor && !context.Function.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The conditional expression  "kind != AccessPathKind.Invalid && values.SelectMany(v => v.Descendants).OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The conditional expression  "v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,The conditional expression  "storeBeforeIf == null || storeInst == null || storeBeforeIf.Variable != s || storeInst.Variable != s"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The conditional expression  "storeBeforeIf == null || storeInst == null || storeBeforeIf.Variable != s || storeInst.Variable != s"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,The conditional expression  "inst.Kind == ComparisonKind.Inequality && inst.LiftingKind == ComparisonLiftingKind.None  				&& inst.Right.MatchLdcI4(0) && (IfInstruction.IsInConditionSlot(inst) || inst.Left is Comp)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,The conditional expression  "rightWithoutConv.MatchLdcI4(0)  			    && inst.Sign == Sign.Unsigned  			    && (inst.Kind == ComparisonKind.GreaterThan || inst.Kind == ComparisonKind.LessThanOrEqual)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitConv,The conditional expression  "inst.Argument.MatchLdLen(StackType.I' out ILInstruction array) && inst.TargetType.IsIntegerType()  				&& (!inst.CheckForOverflow || context.Settings.AssumeArrayLengthFitsIntoInt32)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitConv,The conditional expression  "inst.TargetType.IsFloatType() && inst.Argument is Conv conv   				&& conv.Kind == ConversionKind.IntToFloat && conv.TargetType == PrimitiveType.R"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,CleanUpArrayIndices,The conditional expression  "index is Conv conv && conv.ResultType == StackType.I  					&& (conv.Kind == ConversionKind.Truncate && conv.CheckForOverflow  						|| conv.Kind == ConversionKind.ZeroExtend || conv.Kind == ConversionKind.SignExtend)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The conditional expression  "args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitIfInstruction,The conditional expression  "inst.TrueInst.MatchLdcI4(0) && !inst.FalseInst.MatchLdcI4(0)  				|| inst.FalseInst.MatchLdcI4(1) && !inst.TrueInst.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,IsDelegateConstruction,The conditional expression  "!(opCode == OpCode.LdFtn || opCode == OpCode.LdVirtFtn || (allowTransformed && opCode == OpCode.ILFunction))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,IsAnonymousMethod,The conditional expression  "!(method.HasGeneratedName()  				|| method.Name.Contains("$")  				|| method.IsCompilerGeneratedOrIsInCompilerGeneratedClass()  				|| TransformDisplayClassUsage.IsPotentialClosure(decompiledTypeDefinition' method.DeclaringTypeDefinition)  				|| ContainsAnonymousType(method))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSequentialLocAllocInitializer,The conditional expression  "values == null || store.Kind != VariableKind.StackSlot || store.StoreCount != 1  				|| store.AddressCount != 0 || store.LoadCount > values.Length + 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The conditional expression  "index < 0 || index >= arrayLength[k] || (!previousComponentWasGreater && index < nextMinimumIndex[k])"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The conditional expression  "!(tempAccess is LdElema elemLoad) || !elemLoad.Array.MatchLdLoc(store) || elemLoad.Indices.Count != 1  				|| !elemLoad.Indices[0].MatchLdcI4(index)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorWithInlineStore,The conditional expression  "binary != null && (binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperator,The conditional expression  "!binary.Left.MatchLdLoc(tmpVar) || !(binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataProperty,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataProperty.cs,MergePropertyAccessibility,The conditional expression  "left == Accessibility.Protected && right == Accessibility.Internal ||  				left == Accessibility.Internal && right == Accessibility.Protected"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,GetAttributes,The conditional expression  "layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || layout.PackingSize > 0 || layout.Size > 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,BaseTypeCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BaseTypeCollector.cs,CollectBaseTypes,The conditional expression  "SkipImplementedInterfaces && def != null && def.Kind != TypeKind.Interface && def.Kind != TypeKind.TypeParameter"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetMethodsImpl,The conditional expression  "(options & GetMemberOptions.ReturnMemberDefinitions) == 0  			    && (pt != null || (methodTypeArguments != null && methodTypeArguments.Count > 0))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The conditional expression  "index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,InsertVariableDeclarations,The conditional expression  "context.Settings.Discards && v.ILVariable.LoadCount == 0 && v.ILVariable.StoreCount == 0 && v.ILVariable.AddressCount == 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,DescendIntoStatement,The conditional expression  "node is WhileStatement || node is ForeachStatement || node is DoWhileStatement || node is ForStatement"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,AddressUsedForSingleCall,The conditional expression  "v.StoreCount == 1 && v.AddressCount == 1 && v.LoadCount == 0 && v.Type.IsReferenceType == false"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The conditional expression  "itemVariable == null || !itemVariable.IsSingleDefinition  				|| (itemVariable.Kind != IL.VariableKind.Local && itemVariable.Kind != IL.VariableKind.StackSlot)  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ReplaceBackingFieldUsage,The conditional expression  "field != null && IsBackingFieldOfAutomaticProperty(field' out var property)  					&& CanTransformToAutomaticProperty(property) && currentMethod.AccessorOwner != property"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,TypePattern,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs,DoMatch,The conditional expression  "ct != null && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceUnsafeModifier,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUnsafeModifier.cs,VisitUnaryOperatorExpression,The conditional expression  "bop != null && bop.Operator == BinaryOperatorType.Add   					&& bop.GetResolveResult() is OperatorResolveResult orr  					&& orr.Operands.FirstOrDefault()?.Type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "nullableReferenceTypes || readOnlyMethods || asyncEnumerator || asyncUsingAndForEachStatement"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "introduceRefModifiersOnStructs || introduceReadonlyAndInModifiers || nonTrailingNamedArguments || refExtensionMethods"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "outVariables || throwExpressions || tupleTypes || tupleConversions || discards || localFunctions"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "awaitInCatchFinally || useExpressionBodyForCalculatedGetterOnlyProperties || nullPropagation  				|| stringInterpolation || dictionaryInitializers || extensionMethodsInCollectionInitializers"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "anonymousTypes || objectCollectionInitializers || automaticProperties || queryExpressions || expressionTrees"  is complex.
Complex Conditional,ICSharpCode.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,GetMinimumRequiredVersion,The conditional expression  "anonymousMethods || liftNullables || yieldReturn || useImplicitMethodGroupConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentMemberReference,The conditional expression  "node is IdentifierExpression && node.Role == Roles.TargetExpression && node.Parent is InvocationExpression && symbol is IMember member"  is complex.
Complex Conditional,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentLocalDefinition,The conditional expression  "node is ParameterDeclaration || node is VariableInitializer || node is CatchClause || node is ForeachStatement"  is complex.
Complex Conditional,ICSharpCode.Decompiler,SRMExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,IsAnonymousType,The conditional expression  "type.Namespace.IsNil && type.HasGeneratedName(metadata) && (name.Contains("AnonType") || name.Contains("AnonymousType"))"  is complex.
Complex Conditional,ICSharpCode.Decompiler,NRExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,IsAnonymousType,The conditional expression  "string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,EscapeString,The conditional expression  "char.IsControl(ch) || char.IsSurrogate(ch) || (char.IsWhiteSpace(ch) && ch != ' ')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,Detect,The conditional expression  "elementSize > 0 && mul.Right.MatchLdcI(elementSize.Value)  					|| mul.Right.UnwrapConv(ConversionKind.SignExtend) is SizeOf sizeOf && sizeOf.Type.Equals(pointerElementType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,IntroduceDynamicTypeOnLocals,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\IntroduceDynamicTypeOnLocals.cs,Run,The conditional expression  "variable.Kind != VariableKind.Local &&  					variable.Kind != VariableKind.StackSlot &&  					variable.Kind != VariableKind.ForeachLocal &&  					variable.Kind != VariableKind.UsingLocal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILVariableCollection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ILVariableCollection.cs,RemoveDead,The conditional expression  "v.StoreCount == deadStoreCount && v.LoadCount == 0 && v.AddressCount == 0 && v.Kind != VariableKind.DisplayClassLocal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLogicNot,The conditional expression  "this is Comp comp && comp.Kind == ComparisonKind.Equality  				&& comp.LiftingKind == ComparisonLiftingKind.None  				&& comp.Right.MatchLdcI4(0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLdFld,The conditional expression  "this is LdObj ldobj && ldobj.Target is LdFlda ldflda && ldobj.UnalignedPrefix == 0 && !ldobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLdsFld,The conditional expression  "this is LdObj ldobj && ldobj.Target is LdsFlda ldsflda && ldobj.UnalignedPrefix == 0 && !ldobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchStsFld,The conditional expression  "this is StObj stobj && stobj.Target is LdsFlda ldsflda && stobj.UnalignedPrefix == 0 && !stobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchStFld,The conditional expression  "this is StObj stobj && stobj.Target is LdFlda ldflda && stobj.UnalignedPrefix == 0 && !stobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,ApplyAttributeTypeVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ApplyAttributeTypeVisitor.cs,ApplyAttributesToType,The conditional expression  "hasDynamicAttribute || nullability != Nullability.Oblivious || nullableAttributeData != null   				|| (options & (TypeSystemOptions.Tuple | TypeSystemOptions.KeepModifiers)) != TypeSystemOptions.KeepModifiers"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,Equals,The conditional expression  "x == null || y == null || x.SymbolKind != y.SymbolKind || !nameComparer.Equals(x.Name' y.Name)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.Decompiler.FlowAnalysis,Dominance,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The conditional expression  "j.IsReachable && (j.Predecessors.Count >= 2 || (j.Predecessors.Count >= 1 && j.ImmediateDominator == null))"  is complex.
Virtual Method Call from Constructor,ICSharpCode.Decompiler.IL,ChildrenEnumerator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ILInstruction.cs,ChildrenEnumerator,The constructor "ChildrenEnumerator" calls a virtual method "GetChildCount".
Empty Catch Block,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GetCodeMappingInfo,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteResourceToFile,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteResourceToFile,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,AddSecurityAttributes,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,AddSecurityAttributes,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler,DecompilerException,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler,DecompilerException,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinder.cs,FindDotNetExeDirectory,The method has an empty catch block.
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The following statement contains a magic number: settings.TupleTypes && TupleTransform.MatchTupleConstruction(inst as NewObj' out var tupleElements) && tupleElements.Length >= 2
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The following statement contains a magic number: bool unpackSingleElementArray = !argumentList.IsExpandedForm && argumentList.Length == 2  					&& argumentList.Arguments[1].Expression is ArrayCreateExpression ace  					&& ace.Initializer?.Elements.Count == 1;
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildCollectionInitializerExpression,The following statement contains a magic number: argumentList.Arguments.Length == 2
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsInterpolatedStringCreation,The following statement contains a magic number: return method.IsStatic && (  				(method.DeclaringType.IsKnownType(KnownTypeCode.String) && method.Name == "Format") ||  				(method.Name == "Create" && method.DeclaringType.Name == "FormattableStringFactory" &&  					method.DeclaringType.Namespace == "System.Runtime.CompilerServices")  			)  			&& argumentList.ArgumentNames == null // Argument names are not allowed  			&& (  				argumentList.IsExpandedForm // Must be expanded form  				|| !method.Parameters.Last().IsParams // -or- not a params overload  				|| (argumentList.Length == 2 && argumentList.Arguments[1].Expression is ArrayCreateExpression) // -or- an array literal  			);
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TryGetStringInterpolationTokens,The following statement contains a magic number: switch (kind) {  					case TokenKind.Error:  						return false;  					case TokenKind.String:  						tokens.Add((kind' -1' data));  						break;  					case TokenKind.Argument:  						if (!int.TryParse(data' out index) || index != i)  							return false;  						i++;  						tokens.Add((kind' index' null));  						break;  					case TokenKind.ArgumentWithFormat:  						string[] arg = data.Split(new[] { ':' }' 2);  						if (arg.Length != 2 || arg[1].Length == 0)  							return false;  						if (!int.TryParse(arg[0]' out index) || index != i)  							return false;  						i++;  						tokens.Add((kind' index' arg[1]));  						break;  					default:  						return false;  				}
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,TryGetStringInterpolationTokens,The following statement contains a magic number: switch (kind) {  					case TokenKind.Error:  						return false;  					case TokenKind.String:  						tokens.Add((kind' -1' data));  						break;  					case TokenKind.Argument:  						if (!int.TryParse(data' out index) || index != i)  							return false;  						i++;  						tokens.Add((kind' index' null));  						break;  					case TokenKind.ArgumentWithFormat:  						string[] arg = data.Split(new[] { ':' }' 2);  						if (arg.Length != 2 || arg[1].Length == 0)  							return false;  						if (!int.TryParse(arg[0]' out index) || index != i)  							return false;  						i++;  						tokens.Add((kind' index' arg[1]));  						break;  					default:  						return false;  				}
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildArgumentList,The following statement contains a magic number: int firstOptionalArgumentIndex = expressionBuilder.settings.OptionalArguments ? -2 : -1;
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildArgumentList,The following statement contains a magic number: firstOptionalArgumentIndex == -2
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsDelegateEqualityComparison,The following statement contains a magic number: return method.IsOperator  				&& method.DeclaringType.IsKnownType(KnownTypeCode.Delegate)  				&& (method.Name == "op_Equality" || method.Name == "op_Inequality")  				&& arguments.Count == 2  				&& arguments[0].Type.Kind == TypeKind.Delegate  				&& arguments[1].Type.Equals(arguments[0].Type);
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,BuildDelegateReference,The following statement contains a magic number: (step & 2) != 0
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,The following statement contains a magic number: switch (memberRef.Parent.Kind) {  					case HandleKind.TypeReference:  						// This should never happen in normal code' because we are looking at nested types  						// If it's not a nested type' it can't be a reference to the state machine or lambda anyway' and  						// those should be either TypeDef or TypeSpec.  						return default;  					case HandleKind.TypeDefinition:  						return (TypeDefinitionHandle)memberRef.Parent;  					case HandleKind.TypeSpecification:  						var ts = module.Metadata.GetTypeSpecification((TypeSpecificationHandle)memberRef.Parent);  						if (ts.Signature.IsNil)  							return default;  						// Do a quick scan using BlobReader  						var signature = module.Metadata.GetBlobReader(ts.Signature);  						// When dealing with FSM implementations' we can safely assume that if it's a type spec'  						// it must be a generic type instance.  						if (signature.ReadByte() != (byte)SignatureTypeCode.GenericTypeInstance)  							return default;  						// Skip over the rawTypeKind: value type or class  						var rawTypeKind = signature.ReadCompressedInteger();  						if (rawTypeKind < 17 || rawTypeKind > 18)  							return default;  						// Only read the generic type' ignore the type arguments  						var genericType = signature.ReadTypeHandle();  						// Again' we assume this is a type def' because we are only looking at nested types  						if (genericType.Kind != HandleKind.TypeDefinition)  							return default;  						return (TypeDefinitionHandle)genericType;  				}
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,The following statement contains a magic number: switch (memberRef.Parent.Kind) {  					case HandleKind.TypeReference:  						// This should never happen in normal code' because we are looking at nested types  						// If it's not a nested type' it can't be a reference to the state machine or lambda anyway' and  						// those should be either TypeDef or TypeSpec.  						return default;  					case HandleKind.TypeDefinition:  						return (TypeDefinitionHandle)memberRef.Parent;  					case HandleKind.TypeSpecification:  						var ts = module.Metadata.GetTypeSpecification((TypeSpecificationHandle)memberRef.Parent);  						if (ts.Signature.IsNil)  							return default;  						// Do a quick scan using BlobReader  						var signature = module.Metadata.GetBlobReader(ts.Signature);  						// When dealing with FSM implementations' we can safely assume that if it's a type spec'  						// it must be a generic type instance.  						if (signature.ReadByte() != (byte)SignatureTypeCode.GenericTypeInstance)  							return default;  						// Skip over the rawTypeKind: value type or class  						var rawTypeKind = signature.ReadCompressedInteger();  						if (rawTypeKind < 17 || rawTypeKind > 18)  							return default;  						// Only read the generic type' ignore the type arguments  						var genericType = signature.ReadTypeHandle();  						// Again' we assume this is a type def' because we are only looking at nested types  						if (genericType.Kind != HandleKind.TypeDefinition)  							return default;  						return (TypeDefinitionHandle)genericType;  				}
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The following statement contains a magic number: method.Body = new BlockStatement {  				new IfElseStatement {  					Condition = new BinaryOperatorExpression {  						Left = new MemberReferenceExpression(new TypeReferenceExpression(typeSystemAstBuilder.ConvertType(typeSystem.FindType(KnownTypeCode.IntPtr)))' "Size")'  						Operator = BinaryOperatorType.Equality'  						Right = new PrimitiveExpression(4)  					}'  					TrueStatement = new BlockStatement { // 32-bit  						new ReturnStatement(  							new CastExpression(  								method.ReturnType.Clone()'  								intermediate32  							)  						)  					}'  					FalseStatement = new BlockStatement { // 64-bit  						new ReturnStatement(  							new CastExpression(  								method.ReturnType.Clone()'  								intermediate64  							)  						)  					}'  				}  			};
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The following statement contains a magic number: enumDec.Initializer is PrimitiveExpression primitive  							&& initValue >= 0 && (decompilationContext.CurrentTypeDefinition.HasAttribute(KnownAttribute.Flags)  								|| (initValue > 9 && (unchecked(initValue & (initValue - 1)) == 0 || unchecked(initValue & (initValue + 1)) == 0)))
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsFixedField,The following statement contains a magic number: attr != null && attr.FixedArguments.Length == 2
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNewObj,The following statement contains a magic number: inst.Arguments.Count == 2 && inst.Arguments[0] is Block b && b.Kind == BlockKind.StackAllocInitializer
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ShouldDisplayAsHex,The following statement contains a magic number: value <= 9
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitUserDefinedCompoundAssign,The following statement contains a magic number: Debug.Assert(inst.Method.Parameters.Count == 2);
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ValueMightBeOversized,The following statement contains a magic number: stackType == StackType.I && orr.OperatorType == ExpressionType.Subtract  					&& orr.Operands.Count == 2  					&& orr.Operands[0].Type.Kind == TypeKind.Pointer  					&& orr.Operands[1].Type.Kind == TypeKind.Pointer
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The following statement contains a magic number: var pathElement = currentPath[elementsStack.Count - 2];
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateStackAllocInitializer,The following statement contains a magic number: block.Instructions.Count < 2 || !block.Instructions[1].MatchStObj(out _' out _' out var t)
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitDynamicSetIndexInstruction,The following statement contains a magic number: Debug.Assert(inst.Arguments.Count >= 3);
Magic Number,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,UnwrapNestedContainerIfPossible,The following statement contains a magic number: nestedBlock.Instructions.Count != 2 ||  				!(nestedBlock.Instructions[0] is BlockContainer nestedContainer) ||  				!(nestedBlock.Instructions[1] is Leave leave)
Magic Number,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The following statement contains a magic number: switch (container.Kind) {  				case ContainerKind.Loop:  					continueTarget = container.EntryPoint;  					blockStatement = ConvertBlockContainer(container' true);  					Debug.Assert(continueCount < container.EntryPoint.IncomingEdgeCount);  					Debug.Assert(blockStatement.Statements.First() is LabelStatement);  					if (container.EntryPoint.IncomingEdgeCount == continueCount + 1) {  						// Remove the entrypoint label if all jumps to the label were replaced with 'continue;' statements  						blockStatement.Statements.First().Remove();  					}    					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt)  						continueStmt.Remove();  					DeclareLocalFunctions(currentFunction' container' blockStatement);  					return new WhileStatement(new PrimitiveExpression(true)' blockStatement);  				case ContainerKind.While:  					continueTarget = container.EntryPoint;  					if (!container.MatchConditionBlock(continueTarget' out condition' out loopBody))  						throw new NotSupportedException("Invalid condition block in while loop.");  					blockStatement = ConvertAsBlock(loopBody);  					if (!loopBody.HasFlag(InstructionFlags.EndPointUnreachable))  						blockStatement.Add(new BreakStatement());  					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.Skip(1).Except(new[] { loopBody })' true);  					Debug.Assert(continueCount < container.EntryPoint.IncomingEdgeCount);  					if (continueCount + 1 < container.EntryPoint.IncomingEdgeCount) {  						// There's an incoming edge to the entry point (=while condition) that wasn't represented as "continue;"  						// -> emit a real label  						// We'll also remove any "continue;" in front of the label' as it's redundant.  						if (blockStatement.LastOrDefault() is ContinueStatement)  							blockStatement.Last().Remove();  						blockStatement.Add(new LabelStatement { Label = container.EntryPoint.Label });  					}    					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt2)  						continueStmt2.Remove();  					DeclareLocalFunctions(currentFunction' container' blockStatement);  					return new WhileStatement(exprBuilder.TranslateCondition(condition)' blockStatement);  				case ContainerKind.DoWhile:  					continueTarget = container.Blocks.Last();  					if (!container.MatchConditionBlock(continueTarget' out condition' out _))  						throw new NotSupportedException("Invalid condition block in do-while loop.");  					blockStatement = ConvertBlockContainer(new BlockStatement()' container' container.Blocks.SkipLast(1)' true);  					if (container.EntryPoint.IncomingEdgeCount == 2) {  						// Remove the entry-point label' if there are only two jumps to the entry-point:  						// from outside the loop and from the condition-block.  						blockStatement.Statements.First().Remove();  					}  					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt3)  						continueStmt3.Remove();  					if (continueTarget.IncomingEdgeCount > continueCount) {  						// if there are branches to the condition block' that were not converted  						// to continue statements' we have to introduce an extra label.  						blockStatement.Add(new LabelStatement { Label = continueTarget.Label });  					}  					DeclareLocalFunctions(currentFunction' container' blockStatement);  					if (blockStatement.Statements.Count == 0) {  						return new WhileStatement {  							Condition = exprBuilder.TranslateCondition(condition)'  							EmbeddedStatement = blockStatement  						};  					}  					return new DoWhileStatement {  						EmbeddedStatement = blockStatement'  						Condition = exprBuilder.TranslateCondition(condition)  					};  				case ContainerKind.For:  					continueTarget = container.Blocks.Last();  					if (!container.MatchConditionBlock(container.EntryPoint' out condition' out loopBody))  						throw new NotSupportedException("Invalid condition block in for loop.");  					blockStatement = ConvertAsBlock(loopBody);  					if (!loopBody.HasFlag(InstructionFlags.EndPointUnreachable))  						blockStatement.Add(new BreakStatement());  					if (!container.MatchIncrementBlock(continueTarget))  						throw new NotSupportedException("Invalid increment block in for loop.");  					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.SkipLast(1).Skip(1).Except(new[] { loopBody })' true);  					var forStmt = new ForStatement() {  						Condition = exprBuilder.TranslateCondition(condition)'  						EmbeddedStatement = blockStatement  					};  					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt4)  						continueStmt4.Remove();  					for (int i = 0; i < continueTarget.Instructions.Count - 1; i++) {  						forStmt.Iterators.Add(Convert(continueTarget.Instructions[i]));  					}  					if (continueTarget.IncomingEdgeCount > continueCount)  						blockStatement.Add(new LabelStatement { Label = continueTarget.Label });  					DeclareLocalFunctions(currentFunction' container' blockStatement);  					return forStmt;  				default:  					throw new ArgumentOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: frameworkVersionNumber *= 10;
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: frameworkVersionNumber < 100
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: switch (module.GetRuntime()) {  						case Metadata.TargetRuntime.Net_1_0:  							frameworkVersionNumber = 100;  							w.WriteElementString("TargetFrameworkVersion"' "v1.0");  							break;  						case Metadata.TargetRuntime.Net_1_1:  							frameworkVersionNumber = 110;  							w.WriteElementString("TargetFrameworkVersion"' "v1.1");  							break;  						case Metadata.TargetRuntime.Net_2_0:  							frameworkVersionNumber = 200;  							w.WriteElementString("TargetFrameworkVersion"' "v2.0");  							// TODO: Detect when .NET 3.0/3.5 is required  							break;  						default:  							frameworkVersionNumber = 400;  							w.WriteElementString("TargetFrameworkVersion"' "v4.0");  							break;  					}
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: switch (module.GetRuntime()) {  						case Metadata.TargetRuntime.Net_1_0:  							frameworkVersionNumber = 100;  							w.WriteElementString("TargetFrameworkVersion"' "v1.0");  							break;  						case Metadata.TargetRuntime.Net_1_1:  							frameworkVersionNumber = 110;  							w.WriteElementString("TargetFrameworkVersion"' "v1.1");  							break;  						case Metadata.TargetRuntime.Net_2_0:  							frameworkVersionNumber = 200;  							w.WriteElementString("TargetFrameworkVersion"' "v2.0");  							// TODO: Detect when .NET 3.0/3.5 is required  							break;  						default:  							frameworkVersionNumber = 400;  							w.WriteElementString("TargetFrameworkVersion"' "v4.0");  							break;  					}
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: switch (module.GetRuntime()) {  						case Metadata.TargetRuntime.Net_1_0:  							frameworkVersionNumber = 100;  							w.WriteElementString("TargetFrameworkVersion"' "v1.0");  							break;  						case Metadata.TargetRuntime.Net_1_1:  							frameworkVersionNumber = 110;  							w.WriteElementString("TargetFrameworkVersion"' "v1.1");  							break;  						case Metadata.TargetRuntime.Net_2_0:  							frameworkVersionNumber = 200;  							w.WriteElementString("TargetFrameworkVersion"' "v2.0");  							// TODO: Detect when .NET 3.0/3.5 is required  							break;  						default:  							frameworkVersionNumber = 400;  							w.WriteElementString("TargetFrameworkVersion"' "v4.0");  							break;  					}
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: switch (module.GetRuntime()) {  						case Metadata.TargetRuntime.Net_1_0:  							frameworkVersionNumber = 100;  							w.WriteElementString("TargetFrameworkVersion"' "v1.0");  							break;  						case Metadata.TargetRuntime.Net_1_1:  							frameworkVersionNumber = 110;  							w.WriteElementString("TargetFrameworkVersion"' "v1.1");  							break;  						case Metadata.TargetRuntime.Net_2_0:  							frameworkVersionNumber = 200;  							w.WriteElementString("TargetFrameworkVersion"' "v2.0");  							// TODO: Detect when .NET 3.0/3.5 is required  							break;  						default:  							frameworkVersionNumber = 400;  							w.WriteElementString("TargetFrameworkVersion"' "v4.0");  							break;  					}
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following statement contains a magic number: frameworkVersionNumber > 400 && platformName == "AnyCPU" && (module.Reader.PEHeaders.CorHeader.Flags & CorFlags.Prefers32Bit) == 0
Magic Number,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,CleanUpFileName,The following statement contains a magic number: b.Length >= 200
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: memberIdString.Length < 2 || memberIdString[1] != ':'
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: int pos = 2;
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseTypeName,The following statement contains a magic number: pos = 2;
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,FindEntity,The following statement contains a magic number: return ParseTypeName(idString.Substring(2)).Resolve(context).GetDefinition();
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following statement contains a magic number: switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,GetHashCode,The following statement contains a magic number: h = (h << 5) - h + c;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The following statement contains a magic number: block.Instructions.Count < 2 || !block.Instructions[0].MatchStLoc(out var globalCopyVar' out var value) || !value.MatchLdLoc(tryCatch.Handlers[0].Variable)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The following statement contains a magic number: block.Instructions.Count == 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The following statement contains a magic number: globalCopyVar.LoadCount != 1 || globalCopyVar.StoreCount > 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,Run,The following statement contains a magic number: exitOfFinally.Instructions.RemoveRange(tempStore.ChildIndex' 3);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The following statement contains a magic number: tempStore.ChildIndex != count - 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The following statement contains a magic number: !(endOfFinally.Instructions[count - 2] is IfInstruction ifInst)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The following statement contains a magic number: typeCheckBlock.Instructions.Count != 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The following statement contains a magic number: !typeCheckBlock.Instructions[2].MatchBranch(out var throwBlock)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchExceptionCaptureBlock,The following statement contains a magic number: captureBlock.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInFinallyTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInFinallyTransform.cs,MatchAfterFinallyBlock,The following statement contains a magic number: afterFinally.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: body.Count < 4
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: int pos = body.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: startCall.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchYieldBlock,The following statement contains a magic number: block.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchYieldBlock,The following statement contains a magic number: args.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The following statement contains a magic number: switch (methodType) {  				case AsyncMethodType.TaskOfT:  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdLoc(out resultVar))  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.Task:  				case AsyncMethodType.Void:  					resultVar = null;  					if (args.Count != 1)  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.AsyncEnumerable:  				case AsyncMethodType.AsyncEnumerator:  					resultVar = null;  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdcI4(0))  						throw new SymbolicAnalysisFailedException();  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The following statement contains a magic number: switch (methodType) {  				case AsyncMethodType.TaskOfT:  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdLoc(out resultVar))  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.Task:  				case AsyncMethodType.Void:  					resultVar = null;  					if (args.Count != 1)  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.AsyncEnumerable:  				case AsyncMethodType.AsyncEnumerator:  					resultVar = null;  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdcI4(0))  						throw new SymbolicAnalysisFailedException();  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The following statement contains a magic number: int pos = 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: !MatchCall(catchBlock.Instructions[2]' "SetException"' out var args)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: args.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: int pos = 3;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,TransformYieldBreak,The following statement contains a magic number: block.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,TransformYieldBreak,The following statement contains a magic number: !block.Instructions[block.Instructions.Count - 2].MatchStFld(out var target' out var field' out var value)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,SimplifyIfDisposeMode,The following statement contains a magic number: block.Instructions[block.Instructions.Count - 2] = falseInst;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: int pos = block.Instructions.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: callArgs.Count != 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: callArgs[2].MatchLdThis()
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeYieldReturn,The following statement contains a magic number: int pos = block.Instructions.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: block.Instructions.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: !(block.Instructions[block.Instructions.Count - 3] is StLoc stLocAwaiter)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: !block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: block.Instructions.RemoveAt(block.Instructions.Count - 3);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: block.Instructions.RemoveAt(block.Instructions.Count - 2);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckAwaitBlock,The following statement contains a magic number: block.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckAwaitBlock,The following statement contains a magic number: pos += 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The following statement contains a magic number: catchBlock.Instructions.Count < 2 || catchBlock.Instructions.Count > 4
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The following statement contains a magic number: catchBlock.Instructions.Count < 2 || catchBlock.Instructions.Count > 4
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The following statement contains a magic number: catchBlock.Instructions.Count > 2 && catchBlock.Instructions[catchBlock.Instructions.Count - 3] is StLoc stloc
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The following statement contains a magic number: catchBlock.Instructions.Count > 2 && catchBlock.Instructions[catchBlock.Instructions.Count - 3] is StLoc stloc
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AwaitInCatchTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AwaitInCatchTransform.cs,MatchAwaitCatchHandler,The following statement contains a magic number: jumpTableStartBlock.Instructions.Count == 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,The following statement contains a magic number: body.Instructions[pos].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdLoc(var2 ?? var1)  					&& (value.MatchLdcI4(-2) || value.MatchLdcI4(0))
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationNewObj,The following statement contains a magic number: !(initialState == -2 || initialState == 0)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: !(faultBlock.Instructions.Count == 2  					&& faultBlock.Instructions[0] is Call call  					&& call.Method.MetadataToken == disposeMethod  					&& call.Arguments.Count == 1  					&& call.Arguments[0].MatchLdThis()  					&& faultBlock.Instructions[1].MatchLeave(faultBlockContainer))
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: i < 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,IsContinueBlock,The following statement contains a magic number: container.EntryPoint.IncomingEdgeCount == 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,InlineVariableInReturnBlock,The following statement contains a magic number: block.Instructions.Count == 2 && block.Instructions[1].MatchReturn(out ILInstruction value)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: block.Instructions.Count > 1 && block.Instructions[block.Instructions.Count - 2].HasFlag(InstructionFlags.MayBranch)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: block.Instructions.RemoveRange(block.Instructions.Count - 3' 2);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: block.Instructions.RemoveRange(block.Instructions.Count - 3' 2);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The following statement contains a magic number: block.Instructions.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The following statement contains a magic number: !(block.Instructions.SecondToLastOrDefault() is StLoc deadStore && block.Instructions[block.Instructions.Count - 3] is StLoc tempStore)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,DetectNullSafeArrayToPointer,The following statement contains a magic number: block.Instructions[block.Instructions.Count - 2] = new StLoc(p' arrayToPointer)  						.WithILRange(block.Instructions[block.Instructions.Count - 2]);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,DetectNullSafeArrayToPointer,The following statement contains a magic number: block.Instructions[block.Instructions.Count - 2] = new StLoc(p' arrayToPointer)  						.WithILRange(block.Instructions[block.Instructions.Count - 2]);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The following statement contains a magic number: var previous = block.Instructions.ElementAtOrDefault(block.Instructions.Count - 3) as StLoc;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullBlock,The following statement contains a magic number: block.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullAndNotEmptyBlock,The following statement contains a magic number: block.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNullOrEmptyBlock,The following statement contains a magic number: return block.Instructions.Count == 2  				&& block.Instructions[0].MatchStLoc(out p' out value)  				&& (p.Kind == VariableKind.PinnedLocal || p.Kind == VariableKind.Local)  				&& IsNullOrZero(value)  				&& block.Instructions[1].MatchBranch(out targetBlock);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,CreatePinnedRegion,The following statement contains a magic number: innerBlock.Instructions.RemoveAt(innerBlock.Instructions.Count - 2);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,HandleStringToPointer,The following statement contains a magic number: body.EntryPoint.Instructions.Count != 3
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,HandleStringToPointer,The following statement contains a magic number: !body.EntryPoint.Instructions[2].MatchBranch(out Block adjustOffsetToStringData)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,The following statement contains a magic number: block.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,The following statement contains a magic number: nativeVar.IsSingleDefinition && nativeVar.LoadCount == 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,The following statement contains a magic number: exitNodeArity = 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,The following statement contains a magic number: loopHead.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: !(tailOnly || block.Instructions.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: block.Instructions.Count >= 2  				&& block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)  				&& AnalyzeCondition(condition' out trueValues)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: block.Instructions.Count >= 2  				&& block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)  				&& AnalyzeCondition(condition' out trueValues)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,UseCSharpSwitch,The following statement contains a magic number: analysis.Sections.Count == 2 && IsSingleCondition(flowNodes' caseNodes)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: return insns.Count >= 3 && SwitchOnStringTransform.MatchComputeStringHashCall(insns[insns.Count - 3]' analysis.SwitchVariable' out var switchLdLoc);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: return insns.Count >= 3 && SwitchOnStringTransform.MatchComputeStringHashCall(insns[insns.Count - 3]' analysis.SwitchVariable' out var switchLdLoc);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,AddNullCase,The following statement contains a magic number: nullableBlock == null ||  			    nullableBlock.Instructions.Count < 2 ||  			    !nullableBlock.Instructions.Last().MatchBranch(analysis.RootBlock) ||  			    !nullableBlock.Instructions.SecondToLastOrDefault().MatchIfInstruction(out var cond' out var trueInst) ||  			    !cond.MatchLogicNot(out var getHasValue) ||  			    !NullableLiftingTransform.MatchHasValueCall(getHasValue' out ILInstruction nullableInst)
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,IsShortCircuit,The following statement contains a magic number: !IsFlowNode(node) || node.Successors.Count > 2 || node.Predecessors.Count != 1
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,LoopContext,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,FindContinue,The following statement contains a magic number: pred.Successors.Count <= 2
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,DebugToString,The following statement contains a magic number: return text.Substring(0' 97) + "...";
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,DebugToString,The following statement contains a magic number: text.Length > 100
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,PrimitiveExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\PrimitiveExpression.cs,AdvanceLocation,The following statement contains a magic number: nl == 2
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TextLocation,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (191 * column.GetHashCode() ^ line.GetHashCode());
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TextLocationConverter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs,ConvertFrom,The following statement contains a magic number: parts.Length == 2
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The following statement contains a magic number: switch (attr.Type) {  				case SimpleType st:  					if (st.Identifier.EndsWith("Attribute"' StringComparison.Ordinal))  						st.Identifier = st.Identifier.Substring(0' st.Identifier.Length - 9);  					break;  				case MemberType mt:  					if (mt.MemberName.EndsWith("Attribute"' StringComparison.Ordinal))  						mt.MemberName = mt.MemberName.Substring(0' mt.MemberName.Length - 9);  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The following statement contains a magic number: switch (attr.Type) {  				case SimpleType st:  					if (st.Identifier.EndsWith("Attribute"' StringComparison.Ordinal))  						st.Identifier = st.Identifier.Substring(0' st.Identifier.Length - 9);  					break;  				case MemberType mt:  					if (mt.MemberName.EndsWith("Attribute"' StringComparison.Ordinal))  						mt.MemberName = mt.MemberName.Substring(0' mt.MemberName.Length - 9);  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttributeType,The following statement contains a magic number: shortName = type.Name.Remove(type.Name.Length - 9);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttributeType,The following statement contains a magic number: type.Name.Length > 9 && type.Name.EndsWith("Attribute"' StringComparison.Ordinal)
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsValidFraction,The following statement contains a magic number: return Math.Abs(num) < den && new int[] { 2' 3' 5 }.Any(x => den % x == 0);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsValidFraction,The following statement contains a magic number: return Math.Abs(num) < den && new int[] { 2' 3' 5 }.Any(x => den % x == 0);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsValidFraction,The following statement contains a magic number: return Math.Abs(num) < den && new int[] { 2' 3' 5 }.Any(x => den % x == 0);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The following statement contains a magic number: bool useFraction = (str.Length - (str.StartsWith("-"' StringComparison.OrdinalIgnoreCase) ? 2 : 1) > 5);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertFloatingPointLiteral,The following statement contains a magic number: bool useFraction = (str.Length - (str.StartsWith("-"' StringComparison.OrdinalIgnoreCase) ? 2 : 1) > 5);
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,FractionApprox,The following statement contains a magic number: long['] m = new long[2' 2];
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,FractionApprox,The following statement contains a magic number: long['] m = new long[2' 2];
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AbstractAnnotatable,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs,AddAnnotation,The following statement contains a magic number: list = new AnnotationList(4);
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertVariable,The following statement contains a magic number: return astNode.ToString().TrimEnd(';'' '\r'' '\n'' (char)8232);
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,GetCallChainLengthLimited,The following statement contains a magic number: node.Target is InvocationExpression invocation && invocation.Target is MemberReferenceExpression mre && callChainLength < 4
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,InsertNewLineWhenInMethodCallChain,The following statement contains a magic number: callChainLength < 3
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,InsertNewLineWhenInMethodCallChain,The following statement contains a magic number: callChainLength == 3
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,IsKeyword,The following statement contains a magic number: identifier.Length > maxKeywordLength || identifier.Length < 2 || identifier[0] < 'a'
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitInvocationExpression,The following statement contains a magic number: GetCallChainLengthLimited(mre) >= 3
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitTupleExpression,The following statement contains a magic number: Debug.Assert(tupleExpression.Elements.Count >= 2);
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitTupleType,The following statement contains a magic number: Debug.Assert(tupleType.Elements.Count >= 2);
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					Length += 2 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 4 + content.Length;  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					Length += 3 + content.Length + textWriter.NewLine.Length;  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					Length += 5 + content.Length;  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					Length += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: column += 4;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: Length += 4;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: column += 4;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: Length += 4;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: column += tmp.Length + 2;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: Length += tmp.Length + 2;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,EscapeIdentifier,The following statement contains a magic number: sb.Append(identifier.Substring(i' 2));
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveType,The following statement contains a magic number: column += 2;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveType,The following statement contains a magic number: Length += 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsSubtypeOf,The following statement contains a magic number: subtypeCheckNestingDepth > 10
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversionTarget,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversionTarget,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,TypePair,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetHashCode,The following statement contains a magic number: return 1000000007 * FromType.GetHashCode() + 1000000009 * ToType.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,TypePair,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetHashCode,The following statement contains a magic number: return 1000000007 * FromType.GetHashCode() + 1000000009 * ToType.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpOperators.cs,IsComparisonOperator,The following statement contains a magic number: return m.IsOperator && m.Parameters.Count == 2  				&& (OperatorDeclaration.GetOperatorType(m.Name)?.IsComparisonOperator() ?? false);
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveAssignment,The following statement contains a magic number: opResult == null || opResult.Operands.Count != 2
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following statement contains a magic number: switch (MoreSpecificFormalParameter(pair.Item1' pair.Item2)) {  					case 1:  						c1IsBetter = true;  						break;  					case 2:  						c2IsBetter = true;  						break;  				}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameter,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CombineExitsTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CombineExitsTransform.cs,CombineExits,The following statement contains a magic number: trueInstruction is Block nestedBlock && nestedBlock.Instructions.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: !(pos + 3 < block.Instructions.Count && block.Instructions[pos].MatchStLoc(out var flagVar' out var inst) && inst is DynamicIsEventInstruction isEvent)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: !(flagVar.IsSingleDefinition && flagVar.LoadCount == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: int offset = 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: block.Instructions[pos + offset].MatchStLoc(out var valueVariable)  				&& pos + 4 < block.Instructions.Count && valueVariable.IsSingleDefinition && valueVariable.LoadCount == 2  				&& valueVariable.LoadInstructions.All(ld => ld.Parent is DynamicInstruction)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: block.Instructions[pos + offset].MatchStLoc(out var valueVariable)  				&& pos + 4 < block.Instructions.Count && valueVariable.IsSingleDefinition && valueVariable.LoadCount == 2  				&& valueVariable.LoadInstructions.All(ld => ld.Parent is DynamicInstruction)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,Run,The following statement contains a magic number: block.Instructions.RemoveRange(pos' 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicIsEventAssignmentTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicIsEventAssignmentTransform.cs,MatchIsEventAssignmentIfInstruction,The following statement contains a magic number: !(Block.Unwrap(falseInst) is DynamicInvokeMemberInstruction invokeMemberInst && invokeMemberInst.Arguments.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,IsLocalFunctionReference,The following statement contains a magic number: inst == null || inst.Arguments.Count != 2 || inst.Method.DeclaringType.Kind != TypeKind.Delegate
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LocalFunctionDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LocalFunctionDecompiler.cs,ParseLocalFunctionName,The following statement contains a magic number: functionName = match.Groups[2].Value;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UserDefinedLogicTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UserDefinedLogicTransform.cs,MatchBitwiseCall,The following statement contains a magic number: !(call != null && call.Method.IsOperator && call.Arguments.Count == 2 && !call.IsLifted)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,Run,The following statement contains a magic number: block.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,MakeDynamicInstruction,The following statement contains a magic number: switch (callsite.Kind) {  				case BinderMethodKind.BinaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicBinaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						leftArgumentInfo: callsite.ArgumentInfos[0]'  						left: targetInvokeCall.Arguments[2]'  						rightArgumentInfo: callsite.ArgumentInfos[1]'  						right: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.Convert:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					ILInstruction result = new DynamicConvertInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						type: callsite.ConvertTargetType'  						argument: targetInvokeCall.Arguments[2]  					);  					if (result.ResultType == StackType.Unknown) {  						// if references are missing' we need to coerce the primitive type to None.  						// Otherwise we will get loads of assertions.  						result = new Conv(result' PrimitiveType.None' ((DynamicConvertInstruction)result).IsChecked' Sign.None);  					}  					return result;  				case BinderMethodKind.GetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.GetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicGetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.Invoke:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.InvokeConstructor:  					var arguments = targetInvokeCall.Arguments.Skip(2).ToArray();  					// Extract type information from targetInvokeCall:  					// Must either be an inlined type or  					// a reference to a variable that is initialized with a type.  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(arguments[0]' out var type)) {  						if (!(arguments[0].MatchLdLoc(out var temp) && temp.IsSingleDefinition && temp.StoreInstructions.FirstOrDefault() is StLoc initStore))  							return null;  						if (!TransformExpressionTrees.MatchGetTypeFromHandle(initStore.Value' out type))  							return null;  					}  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeConstructorInstruction(  						binderFlags: callsite.Flags'  						type: type ?? SpecialType.UnknownType'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: arguments  					);  				case BinderMethodKind.InvokeMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicInvokeMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						typeArguments: callsite.TypeArguments'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.IsEvent:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicIsEventInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						argument: targetInvokeCall.Arguments[2]  					);  				case BinderMethodKind.SetIndex:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetIndexInstruction(  						binderFlags: callsite.Flags'  						context: callsite.Context'  						argumentInfo: callsite.ArgumentInfos'  						arguments: targetInvokeCall.Arguments.Skip(2).ToArray()  					);  				case BinderMethodKind.SetMember:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicSetMemberInstruction(  						binderFlags: callsite.Flags'  						name: callsite.MemberName'  						context: callsite.Context'  						targetArgumentInfo: callsite.ArgumentInfos[0]'  						target: targetInvokeCall.Arguments[2]'  						valueArgumentInfo: callsite.ArgumentInfos[1]'  						value: targetInvokeCall.Arguments[3]  					);  				case BinderMethodKind.UnaryOperation:  					deadArguments.AddRange(targetInvokeCall.Arguments.Take(2));  					return new DynamicUnaryOperatorInstruction(  						binderFlags: callsite.Flags'  						operation: callsite.Operation'  						context: callsite.Context'  						operandArgumentInfo: callsite.ArgumentInfos[0]'  						operand: targetInvokeCall.Arguments[2]  					);  				default:  					throw new ArgumentOutOfRangeException($"Value {callsite.Kind} is not supported!");  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: callSiteInitBlock.IncomingEdgeCount != 1 || instCount < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: !callSiteInitBlock.Instructions[instCount - 2].MatchStsFld(out var field' out var value) || !field.Equals(callSiteCacheField)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ScanCallSiteInitBlock,The following statement contains a magic number: switch (binderCall.Method.Name) {  				case "IsEvent":  					callSiteInfo.Kind = BinderMethodKind.IsEvent;  					// In the case of Binder.IsEvent all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' member name' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out int binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!binderCall.Arguments[1].MatchLdStr(out string name))  						return false;  					callSiteInfo.MemberName = name;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out var contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "Convert":  					callSiteInfo.Kind = BinderMethodKind.Convert;  					// In the case of Binder.Convert all arguments should already be properly inlined' as there is no array initializer:  					// Scan arguments: binder flags' target type' context type  					if (binderCall.Arguments.Count != 3)  						return false;  					if (!binderCall.Arguments[0].MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[1]' out var targetType))  						return false;  					callSiteInfo.ConvertTargetType = targetType;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(binderCall.Arguments[2]' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					return true;  				case "InvokeMember":  					callSiteInfo.Kind = BinderMethodKind.InvokeMember;  					if (binderCall.Arguments.Count != 5)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out var variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: type arguments  					// The value must be either ldnull (no type arguments) or an array initializer pattern.  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(out var variableOrTemporary' out value))  						return false;  					int numberOfTypeArguments = 0;  					if (!value.MatchLdNull()) {  						if (value is NewArr typeArgsNewArr && typeArgsNewArr.Type.IsKnownType(KnownTypeCode.Type) && typeArgsNewArr.Indices.Count == 1 && typeArgsNewArr.Indices[0].MatchLdcI4(out numberOfTypeArguments)) {  							if (!TransformArrayInitializers.HandleSimpleArrayInitializer(context.Function' callSiteInitBlock' 3' variableOrTemporary' typeArgsNewArr.Type' new[] { numberOfTypeArguments }' out var typeArguments' out _))  								return false;  							int i = 0;  							callSiteInfo.TypeArguments = new IType[numberOfTypeArguments];  							foreach (var (_' typeArg) in typeArguments) {  								if (!TransformExpressionTrees.MatchGetTypeFromHandle(typeArg' out var type))  									return false;  								callSiteInfo.TypeArguments[i] = type;  								i++;  							}  						} else {  							return false;  						}  					}  					int typeArgumentsOffset = numberOfTypeArguments;  					// Special case for csc array initializers:  					if (variableOrTemporary != variable) {  						// store temporary from array initializer in variable  						if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  							return false;  						if (!value.MatchLdLoc(variableOrTemporary))  							return false;  						typeArgumentsOffset++;  					}  					// Fourth argument: context type  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fifth argument: call parameter info  					if (!binderCall.Arguments[4].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[4 + typeArgumentsOffset].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 5 + typeArgumentsOffset' variable))  						return false;  					return true;  				case "GetMember":  				case "SetMember":  					callSiteInfo.Kind = binderCall.Method.Name == "GetMember" ? BinderMethodKind.GetMember : BinderMethodKind.SetMember;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: method name  					// The value must be a single ldstr instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdStr(out name))  						return false;  					callSiteInfo.MemberName = name;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				case "GetIndex":  				case "SetIndex":  				case "InvokeConstructor":  				case "Invoke":  					switch (binderCall.Method.Name) {  						case "GetIndex":  							callSiteInfo.Kind = BinderMethodKind.GetIndex;  							break;  						case "SetIndex":  							callSiteInfo.Kind = BinderMethodKind.SetIndex;  							break;  						case "InvokeConstructor":  							callSiteInfo.Kind = BinderMethodKind.InvokeConstructor;  							break;  						case "Invoke":  							callSiteInfo.Kind = BinderMethodKind.Invoke;  							break;  						default:  							throw new ArgumentOutOfRangeException();  					}  					if (binderCall.Arguments.Count != 3)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: context type  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Third argument: call parameter info  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 3' variable))  						return false;  					return true;  				case "UnaryOperation":  				case "BinaryOperation":  					callSiteInfo.Kind = binderCall.Method.Name == "BinaryOperation" ? BinderMethodKind.BinaryOperation : BinderMethodKind.UnaryOperation;  					if (binderCall.Arguments.Count != 4)  						return false;  					// First argument: binder flags  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[0].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[0].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out binderFlagsInteger))  						return false;  					callSiteInfo.Flags = (CSharpBinderFlags)binderFlagsInteger;  					// Second argument: operation  					// The value must be a single ldc.i4 instruction.  					if (!binderCall.Arguments[1].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[1].MatchStLoc(variable' out value))  						return false;  					if (!value.MatchLdcI4(out int operation))  						return false;  					callSiteInfo.Operation = (ExpressionType)operation;  					// Third argument: context type  					if (!binderCall.Arguments[2].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[2].MatchStLoc(variable' out value))  						return false;  					if (!TransformExpressionTrees.MatchGetTypeFromHandle(value' out contextType))  						return false;  					callSiteInfo.Context = contextType;  					// Fourth argument: call parameter info  					if (!binderCall.Arguments[3].MatchLdLoc(out variable))  						return false;  					if (!callSiteInitBlock.Instructions[3].MatchStLoc(variable' out value))  						return false;  					if (!ExtractArgumentInfo(value' ref callSiteInfo' 4' variable))  						return false;  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DynamicCallSiteTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DynamicCallSiteTransform.cs,ExtractArgumentInfo,The following statement contains a magic number: !(createCall.Method.Name == "Create" && createCall.Method.DeclaringType.FullName == "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo" && createCall.Arguments.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchWhileLoop,The following statement contains a magic number: loopBody.Instructions.Count != 2 || !loop.EntryPoint.Instructions.Last().MatchLeave(loop)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,CollectConditions,The following statement contains a magic number: int i = block.Instructions.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The following statement contains a magic number: block.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The following statement contains a magic number: nestedConditionBlock.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The following statement contains a magic number: block.Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,The following statement contains a magic number: loop.EntryPoint.IncomingEdgeCount != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,The following statement contains a magic number: incrementBlock.Instructions.Count <= 1 || loop.Blocks.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,The following statement contains a magic number: switch (block.Instructions.Count) {  				case 1:  					// leave IL_0000 (call Test(ldloc this' ldloc A_1))  					if (!block.Instructions[0].MatchLeave(blockContainer' out returnValue))  						return;  					call = returnValue as Call;  					break;  				case 2:  					// call Test(ldloc this' ldloc A_1)  					// leave IL_0000(nop)  					call = block.Instructions[0] as Call;  					if (!block.Instructions[1].MatchLeave(blockContainer' out returnValue))  						return;  					if (!returnValue.MatchNop())  						return;  					break;  				default:  					return;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,InlineReturnTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\InlineReturnTransform.cs,CanModifyInstructions,The following statement contains a magic number: store.ChildIndex + 2 != storeBlock.Instructions.Count
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: newSwitch.AddILRange(block.Instructions[i - 2]);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: block.Instructions.RemoveRange(i - 2' 3);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: block.Instructions.RemoveRange(i - 2' 3);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: i -= 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: i < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: !instructions[i - 2].MatchStLoc(out var tmp' out var ldloca) ||  				!instructions[i - 1].MatchStLoc(out var switchVariable' out var getValueOrDefault) ||  				!instructions[i].MatchIfInstruction(out var condition' out var trueInst)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: !tmp.IsSingleDefinition || tmp.LoadCount != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The following statement contains a magic number: switch (switchBlock.Instructions.Count) {  				case 2: {  					// this is the normal case described by the pattern above  					if (!switchBlock.Instructions[0].MatchStLoc(out var switchVar' out var getValueOrDefault))  						return false;  					if (!switchVar.IsSingleDefinition || switchVar.LoadCount != 1)  						return false;  					if (!(NullableLiftingTransform.MatchGetValueOrDefault(getValueOrDefault' out ILInstruction target2) && target2.Match(target).Success))  						return false;  					if (!(switchBlock.Instructions[1] is SwitchInstruction si))  						return false;  					switchInst = si;  					break;  				}  				case 1: {  					// this is the special case where `call GetValueOrDefault(ldloca tmp)` is inlined into the switch.  					if (!(switchBlock.Instructions[0] is SwitchInstruction si))  						return false;  					if (!(NullableLiftingTransform.MatchGetValueOrDefault(si.Value' out ILInstruction target2) && target2.Match(target).Success))  						return false;  					switchInst = si;  					break;  				}  				default: {  					return false;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,Run,The following statement contains a magic number: hashtableInitializers.Count > 0 && omittedBlocks.Count == hashtableInitializers.Count && body.EntryPoint.Instructions.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ScanHashtableInitializerBlocks,The following statement contains a magic number: entryPoint.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ScanHashtableInitializerBlocks,The following statement contains a magic number: tableInitBlock.IncomingEdgeCount != 1 || tableInitBlock.Instructions.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: i >= 2 && switchValue.MatchLdLoc(out var otherSwitchValueVar) && otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 1  					&& instructions[i - 2].MatchStLoc(otherSwitchValueVar' out var newSwitchValue)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: i >= 2 && switchValue.MatchLdLoc(out var otherSwitchValueVar) && otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 1  					&& instructions[i - 2].MatchStLoc(otherSwitchValueVar' out var newSwitchValue)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: values.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: inst.AddILRange(instructions[i - 2]);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: instructions[i - 2].ReplaceWith(inst);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: instructions.RemoveRange(i - 1' 3);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: i -= 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The following statement contains a magic number: !(temp.Kind == VariableKind.StackSlot && temp.LoadCount == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The following statement contains a magic number: isInternedBlock.IncomingEdgeCount != 1 || isInternedBlock.Instructions.Count != 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCSharp1CascadingIfStatements,The following statement contains a magic number: currentCaseBlock.Instructions.Count != conditionOffset + 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchCaseBlock,The following statement contains a magic number: currentBlock.IncomingEdgeCount != 1 || currentBlock.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: nextBlock.Instructions.Count != 2 || !nextBlock.Instructions[0].MatchIfInstruction(out condition' out var tryGetValueBlockJump)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: dictInitBlock.IncomingEdgeCount != 1 || dictInitBlock.Instructions.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: tryGetValueBlock.IncomingEdgeCount != 2 || tryGetValueBlock.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: tryGetValueBlock.IncomingEdgeCount != 2 || tryGetValueBlock.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: !c.Arguments[1].MatchLdLoc(switchValueVar) || !c.Arguments[2].MatchLdLoca(out var switchIndexVar)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: switch (switchBlock.Instructions[0]) {  				case SwitchInstruction switchInst:  					if (switchBlock.Instructions.Count != 1)  						return false;  					if (!switchInst.Value.MatchLdLoc(switchIndexVar))  						return false;  					sections.AddRange(switchInst.Sections);  					break;  				case IfInstruction ifInst:  					if (switchBlock.Instructions.Count != 2)  						return false;  					if (!ifInst.Condition.MatchCompEquals(out left' out right))  						return false;  					if (!left.MatchLdLoc(switchIndexVar))  						return false;  					if (!right.MatchLdcI4(0))  						return false;  					sections.Add(new SwitchSection() { Body = ifInst.TrueInst' Labels = new LongSet(0) }.WithILRange(ifInst));  					sections.Add(new SwitchSection() { Body = switchBlock.Instructions[1]' Labels = new LongSet(0).Invert() }.WithILRange(switchBlock.Instructions[1]));  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: switchValueVar.LoadCount > 2 || switchValue == null
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: !newObj.Arguments[1].MatchLdcF4(0.5f)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: newObj.Arguments.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: return block.Instructions[i + 3].MatchBranch(out blockAfterInit);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: isHashtablePattern && block.Instructions[i + 2] is IfInstruction
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: return block.Instructions[i + 2].MatchBranch(out blockAfterInit);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: !(inst is CallInstruction c && c.Method.Name == "Add" && c.Arguments.Count == 3)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: return (c.Arguments[2].MatchLdcI4(out index) || (c.Arguments[2].MatchBox(out var arg' out _) && arg.MatchLdcI4(out index)));
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: return (c.Arguments[2].MatchLdcI4(out index) || (c.Arguments[2].MatchBox(out var arg' out _) && arg.MatchLdcI4(out index)));
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,IsStringToIntDictionary,The following statement contains a magic number: dictionaryType.TypeArguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: block.Instructions.Count != i + 4
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: !block.Instructions[i + 2].MatchIfInstruction(out var condition' out var nullCaseBlockBranch)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: !block.Instructions[i + 3].MatchBranch(out var getItemBlock) || !(nullCaseBlockBranch.MatchBranch(out var nullCaseBlock) || nullCaseBlockBranch is Leave)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: getItemBlock.IncomingEdgeCount != 1 || getItemBlock.Instructions.Count != 4
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: !getItemBlock.Instructions[2].MatchIfInstruction(out condition' out var defaultBlockBranch)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: !getItemBlock.Instructions[3].MatchBranch(out var switchBlock) || !(defaultBlockBranch.MatchBranch(out var defaultBlock) || defaultBlockBranch is Leave)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: !(getItemCall.Arguments.Count == 2 && MatchDictionaryFieldLoad(getItemCall.Arguments[0]' IsNonGenericHashtable' out var dictField' out _) && getItemCall.Arguments[1].MatchLdLoc(switchVariable))
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: block.Instructions.RemoveRange(i + 1' 3);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FindHashtableInitBlock,The following statement contains a magic number: entryPoint.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,FindHashtableInitBlock,The following statement contains a magic number: tableInitBlock.IncomingEdgeCount != 1 || tableInitBlock.Instructions.Count < 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynCaseBlockHead,The following statement contains a magic number: target.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynEmptyStringCaseBlockHead,The following statement contains a magic number: target.Instructions.Count != 2 || target.IncomingEdgeCount != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynEmptyStringCaseBlockHead,The following statement contains a magic number: lengthCheckBlock.Instructions.Count != 2 || lengthCheckBlock.IncomingEdgeCount != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchStringEqualityComparison,The following statement contains a magic number: condition is Call c && c.Method.IsOperator && c.Method.Name == "op_Equality"  				&& c.Method.DeclaringType.IsKnownType(KnownTypeCode.String) && c.Arguments.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MightBeExpressionTree,The following statement contains a magic number: !(inst is CallInstruction call  				&& call.Method.FullNameIs("System.Linq.Expressions.Expression"' "Lambda")  				&& call.Arguments.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,The following statement contains a magic number: !(init is CallInstruction initCall && initCall.Arguments.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The following statement contains a magic number: instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertArrayIndex,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBind,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: invocation.Arguments.Count != 2 || !MatchArgumentList(invocation.Arguments[1]' out arguments)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: method.FullName == "System.Reflection.MethodInfo.CreateDelegate" && method.Parameters.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCast,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: switch (kind) {  					case ComparisonKind.Equality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					case ComparisonKind.Inequality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					default:  						return (null' SpecialType.UnknownType);  				}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: switch (kind) {  					case ComparisonKind.Equality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					case ComparisonKind.Inequality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					default:  						return (null' SpecialType.UnknownType);  				}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCondition,The following statement contains a magic number: invocation.Arguments.Count != 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCondition,The following statement contains a magic number: var (falseInst' falseInstType) = ConvertInstruction(invocation.Arguments[2]);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertElementInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertField,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInvoke,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertMemberInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewArrayBounds,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewArrayInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					IMethod method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					IMethod method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNotOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					return (argumentType.IsKnownType(KnownTypeCode.Boolean) ? Comp.LogicNot(argument) : (ILInstruction)new BitNot(argument)' argumentType);  				case 2:  					if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { argument }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertTypeAs,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertTypeIs,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertUnaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					ILInstruction left;  					switch (argument.ResultType) {  						case StackType.I4:  							left = new LdcI4(0);  							break;  						case StackType.I8:  							left = new LdcI8(0);  							break;  						case StackType.I:  							left = new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None);  							break;  						case StackType.F4:  							left = new LdcF4(0);  							break;  						case StackType.F8:  							left = new LdcF8(0);  							break;  						default:  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' argument' isChecked == true' argumentType.GetSign())' argumentType);  				case 2:  					if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { argument }  					}' method.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchConstantCall,The following statement contains a magic number: call.Arguments.Count == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetMethodFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetConstructorFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetFieldFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: entryPoint.Instructions.Count < 2 || entryPoint.Instructions.Count > 3 || entryPoint.IncomingEdgeCount != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: entryPoint.Instructions.Count < 2 || entryPoint.Instructions.Count > 3 || entryPoint.IncomingEdgeCount != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int leaveIndex = entryPoint.Instructions.Count == 2 ? 1 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int leaveIndex = entryPoint.Instructions.Count == 2 ? 1 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int checkIndex = entryPoint.Instructions.Count == 2 ? 0 : 1;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int castIndex = entryPoint.Instructions.Count == 3 ? 0 : -1;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeCheck,The following statement contains a magic number: numObjVarLoadsInCheck = 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = call.GetParameter(i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = call.GetParameter(i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = call.GetParameter(i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = call.GetParameter(i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The following statement contains a magic number: name = name.Substring(2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The following statement contains a magic number: name.Length > 2 && name.StartsWith("m_"' StringComparison.Ordinal)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,The following statement contains a magic number: proposedName = baseName.Substring(0' baseName.Length - 4);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,The following statement contains a magic number: baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The following statement contains a magic number: proposedName = baseName.Substring(0' baseName.Length - 4);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The following statement contains a magic number: baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The following statement contains a magic number: instructions.RemoveAt(2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The following statement contains a magic number: instructions.Count == 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The following statement contains a magic number: !entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The following statement contains a magic number: entryPoint.Instructions.Count == 3
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchFalseBlock,The following statement contains a magic number: falseBlock.IncomingEdgeCount != 1 || falseBlock.Instructions.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchExitBlock,The following statement contains a magic number: exitBlock.IncomingEdgeCount != 2 || exitBlock.Instructions.Count != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The following statement contains a magic number: i < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The following statement contains a magic number: !(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 2] is StLoc objectStore) ||  				!MatchCall(block.Instructions[i - 1] as Call' "Enter"' objectStore.Variable)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The following statement contains a magic number: objectStore.Variable.LoadCount > 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockMCS,The following statement contains a magic number: block.Instructions.RemoveAt(i - 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: i < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: !(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 2] is StLoc objectStore) ||  				!objectStore.Value.MatchLdLoc(out var tempVar) || !MatchCall(block.Instructions[i - 1] as Call' "Enter"' tempVar)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: block.Instructions.RemoveAt(i - 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: i < 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: !(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 1] is StLoc flagStore) || !(block.Instructions[i - 2] is StLoc objectStore)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: objectStore.Variable.LoadCount > 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: block.Instructions.RemoveAt(i - 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The following statement contains a magic number: entryPoint.Instructions.Count != 2 || entryPoint.IncomingEdgeCount != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The following statement contains a magic number: call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The following statement contains a magic number: variables.Length == 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,RunStatements,The following statement contains a magic number: pos != block.Instructions.Count - 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,The following statement contains a magic number: !(call.Method.IsOperator && call.Arguments.Count == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformRefTypes,The following statement contains a magic number: trueInst is Block trueBlock && trueBlock.Instructions.Count == 2  				&& trueBlock.Instructions[0].MatchStLoc(out var temporary' out fallbackValue)  				&& temporary.IsSingleDefinition && temporary.LoadCount == 1  				&& trueBlock.Instructions[1].MatchStLoc(stloc.Variable' out var useOfTemporary)  				&& useOfTemporary.MatchLdLoc(temporary)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformThrowExpressionValueTypes,The following statement contains a magic number: pos + 2 >= block.Instructions.Count
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformThrowExpressionValueTypes,The following statement contains a magic number: !(v.StoreCount == 1 && v.LoadCount == 0 && v.AddressCount == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformThrowExpressionValueTypes,The following statement contains a magic number: var result = ILInlining.FindLoadInNext(block.Instructions[pos + 2]' v' nullCoalescingWithThrow' InliningOptions.None);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformThrowExpressionValueTypes,The following statement contains a magic number: block.Instructions.RemoveRange(pos' 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The following statement contains a magic number: switch (instruction) {  					case CallInstruction call:  						if (!(call is CallVirt || call is Call)) goto default;  						method = call.Method;  						if (resolveContext != null && !IsMethodApplicable(method' call.Arguments' rootType' resolveContext' settings)) goto default;  						instruction = call.Arguments[0];  						if (method.IsAccessor) {  							var property = method.AccessorOwner as IProperty;  							if (!CanBeUsedInInitializer(property' resolveContext' kind' path)) goto default;  							var isGetter = method.Equals(property?.Getter);  							var indices = call.Arguments.Skip(1).Take(call.Arguments.Count - (isGetter ? 1 : 2)).ToArray();  							if (indices.Length > 0 && !settings.DictionaryInitializers) goto default;  							if (possibleIndexVariables != null) {  								// Mark all index variables as used  								foreach (var index in indices.OfType<IInstructionWithVariableOperand>()) {  									if (possibleIndexVariables.TryGetValue(index.Variable' out var info))  										possibleIndexVariables[index.Variable] = (-1' info.Value);  								}  							}  							path.Insert(0' new AccessPathElement(call.OpCode' method.AccessorOwner' indices));  						} else {  							path.Insert(0' new AccessPathElement(call.OpCode' method));  						}  						if (values == null) {  							if (method.IsAccessor) {  								kind = AccessPathKind.Setter;  								values = new List<ILInstruction> { call.Arguments.Last() };  							} else {  								kind = AccessPathKind.Adder;  								values = new List<ILInstruction>(call.Arguments.Skip(1));  								if (values.Count == 0)  									goto default;  							}  						}  						break;  					case LdObj ldobj: {  						if (ldobj.Target is LdFlda ldflda && (kind != AccessPathKind.Setter || !ldflda.Field.IsReadOnly)) {  							path.Insert(0' new AccessPathElement(ldobj.OpCode' ldflda.Field));  							instruction = ldflda.Target;  							break;  						}  						goto default;  					}  					case StObj stobj: {  						if (stobj.Target is LdFlda ldflda) {  							path.Insert(0' new AccessPathElement(stobj.OpCode' ldflda.Field));  							instruction = ldflda.Target;  							if (values == null) {  								values = new List<ILInstruction>(new[] { stobj.Value });  								kind = AccessPathKind.Setter;  							}  							break;  						}  						goto default;  					}  					case LdLoc ldloc:  						target = ldloc.Variable;  						instruction = null;  						break;  					case LdLoca ldloca:  						target = ldloca.Variable;  						instruction = null;  						break;  					case LdFlda ldflda:  						path.Insert(0' new AccessPathElement(ldflda.OpCode' ldflda.Field));  						instruction = ldflda.Target;  						break;  					default:  						kind = AccessPathKind.Invalid;  						instruction = null;  						break;  				}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * Member.GetHashCode();
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDelegateCtorLdVirtFtnToLdVirtDelegate,The following statement contains a magic number: inst.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformSpanTCtorContainingStackAlloc,The following statement contains a magic number: newObj.Arguments.Count != 2 || type.TypeArguments.Count != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following statement contains a magic number: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  				case BinaryNumericOperator.BitAnd:  					if (inst.Left.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean)  						&& inst.Right.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean))  					{  						if (new NullableLiftingTransform(context).Run(inst)) {  							// e.g. "(a.GetValueOrDefault() == b.GetValueOrDefault()) & (a.HasValue & b.HasValue)"  						}  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following statement contains a magic number: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  				case BinaryNumericOperator.BitAnd:  					if (inst.Left.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean)  						&& inst.Right.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean))  					{  						if (new NullableLiftingTransform(context).Run(inst)) {  							// e.g. "(a.GetValueOrDefault() == b.GetValueOrDefault()) & (a.HasValue & b.HasValue)"  						}  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,IsDelegateConstruction,The following statement contains a magic number: inst == null || inst.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The following statement contains a magic number: pos >= body.Instructions.Count - 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchSpanTCtorWithPointerAndSize,The following statement contains a magic number: newObj.Arguments.Count != 2 || type.TypeArguments.Count != 1
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformMultiDim,The following statement contains a magic number: pos >= body.Instructions.Count - 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformStackAllocInitializer,The following statement contains a magic number: pos >= body.Instructions.Count - 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ShouldTransformToInitializer,The following statement contains a magic number: elementCount >= length / 3 - 5
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ShouldTransformToInitializer,The following statement contains a magic number: elementCount >= length / 3 - 5
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The following statement contains a magic number: int inc = hasTemporaryCopy ? 3 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The following statement contains a magic number: int inc = hasTemporaryCopy ? 3 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchInitializeArrayCall,The following statement contains a magic number: !(instruction is Call call) || call.Arguments.Count != 2
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,The following statement contains a magic number: !(inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 2)
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,The following statement contains a magic number: nextPos = pos + 2;
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: attrValue.FixedArguments.Length != 5
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: attrValue.FixedArguments[2].Value is uint hi  					&& attrValue.FixedArguments[3].Value is uint mid  					&& attrValue.FixedArguments[4].Value is uint lo
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: attrValue.FixedArguments[2].Value is uint hi  					&& attrValue.FixedArguments[3].Value is uint mid  					&& attrValue.FixedArguments[4].Value is uint lo
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DecimalConstantHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DecimalConstantHelper.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: attrValue.FixedArguments[2].Value is uint hi  					&& attrValue.FixedArguments[3].Value is uint mid  					&& attrValue.FixedArguments[4].Value is uint lo
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeParameter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeParameter.cs,LoadNullabilityConstraint,The following statement contains a magic number: attrVal.FixedArguments[0].Value is byte b && b <= 2
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,ModifiedType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ModifiedType.cs,GetHashCode,The following statement contains a magic number: return (int)kind ^ (elementType.GetHashCode() * 1344795899) ^ (modifier.GetHashCode() * 901375117);
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,ModifiedType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ModifiedType.cs,GetHashCode,The following statement contains a magic number: return (int)kind ^ (elementType.GetHashCode() * 1344795899) ^ (modifier.GetHashCode() * 901375117);
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,GetClassTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetClassTypeReference.cs,GetHashCodeForInterning,The following statement contains a magic number: return 33 * module.GetHashCode() + fullTypeName.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMember,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMember,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The following statement contains a magic number: index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,UnknownType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,UnknownType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select": {  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameter.Name) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							ParameterDeclaration parameter1' parameter2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameter2' out elementSelector)  							    && parameter1.Name == parameter2.Name)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter1' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							ParameterDeclaration parameter;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameter.Name).CopyAnnotationsFrom(parameter)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						ParameterDeclaration parameter;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameter' out collectionSelector))  							return null;  						if (IsNullConditional(collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameter.Name) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(p1' mre.Target.Detach()));  								query.Clauses.Add(MakeFromClause(p2' collectionSelector.Detach()));  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameter.Name) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						if (!IsComplexQuery(mre))  							return null;  						ParameterDeclaration parameter;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameter' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameter.Name)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameter' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(parameter' mre.Target.Detach()));  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						if (IsNullConditional(source2))  							return null;  						ParameterDeclaration element1' element2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out element1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out element2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == element1.Name && (p2.Name == element2.Name || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(MakeFromClause(element1' source1.Detach()));  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = element2.Name;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The following statement contains a magic number: indexVariable.StoreCount != 2 || indexVariable.LoadCount != 3 || indexVariable.AddressCount != 0
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The following statement contains a magic number: indexVariable.StoreCount != 2 || indexVariable.LoadCount != 3 || indexVariable.AddressCount != 0
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The following statement contains a magic number: itemVariable == null || !itemVariable.IsSingleDefinition  				|| (itemVariable.Kind != IL.VariableKind.Local && itemVariable.Kind != IL.VariableKind.StackSlot)  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0)
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The following statement contains a magic number: itemVariable == null || !itemVariable.IsSingleDefinition  				|| (itemVariable.Kind != IL.VariableKind.Local && itemVariable.Kind != IL.VariableKind.StackSlot)  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0)
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: result.CostInUncheckedContext += new Cost(10000' 0);
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: bop != null && arguments.Length == 2
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,CheckArgumentsForStringConcat,The following statement contains a magic number: arguments.Length < 2
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000007 * target.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000033 * identifier.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000087 * typeArguments.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000021 * (int)lookupMode;
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000021 * identifier.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000033 * typeArguments.GetHashCode();
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode += 1000000087 * (int)lookupMode;
Magic Number,ICSharpCode.Decompiler,SRMExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetNullableContext,The following statement contains a magic number: value.FixedArguments.Length == 1 && value.FixedArguments[0].Value is byte b && b <= 2
Magic Number,ICSharpCode.Decompiler,FieldValueSizeDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetPrimitiveType,The following statement contains a magic number: switch (typeCode) {  					case PrimitiveTypeCode.Boolean:  					case PrimitiveTypeCode.Byte:  					case PrimitiveTypeCode.SByte:  						return 1;  					case PrimitiveTypeCode.Char:  					case PrimitiveTypeCode.Int16:  					case PrimitiveTypeCode.UInt16:  						return 2;  					case PrimitiveTypeCode.Int32:  					case PrimitiveTypeCode.UInt32:  					case PrimitiveTypeCode.Single:  						return 4;  					case PrimitiveTypeCode.Int64:  					case PrimitiveTypeCode.UInt64:  					case PrimitiveTypeCode.Double:  						return 8;  					case PrimitiveTypeCode.IntPtr:  					case PrimitiveTypeCode.UIntPtr:  						return pointerSize;  					default:  						return 0;  				}
Magic Number,ICSharpCode.Decompiler,FieldValueSizeDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetPrimitiveType,The following statement contains a magic number: switch (typeCode) {  					case PrimitiveTypeCode.Boolean:  					case PrimitiveTypeCode.Byte:  					case PrimitiveTypeCode.SByte:  						return 1;  					case PrimitiveTypeCode.Char:  					case PrimitiveTypeCode.Int16:  					case PrimitiveTypeCode.UInt16:  						return 2;  					case PrimitiveTypeCode.Int32:  					case PrimitiveTypeCode.UInt32:  					case PrimitiveTypeCode.Single:  						return 4;  					case PrimitiveTypeCode.Int64:  					case PrimitiveTypeCode.UInt64:  					case PrimitiveTypeCode.Double:  						return 8;  					case PrimitiveTypeCode.IntPtr:  					case PrimitiveTypeCode.UIntPtr:  						return pointerSize;  					default:  						return 0;  				}
Magic Number,ICSharpCode.Decompiler,FieldValueSizeDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\SRMExtensions.cs,GetPrimitiveType,The following statement contains a magic number: switch (typeCode) {  					case PrimitiveTypeCode.Boolean:  					case PrimitiveTypeCode.Byte:  					case PrimitiveTypeCode.SByte:  						return 1;  					case PrimitiveTypeCode.Char:  					case PrimitiveTypeCode.Int16:  					case PrimitiveTypeCode.UInt16:  						return 2;  					case PrimitiveTypeCode.Int32:  					case PrimitiveTypeCode.UInt32:  					case PrimitiveTypeCode.Single:  						return 4;  					case PrimitiveTypeCode.Int64:  					case PrimitiveTypeCode.UInt64:  					case PrimitiveTypeCode.Double:  						return 8;  					case PrimitiveTypeCode.IntPtr:  					case PrimitiveTypeCode.UIntPtr:  						return pointerSize;  					default:  						return 0;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,SkipOperand,The following statement contains a magic number: switch (opCode.GetOperandType()) {  				// 64-bit  				case OperandType.I8:  				case OperandType.R:  					blob.Offset += 8;  					break;  				// 32-bit  				case OperandType.BrTarget:  				case OperandType.Field:  				case OperandType.Method:  				case OperandType.I:  				case OperandType.Sig:  				case OperandType.String:  				case OperandType.Tok:  				case OperandType.Type:  				case OperandType.ShortR:  					blob.Offset += 4;  					break;  				// (n + 1) * 32-bit  				case OperandType.Switch:  					uint n = blob.ReadUInt32();  					blob.Offset += (int)(n * 4);  					break;  				// 16-bit  				case OperandType.Variable:  					blob.Offset += 2;  					break;  				// 8-bit  				case OperandType.ShortVariable:  				case OperandType.ShortBrTarget:  				case OperandType.ShortI:  					blob.Offset++;  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,SkipOperand,The following statement contains a magic number: switch (opCode.GetOperandType()) {  				// 64-bit  				case OperandType.I8:  				case OperandType.R:  					blob.Offset += 8;  					break;  				// 32-bit  				case OperandType.BrTarget:  				case OperandType.Field:  				case OperandType.Method:  				case OperandType.I:  				case OperandType.Sig:  				case OperandType.String:  				case OperandType.Tok:  				case OperandType.Type:  				case OperandType.ShortR:  					blob.Offset += 4;  					break;  				// (n + 1) * 32-bit  				case OperandType.Switch:  					uint n = blob.ReadUInt32();  					blob.Offset += (int)(n * 4);  					break;  				// 16-bit  				case OperandType.Variable:  					blob.Offset += 2;  					break;  				// 8-bit  				case OperandType.ShortVariable:  				case OperandType.ShortBrTarget:  				case OperandType.ShortI:  					blob.Offset++;  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,SkipOperand,The following statement contains a magic number: switch (opCode.GetOperandType()) {  				// 64-bit  				case OperandType.I8:  				case OperandType.R:  					blob.Offset += 8;  					break;  				// 32-bit  				case OperandType.BrTarget:  				case OperandType.Field:  				case OperandType.Method:  				case OperandType.I:  				case OperandType.Sig:  				case OperandType.String:  				case OperandType.Tok:  				case OperandType.Type:  				case OperandType.ShortR:  					blob.Offset += 4;  					break;  				// (n + 1) * 32-bit  				case OperandType.Switch:  					uint n = blob.ReadUInt32();  					blob.Offset += (int)(n * 4);  					break;  				// 16-bit  				case OperandType.Variable:  					blob.Offset += 2;  					break;  				// 8-bit  				case OperandType.ShortVariable:  				case OperandType.ShortBrTarget:  				case OperandType.ShortI:  					blob.Offset++;  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,SkipOperand,The following statement contains a magic number: switch (opCode.GetOperandType()) {  				// 64-bit  				case OperandType.I8:  				case OperandType.R:  					blob.Offset += 8;  					break;  				// 32-bit  				case OperandType.BrTarget:  				case OperandType.Field:  				case OperandType.Method:  				case OperandType.I:  				case OperandType.Sig:  				case OperandType.String:  				case OperandType.Tok:  				case OperandType.Type:  				case OperandType.ShortR:  					blob.Offset += 4;  					break;  				// (n + 1) * 32-bit  				case OperandType.Switch:  					uint n = blob.ReadUInt32();  					blob.Offset += (int)(n * 4);  					break;  				// 16-bit  				case OperandType.Variable:  					blob.Offset += 2;  					break;  				// 8-bit  				case OperandType.ShortVariable:  				case OperandType.ShortBrTarget:  				case OperandType.ShortI:  					blob.Offset++;  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,DecodeBranchTarget,The following statement contains a magic number: return (opCode.GetBranchOperandSize() == 4 ? blob.ReadInt32() : blob.ReadSByte()) + blob.Offset;
Magic Number,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,DecodeSwitchTargets,The following statement contains a magic number: int offset = blob.Offset + 4 * targets.Length;
Magic Number,ICSharpCode.Decompiler.Disassembler,OpCodeInfo,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\OpCodeInfo.cs,GetHashCode,The following statement contains a magic number: return unchecked(982451629 * Code.GetHashCode() + 982451653 * Name.GetHashCode());
Magic Number,ICSharpCode.Decompiler.Disassembler,OpCodeInfo,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\OpCodeInfo.cs,GetHashCode,The following statement contains a magic number: return unchecked(982451629 * Code.GetHashCode() + 982451653 * Name.GetHashCode());
Magic Number,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteOpCode,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Ldarg_0:  				case ILOpCode.Ldarg_1:  				case ILOpCode.Ldarg_2:  				case ILOpCode.Ldarg_3:  					output.WriteReference(opCodeInfo' omitSuffix: true);  					index = opCodeInfo.Name.Substring(6);  					output.WriteLocalReference(index' "param_" + index);  					break;  				case ILOpCode.Ldloc_0:  				case ILOpCode.Ldloc_1:  				case ILOpCode.Ldloc_2:  				case ILOpCode.Ldloc_3:  				case ILOpCode.Stloc_0:  				case ILOpCode.Stloc_1:  				case ILOpCode.Stloc_2:  				case ILOpCode.Stloc_3:  					output.WriteReference(opCodeInfo' omitSuffix: true);  					index = opCodeInfo.Name.Substring(6);  					output.WriteLocalReference(index' "loc_" + index);  					break;  				default:  					output.WriteReference(opCodeInfo);  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteOpCode,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Ldarg_0:  				case ILOpCode.Ldarg_1:  				case ILOpCode.Ldarg_2:  				case ILOpCode.Ldarg_3:  					output.WriteReference(opCodeInfo' omitSuffix: true);  					index = opCodeInfo.Name.Substring(6);  					output.WriteLocalReference(index' "param_" + index);  					break;  				case ILOpCode.Ldloc_0:  				case ILOpCode.Ldloc_1:  				case ILOpCode.Ldloc_2:  				case ILOpCode.Ldloc_3:  				case ILOpCode.Stloc_0:  				case ILOpCode.Stloc_1:  				case ILOpCode.Stloc_2:  				case ILOpCode.Stloc_3:  					output.WriteReference(opCodeInfo' omitSuffix: true);  					index = opCodeInfo.Name.Substring(6);  					output.WriteLocalReference(index' "loc_" + index);  					break;  				default:  					output.WriteReference(opCodeInfo);  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,The following statement contains a magic number: switch ((ushort)secdecl.Action) {  					case 1: // DeclarativeSecurityAction.Request  						output.Write("request");  						break;  					case 2: // DeclarativeSecurityAction.Demand  						output.Write("demand");  						break;  					case 3: // DeclarativeSecurityAction.Assert  						output.Write("assert");  						break;  					case 4: // DeclarativeSecurityAction.Deny  						output.Write("deny");  						break;  					case 5: // DeclarativeSecurityAction.PermitOnly  						output.Write("permitonly");  						break;  					case 6: // DeclarativeSecurityAction.LinkDemand  						output.Write("linkcheck");  						break;  					case 7: // DeclarativeSecurityAction.InheritDemand  						output.Write("inheritcheck");  						break;  					case 8: // DeclarativeSecurityAction.RequestMinimum  						output.Write("reqmin");  						break;  					case 9: // DeclarativeSecurityAction.RequestOptional  						output.Write("reqopt");  						break;  					case 10: // DeclarativeSecurityAction.RequestRefuse  						output.Write("reqrefuse");  						break;  					case 11: // DeclarativeSecurityAction.PreJitGrant  						output.Write("prejitgrant");  						break;  					case 12: // DeclarativeSecurityAction.PreJitDeny  						output.Write("prejitdeny");  						break;  					case 13: // DeclarativeSecurityAction.NonCasDemand  						output.Write("noncasdemand");  						break;  					case 14: // DeclarativeSecurityAction.NonCasLinkDemand  						output.Write("noncaslinkdemand");  						break;  					case 15: // DeclarativeSecurityAction.NonCasInheritance  						output.Write("noncasinheritance");  						break;  					default:  						output.Write(secdecl.Action.ToString());  						break;  				}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,TryDecodeSecurityDeclaration,The following statement contains a magic number: nameParts.Length < 2 || nameParts[1] == currentAssemblyName
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSimpleValue,The following statement contains a magic number: switch (typeName) {  				case "string":  					output.Write("'" + DisassemblerHelpers.EscapeString(value.ToString()).Replace("'"' "\'") + "'");  					break;  				case "type":  					var info = ((PrimitiveTypeCode Code' string Name))value;  					if (info.Name.StartsWith("enum "' StringComparison.Ordinal)) {  						output.Write(info.Name.Substring(5));  					} else {  						output.Write(info.Name);  					}  					break;  				default:  					DisassemblerHelpers.WriteOperand(output' value);  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The following statement contains a magic number: switch (type = blob.ReadByte()) {  				case 0x66: // None  				case 0x50: // Max  					break;  				case 0x02: // NATIVE_TYPE_BOOLEAN   					output.Write("bool");  					break;  				case 0x03: // NATIVE_TYPE_I1  					output.Write("int8");  					break;  				case 0x04: // NATIVE_TYPE_U1  					output.Write("unsigned int8");  					break;  				case 0x05: // NATIVE_TYPE_I2  					output.Write("int16");  					break;  				case 0x06: // NATIVE_TYPE_U2  					output.Write("unsigned int16");  					break;  				case 0x07: // NATIVE_TYPE_I4  					output.Write("int32");  					break;  				case 0x08: // NATIVE_TYPE_U4  					output.Write("unsigned int32");  					break;  				case 0x09: // NATIVE_TYPE_I8  					output.Write("int64");  					break;  				case 0x0a: // NATIVE_TYPE_U8  					output.Write("unsigned int64");  					break;  				case 0x0b: // NATIVE_TYPE_R4  					output.Write("float32");  					break;  				case 0x0c: // NATIVE_TYPE_R8  					output.Write("float64");  					break;  				case 0x14: // NATIVE_TYPE_LPSTR  					output.Write("lpstr");  					break;  				case 0x1f: // NATIVE_TYPE_INT  					output.Write("int");  					break;  				case 0x20: // NATIVE_TYPE_UINT  					output.Write("unsigned int");  					break;  				case 0x26: // NATIVE_TYPE_FUNC  					output.Write("Func");  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (blob.RemainingBytes > 0)  						WriteNativeType(ref blob);  					output.Write('[');  					int sizeParameterIndex = blob.TryReadCompressedInteger(out int value) ? value : -1;  					int size = blob.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = blob.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						output.Write(size.ToString());  					}  					if (sizeParameterIndex >= 0 && sizeParameterMultiplier != 0) {  						output.Write(" + ");  						output.Write(sizeParameterIndex.ToString());  					}  					output.Write(']');  					break;  				case 0x0f: // Currency  					output.Write("currency");  					break;  				case 0x13: // BStr  					output.Write("bstr");  					break;  				case 0x15: // LPWStr  					output.Write("lpwstr");  					break;  				case 0x16: // LPTStr  					output.Write("lptstr");  					break;  				case 0x17: // FixedSysString  					output.Write("fixed sysstring[{0}]"' blob.ReadCompressedInteger());  					break;  				case 0x19: // IUnknown  					output.Write("iunknown");  					break;  				case 0x1a: // IDispatch  					output.Write("idispatch");  					break;  				case 0x1b: // Struct  					output.Write("struct");  					break;  				case 0x1c: // IntF  					output.Write("interface");  					break;  				case 0x1d: // SafeArray  					output.Write("safearray ");  					if (blob.RemainingBytes > 0) {  						byte elementType = blob.ReadByte();  						switch (elementType) {  							case 0: // None  								break;  							case 2: // I2  								output.Write("int16");  								break;  							case 3: // I4  								output.Write("int32");  								break;  							case 4: // R4  								output.Write("float32");  								break;  							case 5: // R8  								output.Write("float64");  								break;  							case 6: // Currency  								output.Write("currency");  								break;  							case 7: // Date  								output.Write("date");  								break;  							case 8: // BStr  								output.Write("bstr");  								break;  							case 9: // Dispatch  								output.Write("idispatch");  								break;  							case 10: // Error  								output.Write("error");  								break;  							case 11: // Bool  								output.Write("bool");  								break;  							case 12: // Variant  								output.Write("variant");  								break;  							case 13: // Unknown  								output.Write("iunknown");  								break;  							case 14: // Decimal  								output.Write("decimal");  								break;  							case 16: // I1  								output.Write("int8");  								break;  							case 17: // UI1  								output.Write("unsigned int8");  								break;  							case 18: // UI2  								output.Write("unsigned int16");  								break;  							case 19: // UI4  								output.Write("unsigned int32");  								break;  							case 22: // Int  								output.Write("int");  								break;  							case 23: // UInt  								output.Write("unsigned int");  								break;  							default:  								output.Write(elementType.ToString());  								break;  						}  					}  					break;  				case 0x1e: // FixedArray  					output.Write("fixed array");  					output.Write("[{0}]"' blob.TryReadCompressedInteger(out value) ? value : 0);  					if (blob.RemainingBytes > 0) {  						output.Write(' ');  						WriteNativeType(ref blob);  					}  					break;  				case 0x22: // ByValStr  					output.Write("byvalstr");  					break;  				case 0x23: // ANSIBStr  					output.Write("ansi bstr");  					break;  				case 0x24: // TBStr  					output.Write("tbstr");  					break;  				case 0x25: // VariantBool  					output.Write("variant bool");  					break;  				case 0x28: // ASAny  					output.Write("as any");  					break;  				case 0x2b: // LPStruct  					output.Write("lpstruct");  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = blob.ReadSerializedString();  					string unmanagedType = blob.ReadSerializedString();  					string managedType = blob.ReadSerializedString();  					string cookie = blob.ReadSerializedString();    					var guid = !string.IsNullOrEmpty(guidValue) ? new Guid(guidValue) : Guid.Empty;    					output.Write("custom(\"{0}\"' \"{1}\""'  								 DisassemblerHelpers.EscapeString(managedType)'  								 DisassemblerHelpers.EscapeString(cookie));  					if (guid != Guid.Empty || !string.IsNullOrEmpty(unmanagedType)) {  						output.Write("' \"{0}\"' \"{1}\""' guid.ToString()' DisassemblerHelpers.EscapeString(unmanagedType));  					}  					output.Write(')');  					break;  				case 0x2d: // Error  					output.Write("error");  					break;  				default:  					output.Write(type.ToString());  					break;  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteBlob,The following statement contains a magic number: i % 16 == 0 && i < reader.Length - 1
Magic Number,ICSharpCode.Decompiler.Disassembler,SecurityDeclarationDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,ResolveType,The following statement contains a magic number: string[] nameParts = typeName.Split(new[] { "' " }' 2' StringSplitOptions.None);
Magic Number,ICSharpCode.Decompiler.Disassembler,SecurityDeclarationDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,ResolveType,The following statement contains a magic number: nameParts.Length == 2
Magic Number,ICSharpCode.Decompiler.Disassembler,SecurityDeclarationDecoder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,ResolveEnumUnderlyingType,The following statement contains a magic number: typeName = typeName.Substring(5);
Magic Number,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ReduceNesting,The following statement contains a magic number: maxDepth < 2
Magic Number,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ShouldReduceNesting,The following statement contains a magic number: return maxDepth2 >= 2 || maxDepth2 >= 1 && maxStatements2 > maxStatements || maxStatements2 >= 2*maxStatements;
Magic Number,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,ShouldReduceNesting,The following statement contains a magic number: return maxDepth2 >= 2 || maxDepth2 >= 1 && maxStatements2 > maxStatements || maxStatements2 >= 2*maxStatements;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicSetMemberInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicBinaryOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,DynamicLogicOperatorInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\DynamicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,ComputeSizeOf,The following statement contains a magic number: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,ComputeSizeOf,The following statement contains a magic number: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,ComputeSizeOf,The following statement contains a magic number: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TupleTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TupleTransform.cs,MatchTupleFieldAccess,The following statement contains a magic number: !int.TryParse(inst.Field.Name.Substring(4)' out position)
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UserDefinedLogicOperator,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LogicInstructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					Debug.Assert(EntryPoint.IncomingEdgeCount == 1);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					Debug.Assert(EntryPoint.IncomingEdgeCount == 1);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					Debug.Assert(EntryPoint.IncomingEdgeCount == 1);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					Debug.Assert(EntryPoint.IncomingEdgeCount == 1);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SortBlocks,The following statement contains a magic number: Blocks.Count < 2
Magic Number,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchIfAtEndOfBlock,The following statement contains a magic number: Instructions.Count < 2
Magic Number,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchIfAtEndOfBlock,The following statement contains a magic number: Instructions[Instructions.Count - 2].MatchIfInstruction(out condition' out trueInst)
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryFinally,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryFault,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,InstructionCollection<T>,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\InstructionCollection.cs,SecondToLastOrDefault,The following statement contains a magic number: return list.Count > 1 ? list[list.Count - 2] : null;
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (opCode) {  				case ILOpCode.Constrained:  					return DecodeConstrainedCall();  				case ILOpCode.Readonly:  					return DecodeReadonly();  				case ILOpCode.Tail:  					return DecodeTailCall();  				case ILOpCode.Unaligned:  					return DecodeUnaligned();  				case ILOpCode.Volatile:  					return DecodeVolatile();  				case ILOpCode.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case ILOpCode.Add_ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case ILOpCode.Add_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case ILOpCode.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case ILOpCode.Arglist:  					return Push(new Arglist());  				case ILOpCode.Beq:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Beq_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Equality);  				case ILOpCode.Bge:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual);  				case ILOpCode.Bge_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bge_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThanOrEqual' un: true);  				case ILOpCode.Bgt:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan);  				case ILOpCode.Bgt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Bgt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.GreaterThan' un: true);  				case ILOpCode.Ble:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual);  				case ILOpCode.Ble_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Ble_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThanOrEqual' un: true);  				case ILOpCode.Blt:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan);  				case ILOpCode.Blt_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Blt_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.LessThan' un: true);  				case ILOpCode.Bne_un:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Bne_un_s:  					return DecodeComparisonBranch(opCode' ComparisonKind.Inequality' un: true);  				case ILOpCode.Br:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Br_s:  					return DecodeUnconditionalBranch(opCode);  				case ILOpCode.Break:  					return new DebugBreak();  				case ILOpCode.Brfalse:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brfalse_s:  					return DecodeConditionalBranch(opCode' true);  				case ILOpCode.Brtrue:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Brtrue_s:  					return DecodeConditionalBranch(opCode' false);  				case ILOpCode.Call:  					return DecodeCall(OpCode.Call);  				case ILOpCode.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case ILOpCode.Calli:  					return DecodeCallIndirect();  				case ILOpCode.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case ILOpCode.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case ILOpCode.Cgt_un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case ILOpCode.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case ILOpCode.Clt_un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case ILOpCode.Ckfinite:  					return new Ckfinite(Peek());  				case ILOpCode.Conv_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case ILOpCode.Conv_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case ILOpCode.Conv_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case ILOpCode.Conv_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case ILOpCode.Conv_r4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case ILOpCode.Conv_r8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case ILOpCode.Conv_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case ILOpCode.Conv_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case ILOpCode.Conv_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case ILOpCode.Conv_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case ILOpCode.Conv_i:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case ILOpCode.Conv_u:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case ILOpCode.Conv_r_un:  					return Push(new Conv(Pop()' PrimitiveType.R' false' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case ILOpCode.Conv_ovf_u:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case ILOpCode.Conv_ovf_i1_un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i2_un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i4_un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i8_un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u1_un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u2_un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u4_un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u8_un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_i_un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case ILOpCode.Conv_ovf_u_un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case ILOpCode.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case ILOpCode.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case ILOpCode.Div_un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case ILOpCode.Dup:  					return Push(Peek());  				case ILOpCode.Endfilter:  					return new Leave(null' Pop());  				case ILOpCode.Endfinally:  					return new Leave(null);  				case ILOpCode.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case ILOpCode.Jmp:  					return DecodeJmp();  				case ILOpCode.Ldarg:  				case ILOpCode.Ldarg_s:  					return Push(Ldarg(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldarg_0:  					return Push(Ldarg(0));  				case ILOpCode.Ldarg_1:  					return Push(Ldarg(1));  				case ILOpCode.Ldarg_2:  					return Push(Ldarg(2));  				case ILOpCode.Ldarg_3:  					return Push(Ldarg(3));  				case ILOpCode.Ldarga:  				case ILOpCode.Ldarga_s:  					return Push(Ldarga(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldc_i4:  					return Push(new LdcI4(reader.ReadInt32()));  				case ILOpCode.Ldc_i8:  					return Push(new LdcI8(reader.ReadInt64()));  				case ILOpCode.Ldc_r4:  					return Push(new LdcF4(reader.ReadSingle()));  				case ILOpCode.Ldc_r8:  					return Push(new LdcF8(reader.ReadDouble()));  				case ILOpCode.Ldc_i4_m1:  					return Push(new LdcI4(-1));  				case ILOpCode.Ldc_i4_0:  					return Push(new LdcI4(0));  				case ILOpCode.Ldc_i4_1:  					return Push(new LdcI4(1));  				case ILOpCode.Ldc_i4_2:  					return Push(new LdcI4(2));  				case ILOpCode.Ldc_i4_3:  					return Push(new LdcI4(3));  				case ILOpCode.Ldc_i4_4:  					return Push(new LdcI4(4));  				case ILOpCode.Ldc_i4_5:  					return Push(new LdcI4(5));  				case ILOpCode.Ldc_i4_6:  					return Push(new LdcI4(6));  				case ILOpCode.Ldc_i4_7:  					return Push(new LdcI4(7));  				case ILOpCode.Ldc_i4_8:  					return Push(new LdcI4(8));  				case ILOpCode.Ldc_i4_s:  					return Push(new LdcI4(reader.ReadSByte()));  				case ILOpCode.Ldnull:  					return Push(new LdNull());  				case ILOpCode.Ldstr:  					return Push(DecodeLdstr());  				case ILOpCode.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case ILOpCode.Ldind_i1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case ILOpCode.Ldind_i2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case ILOpCode.Ldind_i4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case ILOpCode.Ldind_i8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case ILOpCode.Ldind_u1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case ILOpCode.Ldind_u2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case ILOpCode.Ldind_u4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case ILOpCode.Ldind_r4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case ILOpCode.Ldind_r8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case ILOpCode.Ldind_i:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case ILOpCode.Ldind_ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case ILOpCode.Ldloc:  				case ILOpCode.Ldloc_s:  					return Push(Ldloc(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Ldloc_0:  					return Push(Ldloc(0));  				case ILOpCode.Ldloc_1:  					return Push(Ldloc(1));  				case ILOpCode.Ldloc_2:  					return Push(Ldloc(2));  				case ILOpCode.Ldloc_3:  					return Push(Ldloc(3));  				case ILOpCode.Ldloca:  				case ILOpCode.Ldloca_s:  					return Push(Ldloca(ILParser.DecodeIndex(ref reader' opCode)));  				case ILOpCode.Leave:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Leave_s:  					return DecodeUnconditionalBranch(opCode' isLeave: true);  				case ILOpCode.Localloc:  					return Push(new LocAlloc(Pop()));  				case ILOpCode.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case ILOpCode.Mul_ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case ILOpCode.Mul_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case ILOpCode.Neg:  					return Neg();  				case ILOpCode.Newobj:  					return DecodeCall(OpCode.NewObj);  				case ILOpCode.Nop:  					return new Nop();  				case ILOpCode.Not:  					return Push(new BitNot(Pop()));  				case ILOpCode.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case ILOpCode.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case ILOpCode.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case ILOpCode.Rem_un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case ILOpCode.Ret:  					return Return();  				case ILOpCode.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case ILOpCode.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case ILOpCode.Shr_un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case ILOpCode.Starg:  				case ILOpCode.Starg_s:  					return Starg(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stind_i1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stind_i2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stind_i4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stind_i8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stind_r4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stind_r8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stind_i:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stind_ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stloc:  				case ILOpCode.Stloc_s:  					return Stloc(ILParser.DecodeIndex(ref reader' opCode));  				case ILOpCode.Stloc_0:  					return Stloc(0);  				case ILOpCode.Stloc_1:  					return Stloc(1);  				case ILOpCode.Stloc_2:  					return Stloc(2);  				case ILOpCode.Stloc_3:  					return Stloc(3);  				case ILOpCode.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case ILOpCode.Sub_ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case ILOpCode.Sub_ovf_un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case ILOpCode.Switch:  					return DecodeSwitch();  				case ILOpCode.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case ILOpCode.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case ILOpCode.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case ILOpCode.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case ILOpCode.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldelem:  					return LdElem(ReadAndDecodeTypeReference());  				case ILOpCode.Ldelem_i1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Ldelem_i2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Ldelem_i4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Ldelem_i8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Ldelem_u1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case ILOpCode.Ldelem_u2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case ILOpCode.Ldelem_u4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case ILOpCode.Ldelem_r4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Ldelem_r8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Ldelem_i:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Ldelem_ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case ILOpCode.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case ILOpCode.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case ILOpCode.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case ILOpCode.Ldlen:  					return Push(new LdLen(StackType.I' Pop(StackType.O)));  				case ILOpCode.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case ILOpCode.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case ILOpCode.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case ILOpCode.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case ILOpCode.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case ILOpCode.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case ILOpCode.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case ILOpCode.Refanytype:  					return Push(new RefAnyType(Pop()));  				case ILOpCode.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Rethrow:  					return new Rethrow();  				case ILOpCode.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case ILOpCode.Stelem:  					return StElem(ReadAndDecodeTypeReference());  				case ILOpCode.Stelem_i1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case ILOpCode.Stelem_i2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case ILOpCode.Stelem_i4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case ILOpCode.Stelem_i8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case ILOpCode.Stelem_r4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case ILOpCode.Stelem_r8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case ILOpCode.Stelem_i:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case ILOpCode.Stelem_ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case ILOpCode.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case ILOpCode.Throw:  					return new Throw(Pop());  				case ILOpCode.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case ILOpCode.Unbox_any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeCall,The following statement contains a magic number: switch (method.DeclaringType.Kind) {  				case TypeKind.Array:  					var elementType = ((ArrayType)method.DeclaringType).ElementType;  					if (opCode == OpCode.NewObj)  						return Push(new NewArr(elementType' arguments));  					if (method.Name == "Set") {  						var target = arguments[0];  						var value = arguments.Last();  						var indices = arguments.Skip(1).Take(arguments.Length - 2).ToArray();  						return new StObj(new LdElema(elementType' target' indices) { DelayExceptions = true }' value' elementType);  					}  					if (method.Name == "Get") {  						var target = arguments[0];  						var indices = arguments.Skip(1).ToArray();  						return Push(new LdObj(new LdElema(elementType' target' indices) { DelayExceptions = true }' elementType));  					}  					if (method.Name == "Address") {  						var target = arguments[0];  						var indices = arguments.Skip(1).ToArray();  						return Push(new LdElema(elementType' target' indices));  					}  					Warn("Unknown method called on array type: " + method.Name);  					goto default;  				default:  					var call = CallInstruction.Create(opCode' method);  					call.ILStackWasEmpty = currentStack.IsEmpty;  					call.ConstrainedTo = constrainedPrefix;  					call.Arguments.AddRange(arguments);  					if (call.ResultType != StackType.Void)  						return Push(call);  					return call;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  				case PrimitiveType.R:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  				case PrimitiveType.R:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  				case PrimitiveType.R:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,IsSmallIntegerType,The following statement contains a magic number: return GetSize(type) < 4;
Magic Number,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,The following statement contains a magic number: parts.Length != 2
Magic Number,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,The following statement contains a magic number: switch (parts[0].ToLowerInvariant()) {  					case "version":  						name.Version = new Version(parts[1]);  						break;  					case "culture":  						name.Culture = parts[1] == "neutral" ? "" : parts[1];  						break;  					case "publickeytoken":  						var pk_token = parts[1];  						if (pk_token == "null")  							break;    						name.PublicKeyToken = new byte[pk_token.Length / 2];  						for (int j = 0; j < name.PublicKeyToken.Length; j++)  							name.PublicKeyToken[j] = Byte.Parse(pk_token.Substring(j * 2' 2)' System.Globalization.NumberStyles.HexNumber);    						break;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,The following statement contains a magic number: switch (parts[0].ToLowerInvariant()) {  					case "version":  						name.Version = new Version(parts[1]);  						break;  					case "culture":  						name.Culture = parts[1] == "neutral" ? "" : parts[1];  						break;  					case "publickeytoken":  						var pk_token = parts[1];  						if (pk_token == "null")  							break;    						name.PublicKeyToken = new byte[pk_token.Length / 2];  						for (int j = 0; j < name.PublicKeyToken.Length; j++)  							name.PublicKeyToken[j] = Byte.Parse(pk_token.Substring(j * 2' 2)' System.Globalization.NumberStyles.HexNumber);    						break;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,The following statement contains a magic number: switch (parts[0].ToLowerInvariant()) {  					case "version":  						name.Version = new Version(parts[1]);  						break;  					case "culture":  						name.Culture = parts[1] == "neutral" ? "" : parts[1];  						break;  					case "publickeytoken":  						var pk_token = parts[1];  						if (pk_token == "null")  							break;    						name.PublicKeyToken = new byte[pk_token.Length / 2];  						for (int j = 0; j < name.PublicKeyToken.Length; j++)  							name.PublicKeyToken[j] = Byte.Parse(pk_token.Substring(j * 2' 2)' System.Globalization.NumberStyles.HexNumber);    						break;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,AssemblyReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,GetPublicKeyToken,The following statement contains a magic number: return sha1.ComputeHash(bytes).Skip(12).ToArray();
Magic Number,ICSharpCode.Decompiler.Metadata,Resource,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\Dom.cs,GetHashCode,The following statement contains a magic number: return unchecked(982451629 * Module.GetHashCode() + 982451653 * MetadataTokens.GetToken(Handle));
Magic Number,ICSharpCode.Decompiler.Metadata,Resource,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\Dom.cs,GetHashCode,The following statement contains a magic number: return unchecked(982451629 * Module.GetHashCode() + 982451653 * MetadataTokens.GetToken(Handle));
Magic Number,ICSharpCode.Decompiler.Metadata,DotNetCorePathFinderExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\DotNetCorePathFinderExtensions.cs,DetectTargetFrameworkId,The following statement contains a magic number: var version = pathMatch.Groups[2].Value;
Magic Number,ICSharpCode.Decompiler.Metadata,ILOpCodeExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\OperandType.cs,GetOperandType,The following statement contains a magic number: return (OperandType)255;
Magic Number,ICSharpCode.Decompiler.Metadata,PEFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\PEFile.cs,GetRuntime,The following statement contains a magic number: switch (version[1]) {  				case '1':  					if (version[3] == 1)  						return TargetRuntime.Net_1_0;  					else  						return TargetRuntime.Net_1_1;  				case '2':  					return TargetRuntime.Net_2_0;  				case '4':  					return TargetRuntime.Net_4_0;  				default:  					return TargetRuntime.Unknown;  			}
Magic Number,ICSharpCode.Decompiler.Metadata,SignatureBlobComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\SignatureBlobComparer.cs,EqualsMethodSignature,The following statement contains a magic number: typeCode == 65
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ParseTargetFramework,The following statement contains a magic number: pair.Length != 2
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ParseTargetFramework,The following statement contains a magic number: switch (pair[0].Trim().ToUpperInvariant()) {  					case "VERSION":  						var versionString = pair[1].TrimStart('v'' ' '' '\t');  						if (identifier == TargetFrameworkIdentifier.NETCoreApp ||  							identifier == TargetFrameworkIdentifier.NETStandard)  						{  							if (versionString.Length == 3)  								versionString += ".0";  						}  						if (!Version.TryParse(versionString' out version))  							version = null;  						break;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,IsZeroOrAllOnes,The following statement contains a magic number: return version == null  				|| (version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0)  				|| (version.Major == 65535 && version.Minor == 65535 && version.Build == 65535 && version.Revision == 65535);
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,IsZeroOrAllOnes,The following statement contains a magic number: return version == null  				|| (version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0)  				|| (version.Major == 65535 && version.Minor == 65535 && version.Build == 65535 && version.Revision == 65535);
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,IsZeroOrAllOnes,The following statement contains a magic number: return version == null  				|| (version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0)  				|| (version.Major == 65535 && version.Minor == 65535 && version.Build == 65535 && version.Revision == 65535);
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,IsZeroOrAllOnes,The following statement contains a magic number: return version == null  				|| (version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0)  				|| (version.Major == 65535 && version.Minor == 65535 && version.Build == 65535 && version.Revision == 65535);
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,GetMscorlibBasePath,The following statement contains a magic number: switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							return "v1.0.3705";  						return "v1.1.4322";  					case 2:  						return "v2.0.50727";  					case 4:  						return "v4.0.30319";  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,GetMscorlibBasePath,The following statement contains a magic number: switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							return "v1.0.3705";  						return "v1.1.4322";  					case 2:  						return "v2.0.50727";  					case 4:  						return "v4.0.30319";  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,GetMscorlibBasePath,The following statement contains a magic number: switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							return "v1.0.3705";  						return "v1.1.4322";  					case 2:  						return "v2.0.50727";  					case 4:  						return "v4.0.30319";  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}
Magic Number,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,GetGacPaths,The following statement contains a magic number: var paths = new List<string>(2);
Magic Number,ICSharpCode.Decompiler.Metadata,MetadataExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\MetadataExtensions.cs,CalculatePublicKeyToken,The following statement contains a magic number: return publicKeyTokenBytes.TakeLast(8).Reverse().ToHexString(8);
Magic Number,ICSharpCode.Decompiler.Metadata,MetadataExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\MetadataExtensions.cs,CalculatePublicKeyToken,The following statement contains a magic number: return publicKeyTokenBytes.TakeLast(8).Reverse().ToHexString(8);
Magic Number,ICSharpCode.Decompiler.Metadata,MetadataExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\MetadataExtensions.cs,ToHexString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(estimatedLength * 2);
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 4096;
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 256;
Magic Number,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 16;
Magic Number,ICSharpCode.Decompiler.Semantics,NumericOrEnumerationConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.Decompiler.Semantics,NumericOrEnumerationConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,TupleConv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: hash *= 31;
Magic Number,ICSharpCode.Decompiler.TypeSystem,TupleType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TupleType.cs,GetHashCode,The following statement contains a magic number: hash *= 31;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ArrayType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ArrayType.cs,GetHashCode,The following statement contains a magic number: return unchecked(elementType.GetHashCode() * 71681 + dimensions);
Magic Number,ICSharpCode.Decompiler.TypeSystem,AssemblyQualifiedTypeName,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AssemblyQualifiedTypeName.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * AssemblyName.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem,ByReferenceType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725813;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ByReferenceTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725814;
Magic Number,ICSharpCode.Decompiler.TypeSystem,FullTypeNameComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\FullTypeName.cs,GetHashCode,The following statement contains a magic number: hash *= 31;
Magic Number,ICSharpCode.Decompiler.TypeSystem,IntersectionType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\IntersectionType.cs,IntersectionType,The following statement contains a magic number: Debug.Assert(types.Length >= 2);
Magic Number,ICSharpCode.Decompiler.TypeSystem,IntersectionType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\IntersectionType.cs,GetHashCode,The following statement contains a magic number: hashCode *= 7137517;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: hashCode *= 1000000007;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * ta.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCodeForInterning,The following statement contains a magic number: hashCode *= 27;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterListComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: hashCode *= 27;
Magic Number,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);
Magic Number,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: hash *= 27;
Magic Number,ICSharpCode.Decompiler.TypeSystem,PointerType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\PointerType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725811;
Magic Number,ICSharpCode.Decompiler.TypeSystem,PointerTypeReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\PointerType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725812;
Magic Number,ICSharpCode.Decompiler.TypeSystem,SpecialType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\SpecialType.cs,GetHashCode,The following statement contains a magic number: return 81625621 ^ (int)kind;
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,TypeListHashCode,The following statement contains a magic number: hashCode *= 27;
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (type) {  				case StackType.I4:  					return 4;  				case StackType.I8:  					return 8;  				case StackType.I:  				case StackType.Ref:  					return NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (type) {  				case StackType.I4:  					return 4;  				case StackType.I8:  					return 8;  				case StackType.I:  				case StackType.Ref:  					return NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,IsSmallIntegerType,The following statement contains a magic number: return size > 0 && size < 4;
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,ResourcesFile,The following statement contains a magic number: int alignBytes = unchecked((int)pos) & 7;
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,ResourcesFile,The following statement contains a magic number: i < 8 - alignBytes
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,ResourcesFile,The following statement contains a magic number: reader.Seek(checked(4 * numResources)' SeekOrigin.Current);
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,AllEntriesAreStreams,The following statement contains a magic number: version != 2
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,LoadObjectV1,The following statement contains a magic number: switch (typeName) {  				case "System.String":  					return reader.ReadString();  				case "System.Byte":  					return reader.ReadByte();  				case "System.SByte":  					return reader.ReadSByte();  				case "System.Int16":  					return reader.ReadInt16();  				case "System.UInt16":  					return reader.ReadUInt16();  				case "System.Int32":  					return reader.ReadInt32();  				case "System.UInt32":  					return reader.ReadUInt32();  				case "System.Int64":  					return reader.ReadInt64();  				case "System.UInt64":  					return reader.ReadUInt64();  				case "System.Single":  					return reader.ReadSingle();  				case "System.Double":  					return reader.ReadDouble();  				case "System.DateTime":  					// Ideally we should use DateTime's ToBinary & FromBinary'  					// but we can't for compatibility reasons.  					return new DateTime(reader.ReadInt64());  				case "System.TimeSpan":  					return new TimeSpan(reader.ReadInt64());  				case "System.Decimal":  					int[] bits = new int[4];  					for (int i = 0; i < bits.Length; i++)  						bits[i] = reader.ReadInt32();  					return new decimal(bits);  				default:  					return new ResourceSerializedObject(FindType(typeIndex)' this' reader.BaseStream.Position);  			}
Magic Number,ICSharpCode.Decompiler.Util,ResourcesFile,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResourcesFile.cs,GetStartPositions,The following statement contains a magic number: positions = new long[numResources * 2];
Magic Number,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,WriteNiceBase64,The following statement contains a magic number: sb = new StringBuilder(b64' b64.Length + ((b64.Length + 160) / 80) * 3);
Magic Number,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,WriteNiceBase64,The following statement contains a magic number: sb = new StringBuilder(b64' b64.Length + ((b64.Length + 160) / 80) * 3);
Magic Number,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,WriteNiceBase64,The following statement contains a magic number: sb = new StringBuilder(b64' b64.Length + ((b64.Length + 160) / 80) * 3);
Magic Number,ICSharpCode.Decompiler.Util,ResXResourceWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs,WriteNiceBase64,The following statement contains a magic number: inc = 80 + Environment.NewLine.Length + 1;
Magic Number,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: length = 2;
Magic Number,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: length = 2;
Magic Number,ICSharpCode.Decompiler.Util,BitSet,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\BitSet.cs,ToString,The following statement contains a magic number: b.Length > 500
Magic Number,ICSharpCode.Decompiler.Util,Interval,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\Interval.cs,GetHashCode,The following statement contains a magic number: return Start ^ End ^ (End << 7);
Magic Number,ICSharpCode.Decompiler.Util,LongInterval,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\Interval.cs,GetHashCode,The following statement contains a magic number: return (Start ^ End ^ (End << 7)).GetHashCode();
Magic Number,ICSharpCode.Decompiler.Util,LongSet,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\LongSet.cs,upper_bound,The following statement contains a magic number: int m = min + (max - min) / 2;
Magic Number,ICSharpCode.Decompiler.FlowAnalysis,Dominance,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The following statement contains a magic number: j.IsReachable && (j.Predecessors.Count >= 2 || (j.Predecessors.Count >= 1 && j.ImmediateDominator == null))
Missing Default,ICSharpCode.Decompiler.CSharp,CallBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The following switch statement is missing a default case: switch (kind) {  							case TokenKind.String:  								content.Add(new InterpolatedStringText(text));  								break;  							case TokenKind.Argument:  								argument = arguments[index + 1];  								UnpackSingleElementArray(ref argument);  								content.Add(new Interpolation(argument));  								break;  							case TokenKind.ArgumentWithFormat:  								argument = arguments[index + 1];  								UnpackSingleElementArray(ref argument);  								content.Add(new Interpolation(argument' text));  								break;  						}
Missing Default,ICSharpCode.Decompiler.CSharp,RequiredNamespaceCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\RequiredNamespaceCollector.cs,CollectNamespaces,The following switch statement is missing a default case: switch (entity) {  				case ITypeDefinition td:  					namespaces.Add(td.Namespace);  					HandleAttributes(td.GetAttributes());  					HandleTypeParameters(td.TypeParameters);    					foreach (var baseType in td.DirectBaseTypes) {  						CollectNamespacesForTypeReference(baseType);  					}    					foreach (var nestedType in td.NestedTypes) {  						CollectNamespaces(nestedType' module' mappingInfo);  					}    					foreach (var field in td.Fields) {  						CollectNamespaces(field' module' mappingInfo);  					}    					foreach (var property in td.Properties) {  						CollectNamespaces(property' module' mappingInfo);  					}    					foreach (var @event in td.Events) {  						CollectNamespaces(@event' module' mappingInfo);  					}    					foreach (var method in td.Methods) {  						CollectNamespaces(method' module' mappingInfo);  					}  					break;  				case IField field:  					HandleAttributes(field.GetAttributes());  					CollectNamespacesForTypeReference(field.ReturnType);  					break;  				case IMethod method:  					HandleAttributes(method.GetAttributes());  					HandleAttributes(method.GetReturnTypeAttributes());  					CollectNamespacesForTypeReference(method.ReturnType);  					foreach (var param in method.Parameters) {  						HandleAttributes(param.GetAttributes());  						CollectNamespacesForTypeReference(param.Type);  					}  					HandleTypeParameters(method.TypeParameters);  					var reader = module.PEFile.Reader;  					var parts = mappingInfo.GetMethodParts((MethodDefinitionHandle)method.MetadataToken).ToList();  					foreach (var part in parts) {  						HandleOverrides(part.GetMethodImplementations(module.metadata)' module);  						var methodDef = module.metadata.GetMethodDefinition(part);  						if (method.HasBody) {  							MethodBodyBlock body;  							try {  								body = reader.GetMethodBody(methodDef.RelativeVirtualAddress);  							} catch (BadImageFormatException) {  								continue;  							}  							CollectNamespacesFromMethodBody(body' module);  						}  					}  					break;  				case IProperty property:  					HandleAttributes(property.GetAttributes());  					CollectNamespaces(property.Getter' module' mappingInfo);  					CollectNamespaces(property.Setter' module' mappingInfo);  					break;  				case IEvent @event:  					HandleAttributes(@event.GetAttributes());  					CollectNamespaces(@event.AddAccessor' module' mappingInfo);  					CollectNamespaces(@event.RemoveAccessor' module' mappingInfo);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,RequiredNamespaceCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\RequiredNamespaceCollector.cs,CollectNamespacesFromMethodBody,The following switch statement is missing a default case: switch (handle.Kind) {  							case HandleKind.TypeDefinition:  							case HandleKind.TypeReference:  							case HandleKind.TypeSpecification:  								IType type;  								try {  									type = module.ResolveType(handle' genericContext);  								} catch (BadImageFormatException) {  									break;  								}  								CollectNamespacesForTypeReference(type);  								break;  							case HandleKind.FieldDefinition:  							case HandleKind.MethodDefinition:  							case HandleKind.MethodSpecification:  							case HandleKind.MemberReference:  								IMember member;  								try {  									member = module.ResolveEntity(handle' genericContext) as IMember;  								} catch (BadImageFormatException) {  									break;  								}  								CollectNamespacesForMemberReference(member);  								break;  							case HandleKind.StandaloneSignature:  								StandaloneSignature sig;  								try {  									sig = metadata.GetStandaloneSignature((StandaloneSignatureHandle)handle);  								} catch (BadImageFormatException) {  									break;  								}  								if (sig.GetKind() == StandaloneSignatureKind.Method) {  									MethodSignature<IType> methodSig;  									try {  										methodSig = module.DecodeMethodSignature((StandaloneSignatureHandle)handle' genericContext);  									} catch (BadImageFormatException) {  										break;  									}  									CollectNamespacesForTypeReference(methodSig.ReturnType);  									foreach (var paramType in methodSig.ParameterTypes) {  										CollectNamespacesForTypeReference(paramType);  									}  								}  								break;  						}
Missing Default,ICSharpCode.Decompiler.CSharp,RequiredNamespaceCollector,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\RequiredNamespaceCollector.cs,CollectNamespacesForMemberReference,The following switch statement is missing a default case: switch (member) {  				case IField field:  					CollectNamespacesForTypeReference(field.DeclaringType);  					CollectNamespacesForTypeReference(field.ReturnType);  					break;  				case IMethod method:  					CollectNamespacesForTypeReference(method.DeclaringType);  					CollectNamespacesForTypeReference(method.ReturnType);  					foreach (var param in method.Parameters)  						CollectNamespacesForTypeReference(param.Type);  					foreach (var arg in method.TypeArguments)  						CollectNamespacesForTypeReference(arg);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,TranslatedExpression,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The following switch statement is missing a default case: switch (ResolveResult) {  						case ConversionResolveResult conversion: {  							if (Expression is CastExpression cast && CastCanBeMadeImplicit(  									Resolver.CSharpConversions.Get(expressionBuilder.compilation)'  									conversion.Conversion'  									conversion.Input.Type'  									type' targetType  								)) {  								var result = this.UnwrapChild(cast.Expression);  								if (conversion.Conversion.IsUserDefined) {  									result.Expression.AddAnnotation(new ImplicitConversionAnnotation(conversion));  								}  								return result;  							} else if (Expression is ObjectCreateExpression oce && conversion.Conversion.IsMethodGroupConversion  									&& oce.Arguments.Count == 1 && expressionBuilder.settings.UseImplicitMethodGroupConversion) {  								return this.UnwrapChild(oce.Arguments.Single());  							}  							break;  						}  						case InvocationResolveResult invocation: {  							if (Expression is ObjectCreateExpression oce && oce.Arguments.Count == 1 && invocation.Type.IsKnownType(KnownTypeCode.NullableOfT)) {  								return this.UnwrapChild(oce.Arguments.Single());  							}  							break;  						}  					}
Missing Default,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The following switch statement is missing a default case: switch (member.Kind) {  				case HandleKind.MethodDefinition:  					var methodHandle = (MethodDefinitionHandle)member;  					var method = metadata.GetMethodDefinition(methodHandle);  					var methodSemantics = module.MethodSemanticsLookup.GetSemantics(methodHandle).Item2;  					if (methodSemantics != 0 && methodSemantics != System.Reflection.MethodSemanticsAttributes.Other)  						return true;  					if (LocalFunctionDecompiler.IsLocalFunctionMethod(module' methodHandle))  						return settings.LocalFunctions;  					if (settings.AnonymousMethods && methodHandle.HasGeneratedName(metadata) && methodHandle.IsCompilerGenerated(metadata))  						return true;  					if (settings.AsyncAwait && AsyncAwaitDecompiler.IsCompilerGeneratedMainMethod(module' methodHandle))  						return true;  					return false;  				case HandleKind.TypeDefinition:  					var typeHandle = (TypeDefinitionHandle)member;  					var type = metadata.GetTypeDefinition(typeHandle);  					name = metadata.GetString(type.Name);  					if (!type.GetDeclaringType().IsNil) {  						if (LocalFunctionDecompiler.IsLocalFunctionDisplayClass(module' typeHandle))  							return settings.LocalFunctions;  						if (settings.AnonymousMethods && IsClosureType(type' metadata))  							return true;  						if (settings.YieldReturn && YieldReturnDecompiler.IsCompilerGeneratorEnumerator(typeHandle' metadata))  							return true;  						if (settings.AsyncAwait && AsyncAwaitDecompiler.IsCompilerGeneratedStateMachine(typeHandle' metadata))  							return true;  						if (settings.AsyncEnumerator && AsyncAwaitDecompiler.IsCompilerGeneratorAsyncEnumerator(typeHandle' metadata))  							return true;  						if (settings.FixedBuffers && name.StartsWith("<"' StringComparison.Ordinal) && name.Contains("__FixedBuffer"))  							return true;  					} else if (type.IsCompilerGenerated(metadata)) {  						if (settings.ArrayInitializers && name.StartsWith("<PrivateImplementationDetails>"' StringComparison.Ordinal))  							return true;  						if (settings.AnonymousTypes && type.IsAnonymousType(metadata))  							return true;  						if (settings.Dynamic && type.IsDelegate(metadata) && (name.StartsWith("<>A"' StringComparison.Ordinal) || name.StartsWith("<>F"' StringComparison.Ordinal)))  							return true;  					}  					if (settings.ArrayInitializers && settings.SwitchStatementOnString && name.StartsWith("<PrivateImplementationDetails>"' StringComparison.Ordinal))  						return true;  					return false;  				case HandleKind.FieldDefinition:  					var fieldHandle = (FieldDefinitionHandle)member;  					var field = metadata.GetFieldDefinition(fieldHandle);  					name = metadata.GetString(field.Name);  					if (field.IsCompilerGenerated(metadata)) {  						if (settings.AnonymousMethods && IsAnonymousMethodCacheField(field' metadata))  							return true;  						if (settings.AutomaticProperties && IsAutomaticPropertyBackingField(field' metadata))  							return true;  						if (settings.SwitchStatementOnString && IsSwitchOnStringCache(field' metadata))  							return true;  					}  					// event-fields are not [CompilerGenerated]  					if (settings.AutomaticEvents && metadata.GetTypeDefinition(field.GetDeclaringType()).GetEvents().Any(ev => metadata.GetEventDefinition(ev).Name == field.Name))  						return true;  					if (settings.ArrayInitializers && metadata.GetString(metadata.GetTypeDefinition(field.GetDeclaringType()).Name).StartsWith("<PrivateImplementationDetails>"' StringComparison.Ordinal)) {  						// only hide fields starting with '__StaticArrayInit'  						if (name.StartsWith("__StaticArrayInit"' StringComparison.Ordinal))  							return true;  						// hide fields starting with '$$method'  						if (name.StartsWith("$$method"' StringComparison.Ordinal))  							return true;  						if (field.DecodeSignature(new Metadata.FullTypeNameSignatureDecoder(metadata)' default).ToString().StartsWith("__StaticArrayInit"' StringComparison.Ordinal))  							return true;  					}  					return false;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ReadCodeMappingInfo,The following switch statement is missing a default case: switch (memberRef.Parent.Kind) {  					case HandleKind.TypeReference:  						// This should never happen in normal code' because we are looking at nested types  						// If it's not a nested type' it can't be a reference to the state machine or lambda anyway' and  						// those should be either TypeDef or TypeSpec.  						return default;  					case HandleKind.TypeDefinition:  						return (TypeDefinitionHandle)memberRef.Parent;  					case HandleKind.TypeSpecification:  						var ts = module.Metadata.GetTypeSpecification((TypeSpecificationHandle)memberRef.Parent);  						if (ts.Signature.IsNil)  							return default;  						// Do a quick scan using BlobReader  						var signature = module.Metadata.GetBlobReader(ts.Signature);  						// When dealing with FSM implementations' we can safely assume that if it's a type spec'  						// it must be a generic type instance.  						if (signature.ReadByte() != (byte)SignatureTypeCode.GenericTypeInstance)  							return default;  						// Skip over the rawTypeKind: value type or class  						var rawTypeKind = signature.ReadCompressedInteger();  						if (rawTypeKind < 17 || rawTypeKind > 18)  							return default;  						// Only read the generic type' ignore the type arguments  						var genericType = signature.ReadTypeHandle();  						// Again' we assume this is a type def' because we are only looking at nested types  						if (genericType.Kind != HandleKind.TypeDefinition)  							return default;  						return (TypeDefinitionHandle)genericType;  				}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertConstantValue,The following switch statement is missing a default case: switch (rr.Type.GetDefinition()?.KnownTypeCode) {  						case KnownTypeCode.SByte:  						case KnownTypeCode.Byte:  						case KnownTypeCode.Int16:  						case KnownTypeCode.UInt16:  							expr = new CastExpression(new PrimitiveType(KnownTypeReference.GetCSharpNameByTypeCode(rr.Type.GetDefinition().KnownTypeCode))' expr);  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ShouldDisplayAsHex,The following switch statement is missing a default case: switch (parent) {  				case BinaryNumericInstruction bni:  					if (bni.Operator == BinaryNumericOperator.BitAnd  						|| bni.Operator == BinaryNumericOperator.BitOr  						|| bni.Operator == BinaryNumericOperator.BitXor)  						return true;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateComp,The following switch statement is missing a default case: switch (inst.InputType) {  				case StackType.I: // In order to generate valid C# we need to treat (U)IntPtr as (U)Int64 in comparisons.  				case StackType.I8:  					inputType = inst.Sign == Sign.Unsigned ? KnownTypeCode.UInt64 : KnownTypeCode.Int64;  					break;  				case StackType.I4:  					inputType = inst.Sign == Sign.Unsigned ? KnownTypeCode.UInt32 : KnownTypeCode.Int32;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The following switch statement is missing a default case: switch (op) {  					case AssignmentOperatorType.Add:  					case AssignmentOperatorType.Subtract:  						if (target.Type.Kind == TypeKind.Pointer) {  							var pao = GetPointerArithmeticOffset(inst.Value' value' ((PointerType)target.Type).ElementType' inst.CheckForOverflow);  							if (pao != null) {  								value = pao.Value;  							} else {  								value.Expression.AddChild(new Comment("ILSpy Error: GetPointerArithmeticOffset() failed"' CommentType.MultiLine)' Roles.Comment);  							}  						} else {  							IType targetType = NullableType.GetUnderlyingType(target.Type).GetEnumUnderlyingType();  							if (NullableType.IsNullable(value.Type)) {  								targetType = NullableType.Create(compilation' targetType);  							}  							value = value.ConvertTo(targetType' this' inst.CheckForOverflow' allowImplicitConversion: true);  						}  						break;  					case AssignmentOperatorType.Multiply:  					case AssignmentOperatorType.Divide:  					case AssignmentOperatorType.Modulus:  					case AssignmentOperatorType.BitwiseAnd:  					case AssignmentOperatorType.BitwiseOr:  					case AssignmentOperatorType.ExclusiveOr: {  							IType targetType = NullableType.GetUnderlyingType(target.Type);  							if (NullableType.IsNullable(value.Type)) {  								targetType = NullableType.Create(compilation' targetType);  							}  							value = value.ConvertTo(targetType' this' inst.CheckForOverflow' allowImplicitConversion: true);  							break;  						}  				}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The following switch statement is missing a default case: switch (info.Kind) {  					case IL.Transforms.AccessPathKind.Adder:  						Debug.Assert(lastElement.Member is IMethod);  						elementsStack.Peek().Add(  							new CallBuilder(this' typeSystem' settings)  								.BuildCollectionInitializerExpression(lastElement.OpCode' (IMethod)lastElement.Member' initObjRR' info.Values)  								.WithILInstruction(inst)  						);  						break;  					case IL.Transforms.AccessPathKind.Setter:  						Debug.Assert(lastElement.Member is IProperty || lastElement.Member is IField);  						if (lastElement.Indices?.Length > 0) {  							var property = (IProperty)lastElement.Member;  							Debug.Assert(property.IsIndexer);  							elementsStack.Peek().Add(  								new CallBuilder(this' typeSystem' settings)  									.BuildDictionaryInitializerExpression(lastElement.OpCode' property.Setter' initObjRR' GetIndices(lastElement.Indices' indexVariables).ToList()' info.Values.Single())  									.WithILInstruction(inst)  							);  						} else {  							var value = Translate(info.Values.Single()' typeHint: memberRR.Type)  								.ConvertTo(memberRR.Type' this' allowImplicitConversion: true);  							var assignment = new NamedExpression(lastElement.Member.Name' value)  								.WithILInstruction(inst).WithRR(memberRR);  							elementsStack.Peek().Add(assignment);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp,StatementBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The following switch statement is missing a default case: switch (transformation) {  				case RequiredGetCurrentTransformation.UseExistingVariable:  					if (foreachVariable.Type.Kind != TypeKind.Dynamic)  						foreachVariable.Type = type;  					foreachVariable.Kind = VariableKind.ForeachLocal;  					foreachVariable.Name = AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>()' foreachVariable);  					break;  				case RequiredGetCurrentTransformation.IntroduceNewVariable:  					foreachVariable = currentFunction.RegisterVariable(  						VariableKind.ForeachLocal' type'  						AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>())  					);  					instToReplace.ReplaceWith(new LdLoc(foreachVariable));  					body.Instructions.Insert(0' new StLoc(foreachVariable' instToReplace));  					break;  				case RequiredGetCurrentTransformation.IntroduceNewVariableAndLocalCopy:  					foreachVariable = currentFunction.RegisterVariable(  						VariableKind.ForeachLocal' type'  						AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>())  					);  					var localCopyVariable = currentFunction.RegisterVariable(  						VariableKind.Local' type'  						AssignVariableNames.GenerateVariableName(currentFunction' type)  					);  					instToReplace.Parent.ReplaceWith(new LdLoca(localCopyVariable));  					body.Instructions.Insert(0' new StLoc(localCopyVariable' new LdLoc(foreachVariable)));  					body.Instructions.Insert(0' new StLoc(foreachVariable' instToReplace));  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following switch statement is missing a default case: switch (frameworkIdentifier) {  							case ".NETPortable":  								languageTargets = LanguageTargets.Portable;  								break;  						}
Missing Default,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadXmlDoc,The following switch statement is missing a default case: switch (reader.LocalName) {  							case "members":  								ReadMembersSection(reader' linePosMapper' indexList);  								break;  						}
Missing Default,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckSetResultAndExitBlock,The following switch statement is missing a default case: switch (methodType) {  				case AsyncMethodType.TaskOfT:  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdLoc(out resultVar))  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.Task:  				case AsyncMethodType.Void:  					resultVar = null;  					if (args.Count != 1)  						throw new SymbolicAnalysisFailedException();  					break;  				case AsyncMethodType.AsyncEnumerable:  				case AsyncMethodType.AsyncEnumerator:  					resultVar = null;  					if (args.Count != 2)  						throw new SymbolicAnalysisFailedException();  					if (!args[1].MatchLdcI4(0))  						throw new SymbolicAnalysisFailedException();  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The following switch statement is missing a default case: switch (inst) {  					case Branch branch:  						if (branch.TargetContainer == oldBody) {  							branch.TargetBlock = newBody.Blocks[branch.TargetBlock.ChildIndex];  						}  						break;  					case Leave leave:  						if (leave.MatchReturn(out var value)) {  							bool validYieldBreak = value.MatchLdcI4(0);  							if (value.MatchLdLoc(out var v)  								&& (v.Kind == VariableKind.Local || v.Kind == VariableKind.StackSlot)  								&& v.StoreInstructions.All(store => store is StLoc stloc && stloc.Value.MatchLdcI4(0)))  							{  								validYieldBreak = true;  								returnStores.AddRange(v.StoreInstructions.Cast<StLoc>());  							}  							if (validYieldBreak) {  								// yield break  								leave.ReplaceWith(new Leave(newBody).WithILRange(leave));  							} else {  								leave.ReplaceWith(new InvalidBranch("Unexpected return in MoveNext()").WithILRange(leave));  							}  						} else {  							if (leave.TargetContainer == oldBody) {  								leave.TargetContainer = newBody;  							}  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,NegateRelationalOperator,The following switch statement is missing a default case: switch (op) {  				case BinaryOperatorType.GreaterThan:  					return BinaryOperatorType.LessThanOrEqual;  				case BinaryOperatorType.GreaterThanOrEqual:  					return BinaryOperatorType.LessThan;  				case BinaryOperatorType.Equality:  					return BinaryOperatorType.InEquality;  				case BinaryOperatorType.InEquality:  					return BinaryOperatorType.Equality;  				case BinaryOperatorType.LessThan:  					return BinaryOperatorType.GreaterThanOrEqual;  				case BinaryOperatorType.LessThanOrEqual:  					return BinaryOperatorType.GreaterThan;  				case BinaryOperatorType.ConditionalOr:  					return BinaryOperatorType.ConditionalAnd;  				case BinaryOperatorType.ConditionalAnd:  					return BinaryOperatorType.ConditionalOr;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,NegateConditionOperator,The following switch statement is missing a default case: switch (op) {  				case BinaryOperatorType.ConditionalOr:  					return BinaryOperatorType.ConditionalAnd;  				case BinaryOperatorType.ConditionalAnd:  					return BinaryOperatorType.ConditionalOr;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The following switch statement is missing a default case: switch (attr.Type) {  				case SimpleType st:  					if (st.Identifier.EndsWith("Attribute"' StringComparison.Ordinal))  						st.Identifier = st.Identifier.Substring(0' st.Identifier.Length - 9);  					break;  				case MemberType mt:  					if (mt.MemberName.EndsWith("Attribute"' StringComparison.Ordinal))  						mt.MemberName = mt.MemberName.Substring(0' mt.MemberName.Length - 9);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttributeType,The following switch statement is missing a default case: switch (astType) {  					case SimpleType st:  						st.Identifier = shortName;  						break;  					case MemberType mt:  						mt.MemberName = shortName;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ApplyShortAttributeNameIfPossible,The following switch statement is missing a default case: switch (astType) {  				case SimpleType st:  					ResolveResult shortRR = null;  					ResolveResult withExtraAttrSuffix = resolver.LookupSimpleNameOrTypeName(type.Name + "Attribute"' EmptyList<IType>.Instance' NameLookupMode.Type);  					if (shortName != null) {  						shortRR = resolver.LookupSimpleNameOrTypeName(shortName' EmptyList<IType>.Instance' NameLookupMode.Type);  					}  					// short type is either unknown or not an attribute type -> we can use the short name.  					if (shortRR != null && (shortRR is UnknownIdentifierResolveResult || !IsAttributeType(shortRR))) {  						st.Identifier = shortName;  					} else if (IsAttributeType(withExtraAttrSuffix)) {  						// typeName + "Attribute" is an attribute type -> we cannot use long type name' add '@' to disable implicit "Attribute" suffix.  						st.Identifier = '@' + st.Identifier;  					}  					break;  				case MemberType mt:  					if (type.DeclaringType != null) {  						var declaringTypeDef = type.DeclaringType.GetDefinition();  						if (declaringTypeDef != null) {  							if (shortName != null && !declaringTypeDef.GetNestedTypes(t => t.TypeParameterCount == 0 && t.Name == shortName).Any(IsAttributeType)) {  								mt.MemberName = shortName;  							} else if (declaringTypeDef.GetNestedTypes(t => t.TypeParameterCount == 0 && t.Name == type.Name + "Attribute").Any(IsAttributeType)) {  								mt.MemberName = '@' + mt.MemberName;  							}  						}  					} else if (mt.Target.GetResolveResult() is NamespaceResolveResult nrr) {  						if (shortName != null && !IsAttributeType(nrr.Namespace.GetTypeDefinition(shortName' 0))) {  							mt.MemberName = shortName;  						} else if (IsAttributeType(nrr.Namespace.GetTypeDefinition(type.Name + "Attribute"' 0))) {  							mt.MemberName = '@' + mt.MemberName;  						}  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsSpecialConstant,The following switch statement is missing a default case: switch ((double)constant) {  						case double.NegativeInfinity: // (-1.0 / 0.0)  							var left = new PrimitiveExpression(-1.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' -1.0));  							var right = new PrimitiveExpression(0.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' double.NegativeInfinity));  							return true;  						case double.PositiveInfinity: // (1.0 / 0.0)  							left = new PrimitiveExpression(1.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 1.0));  							right = new PrimitiveExpression(0.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' double.PositiveInfinity));  							return true;  						case double.NaN: // (0.0 / 0.0)  							left = new PrimitiveExpression(0.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0));  							right = new PrimitiveExpression(0.0).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' double.NaN));  							return true;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsSpecialConstant,The following switch statement is missing a default case: switch ((float)constant) {  						case float.NegativeInfinity: // (-1.0f / 0.0f)  							var left = new PrimitiveExpression(-1.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' -1.0f));  							var right = new PrimitiveExpression(0.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0f));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' float.NegativeInfinity));  							return true;  						case float.PositiveInfinity: // (1.0f / 0.0f)  							left = new PrimitiveExpression(1.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 1.0f));  							right = new PrimitiveExpression(0.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0f));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' float.PositiveInfinity));  							return true;  						case float.NaN: // (0.0f / 0.0f)  							left = new PrimitiveExpression(0.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0f));  							right = new PrimitiveExpression(0.0f).WithoutILInstruction().WithRR(new ConstantResolveResult(constantType' 0.0f));  							expression = new BinaryOperatorExpression(left' BinaryOperatorType.Divide' right).WithoutILInstruction()  								.WithRR(new ConstantResolveResult(constantType' float.NaN));  							return true;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,The following switch statement is missing a default case: switch (enumBaseTypeCode) {  					case TypeCode.Byte:  					case TypeCode.SByte:  						negatedEnumValue &= byte.MaxValue;  						break;  					case TypeCode.Int16:  					case TypeCode.UInt16:  						negatedEnumValue &= ushort.MaxValue;  						break;  					case TypeCode.Int32:  					case TypeCode.UInt32:  						negatedEnumValue &= uint.MaxValue;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitUndocumentedExpression,The following switch statement is missing a default case: switch (undocumentedExpression.UndocumentedExpressionType) {  				case UndocumentedExpressionType.ArgList:  				case UndocumentedExpressionType.ArgListAccess:  					WriteKeyword(UndocumentedExpression.ArglistKeywordRole);  					break;  				case UndocumentedExpressionType.MakeRef:  					WriteKeyword(UndocumentedExpression.MakerefKeywordRole);  					break;  				case UndocumentedExpressionType.RefType:  					WriteKeyword(UndocumentedExpression.ReftypeKeywordRole);  					break;  				case UndocumentedExpressionType.RefValue:  					WriteKeyword(UndocumentedExpression.RefvalueKeywordRole);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitQueryOrdering,The following switch statement is missing a default case: switch (queryOrdering.Direction) {  				case QueryOrderingDirection.Ascending:  					Space();  					WriteKeyword(QueryOrdering.AscendingKeywordRole);  					break;  				case QueryOrderingDirection.Descending:  					Space();  					WriteKeyword(QueryOrdering.DescendingKeywordRole);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitParameterDeclaration,The following switch statement is missing a default case: switch (parameterDeclaration.ParameterModifier) {  				case ParameterModifier.Ref:  					WriteKeyword(ParameterDeclaration.RefModifierRole);  					Space();  					break;  				case ParameterModifier.Out:  					WriteKeyword(ParameterDeclaration.OutModifierRole);  					Space();  					break;  				case ParameterModifier.Params:  					WriteKeyword(ParameterDeclaration.ParamsModifierRole);  					Space();  					break;  				case ParameterModifier.In:  					WriteKeyword(ParameterDeclaration.InModifierRole);  					Space();  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,VisitCastExpression,The following switch statement is missing a default case: switch (typeCode) {  					case TypeCode.SByte:  						if ((sbyte)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int16:  						if ((short)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int32:  						if ((int)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int64:  						if ((long)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Single:  						if ((float)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Double:  						if ((double)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Decimal:  						if ((decimal)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,UpdateEndLocation,The following switch statement is missing a default case: switch (ch) {  					case '\r':  						if (i + 1 < content.Length && content[i + 1] == '\n')  							i++;  						goto case '\n';  					case '\n':  						line++;  						column = 0;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,IsPrintableIdentifierChar,The following switch statement is missing a default case: switch (identifier[index]) {  				case '\\':  					return false;  				case ' ':  				case '_':  				case '`':  				case '^':  					return true;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackGenericArrayInterface,The following switch statement is missing a default case: switch (pt.GetDefinition()?.KnownTypeCode) {  					case KnownTypeCode.IListOfT:  					case KnownTypeCode.ICollectionOfT:  					case KnownTypeCode.IEnumerableOfT:  					case KnownTypeCode.IReadOnlyListOfT:  						return pt.GetTypeArgument(0);  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ImplicitConstantExpressionConversion,The following switch statement is missing a default case: switch (toTypeCode) {  					case TypeCode.SByte:  						return val >= SByte.MinValue && val <= SByte.MaxValue;  					case TypeCode.Byte:  						return val >= Byte.MinValue && val <= Byte.MaxValue;  					case TypeCode.Int16:  						return val >= Int16.MinValue && val <= Int16.MaxValue;  					case TypeCode.UInt16:  						return val >= UInt16.MinValue && val <= UInt16.MaxValue;  					case TypeCode.UInt32:  						return val >= 0;  					case TypeCode.UInt64:  						return val >= 0;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,UnaryNumericPromotion,The following switch statement is missing a default case: switch (op) {  				case UnaryOperatorType.Minus:  					if (code == TypeCode.UInt32) {  						type = compilation.FindType(KnownTypeCode.Int64);  						return Convert(expression' MakeNullable(type' isNullable)'  						               isNullable ? Conversion.ImplicitNullableConversion : Conversion.ImplicitNumericConversion);  					}  					goto case UnaryOperatorType.Plus;  				case UnaryOperatorType.Plus:  				case UnaryOperatorType.BitNot:  					if (code >= TypeCode.Char && code <= TypeCode.UInt16) {  						type = compilation.FindType(KnownTypeCode.Int32);  						return Convert(expression' MakeNullable(type' isNullable)'  						               isNullable ? Conversion.ImplicitNullableConversion : Conversion.ImplicitNumericConversion);  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The following switch statement is missing a default case: switch (lookupMode) {  						case NameLookupMode.Expression:  							cache = currentTypeDefinitionCache.SimpleNameLookupCacheExpression;  							break;  						case NameLookupMode.InvocationTarget:  							cache = currentTypeDefinitionCache.SimpleNameLookupCacheInvocationTarget;  							break;  						case NameLookupMode.Type:  							cache = currentTypeDefinitionCache.SimpleTypeLookupCache;  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The following switch statement is missing a default case: switch (target.Type.Kind) {  				case TypeKind.Dynamic:  					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames));  					  				case TypeKind.Array:  				case TypeKind.Pointer:  					// 7.6.6.1 Array access / 18.5.3 Pointer element access  					AdjustArrayAccessArguments(arguments);  					return new ArrayAccessResolveResult(((TypeWithElementType)target.Type).ElementType' target' arguments);  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following switch statement is missing a default case: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,The following switch statement is missing a default case: switch (typeArgument.Kind) { // void' null' and pointers cannot be used as type arguments  				case TypeKind.Void:  				case TypeKind.Null:  				case TypeKind.Pointer:  					return false;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following switch statement is missing a default case: switch (conversions.BetterConversion(arguments[i]' c1.ParameterTypes[p1]' c2.ParameterTypes[p2])) {  						case 1:  							c1IsBetter = true;  							break;  						case 2:  							c2IsBetter = true;  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following switch statement is missing a default case: switch (MoreSpecificFormalParameter(pair.Item1' pair.Item2)) {  					case 1:  						c1IsBetter = true;  						break;  					case 2:  						c2IsBetter = true;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ConsiderIfNewCandidateIsBest,The following switch statement is missing a default case: switch (BetterFunctionMember(candidate' bestCandidate)) {  					case 0:  						// Overwrite 'bestCandidateAmbiguousWith' so that API users can  						// detect the set of all ambiguous methods if they look at  						// bestCandidateAmbiguousWith after each step.  						bestCandidateAmbiguousWith = candidate;  						break;  					case 1:  						bestCandidate = candidate;  						bestCandidateWasValidated = false;  						bestCandidateAmbiguousWith = null;  						break;  						// case 2: best candidate stays best  				}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following switch statement is missing a default case: switch (switchBlock.Instructions[0]) {  				case SwitchInstruction switchInst:  					if (switchBlock.Instructions.Count != 1)  						return false;  					if (!switchInst.Value.MatchLdLoc(switchIndexVar))  						return false;  					sections.AddRange(switchInst.Sections);  					break;  				case IfInstruction ifInst:  					if (switchBlock.Instructions.Count != 2)  						return false;  					if (!ifInst.Condition.MatchCompEquals(out left' out right))  						return false;  					if (!left.MatchLdLoc(switchIndexVar))  						return false;  					if (!right.MatchLdcI4(0))  						return false;  					sections.Add(new SwitchSection() { Body = ifInst.TrueInst' Labels = new LongSet(0) }.WithILRange(ifInst));  					sections.Add(new SwitchSection() { Body = switchBlock.Instructions[1]' Labels = new LongSet(0).Invert() }.WithILRange(switchBlock.Instructions[1]));  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInstruction,The following switch statement is missing a default case: switch (invocation.Method.Name) {  							case "Add":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Add' false);  							case "AddChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Add' true);  							case "And":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitAnd);  							case "AndAlso":  								return ConvertLogicOperator(invocation' true);  							case "ArrayAccess":  							case "ArrayIndex":  								return ConvertArrayIndex(invocation);  							case "ArrayLength":  								return ConvertArrayLength(invocation);  							case "Call":  								return ConvertCall(invocation);  							case "Coalesce":  								return ConvertCoalesce(invocation);  							case "Condition":  								return ConvertCondition(invocation);  							case "Constant":  								return ConvertConstant(invocation);  							case "Convert":  								return ConvertCast(invocation' false);  							case "ConvertChecked":  								return ConvertCast(invocation' true);  							case "Divide":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Div);  							case "Equal":  								return ConvertComparison(invocation' ComparisonKind.Equality);  							case "ExclusiveOr":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitXor);  							case "Field":  								return ConvertField(invocation' typeHint);  							case "GreaterThan":  								return ConvertComparison(invocation' ComparisonKind.GreaterThan);  							case "GreaterThanOrEqual":  								return ConvertComparison(invocation'  ComparisonKind.GreaterThanOrEqual);  							case "Invoke":  								return ConvertInvoke(invocation);  							case "Lambda":  								return ConvertLambda(invocation);  							case "LeftShift":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.ShiftLeft);  							case "LessThan":  								return ConvertComparison(invocation' ComparisonKind.LessThan);  							case "LessThanOrEqual":  								return ConvertComparison(invocation' ComparisonKind.LessThanOrEqual);  							case "ListInit":  								return ConvertListInit(invocation);  							case "MemberInit":  								return ConvertMemberInit(invocation);  							case "Modulo":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Rem);  							case "Multiply":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Mul' false);  							case "MultiplyChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Mul' true);  							case "Negate":  								return ConvertUnaryNumericOperator(invocation' BinaryNumericOperator.Sub' false);  							case "NegateChecked":  								return ConvertUnaryNumericOperator(invocation' BinaryNumericOperator.Sub' true);  							case "New":  								return ConvertNewObject(invocation);  							case "NewArrayBounds":  								return ConvertNewArrayBounds(invocation);  							case "NewArrayInit":  								return ConvertNewArrayInit(invocation);  							case "Not":  								return ConvertNotOperator(invocation);  							case "NotEqual":  								return ConvertComparison(invocation' ComparisonKind.Inequality);  							case "OnesComplement":  								return ConvertNotOperator(invocation);  							case "Or":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitOr);  							case "OrElse":  								return ConvertLogicOperator(invocation' false);  							case "Property":  								return ConvertProperty(invocation);  							case "Quote":  								return ConvertQuote(invocation);  							case "RightShift":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.ShiftRight);  							case "Subtract":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Sub' false);  							case "SubtractChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Sub' true);  							case "TypeAs":  								return ConvertTypeAs(invocation);  							case "TypeIs":  								return ConvertTypeIs(invocation);  						}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBind,The following switch statement is missing a default case: switch (member) {  				case IMethod method:  					return (new Call(method) { Arguments = { new LdLoc(targetVariable)' value } }' method.ReturnType);  				case IField field:  					return (new StObj(new LdFlda(new LdLoc(targetVariable)' (IField)member)' value' member.ReturnType)' field.ReturnType);  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following switch statement is missing a default case: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					IMethod method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					method = (IMethod)member;  					if (!ConvertCallArguments(arguments' method))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj(method);  					newObj.Arguments.AddRange(arguments);  					return (newObj' member.DeclaringType);  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetMethodFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetConstructorFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetFieldFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following switch statement is missing a default case: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following switch statement is missing a default case: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = call.GetParameter(i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The following switch statement is missing a default case: switch (body.Instructions[i + pos]) {  						case CallInstruction call:  							if (!(call is CallVirt || call is Call)) continue;  							var newCall = call;  							var newTarget = newCall.Arguments[0];  							foreach (var load in newTarget.Descendants.OfType<IInstructionWithVariableOperand>())  								if ((load is LdLoc || load is LdLoca) && load.Variable == v)  									load.Variable = finalSlot;  							initializerBlock.Instructions.Add(newCall);  							break;  						case StObj stObj:  							var newStObj = stObj;  							foreach (var load in newStObj.Target.Descendants.OfType<IInstructionWithVariableOperand>())  								if ((load is LdLoc || load is LdLoca) && load.Variable == v)  									load.Variable = finalSlot;  							initializerBlock.Instructions.Add(newStObj);  							break;  						case StLoc stLoc:  							var newStLoc = stLoc;  							initializerBlock.Instructions.Add(newStLoc);  							break;  					}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,NonAggressiveInlineInto,The following switch statement is missing a default case: switch (inlinedExpression.OpCode) {  				case OpCode.DefaultValue:  				case OpCode.StObj:  				case OpCode.NumericCompoundAssign:  				case OpCode.UserDefinedCompoundAssign:  				case OpCode.Await:  					return true;  				case OpCode.LdLoc:  					if (v.StateMachineField == null && ((LdLoc)inlinedExpression).Variable.StateMachineField != null) {  						// Roslyn likes to put the result of fetching a state machine field into a temporary variable'  						// so inline more aggressively in such cases.  						return true;  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,ILInlining,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,NonAggressiveInlineInto,The following switch statement is missing a default case: switch (parent.OpCode) {  				case OpCode.NullCoalescingInstruction:  					if (NullableType.IsNullable(v.Type))  						return true; // inline nullables into ?? operator  					break;  				case OpCode.NullableUnwrap:  					return true; // inline into ?. operator  				case OpCode.UserDefinedLogicOperator:  				case OpCode.DynamicLogicOperatorInstruction:  					return true; // inline into (left slot of) user-defined && or || operator  				case OpCode.DynamicGetMemberInstruction:  				case OpCode.DynamicGetIndexInstruction:  					if (parent.Parent.OpCode == OpCode.DynamicCompoundAssign)  						return true; // inline into dynamic compound assignments  					break;  				case OpCode.DynamicCompoundAssign:  					return true;  				case OpCode.ArrayToPointer:  				case OpCode.LocAllocSpan:  					return true; // inline size-expressions into localloc.span  				case OpCode.Call:  				case OpCode.CallVirt:  					// Aggressive inline into property/indexer getter calls for compound assignment calls  					// (The compiler generates locals for these because it doesn't want to evalute the args twice for getter+setter)  					if (parent.SlotInfo == CompoundAssignmentInstruction.TargetSlot) {  						return true;  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following switch statement is missing a default case: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  				case BinaryNumericOperator.BitAnd:  					if (inst.Left.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean)  						&& inst.Right.InferType(context.TypeSystem).IsKnownType(KnownTypeCode.Boolean))  					{  						if (new NullableLiftingTransform(context).Run(inst)) {  							// e.g. "(a.GetValueOrDefault() == b.GetValueOrDefault()) & (a.HasValue & b.HasValue)"  						}  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsImplicitTruncation,The following switch statement is missing a default case: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  					case KnownTypeCode.Boolean:  						return !(val == 0 || val == 1);  					case KnownTypeCode.Byte:  						return !(val >= byte.MinValue && val <= byte.MaxValue);  					case KnownTypeCode.SByte:  						return !(val >= sbyte.MinValue && val <= sbyte.MaxValue);  					case KnownTypeCode.Int16:  						return !(val >= short.MinValue && val <= short.MaxValue);  					case KnownTypeCode.UInt16:  					case KnownTypeCode.Char:  						return !(val >= ushort.MinValue && val <= ushort.MaxValue);  				}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsImplicitTruncation,The following switch statement is missing a default case: switch (bni.Operator) {  					case BinaryNumericOperator.BitAnd:  					case BinaryNumericOperator.BitOr:  					case BinaryNumericOperator.BitXor:  						// If both input values fit into the type without truncation'  						// the result of a binary operator will also fit.  						return IsImplicitTruncation(bni.Left' type' compilation' allowNullableValue)  							|| IsImplicitTruncation(bni.Right' type' compilation' allowNullableValue);  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem.Implementation,AttributeListBuilder,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AttributeListBuilder.cs,ConvertMarshalInfo,The following switch statement is missing a default case: switch (type) {  				case 0x1e: // FixedArray  					if (!marshalInfo.TryReadCompressedInteger(out size))  						size = 0;  					b.AddNamedArg("SizeConst"' KnownTypeCode.Int32' size);  					if (marshalInfo.RemainingBytes > 0) {  						type = marshalInfo.ReadByte();  						if (type != 0x66) // None  							b.AddNamedArg("ArraySubType"' unmanagedTypeType' type);  					}  					break;  				case 0x1d: // SafeArray  					if (marshalInfo.RemainingBytes > 0) {  						VarEnum varType = (VarEnum)marshalInfo.ReadByte();  						if (varType != VarEnum.VT_EMPTY) {  							var varEnumType = new TopLevelTypeName(InteropServices' nameof(VarEnum));  							b.AddNamedArg("SafeArraySubType"' varEnumType' (int)varType);  						}  					}  					break;  				case 0x2a: // NATIVE_TYPE_ARRAY  					if (marshalInfo.RemainingBytes > 0) {  						type = marshalInfo.ReadByte();  					} else {  						type = 0x66; // Cecil uses NativeType.None as default.  					}  					if (type != 0x50) { // Max  						b.AddNamedArg("ArraySubType"' unmanagedTypeType' type);  					}  					int sizeParameterIndex = marshalInfo.TryReadCompressedInteger(out int value) ? value : -1;  					size = marshalInfo.TryReadCompressedInteger(out value) ? value : -1;  					int sizeParameterMultiplier = marshalInfo.TryReadCompressedInteger(out value) ? value : -1;  					if (size >= 0) {  						b.AddNamedArg("SizeConst"' KnownTypeCode.Int32' size);  					}  					if (sizeParameterMultiplier != 0 && sizeParameterIndex >= 0) {  						b.AddNamedArg("SizeParamIndex"' KnownTypeCode.Int16' (short)sizeParameterIndex);  					}  					break;  				case 0x2c: // CustomMarshaler  					string guidValue = marshalInfo.ReadSerializedString();  					string unmanagedType = marshalInfo.ReadSerializedString();  					string managedType = marshalInfo.ReadSerializedString();  					string cookie = marshalInfo.ReadSerializedString();  					if (managedType != null) {  						b.AddNamedArg("MarshalType"' KnownTypeCode.String' managedType);  					}  					if (!string.IsNullOrEmpty(cookie)) {  						b.AddNamedArg("MarshalCookie"' KnownTypeCode.String' cookie);  					}  					break;  				case 0x17: // FixedSysString  					b.AddNamedArg("SizeConst"' KnownTypeCode.Int32' marshalInfo.ReadCompressedInteger());  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataMethod,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataMethod.cs,GetAttributes,The following switch statement is missing a default case: switch (info.Attributes & MethodImportAttributes.CharSetMask) {  					case MethodImportAttributes.CharSetAnsi:  						charSet = CharSet.Ansi;  						break;  					case MethodImportAttributes.CharSetAuto:  						charSet = CharSet.Auto;  						break;  					case MethodImportAttributes.CharSetUnicode:  						charSet = CharSet.Unicode;  						break;  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,GetAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.LayoutMask) {  				case TypeAttributes.SequentialLayout:  					layoutKind = LayoutKind.Sequential;  					break;  				case TypeAttributes.ExplicitLayout:  					layoutKind = LayoutKind.Explicit;  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem.Implementation,MetadataTypeDefinition,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\MetadataTypeDefinition.cs,GetAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.StringFormatMask) {  				case TypeAttributes.AnsiClass:  					charSet = CharSet.Ansi;  					break;  				case TypeAttributes.AutoClass:  					charSet = CharSet.Auto;  					break;  				case TypeAttributes.UnicodeClass:  					charSet = CharSet.Unicode;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,TryRemoveTransparentIdentifier,The following switch statement is missing a default case: switch (expr) {  					case IdentifierExpression identifier:  						// nothing to add  						continue;  					case MemberReferenceExpression member:  						AddQueryLetClause(member.MemberName' member);  						break;  					case NamedExpression namedExpression:  						if (namedExpression.Expression is IdentifierExpression identifierExpression && namedExpression.Name == identifierExpression.Identifier) {  							letClauses[namedExpression.Name] = identifierExpression.Annotation<ILVariableResolveResult>();  							continue;  						}  						AddQueryLetClause(namedExpression.Name' namedExpression.Expression);  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,CanBeDeclaredAsOutVariable,The following switch statement is missing a default case: switch (node) {  					case IfElseStatement _:  // variable declared in if condition appears in parent scope  					case ExpressionStatement _:  						return node == v.InsertionPoint.nextNode;  					case Statement _:  						return false; // other statements (e.g. while) don't allow variables to be promoted to parent scope  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,VisitBinaryOperatorExpression,The following switch statement is missing a default case: switch (expr.Operator) {  				case BinaryOperatorType.ConditionalAnd:  				case BinaryOperatorType.ConditionalOr:  					// a && (b && c) ==> (a && b) && c  					var bAndC = expr.Right as BinaryOperatorExpression;  					if (bAndC != null && bAndC.Operator == expr.Operator) {  						// make bAndC the parent and expr the child  						var b = bAndC.Left.Detach();  						var c = bAndC.Right.Detach();  						expr.ReplaceWith(bAndC.Detach());  						bAndC.Left = expr;  						bAndC.Right = c;  						expr.Right = b;  						return base.VisitBinaryOperatorExpression(bAndC);  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,VisitConstructorDeclaration,The following switch statement is missing a default case: switch (stmt.Expression) {  				// Pattern for reference types:  				// this..ctor(...);  				case InvocationExpression invocation:  					if (!(invocation.Target is MemberReferenceExpression mre) || mre.MemberName != ".ctor")  						return;  					if (!(invocation.GetSymbol() is IMethod ctor && ctor.IsConstructor))  						return;  					ci = new ConstructorInitializer();  					var target = mre.Target;  					// Ignore casts' those might be added if references are missing.  					if (target is CastExpression cast)  						target = cast.Expression;  					if (target is ThisReferenceExpression)  						ci.ConstructorInitializerType = ConstructorInitializerType.This;  					else if (target is BaseReferenceExpression)  						ci.ConstructorInitializerType = ConstructorInitializerType.Base;  					else  						return;  					// Move arguments from invocation to initializer:  					invocation.Arguments.MoveTo(ci.Arguments);  					// Add the initializer: (unless it is the default 'base()')  					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))  						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(invocation);  					// Remove the statement:  					stmt.Remove();  					break;  				// Pattern for value types:  				// this = new TSelf(...);  				case AssignmentExpression assignment:  					if (!(assignment.Right is ObjectCreateExpression oce && oce.GetSymbol() is IMethod ctor2 && ctor2.DeclaringTypeDefinition == currentCtor.DeclaringTypeDefinition))  						return;  					ci = new ConstructorInitializer();  					if (assignment.Left is ThisReferenceExpression)  						ci.ConstructorInitializerType = ConstructorInitializerType.This;  					else  						return;  					// Move arguments from invocation to initializer:  					oce.Arguments.MoveTo(ci.Arguments);  					// Add the initializer: (unless it is the default 'base()')  					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))  						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(oce);  					// Remove the statement:  					stmt.Remove();  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following switch statement is missing a default case: switch (method.FullName) {  				case "System.Type.GetTypeFromHandle":  					if (arguments.Length == 1) {  						if (typeHandleOnTypeOfPattern.IsMatch(arguments[0])) {  							Expression target = ((MemberReferenceExpression)arguments[0]).Target;  							target.CopyInstructionsFrom(invocationExpression);  							invocationExpression.ReplaceWith(target);  							return;  						}  					}  					break;  					/*  				case "System.Reflection.FieldInfo.GetFieldFromHandle":  					// TODO : This is dead code because LdTokenAnnotation is not added anywhere:  					if (arguments.Length == 1) {  						MemberReferenceExpression mre = arguments[0] as MemberReferenceExpression;  						if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation>() != null) {  							invocationExpression.ReplaceWith(mre.Target);  							return;  						}  					} else if (arguments.Length == 2) {  						MemberReferenceExpression mre1 = arguments[0] as MemberReferenceExpression;  						MemberReferenceExpression mre2 = arguments[1] as MemberReferenceExpression;  						if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation>() != null) {  							if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  								Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single();  								FieldReference field = oldArg.Annotation<FieldReference>();  								if (field != null) {  									AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach();  									oldArg.ReplaceWith(new MemberReferenceExpression(new TypeReferenceExpression(declaringType)' field.Name).CopyAnnotationsFrom(oldArg));  									invocationExpression.ReplaceWith(mre1.Target);  									return;  								}  							}  						}  					}  					break;  					*/  				case "System.Activator.CreateInstance":  					if (arguments.Length == 0 && method.TypeArguments.Count == 1 && IsInstantiableTypeParameter(method.TypeArguments[0])) {  						invocationExpression.ReplaceWith(new ObjectCreateExpression(context.TypeSystemAstBuilder.ConvertType(method.TypeArguments.First())));  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WriteIdentifier,The following switch statement is missing a default case: switch (definition) {  				case IType t:  					output.WriteReference(t' name' true);  					return;  				case IMember m:  					output.WriteReference(m' name' true);  					return;  			}
Missing Default,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WriteIdentifier,The following switch statement is missing a default case: switch (member) {  				case IType t:  					output.WriteReference(t' name' false);  					return;  				case IMember m:  					output.WriteReference(m' name' false);  					return;  			}
Missing Default,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WriteToken,The following switch statement is missing a default case: switch (member) {  							case IType t:  								output.WriteReference(t' token' false);  								return;  							case IMember m:  								output.WriteReference(m' token' false);  								return;  						}
Missing Default,ICSharpCode.Decompiler,TextTokenWriter,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WritePrimitiveType,The following switch statement is missing a default case: switch (symbol) {  						case IType t:  							output.WriteReference(t' type' false);  							return;  						case IMember m:  							output.WriteReference(m' type' false);  							return;  					}
Missing Default,ICSharpCode.Decompiler.Disassembler,ILParser,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILParser.cs,SkipOperand,The following switch statement is missing a default case: switch (opCode.GetOperandType()) {  				// 64-bit  				case OperandType.I8:  				case OperandType.R:  					blob.Offset += 8;  					break;  				// 32-bit  				case OperandType.BrTarget:  				case OperandType.Field:  				case OperandType.Method:  				case OperandType.I:  				case OperandType.Sig:  				case OperandType.String:  				case OperandType.Tok:  				case OperandType.Type:  				case OperandType.ShortR:  					blob.Offset += 4;  					break;  				// (n + 1) * 32-bit  				case OperandType.Switch:  					uint n = blob.ReadUInt32();  					blob.Offset += (int)(n * 4);  					break;  				// 16-bit  				case OperandType.Variable:  					blob.Offset += 2;  					break;  				// 8-bit  				case OperandType.ShortVariable:  				case OperandType.ShortBrTarget:  				case OperandType.ShortI:  					blob.Offset++;  					break;  			}
Missing Default,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The following switch statement is missing a default case: switch (opCode.GetOperandType()) {  					case OperandType.BrTarget:  					case OperandType.ShortBrTarget:  						output.Write(' ');  						int targetOffset = ILParser.DecodeBranchTarget(ref blob' opCode);  						output.WriteLocalReference($"IL_{targetOffset:x4}"' targetOffset);  						break;  					case OperandType.Field:  					case OperandType.Method:  					case OperandType.Sig:  					case OperandType.Type:  						output.Write(' ');  						int metadataToken = blob.ReadInt32();  						EntityHandle? handle = MetadataTokenHelpers.TryAsEntityHandle(metadataToken);  						try {  							handle?.WriteTo(module' output' genericContext);  						} catch (BadImageFormatException) {  							handle = null;  						}  						WriteMetadataToken(handle' metadataToken' spaceBefore: true);  						break;  					case OperandType.Tok:  						output.Write(' ');  						metadataToken = blob.ReadInt32();  						handle = MetadataTokenHelpers.TryAsEntityHandle(metadataToken);  						switch (handle?.Kind) {  							case HandleKind.MemberReference:  								switch (metadata.GetMemberReference((MemberReferenceHandle)handle).GetKind()) {  									case MemberReferenceKind.Method:  										output.Write("method ");  										break;  									case MemberReferenceKind.Field:  										output.Write("field ");  										break;  								}  								break;  							case HandleKind.FieldDefinition:  								output.Write("field ");  								break;  							case HandleKind.MethodDefinition:  								output.Write("method ");  								break;  						}  						try {  							handle?.WriteTo(module' output' genericContext);  						} catch (BadImageFormatException) {  							handle = null;  						}  						WriteMetadataToken(handle' metadataToken' spaceBefore: true);  						break;  					case OperandType.ShortI:  						output.Write(' ');  						DisassemblerHelpers.WriteOperand(output' blob.ReadSByte());  						break;  					case OperandType.I:  						output.Write(' ');  						DisassemblerHelpers.WriteOperand(output' blob.ReadInt32());  						break;  					case OperandType.I8:  						output.Write(' ');  						DisassemblerHelpers.WriteOperand(output' blob.ReadInt64());  						break;  					case OperandType.ShortR:  						output.Write(' ');  						DisassemblerHelpers.WriteOperand(output' blob.ReadSingle());  						break;  					case OperandType.R:  						output.Write(' ');  						DisassemblerHelpers.WriteOperand(output' blob.ReadDouble());  						break;  					case OperandType.String:  						metadataToken = blob.ReadInt32();  						output.Write(' ');  						UserStringHandle? userString;  						string text;  						try {  							userString = MetadataTokens.UserStringHandle(metadataToken);  							text = metadata.GetUserString(userString.Value);  						} catch (BadImageFormatException) {  							userString = null;  							text = null;  						}  						if (userString != null) {  							DisassemblerHelpers.WriteOperand(output' text);  						}  						WriteMetadataToken(userString' metadataToken' spaceBefore: true);  						break;  					case OperandType.Switch:  						int[] targets = ILParser.DecodeSwitchTargets(ref blob);  						output.Write(" (");  						for (int i = 0; i < targets.Length; i++) {  							if (i > 0)  								output.Write("' ");  							output.WriteLocalReference($"IL_{targets[i]:x4}"' targets[i]);  						}  						output.Write(")");  						break;  					case OperandType.Variable:  						output.Write(' ');  						int index = blob.ReadUInt16();  						if (opCode == ILOpCode.Ldloc || opCode == ILOpCode.Ldloca || opCode == ILOpCode.Stloc) {  							DisassemblerHelpers.WriteVariableReference(output' metadata' methodDefinition' index);  						} else {  							DisassemblerHelpers.WriteParameterReference(output' metadata' methodDefinition' index);  						}  						break;  					case OperandType.ShortVariable:  						output.Write(' ');  						index = blob.ReadByte();  						if (opCode == ILOpCode.Ldloc_s || opCode == ILOpCode.Ldloca_s || opCode == ILOpCode.Stloc_s) {  							DisassemblerHelpers.WriteVariableReference(output' metadata' methodDefinition' index);  						} else {  							DisassemblerHelpers.WriteParameterReference(output' metadata' methodDefinition' index);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The following switch statement is missing a default case: switch (handle?.Kind) {  							case HandleKind.MemberReference:  								switch (metadata.GetMemberReference((MemberReferenceHandle)handle).GetKind()) {  									case MemberReferenceKind.Method:  										output.Write("method ");  										break;  									case MemberReferenceKind.Field:  										output.Write("field ");  										break;  								}  								break;  							case HandleKind.FieldDefinition:  								output.Write("field ");  								break;  							case HandleKind.MethodDefinition:  								output.Write("method ");  								break;  						}
Missing Default,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The following switch statement is missing a default case: switch (metadata.GetMemberReference((MemberReferenceHandle)handle).GetKind()) {  									case MemberReferenceKind.Method:  										output.Write("method ");  										break;  									case MemberReferenceKind.Field:  										output.Write("field ");  										break;  								}
Missing Default,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The following switch statement is missing a default case: switch (info.Attributes & MethodImportAttributes.CharSetMask) {  						case MethodImportAttributes.CharSetAnsi:  							output.Write(" ansi");  							break;  						case MethodImportAttributes.CharSetAuto:  							output.Write(" autochar");  							break;  						case MethodImportAttributes.CharSetUnicode:  							output.Write(" unicode");  							break;  					}
Missing Default,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The following switch statement is missing a default case: switch (info.Attributes & MethodImportAttributes.CallingConventionMask) {  						case MethodImportAttributes.CallingConventionCDecl:  							output.Write(" cdecl");  							break;  						case MethodImportAttributes.CallingConventionFastCall:  							output.Write(" fastcall");  							break;  						case MethodImportAttributes.CallingConventionStdCall:  							output.Write(" stdcall");  							break;  						case MethodImportAttributes.CallingConventionThisCall:  							output.Write(" thiscall");  							break;  						case MethodImportAttributes.CallingConventionWinApi:  							output.Write(" winapi");  							break;  					}
Missing Default,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,TryDecodeSecurityDeclaration,The following switch statement is missing a default case: switch (argument.Kind) {  						case CustomAttributeNamedArgumentKind.Field:  							output.Write("field ");  							break;  						case CustomAttributeNamedArgumentKind.Property:  							output.Write("property ");  							break;  					}
Missing Default,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,Visit,The following switch statement is missing a default case: switch (container.Kind) {  				case ContainerKind.Loop:  				case ContainerKind.While:  					continueTarget = container.EntryPoint;  					break;  				case ContainerKind.DoWhile:  				case ContainerKind.For:  					continueTarget = container.Blocks.Last();  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,ReduceNestingTransform,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ReduceNestingTransform.cs,Visit,The following switch statement is missing a default case: switch (inst) {  					case BlockContainer container:  						// visit the contents of the container  						Visit(container' continueTarget);    						// reduce nesting in switch blocks  						if (container.Kind == ContainerKind.Switch &&  								CanDuplicateExit(NextInsn()' continueTarget) &&  								ReduceSwitchNesting(block' container' NextInsn())) {  							RemoveRedundantExit(block' nextInstruction);  						}  						break;  					case IfInstruction ifInst:  						ImproveILOrdering(block' ifInst);  						  						// reduce nesting in if/else blocks  						if (CanDuplicateExit(NextInsn()' continueTarget) && ReduceNesting(block' ifInst' NextInsn()))  							RemoveRedundantExit(block' nextInstruction);  						  						// visit content blocks  						if (ifInst.TrueInst is Block trueBlock)  							Visit(trueBlock' continueTarget' NextInsn());  						  						if (ifInst.FalseInst is Block falseBlock) {  							if (ifInst.TrueInst.HasFlag(InstructionFlags.EndPointUnreachable)) {  								ExtractElseBlock(ifInst);  								break;  							}    							Visit(falseBlock' continueTarget' NextInsn());  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.IL,PointerArithmeticOffset,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\PointerArithmeticOffset.cs,ComputeSizeOf,The following switch statement is missing a default case: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Missing Default,ICSharpCode.Decompiler.IL,LdFlda,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,CheckInvariant,The following switch statement is missing a default case: switch (field.DeclaringType.IsReferenceType) {  				case true:  					Debug.Assert(target.ResultType == StackType.O'  						"Class fields can only be accessed with an object on the stack");  					break;  				case false:  					Debug.Assert(target.ResultType == StackType.I || target.ResultType == StackType.Ref'  						"Struct fields can only be accessed with a pointer on the stack");  					break;  				case null:  					// field of unresolved type  					Debug.Assert(target.ResultType == StackType.O || target.ResultType == StackType.I  						|| target.ResultType == StackType.Ref || target.ResultType == StackType.Unknown'  						"Field of unresolved type with invalid target");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckValidTarget,The following switch statement is missing a default case: switch (TargetKind) {  				case CompoundTargetKind.Address:  					Debug.Assert(target.ResultType == StackType.Ref || target.ResultType == StackType.I);  					break;  				case CompoundTargetKind.Property:  					Debug.Assert(target.OpCode == OpCode.Call || target.OpCode == OpCode.CallVirt);  					var owner = ((CallInstruction)target).Method.AccessorOwner as IProperty;  					Debug.Assert(owner != null && owner.CanSet);  					break;  				case CompoundTargetKind.Dynamic:  					Debug.Assert(target.OpCode == OpCode.DynamicGetMemberInstruction || target.OpCode == OpCode.DynamicGetIndexInstruction);  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteSuffix,The following switch statement is missing a default case: switch (TargetKind) {  				case CompoundTargetKind.Address:  					output.Write(".address");  					break;  				case CompoundTargetKind.Property:  					output.Write(".property");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteSuffix,The following switch statement is missing a default case: switch (EvalMode) {  				case CompoundEvalMode.EvaluatesToNewValue:  					output.Write(".new");  					break;  				case CompoundEvalMode.EvaluatesToOldValue:  					output.Write(".old");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following switch statement is missing a default case: switch (kind) {  				case ILFunctionKind.TopLevelFunction:  					Debug.Assert(Parent == null);  					Debug.Assert(DelegateType == null);  					Debug.Assert(DeclarationScope == null);  					Debug.Assert(Method != null);  					break;  				case ILFunctionKind.Delegate:  					Debug.Assert(DelegateType != null);  					Debug.Assert(DeclarationScope == null);  					Debug.Assert(!(DelegateType?.FullName == "System.Linq.Expressions.Expression" && DelegateType.TypeParameterCount == 1));  					break;  				case ILFunctionKind.ExpressionTree:  					Debug.Assert(DelegateType != null);  					Debug.Assert(DeclarationScope == null);  					Debug.Assert(DelegateType?.FullName == "System.Linq.Expressions.Expression" && DelegateType.TypeParameterCount == 1);  					break;  				case ILFunctionKind.LocalFunction:  					Debug.Assert(Parent is ILFunction && SlotInfo == ILFunction.LocalFunctionsSlot);  					Debug.Assert(DeclarationScope != null);  					Debug.Assert(DelegateType == null);  					Debug.Assert(Method != null);  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,ILFunction,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (kind) {  				case ILFunctionKind.ExpressionTree:  					output.Write(".ET");  					break;  				case ILFunctionKind.LocalFunction:  					output.Write(".local");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Kind) {  				case ContainerKind.Loop:  					output.Write("(while-true) ");  					break;  				case ContainerKind.Switch:  					output.Write("(switch) ");  					break;  				case ContainerKind.While:  					output.Write("(while) ");  					break;  				case ContainerKind.DoWhile:  					output.Write("(do-while) ");  					break;  				case ContainerKind.For:  					output.Write("(for) ");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,BlockContainer,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following switch statement is missing a default case: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					Debug.Assert(EntryPoint.IncomingEdgeCount == 1);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Block,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following switch statement is missing a default case: switch (this.Kind) {  				case BlockKind.ControlFlow:  					Debug.Assert(finalInstruction.OpCode == OpCode.Nop);  					break;  				case BlockKind.CallInlineAssign:  					Debug.Assert(MatchInlineAssignBlock(out _' out _));  					break;  				case BlockKind.CallWithNamedArgs:  					Debug.Assert(finalInstruction is CallInstruction);  					foreach (var inst in Instructions) {  						var stloc = inst as StLoc;  						Debug.Assert(stloc != null' "Instructions in CallWithNamedArgs must be assignments");  						Debug.Assert(stloc.Variable.Kind == VariableKind.NamedArgument);  						Debug.Assert(stloc.Variable.IsSingleDefinition && stloc.Variable.LoadCount == 1);  						Debug.Assert(stloc.Variable.LoadInstructions.Single().Parent == finalInstruction);  					}  					var call = (CallInstruction)finalInstruction;  					if (call.IsInstanceCall) {  						// special case: with instance calls' Instructions[0] must be for the this parameter  						ILVariable v = ((StLoc)Instructions[0]).Variable;  						Debug.Assert(call.Arguments[0].MatchLdLoc(v));  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Sign) {  				case Sign.Signed:  					output.Write(".signed");  					break;  				case Sign.Unsigned:  					output.Write(".unsigned");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Comp,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (LiftingKind) {  				case ComparisonLiftingKind.CSharp:  					output.Write(".lifted[C#]");  					break;  				case ComparisonLiftingKind.ThreeValuedLogic:  					output.Write(".lifted[3VL]");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Conv,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Kind) {  				case ConversionKind.SignExtend:  					output.Write("<sign extend>");  					break;  				case ConversionKind.ZeroExtend:  					output.Write("<zero extend>");  					break;  				case ConversionKind.Invalid:  					output.Write("<invalid>");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (currentTypeRef.ResolutionScope.Kind) {  								case HandleKind.ModuleDefinition:  									var modDef = metadata.GetModuleDefinition();  									output.Write(DisassemblerHelpers.Escape(metadata.GetString(modDef.Name)));  									break;  								case HandleKind.ModuleReference:  									break;  								case HandleKind.AssemblyReference:  									var asmRef = metadata.GetAssemblyReference((AssemblyReferenceHandle)currentTypeRef.ResolutionScope);  									output.Write(DisassemblerHelpers.Escape(metadata.GetString(asmRef.Name)));  									break;  							}
Missing Default,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (mr.GetKind()) {  						case MemberReferenceKind.Method:  							methodSignature = mr.DecodeMethodSignature(new DisassemblerSignatureProvider(module' output)' genericContext);  							WriteSignatureHeader(output' methodSignature);  							methodSignature.ReturnType(ILNameSyntax.SignatureNoNamedTypeParameters);  							output.Write(' ');  							WriteParent(output' module' metadata' mr.Parent' genericContext' syntax);  							output.Write("::");  							output.WriteReference(module' entity' DisassemblerHelpers.Escape(memberName));  							WriteParameterList(output' methodSignature);  							break;  						case MemberReferenceKind.Field:  							var fieldSignature = mr.DecodeFieldSignature(new DisassemblerSignatureProvider(module' output)' genericContext);  							fieldSignature(ILNameSyntax.SignatureNoNamedTypeParameters);  							output.Write(' ');  							WriteParent(output' module' metadata' mr.Parent' genericContext' syntax);  							output.Write("::");  							output.WriteReference(module' entity' DisassemblerHelpers.Escape(memberName));  							break;  					}
Missing Default,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (ms.Method.Kind) {  						case HandleKind.MethodDefinition:  							var methodDefinition = metadata.GetMethodDefinition((MethodDefinitionHandle)ms.Method);  							var methodName = metadata.GetString(methodDefinition.Name);  							methodSignature = methodDefinition.DecodeSignature(new DisassemblerSignatureProvider(module' output)' genericContext);  							WriteSignatureHeader(output' methodSignature);  							methodSignature.ReturnType(ILNameSyntax.SignatureNoNamedTypeParameters);  							output.Write(' ');  							var declaringType = methodDefinition.GetDeclaringType();  							if (!declaringType.IsNil) {  								((EntityHandle)declaringType).WriteTo(module' output' genericContext' ILNameSyntax.TypeName);  								output.Write("::");  							}  							bool isCompilerControlled = (methodDefinition.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope;  							if (isCompilerControlled) {  								output.Write(DisassemblerHelpers.Escape(methodName + "$PST" + MetadataTokens.GetToken(ms.Method).ToString("X8")));  							} else {  								output.Write(DisassemblerHelpers.Escape(methodName));  							}  							WriteTypeParameterList(output' syntax' substitution);  							WriteParameterList(output' methodSignature);  							break;  						case HandleKind.MemberReference:  							var memberReference = metadata.GetMemberReference((MemberReferenceHandle)ms.Method);  							memberName = metadata.GetString(memberReference.Name);  							methodSignature = memberReference.DecodeMethodSignature(new DisassemblerSignatureProvider(module' output)' genericContext);  							WriteSignatureHeader(output' methodSignature);  							methodSignature.ReturnType(ILNameSyntax.SignatureNoNamedTypeParameters);  							output.Write(' ');  							WriteParent(output' module' metadata' memberReference.Parent' genericContext' syntax);  							output.Write("::");  							output.Write(DisassemblerHelpers.Escape(memberName));  							WriteTypeParameterList(output' syntax' substitution);  							WriteParameterList(output' methodSignature);  							break;  					}
Missing Default,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteSignatureHeader,The following switch statement is missing a default case: switch (methodSignature.Header.CallingConvention) {  				case SignatureCallingConvention.CDecl:  					output.Write("unmanaged cdecl ");  					break;  				case SignatureCallingConvention.StdCall:  					output.Write("unmanaged stdcall ");  					break;  				case SignatureCallingConvention.ThisCall:  					output.Write("unmanaged thiscall ");  					break;  				case SignatureCallingConvention.FastCall:  					output.Write("unmanaged fastcall ");  					break;  				case SignatureCallingConvention.VarArgs:  					output.Write("vararg ");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,InstructionOutputExtensions,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteParent,The following switch statement is missing a default case: switch (parentHandle.Kind) {  				case HandleKind.MethodDefinition:  					var methodDef = metadata.GetMethodDefinition((MethodDefinitionHandle)parentHandle);  					((EntityHandle)methodDef.GetDeclaringType()).WriteTo(module' output' genericContext' syntax);  					break;  				case HandleKind.ModuleReference:  					output.Write('[');  					var moduleRef = metadata.GetModuleReference((ModuleReferenceHandle)parentHandle);  					output.Write(metadata.GetString(moduleRef.Name));  					output.Write(']');  					break;  				case HandleKind.TypeDefinition:  				case HandleKind.TypeReference:  				case HandleKind.TypeSpecification:  					parentHandle.WriteTo(module' output' genericContext' syntax);  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,ILVariable,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILVariable.cs,CheckInvariant,The following switch statement is missing a default case: switch (kind) {  				case VariableKind.Local:  				case VariableKind.ForeachLocal:  				case VariableKind.PinnedLocal:  				case VariableKind.UsingLocal:  				case VariableKind.ExceptionLocal:  				case VariableKind.DisplayClassLocal:  					// in range of LocalVariableSignature  					Debug.Assert(Index == null || Index >= 0);  					break;  				case VariableKind.Parameter:  					// -1 for the "this" parameter  					Debug.Assert(Index >= -1);  					Debug.Assert(Function == null || Index < Function.Parameters.Count);  					break;  				case VariableKind.ExceptionStackSlot:  					Debug.Assert(Index >= 0);  					break;  			}
Missing Default,ICSharpCode.Decompiler.Metadata,AssemblyNameReference,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\AssemblyReferences.cs,Parse,The following switch statement is missing a default case: switch (parts[0].ToLowerInvariant()) {  					case "version":  						name.Version = new Version(parts[1]);  						break;  					case "culture":  						name.Culture = parts[1] == "neutral" ? "" : parts[1];  						break;  					case "publickeytoken":  						var pk_token = parts[1];  						if (pk_token == "null")  							break;    						name.PublicKeyToken = new byte[pk_token.Length / 2];  						for (int j = 0; j < name.PublicKeyToken.Length; j++)  							name.PublicKeyToken[j] = Byte.Parse(pk_token.Substring(j * 2' 2)' System.Globalization.NumberStyles.HexNumber);    						break;  				}
Missing Default,ICSharpCode.Decompiler.Metadata,UniversalAssemblyResolver,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\UniversalAssemblyResolver.cs,ParseTargetFramework,The following switch statement is missing a default case: switch (pair[0].Trim().ToUpperInvariant()) {  					case "VERSION":  						var versionString = pair[1].TrimStart('v'' ' '' '\t');  						if (identifier == TargetFrameworkIdentifier.NETCoreApp ||  							identifier == TargetFrameworkIdentifier.NETStandard)  						{  							if (versionString.Length == 3)  								versionString += ".0";  						}  						if (!Version.TryParse(versionString' out version))  							version = null;  						break;  				}
Missing Default,LightJson.Serialization,JsonReader,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\JsonReader.cs,ReadNumber,The following switch statement is missing a default case: switch (next) {  					case '+':  					case '-':  						builder.Append(this.scanner.Read());  						break;  				}
Missing Default,ICSharpCode.Decompiler.Semantics,BuiltinConversion,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following switch statement is missing a default case: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  					case 10:  						return "interpolated string";  					case 11:  						return "throw-expression conversion";  				}
Missing Default,ICSharpCode.Decompiler.Semantics,MemberResolveResult,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,ComputeType,The following switch statement is missing a default case: switch (member.SymbolKind) {  				case SymbolKind.Constructor:  					return member.DeclaringType ?? SpecialType.UnknownType;  				case SymbolKind.Field:  					//if (((IField)member).IsFixed)  					//	return new PointerType(member.ReturnType);  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TupleType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TupleType.cs,IsTupleCompatible,The following switch statement is missing a default case: switch (type.Kind) {  				case TypeKind.Tuple:  					tupleCardinality = ((TupleType)type).ElementTypes.Length;  					return true;  				case TypeKind.Class:  				case TypeKind.Struct:  					if (type.Namespace == "System" && type.Name == "ValueTuple") {  						int tpc = type.TypeParameterCount;  						if (tpc > 0 && tpc < RestPosition) {  							tupleCardinality = tpc;  							return true;  						} else if (tpc == RestPosition && type is ParameterizedType pt) {  							if (IsTupleCompatible(pt.TypeArguments[RestIndex]' out tupleCardinality)) {  								tupleCardinality += RestPosition - 1;  								return true;  							}  						}  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TupleType,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TupleType.cs,GetTupleElementTypes,The following switch statement is missing a default case: switch (type.Kind) {  					case TypeKind.Tuple:  						if (output == null)  							output = new List<IType>();  						output.AddRange(((TupleType)type).ElementTypes);  						return true;  					case TypeKind.Class:  					case TypeKind.Struct:  						if (type.Namespace == "System" && type.Name == "ValueTuple") {  							if (output == null)  								output = new List<IType>();  							int tpc = type.TypeParameterCount;  							if (tpc > 0 && tpc < RestPosition) {  								output.AddRange(type.TypeArguments);  								return true;  							} else if (tpc == RestPosition) {  								output.AddRange(type.TypeArguments.Take(RestPosition - 1));  								return Collect(type.TypeArguments[RestIndex]);  							}  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,DecompilerTypeSystem,The following switch statement is missing a default case: switch (exportedType.Implementation.Kind) {  							case SRM.HandleKind.AssemblyReference:  								assemblyReferenceQueue.Enqueue((true' asm' new AssemblyReference(asm' (SRM.AssemblyReferenceHandle)exportedType.Implementation)));  								break;  							case SRM.HandleKind.AssemblyFile:  								var file = metadata.GetAssemblyFile((SRM.AssemblyFileHandle)exportedType.Implementation);  								assemblyReferenceQueue.Enqueue((false' asm' metadata.GetString(file.Name)));  								break;  						}
Missing Default,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,SkipAheadAndReadAssemblyName,The following switch statement is missing a default case: switch (reflectionTypeName[pos++]) {  					case '[':  						nestingLevel++;  						break;  					case ']':  						if (nestingLevel == 0)  							return null;  						nestingLevel--;  						break;  					case ''':  						if (nestingLevel == 0) {  							// first skip the whitespace  							while (pos < reflectionTypeName.Length && reflectionTypeName[pos] == ' ')  								pos++;  							// everything up to the end/next ']' is the assembly name  							int endPos = pos;  							while (endPos < reflectionTypeName.Length && reflectionTypeName[endPos] != ']')  								endPos++;  							return reflectionTypeName.Substring(pos' endPos - pos);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following switch statement is missing a default case: switch (type.Kind) {  				case TypeKind.Pointer:  				case TypeKind.ByReference:  				case TypeKind.Class:  					return NativeIntSize;  				case TypeKind.Enum:  					type = type.GetEnumUnderlyingType();  					break;  				case TypeKind.ModOpt:  				case TypeKind.ModReq:  					return type.SkipModifiers().GetSize();  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following switch statement is missing a default case: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetStackType,The following switch statement is missing a default case: switch (type.Kind) {  				case TypeKind.Unknown:  					if (type.IsReferenceType == true) {  						return StackType.O;  					}  					return StackType.Unknown;  				case TypeKind.ByReference:  					return StackType.Ref;  				case TypeKind.Pointer:  					return StackType.I;  				case TypeKind.TypeParameter:  					// Type parameters are always considered StackType.O' even  					// though they might be instantiated with primitive types.  					return StackType.O;  				case TypeKind.ModOpt:  				case TypeKind.ModReq:  					return type.SkipModifiers().GetStackType();  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  				case CR:  				if (nextChar != null && nextChar () == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  				case LF:  				return UnicodeNewline.LF;  				case NEL:  				return UnicodeNewline.NEL;  				case VT:  				return UnicodeNewline.VT;  				case FF:  				return UnicodeNewline.FF;  				case LS:  				return UnicodeNewline.LS;  				case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  			case CR:  				if (nextChar == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  			case LF:  				return UnicodeNewline.LF;  			case NEL:  				return UnicodeNewline.NEL;  			case VT:  				return UnicodeNewline.VT;  			case FF:  				return UnicodeNewline.FF;  			case LS:  				return UnicodeNewline.LS;  			case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  								case TypeCode.Boolean: return (char)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  								case TypeCode.Boolean: return (sbyte)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  								case TypeCode.Boolean: return (byte)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  								case TypeCode.Boolean: return (short)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  								case TypeCode.Boolean: return (ushort)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  								case TypeCode.Boolean: return (int)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  								case TypeCode.Boolean: return (uint)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  								case TypeCode.Boolean: return (long)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  								case TypeCode.Boolean: return (ulong)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  								case TypeCode.Boolean: return (float)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  								case TypeCode.Boolean: return (double)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  								case TypeCode.Boolean: return (decimal)((bool)input ? 1 : 0);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  								case TypeCode.Boolean: return (char)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  								case TypeCode.Boolean: return (sbyte)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  								case TypeCode.Boolean: return (byte)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  								case TypeCode.Boolean: return (short)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  								case TypeCode.Boolean: return (ushort)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  								case TypeCode.Boolean: return (int)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  								case TypeCode.Boolean: return (uint)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  								case TypeCode.Boolean: return (long)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  								case TypeCode.Boolean: return (ulong)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  								case TypeCode.Boolean: return (float)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  								case TypeCode.Boolean: return (double)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  								case TypeCode.Boolean: return (decimal)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  								case TypeCode.Boolean: return (char)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  								case TypeCode.Boolean: return (sbyte)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  								case TypeCode.Boolean: return (byte)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  								case TypeCode.Boolean: return (short)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  								case TypeCode.Boolean: return (ushort)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  								case TypeCode.Boolean: return (int)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  								case TypeCode.Boolean: return (uint)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  								case TypeCode.Boolean: return (long)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  								case TypeCode.Boolean: return (ulong)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  								case TypeCode.Boolean: return (float)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  								case TypeCode.Boolean: return (double)((bool)input ? 1 : 0);  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  								case TypeCode.Boolean: return (decimal)((bool)input ? 1 : 0);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  								case TypeCode.Boolean: return (char)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  								case TypeCode.Boolean: return (sbyte)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  								case TypeCode.Boolean: return (byte)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  								case TypeCode.Boolean: return (short)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  								case TypeCode.Boolean: return (ushort)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  								case TypeCode.Boolean: return (int)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  								case TypeCode.Boolean: return (uint)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  								case TypeCode.Boolean: return (long)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  								case TypeCode.Boolean: return (ulong)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  								case TypeCode.Boolean: return (float)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  								case TypeCode.Boolean: return (double)((bool)input ? 1 : 0);  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,D:\research\architectureSmells\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  								case TypeCode.Boolean: return (decimal)((bool)input ? 1 : 0);  						}
