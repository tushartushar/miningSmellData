Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The method has 179 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The method has 184 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The method has 133 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The method has 118 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitConv,The method has 126 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The method has 101 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The method has 117 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The method has 134 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,FormattingOptionsFactory,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\FormattingOptionsFactory.cs,CreateMono,The method has 150 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,FormattingOptionsFactory,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\FormattingOptionsFactory.cs,CreateKRStyle,The method has 147 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The method has 119 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The method has 148 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The method has 302 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The method has 100 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,The method has 107 lines of code.
Long Method,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The method has 162 lines of code.
Long Method,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetConversionKind,The method has 115 lines of code.
Long Method,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The method has 466 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInstruction,The method has 126 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,Lift,The method has 125 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,The method has 101 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The method has 101 lines of code.
Long Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The method has 102 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The method has 127 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,StateRangeAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\StateRangeAnalysis.cs,AssignStateRanges,The method has 103 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The method has 146 lines of code.
Long Method,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,HandleIfInstruction,The method has 138 lines of code.
Long Method,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The method has 190 lines of code.
Long Method,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The method has 190 lines of code.
Long Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The method has 210 lines of code.
Long Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The method has 107 lines of code.
Long Method,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,ParseReflectionName,The method has 103 lines of code.
Complex Method,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ApplyTypeArgumentsTo,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertBlockContainer,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,GetDescendantsImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertNamespace,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeDefinition,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertDelegate,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching,Pattern,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\PatternMatching\Pattern.cs,DoMatchCollection,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,IsKeyword,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitTypeDeclaration,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ImplicitConversion,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,StandardImplicitConversion,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsConstraintConvertible,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ExplicitConversionImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ExplicitReferenceConversion,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,AnonymousFunctionConversion,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsDelegateCompatible,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpInvocationResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpInvocationResolveResult.cs,GetArgumentsForCall,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInCurrentType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInCurrentUsingScope,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInUsingScopeNamespace,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,GetExtensionMethods,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupType,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,Lookup,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddNestedTypes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,CreateResult,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,RunTypeInference,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArguments,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArgumentsFromBounds,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,PhaseTwo,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,CalculateDependencyMatrix,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeOutputTypeInference,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeLowerBoundInference,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeUpperBoundInference,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,FindInsertionPoints,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,ResolveCollisions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,InsertVariableDeclarations,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,FixNameCollisions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\FixNameCollisions.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler,DecompilerException,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,ResolveInternal,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler,TextTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,WriteIdentifier,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,GetIdString,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.Documentation,XmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocKeyProvider.cs,FindMember,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL,ILFunction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL,BlockBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateBlocks,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,ReadInstructions,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchWhileLoop,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,InlineReturnTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\InlineReturnTransform.cs,CanModifyInstructions,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,Cyclomatic complexity of the method is 25
Complex Method,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertMemberInit,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateNameForVariable,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,RunStatements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,Lift,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchThreeValuedLogicConditionPattern,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,Run,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.IL.Transforms,RemoveDeadVariableInit,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\RemoveDeadVariableInit.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleCallCompoundAssign,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,HandleStObjCompoundAssign,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorWithInlineStore,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperator,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,Cyclomatic complexity of the method is 31
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeStateMachine,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,RestoreStack,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanDoFinallyBodies,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,HandleIfInstruction,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,SimplifyBranchChains,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,CreatePinnedRegion,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,WriteOperand,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.Disassembler,ILStructure,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,ILStructure,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,LoadModule,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ConvertMarshalInfo,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,InitMembers,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ReadMethod,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ReadParameter,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ReadProperty,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,DecompilerTypeSystem,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,FindNonGenericMethod,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetDerivedMember,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,ParameterizedType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,VisitChildren,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,GetAttributes,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,FindBaseProperties,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,IsVisibleFromDerived,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,GetAccessAttributes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,MatchMethod,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,CalculateDirectBaseTypes,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetInterfaceImplementation,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedMethod.cs,Resolve,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,CecilResolvedAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\ResolvedAttributeBlob.cs,DecodeBlob,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,SpecializedMethod,Cyclomatic complexity of the method is 9
Long Parameter List,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The method has 5 parameters. Parameters: expectedTargetDetails' method' target' typeArguments' arguments
Long Parameter List,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The method has 6 parameters. Parameters: name' source' target' typeSystemAstBuilder' intermediate32' intermediate64
Long Parameter List,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,GetPointerArithmeticOffset,The method has 5 parameters. Parameters: byteOffsetInst' byteOffsetExpr' pointerType' checkForOverflow' unwrapZeroExtension
Long Parameter List,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,StatementBuilder,The method has 5 parameters. Parameters: typeSystem' decompilationContext' currentFunction' settings' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The method has 6 parameters. Parameters: usingContainer' loopBody' enumerator' moveNextUsage' singleGetter' foreachVariable
Long Parameter List,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,AddTypeArguments,The method has 5 parameters. Parameters: result' typeDef' typeArguments' startIndex' endIndex
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,AwaitResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\AwaitResolveResult.cs,AwaitResolveResult,The method has 6 parameters. Parameters: resultType' getAwaiterInvocation' awaiterType' isCompletedProperty' onCompletedMethod' getResultMethod
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The method has 6 parameters. Parameters: mostSpecificSource' mostSpecificTarget' operators' isImplicit' source' target
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpInvocationResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpInvocationResolveResult.cs,CSharpInvocationResolveResult,The method has 10 parameters. Parameters: targetResult' member' arguments' overloadResolutionErrors' isExtensionMethodInvocation' isExpandedForm' isDelegateInvocation' argumentToParameterMap' initializerStatements' returnTypeOverride
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,CSharpResolver,The method has 8 parameters. Parameters: compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryOperatorResolveResult,The method has 5 parameters. Parameters: resultType' lhs' op' rhs' isLifted
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumComparison,The method has 5 parameters. Parameters: op' enumType' isNullable' lhs' rhs
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumOperator,The method has 5 parameters. Parameters: isNullable' enumType' op' lhs' rhs
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,TryConvertEnum,The method has 5 parameters. Parameters: rr' targetType' isNullable' enumRR' allowConversionFromConstantZero
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookInUsingScopeNamespace,The method has 5 parameters. Parameters: usingScope' n' identifier' typeArguments' parameterizeResultType
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,The method has 6 parameters. Parameters: compilation' conversions' targetType' method' useTypeInference' outInferredTypes
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The method has 5 parameters. Parameters: type' arguments' argumentNames' allowProtectedAccess' initializerStatements
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,DecompiledLambdaResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\LambdaResolveResult.cs,DecompiledLambdaResolveResult,The method has 6 parameters. Parameters: function' delegateType' inferredReturnType' hasParameterList' isAnonymousMethod' isImplicitlyTyped
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddNestedTypes,The method has 6 parameters. Parameters: type' nestedTypes' typeArgumentCount' lookupGroups' typeBaseTypes' newNestedTypes
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The method has 8 parameters. Parameters: type' members' allowProtectedAccess' lookupGroups' treatAllParameterizedMembersAsMethods' typeBaseTypes' newMethods' newNonMethod
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,The method has 8 parameters. Parameters: compilation' arguments' argumentNames' allowExtensionMethods' allowExpandingParams' allowOptionalParameters' checkForOverflow' conversions
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,OverloadResolution,The method has 5 parameters. Parameters: compilation' arguments' argumentNames' typeArguments' conversions
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArguments,The method has 5 parameters. Parameters: typeParameters' arguments' parameterTypes' success' classTypeArguments
Long Parameter List,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,InferTypeArgumentsFromBounds,The method has 5 parameters. Parameters: typeParameters' targetType' lowerBounds' upperBounds' success
Long Parameter List,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,MatchForeachOnMultiDimArray,The method has 6 parameters. Parameters: upperBounds' collection' firstInitializerStatement' foreachVariable' statements' lowerBounds
Long Parameter List,ICSharpCode.Decompiler.CSharp.Transforms,TransformContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\TransformContext.cs,TransformContext,The method has 5 parameters. Parameters: typeSystem' decompilationContext' typeSystemAstBuilder' settings' cancellationToken
Long Parameter List,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpAttribute.cs,CSharpAttribute,The method has 5 parameters. Parameters: attributeType' region' positionalArguments' namedCtorArguments' namedArguments
Long Parameter List,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,CSharpTypeResolveContext,The method has 5 parameters. Parameters: assembly' usingScope' typeDefinition' member' methodTypeParameterNames
Long Parameter List,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The method has 5 parameters. Parameters: typeName' pos' allowDottedName' typeParameterCount' typeArguments
Long Parameter List,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,CallIndirect,The method has 5 parameters. Parameters: callingConvention' returnType' parameterTypes' arguments' functionPointer
Long Parameter List,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,BinaryNumericInstruction,The method has 5 parameters. Parameters: op' left' right' checkForOverflow' sign
Long Parameter List,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,BinaryNumericInstruction,The method has 8 parameters. Parameters: op' left' right' leftInputType' rightInputType' checkForOverflow' sign' isLifted
Long Parameter List,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CompoundAssignmentInstruction,The method has 5 parameters. Parameters: binary' target' value' type' compoundAssignmentType
Long Parameter List,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,Comp,The method has 6 parameters. Parameters: kind' lifting' inputType' sign' left' right
Long Parameter List,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,Conv,The method has 6 parameters. Parameters: argument' inputType' inputSign' targetType' checkForOverflow' isLifted
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The method has 5 parameters. Parameters: loop' block' swapBranches' unwrapCondtionBlock' conditionBlock
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The method has 5 parameters. Parameters: block' values' targetBlock' dictionaryType' dictionaryField
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The method has 5 parameters. Parameters: dictionaryType' inst' dictVar' index' value
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The method has 5 parameters. Parameters: container' entryPoint' exceptionType' exceptionSlot' whenConditionBlock
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The method has 5 parameters. Parameters: instructions' pos' target' rootType' blockKind
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,CopyPropagation,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CopyPropagation.cs,DoPropagate,The method has 5 parameters. Parameters: v' copiedExpr' block' i' context
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,ILInlining,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,DoInline,The method has 5 parameters. Parameters: v' inlinedExpression' next' aggressive' context
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsages,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDisplayClassUsages,The method has 5 parameters. Parameters: function' targetLoad' captureScope' orphanedVariableInits' translatedDisplayClasses
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The method has 7 parameters. Parameters: block' pos' store' elementType' length' values' instructionsToRemove
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The method has 8 parameters. Parameters: block' pos' store' elementType' length' finalStore' values' instructionsToRemove
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The method has 6 parameters. Parameters: block' pos' store' index' initializer' type
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ForwardScanInitializeArrayRuntimeHelper,The method has 7 parameters. Parameters: body' pos' array' arrayType' arrayLength' values' foundPos
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The method has 5 parameters. Parameters: type' array' initialValue' arrayLength' output
Long Parameter List,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The method has 7 parameters. Parameters: initialValue' array' arrayLength' output' elementType' type' decoder
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The method has 5 parameters. Parameters: block' awaiterVar' awaiterField' completedBlock' stackField
Long Parameter List,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullBlock,The method has 5 parameters. Parameters: block' v' p' nullOrEmptyBlock' targetBlock
Long Parameter List,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The method has 6 parameters. Parameters: operatorMethod' isImplicit' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The method has 6 parameters. Parameters: isImplicit' method' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.Decompiler.Semantics,ForEachResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\ForEachResolveResult.cs,ForEachResolveResult,The method has 8 parameters. Parameters: getEnumeratorCall' collectionType' enumeratorType' elementType' elementVariable' currentProperty' moveNextMethod' voidType
Long Parameter List,ICSharpCode.Decompiler.Semantics,InvocationResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\InvocationResolveResult.cs,InvocationResolveResult,The method has 5 parameters. Parameters: targetResult' member' arguments' initializerStatements' returnTypeOverride
Long Parameter List,ICSharpCode.Decompiler.Semantics,MemberResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 5 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue
Long Parameter List,ICSharpCode.Decompiler.Semantics,MemberResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 6 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue' isVirtualCall
Long Parameter List,ICSharpCode.Decompiler.Semantics,OperatorResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\OperatorResolveResult.cs,OperatorResolveResult,The method has 5 parameters. Parameters: resultType' operatorType' userDefinedOperatorMethod' isLiftedOperator' operands
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,DomRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DomRegion.cs,DomRegion,The method has 5 parameters. Parameters: fileName' beginLine' beginColumn' endLine' endColumn
Long Parameter List,ICSharpCode.Decompiler.TypeSystem,KnownTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\KnownTypeReference.cs,KnownTypeReference,The method has 5 parameters. Parameters: knownTypeCode' namespaceName' name' typeParameterCount' baseType
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractResolvedTypeParameter.cs,AbstractTypeParameter,The method has 6 parameters. Parameters: owner' index' name' variance' attributes' region
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractResolvedTypeParameter.cs,AbstractTypeParameter,The method has 7 parameters. Parameters: compilation' ownerType' index' name' variance' attributes' region
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The method has 6 parameters. Parameters: context' symbolKind' name' explicitInterfaceTypeReference' typeParameterNames' parameterTypeReferences
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultMemberReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultMemberReference.cs,DefaultMemberReference,The method has 5 parameters. Parameters: symbolKind' typeReference' name' typeParameterCount' parameterTypes
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultParameter.cs,DefaultParameter,The method has 10 parameters. Parameters: type' name' owner' region' attributes' isRef' isOut' isParams' isOptional' defaultValue
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,ParameterReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultParameter.cs,ParameterReference,The method has 8 parameters. Parameters: type' name' region' isRef' isOut' isParams' isOptional' defaultValue
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The method has 10 parameters. Parameters: owner' index' name' variance' attributes' region' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The method has 11 parameters. Parameters: compilation' ownerType' index' name' variance' attributes' region' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultVariable,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultVariable.cs,DefaultVariable,The method has 5 parameters. Parameters: type' name' region' isConst' constantValue
Long Parameter List,ICSharpCode.Decompiler.TypeSystem.Implementation,VariableReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultVariable.cs,VariableReference,The method has 5 parameters. Parameters: variableTypeReference' name' region' isConst' constantValue
Long Identifier,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,EarlyILTransforms,The length of the parameter aggressivelyDuplicateReturnBlocks is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateFunction,The length of the parameter parameterReferencingIdentifiers is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Syntax,DocumentationReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\DocumentationReference.cs,,The length of the parameter ConversionOperatorReturnTypeRole is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpFormattingOptions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpFormattingOptions.cs,,The length of the parameter allowOneLinedArrayInitialziers is 30.
Long Identifier,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitIdentifierExpressionBackreference,The length of the parameter identifierExpressionBackreference is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the parameter operatorsWithSourceEncompassingFromType is 39.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,,The length of the parameter implicitNumericConversionLookup is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,TryConvertEnum,The length of the parameter allowConversionFromConstantZero is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,TypeDefinitionCache,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,,The length of the parameter SimpleNameLookupCacheExpression is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,TypeDefinitionCache,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,,The length of the parameter SimpleNameLookupCacheInvocationTarget is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The length of the parameter treatAllParameterizedMembersAsMethods is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,AddMembers,The length of the parameter replacedVirtualMemberWithOverride is 33.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,The length of the parameter foundApplicableCandidateInCurrentList is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,IsApplicable,The length of the parameter errorsThatDoNotMatterForApplicability is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,The length of the parameter bestCandidateForNamedArguments is 30.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,CombineQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs,,The length of the parameter selectTransparentIdentifierPattern is 34.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter variableAssignUpperBoundPattern is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter variableAssignLowerBoundPattern is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter foreachVariableOnMultArrayAssignPattern is 39.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter automaticReadonlyPropertyPattern is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,,The length of the parameter attributeTypesToRemoveFromAutoEvents is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costCheckedContextUncheckedBlockOpen is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesCheckedContextUncheckedBlockOpen is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costUncheckedContextCheckedBlockOpen is 36.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesUncheckedContextCheckedBlockOpen is 37.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,Result,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,,The length of the parameter NodesToInsertInUncheckedContext is 31.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the parameter instanceCtorsNotChainingWithThis is 32.
Long Identifier,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,,The length of the parameter getMethodOrConstructorFromHandlePattern is 39.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter useImplicitMethodGroupConversion is 32.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter fullyQualifyAmbiguousTypeNames is 30.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter introduceIncrementAndDecrement is 30.
Long Identifier,ICSharpCode.Decompiler,DecompilerSettings,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerSettings.cs,,The length of the parameter alwaysGenerateExceptionVariableForCatchBlocks is 45.
Long Identifier,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateNameForVariable,The length of the parameter proposedNameForStoresFromNewObj is 31.
Long Identifier,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,The length of the parameter isNullCoalescingWithNonNullableFallback is 39.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowGraph,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowGraph.cs,,The length of the parameter nodeHasDirectExitOutOfContainer is 31.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,,The length of the parameter aggressivelyDuplicateReturnBlocks is 33.
Long Identifier,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,The length of the parameter multipleNodesTreatedAsExitNodes is 31.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DataFlowVisitor<State>,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DataFlowVisitor.cs,VisitTryFinally,The length of the parameter branchesTriggeringFinallyOldCount is 33.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DataFlowVisitor<State>,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DataFlowVisitor.cs,ProcessBranchesLeavingTryFinally,The length of the parameter branchesTriggeringFinallyOldCount is 33.
Long Identifier,ICSharpCode.Decompiler.FlowAnalysis,DefiniteAssignmentVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\DefiniteAssignmentVisitor.cs,,The length of the parameter variablesWithUninitializedUsage is 31.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ImplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ExplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter ImplicitConstantExpressionConversion is 36.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,LoadModule,The length of the parameter cecilLoaderCloneForLazyLoading is 30.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,,The length of the parameter assemblyVersionAttributeTypeRef is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,TypeClassificationVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,,The length of the parameter typeParameterOwnerNestingLevel is 30.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,GenericContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,,The length of the parameter UnresolvedGenericTypeParameter is 30.
Long Identifier,ICSharpCode.Decompiler.TypeSystem,GenericContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,,The length of the parameter UnresolvedGenericMethodParameter is 32.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedEntity,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedEntity.cs,,The length of the parameter FlagAddDefaultConstructorIfRequired is 35.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedEntity,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedEntity.cs,,The length of the parameter FlagExplicitInterfaceImplementation is 35.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The length of the parameter explicitInterfaceTypeReference is 30.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The length of the parameter addDefaultConstructorIfRequired is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAssembly,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAssembly.cs,,The length of the parameter typeForwardedToAttributeTypeRef is 31.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAssembly,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAssembly.cs,,The length of the parameter unresolvedNamespacesPerNameComparer is 35.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedTypeParameter.cs,,The length of the parameter FlagDefaultConstructorConstraint is 32.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,,The length of the parameter substitutionWithoutSpecializedTypeParameters is 44.
Long Identifier,ICSharpCode.Decompiler.TypeSystem.Implementation,UnresolvedSecurityDeclarationBlob,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnresolvedSecurityDeclarationBlob.cs,,The length of the parameter permissionSetAttributeTypeReference is 35.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				target = expressionBuilder.TranslateTarget(method' callArguments.FirstOrDefault()' callOpCode == OpCode.Call' constrainedTo); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "						if (IsUnambiguousCall(expectedTargetDetails' method' target' Array.Empty<IType>()' expandedArguments) == OverloadResolutionErrors.None) { " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				argListArg.Arguments.AddRange(arguments.Skip(regularParameterCount).Select(arg => arg.ConvertTo(expectedParameters[paramIndex++].Type' builder).Expression)); " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "			ResolveResult rr = new CSharpInvocationResolveResult(target.ResolveResult' method' argumentResolveResults' isExpandedForm: isExpandedForm); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "					if (IsUnambiguousCall(expectedTargetDetails' method' target' Array.Empty<IType>()' arguments) != OverloadResolutionErrors.None) { " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "					return new ObjectCreateExpression(expressionBuilder.ConvertType(method.DeclaringType)' arguments.SelectArray(arg => arg.Expression)) " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "				if (method.IsAccessor && (method.AccessorOwner.SymbolKind == SymbolKind.Indexer || expectedParameters.Count == allowedParamCount)) { " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "					while ((errors = IsUnambiguousCall(expectedTargetDetails' method' target' typeArguments' arguments)) != OverloadResolutionErrors.None) { " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "					// HACK : convert this.Dispose() to ((IDisposable)this).Dispose()' if Dispose is an explicitly implemented interface method. " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The length of the statement  "						targetExpr = new CastExpression(expressionBuilder.ConvertType(method.ImplementedInterfaceMembers[0].DeclaringType)' targetExpr); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "			var or = new OverloadResolution(resolver.Compilation' arguments.SelectArray(a => a.ResolveResult)' typeArguments: typeArguments); " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "					if (lookup.IsAccessible(ctor' allowProtectedAccess: resolver.CurrentTypeDefinition == method.DeclaringTypeDefinition)) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsUnambiguousCall,The length of the statement  "				var result = lookup.Lookup(target.ResolveResult' method.Name' EmptyList<IType>.Instance' true) as MethodGroupResolveResult; " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "			var result = lookup.Lookup(target.ResolveResult' method.AccessorOwner.Name' EmptyList<IType>.Instance' isInvocation: false); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "			if (result.IsError || (result is MemberResolveResult && !IsAppropriateCallTarget(expectedTargetDetails' method.AccessorOwner' ((MemberResolveResult)result).Member))) " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleAccessorCall,The length of the statement  "				return new AssignmentExpression(expr' op' value.Expression).WithRR(new TypeResolveResult(method.AccessorOwner.ReturnType)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleDelegateConstruction,The length of the statement  "			var or = new OverloadResolution(resolver.Compilation' method.Parameters.SelectArray(p => new TypeResolveResult(p.Type))); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,HandleDelegateConstruction,The length of the statement  "				needsCast = (or.BestCandidateErrors != OverloadResolutionErrors.None || !IsAppropriateCallTarget(expectedTargetDetails' method' or.BestCandidate)); " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "								|| (conversion.Conversion.IsImplicit && (conversion.Conversion.IsUserDefined || targetType.IsKnownType(KnownTypeCode.Decimal))) " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "							if (Expression is ObjectCreateExpression oce && oce.Arguments.Count == 1 && invocation.Type.IsKnownType(KnownTypeCode.NullableOfT)) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "				if (!(targetType.IsKnownType(KnownTypeCode.Int64) || checkForOverflow && targetType.IsKnownType(KnownTypeCode.Int32))) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "				if (!(targetType.IsKnownType(KnownTypeCode.UInt64) || checkForOverflow && targetType.IsKnownType(KnownTypeCode.UInt32))) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The length of the statement  "			if (targetType.Kind == TypeKind.Pointer && (0.Equals(ResolveResult.ConstantValue) || 0u.Equals(ResolveResult.ConstantValue))) { " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The length of the statement  "					if (settings.FixedBuffers && type.Name.StartsWith("<"' StringComparison.Ordinal) && type.Name.Contains("__FixedBuffer")) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsAnonymousMethodCacheField,The length of the statement  "			return field.Name.StartsWith("CS$<>"' StringComparison.Ordinal) || field.Name.StartsWith("<>f__am"' StringComparison.Ordinal); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,RunTransforms,The length of the statement  "			var context = new TransformContext(typeSystem' decompilationContext' typeSystemAstBuilder' settings' CancellationToken); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,Decompile,The length of the statement  "			RunTransforms(syntaxTree' parentTypeDef != null ? new SimpleTypeResolveContext(parentTypeDef) : new SimpleTypeResolveContext(typeSystem.MainAssembly)); " is 151.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,AddInterfaceImplHelpers,The length of the statement  "				var forwardingCall = new InvocationExpression(new MemberReferenceExpression(new ThisReferenceExpression()' memberDecl.Name' " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "				addNewModifier = baseTypes.SelectMany(b => b.GetNestedTypes(t => t.Name == entity.Name && lookup.IsAccessible(t' true))).Any(); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,SetNewModifier,The length of the statement  "				var members = baseTypes.SelectMany(b => b.GetMembers(m => m.Name == entity.Name).Where(m => lookup.IsAccessible(m' true))); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The length of the statement  "			method.Parameters.Add(new ParameterDeclaration(typeSystemAstBuilder.ConvertType(typeSystem.Compilation.FindType(source))' "input")); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The length of the statement  "						Left = new MemberReferenceExpression(new TypeReferenceExpression(typeSystemAstBuilder.ConvertType(typeSystem.Compilation.FindType(KnownTypeCode.IntPtr)))' "Size")' " is 163.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "			if (method.SymbolKind == SymbolKind.Method && !method.IsExplicitInterfaceImplementation && methodDefinition.IsVirtual == methodDefinition.IsNewSlot) { " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DecompileBody,The length of the statement  "				var statementBuilder = new StatementBuilder(specializingTypeSystem' decompilationContext' function' settings' CancellationToken); " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,AddDefinesForConditionalAttributes,The length of the statement  "				syntaxTree.InsertChildAfter(null' new PreProcessorDirective(PreProcessorDirectiveType.Define' symbolName)' Roles.PreProcessorDirective); " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				if (decompilationContext.CurrentTypeDefinition.Attributes.Any(a => a.AttributeType.FullName == "System.FlagsAttribute")) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "					if (enumDec.Initializer is PrimitiveExpression primitive && initValue > 9 && ((initValue & (initValue - 1)) == 0 || (initValue & (initValue + 1)) == 0)) { " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				enumDec.Attributes.AddRange(field.Attributes.Select(a => new AttributeSection(typeSystemAstBuilder.ConvertAttribute(a)))); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsFixedField,The length of the statement  "				if (attr.PositionalArguments[0] is TypeOfResolveResult trr && attr.PositionalArguments[1].ConstantValue is int length) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				DecompileBody(eventDefinition.AddMethod' ev.AddAccessor' ((CustomEventDeclaration)eventDecl).AddAccessor' decompilationContext); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The length of the statement  "				DecompileBody(eventDefinition.RemoveMethod' ev.RemoveAccessor' ((CustomEventDeclaration)eventDecl).RemoveAccessor' decompilationContext); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "				if (gType.ElementType.Namespace == "System" && gType.ElementType.Name == "Nullable`1" && gType.GenericArguments.Count == 1) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "				AstType baseType = ConvertType(gType.ElementType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "				AstType typeRef = ConvertType(type.DeclaringType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "				if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "					if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "							((SimpleType)memberType).TypeArguments.AddRange(typeArguments.GetRange(typeArguments.Count - typeParameterCount' typeParameterCount)); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The length of the statement  "					if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertConstantValue,The length of the statement  "							expr = new CastExpression(new PrimitiveType(KnownTypeReference.GetCSharpNameByTypeCode(rr.Type.GetDefinition().KnownTypeCode))' expr); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The length of the statement  "					Debug.Assert(cexpr.Type.GetStackType().IsIntegerType()' "IL instructions of integer type must convert into C# expressions of integer type"); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,Translate,The length of the statement  "						Debug.Assert(underlying.GetStackType().IsIntegerType()' "IL instructions of integer type must convert into C# expressions of integer type"); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertField,The length of the statement  "			var result = lookup.Lookup(targetExpression.ResolveResult' field.Name' EmptyList<IType>.Instance' false) as MemberResolveResult; " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNewArr,The length of the statement  "				.WithRR(new ArrayCreateResolveResult(new ArrayType(compilation' inst.Type' dimensions)' args.Select(a => a.ResolveResult).ToList()' new ResolveResult[0])); " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,LogicNot,The length of the statement  "				.WithRR(new OperatorResolveResult(compilation.FindType(KnownTypeCode.Boolean)' ExpressionType.Not' expr.ResolveResult)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleThreeValuedLogic,The length of the statement  "				.WithRR(new OperatorResolveResult(nullableBoolType' eop' null' true' new[] { left.ResolveResult' right.ResolveResult })) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandlePointerArithmetic,The length of the statement  "			TranslatedExpression offsetExpr = GetPointerArithmeticOffset(byteOffsetInst' byteOffsetExpr' pointerType' inst.CheckForOverflow) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,GetPointerArithmeticOffset,The length of the statement  "			} else if (byteOffsetInst.UnwrapConv(ConversionKind.SignExtend) is SizeOf sizeOf && sizeOf.Type.Equals(pointerType.ElementType)) { " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				if (rightUType.IsKnownType(KnownTypeCode.Int32) || rightUType.IsKnownType(KnownTypeCode.Int64) || rightUType.IsCSharpSmallIntegerType()) { " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				left = left.ConvertTo(NullableType.IsNullable(left.Type) ? NullableType.Create(compilation' targetType) : targetType' this); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				right = right.ConvertTo(NullableType.IsNullable(right.Type) ? NullableType.Create(compilation' targetType) : targetType' this); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The length of the statement  "				resultExpr.Expression.AddAnnotation(inst.CheckForOverflow ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation); " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The length of the statement  "					.WithRR(new OperatorResolveResult(target.Type' AssignmentExpression.GetLinqNodeType(op' inst.CheckForOverflow)' target.ResolveResult' value.ResolveResult)); " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The length of the statement  "				resultExpr.Expression.AddAnnotation(inst.CheckForOverflow ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation); " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateFunction,The length of the statement  "			StatementBuilder builder = new StatementBuilder(typeSystem.GetSpecializingTypeSystem(context)' this.decompilationContext' function' settings' cancellationToken); " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateTarget,The length of the statement  "					if (CallInstruction.ExpectedTypeForThisPointer(constrainedTo ?? member.DeclaringType) == StackType.Ref && translatedTarget.Type.GetStackType().IsIntegerType()) { " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The length of the statement  "			if (stloc == null || final == null || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The length of the statement  "							var indexer = new IndexerExpression(null' lastElement.Indices.SelectArray(i => Translate(i is LdLoc ld ? indexVariables[ld.Variable] : i).Expression)) " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The length of the statement  "			var target = member.Indices?.Length > 0 ? (Expression)new IndexerExpression(null' member.Indices.SelectArray(i => Translate(i is LdLoc ld ? indexVariables[ld.Variable] : i).Expression)) : new IdentifierExpression(member.Member.Name); " is 233.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The length of the statement  "			if (values.Count == 1 && !(values[0] is AssignmentExpression) && !(method.SymbolKind == SymbolKind.Method && method.Name == "Add")) " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The length of the statement  "			if (stloc == null || final == null || !stloc.Value.MatchNewArr(out type) || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget) " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The length of the statement  "				.WithRR(new ArrayCreateResolveResult(new ArrayType(compilation' type' dimensions)' newArr.Indices.Select(i => Translate(i).ResolveResult).ToArray()' elementResolveResults)); " is 173.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslatePostfixOperator,The length of the statement  "			if (targetInst == null || inst == null || (inst.Operator != BinaryNumericOperator.Add && inst.Operator != BinaryNumericOperator.Sub)) " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslatePostfixOperator,The length of the statement  "			var op = inst.Operator == BinaryNumericOperator.Add ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement; " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNullCoalescingInstruction,The length of the statement  "			var rr = resolver.ResolveBinaryOperator(BinaryOperatorType.NullCoalescing' value.ResolveResult' fallback.ResolveResult); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitNullCoalescingInstruction,The length of the statement  "				if (!value.Type.Equals(SpecialType.NullType) && !fallback.Type.Equals(SpecialType.NullType) && !value.Type.Equals(fallback.Type)) { " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "			if (op != BinaryOperatorType.Any && (rhs.Type.IsKnownType(KnownTypeCode.Boolean) || IfInstruction.IsInConditionSlot(inst))) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "				if (!trueBranch.Type.Equals(SpecialType.NullType) && !falseBranch.Type.Equals(SpecialType.NullType) && !trueBranch.Type.Equals(falseBranch.Type)) { " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitIfInstruction,The length of the statement  "					targetType = typeInference.GetBestCommonType(new[] { trueBranch.ResolveResult' falseBranch.ResolveResult }' out bool success); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "			Dictionary<IL.SwitchSection' Syntax.SwitchSection> translationDictionary = new Dictionary<IL.SwitchSection' Syntax.SwitchSection>(); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "					astSection.CaseLabels.AddRange(values.Select(label => new CaseLabel(exprBuilder.ConvertConstantValue(label' allowImplicitConversion: true)))); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (br.TargetBlock.Parent == switchContainer && switchContainer.Descendants.OfType<Branch>().Where(b => b.TargetBlock == br.TargetBlock).All(b => BlockContainer.FindClosestSwitchContainer(b) == switchContainer)) " is 211.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (br.TargetBlock.Parent == switchContainer && switchContainer.Descendants.OfType<Branch>().Where(b => b.TargetBlock == br.TargetBlock).All(b => BlockContainer.FindClosestSwitchContainer(b) == switchContainer)) " is 211.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TranslateSwitch,The length of the statement  "						if (astSection.CaseLabels.Count == 1 && astSection.CaseLabels.First().Expression.IsNull && leave.TargetContainer == switchContainer) { " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitBranch,The length of the statement  "				return new GotoCaseStatement() { LabelExpression = exprBuilder.ConvertConstantValue(label' allowImplicitConversion: true) }; " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitLeave,The length of the statement  "					return new ReturnStatement(exprBuilder.Translate(inst.Value).ConvertTo(targetType' exprBuilder' allowImplicitConversion: true)); " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitYieldReturn,The length of the statement  "			var elementType = currentFunction.ReturnType.GetElementTypeFromIEnumerable(typeSystem.Compilation' true' out var isGeneric); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "			if (!inst.ResourceExpression.MatchLdNull() && !NullableType.GetUnderlyingType(var.Type).GetAllBaseTypes().Any(b => b.IsKnownType(KnownTypeCode.IDisposable))) { " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "							new ExpressionStatement(new AssignmentExpression(exprBuilder.ConvertVariable(disposeVariable).Expression' new AsExpression(exprBuilder.ConvertVariable(var).Expression' exprBuilder.ConvertType(disposeType))))' " is 208.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "								Condition = new BinaryOperatorExpression(exprBuilder.ConvertVariable(disposeVariable)' BinaryOperatorType.InEquality' new NullReferenceExpression())' " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "								TrueStatement = new ExpressionStatement(new InvocationExpression(new MemberReferenceExpression(exprBuilder.ConvertVariable(disposeVariable).Expression' "Dispose"))) " is 164.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitUsingInstruction,The length of the statement  "					var type = settings.AnonymousTypes && var.Type.ContainsAnonymousType() ? new SimpleType("var") : exprBuilder.ConvertType(var.Type); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "			var transformation = DetectGetCurrentTransformation(container' body' enumeratorVar' conditionInst' out var singleGetter' out var foreachVariable); " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "			if (foreachVariable != null && !(foreachVariable.CaptureScope == null || foreachVariable.CaptureScope == loopContainer)) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "					foreachVariable.Name = AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>()' foreachVariable); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The length of the statement  "				VariableType = settings.AnonymousTypes && foreachVariable.Type.ContainsAnonymousType() ? new SimpleType("var") : exprBuilder.ConvertType(foreachVariable.Type)' " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The length of the statement  "			var loads = (enumerator.LoadInstructions.OfType<ILInstruction>().Concat(enumerator.AddressInstructions.OfType<ILInstruction>())).Where(ld => !ld.IsDescendantOf(moveNextUsage)).ToArray(); " is 186.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,DetectGetCurrentTransformation,The length of the statement  "			if (!(singleGetter.IsDescendantOf(loopBody.Instructions[0]) && ILInlining.CanUninline(singleGetter' loopBody.Instructions[0]))) " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VariableIsOnlyUsedInBlock,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(usingContainer) || !ILInlining.IsUsedAsThisPointerInCall(la) || IsTargetOfSetterCall(la' la.Variable.Type))) " is 180.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,VisitBlockContainer,The length of the statement  "			} else if (container.EntryPoint.Instructions.Count == 1 && container.EntryPoint.Instructions[0] is SwitchInstruction switchInst) { " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The length of the statement  "					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.Skip(1).Except(new[] { loopBody })' true); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The length of the statement  "					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.SkipLast(1).Skip(1).Except(new[] { loopBody })' true); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,DecompileProject,The length of the statement  "			string projectFileName = Path.Combine(targetDirectory' CleanUpFileName(moduleDefinition.Assembly.Name.Name) + ".csproj"); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "				var targetFrameworkAttribute = module.Assembly.CustomAttributes.FirstOrDefault(a => a.AttributeType.FullName == "System.Runtime.Versioning.TargetFrameworkAttribute"); " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkIdentifier = frameworkParts.FirstOrDefault(a => !a.StartsWith("Version="' StringComparison.OrdinalIgnoreCase) && !a.StartsWith("Profile="' StringComparison.OrdinalIgnoreCase)); " is 192.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkVersion = frameworkParts.FirstOrDefault(a => a.StartsWith("Version="' StringComparison.OrdinalIgnoreCase)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "					string frameworkProfile = frameworkParts.FirstOrDefault(a => a.StartsWith("Profile="' StringComparison.OrdinalIgnoreCase)); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The length of the statement  "						w.WriteAttributeString("Project"' "$(MSBuildExtensionsPath32)\\Microsoft\\Portable\\$(TargetFrameworkVersion)\\Microsoft.Portable.CSharp.targets"); " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,The length of the statement  "				throw new ArgumentException (string.Format ("The new node '{0}' is not valid in the role {1}"' newNode.GetType ().Name' this.Role.ToString ())' "newNode"); " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,ReplaceWith,The length of the statement  "					throw new InvalidOperationException (string.Format ("The new node '{0}' is not valid in the role {1}"' replacement.GetType ().Name' oldRole.ToString ())); " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AstType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstType.cs,GetNameLookupMode,The length of the statement  "				if (outermostType.Parent is TypeDeclaration || (outermostType.Parent is Constraint && outermostType.Parent.Parent is TypeDeclaration)) " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The length of the statement  "					return new BinaryOperatorExpression(InvertCondition(bOp.Left)' NegateConditionOperator(bOp.Operator)' InvertCondition(bOp.Right)); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The length of the statement  "				} else if ((bOp.Operator == BinaryOperatorType.Equality) || (bOp.Operator == BinaryOperatorType.InEquality) || (bOp.Operator == BinaryOperatorType.GreaterThan) " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ArrayCreateExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ArrayCreateExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && this.Arguments.DoMatch(o.Arguments' match) && this.AdditionalArraySpecifiers.DoMatch(o.AdditionalArraySpecifiers' match) && this.Initializer.DoMatch(o.Initializer' match); " is 227.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ConditionalExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ConditionalExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.TrueExpression.DoMatch(o.TrueExpression' match) && this.FalseExpression.DoMatch(o.FalseExpression' match); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,LambdaExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\LambdaExpression.cs,DoMatch,The length of the statement  "			return o != null && this.IsAsync == o.IsAsync && this.Parameters.DoMatch(o.Parameters' match) && this.Body.DoMatch(o.Body' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,MemberReferenceExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\MemberReferenceExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Target.DoMatch(o.Target' match) && MatchString(this.MemberName' o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments' match); " is 157.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ObjectCreateExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ObjectCreateExpression.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && this.Arguments.DoMatch(o.Arguments' match) && this.Initializer.DoMatch(o.Initializer' match); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,UndocumentedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UndocumentedExpression.cs,DoMatch,The length of the statement  "			return o != null && this.UndocumentedExpressionType == o.UndocumentedExpressionType && this.Arguments.DoMatch(o.Arguments' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,AttributeSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\AttributeSection.cs,DoMatch,The length of the statement  "			return o != null && MatchString(this.AttributeTarget' o.AttributeTarget) && this.Attributes.DoMatch(o.Attributes' match); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeParameterDeclaration,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\TypeParameterDeclaration.cs,DoMatch,The length of the statement  "			return o != null && this.Variance == o.Variance && MatchString(this.Name' o.Name) && this.Attributes.DoMatch(o.Attributes' match); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,Identifier,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Identifier.cs,Create,The length of the statement  "				return new Identifier (name.Substring (1)' new TextLocation (location.Line' location.Column + 1)) { IsVerbatim = true }; " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,MemberType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\MemberType.cs,ToTypeReference,The length of the statement  "			return interningProvider.Intern(new MemberTypeOrNamespaceReference(t' memberName' interningProvider.InternList(typeArguments)' lookupMode)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,DoWhileStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\DoWhileStatement.cs,DoMatch,The length of the statement  "			return o != null && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match) && this.Condition.DoMatch(o.Condition' match); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,FixedStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\FixedStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && this.Variables.DoMatch(o.Variables' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 161.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,IfElseStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\IfElseStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.TrueStatement.DoMatch(o.TrueStatement' match) && this.FalseStatement.DoMatch(o.FalseStatement' match); " is 173.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,LockStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\LockStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Expression.DoMatch(o.Expression' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,SwitchStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\SwitchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Expression.DoMatch(o.Expression' match) && this.SwitchSections.DoMatch(o.SwitchSections' match); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TryCatchStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.TryBlock.DoMatch(o.TryBlock' match) && this.CatchClauses.DoMatch(o.CatchClauses' match) && this.FinallyBlock.DoMatch(o.FinallyBlock' match); " is 165.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,CatchClause,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Type.DoMatch(o.Type' match) && MatchString(this.VariableName' o.VariableName) && this.Body.DoMatch(o.Body' match); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,UsingStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\UsingStatement.cs,DoMatch,The length of the statement  "			return o != null && this.ResourceAcquisition.DoMatch(o.ResourceAcquisition' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 145.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,VariableDeclarationStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\VariableDeclarationStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Modifiers == o.Modifiers && this.Type.DoMatch(o.Type' match) && this.Variables.DoMatch(o.Variables' match); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,WhileStatement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Statements\WhileStatement.cs,DoMatch,The length of the statement  "			return o != null && this.Condition.DoMatch(o.Condition' match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement' match); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,SyntaxTree,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxTree.cs,GetTypes,The length of the statement  "					    (child.Role != Roles.TypeMemberRole || ((child is TypeDeclaration || child is DelegateDeclaration) && includeInnerTypes))) " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,ConstructorInitializer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\ConstructorDeclaration.cs,DoMatch,The length of the statement  "				&& (this.ConstructorInitializerType == ConstructorInitializerType.Any || this.ConstructorInitializerType == o.ConstructorInitializerType) " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,EntityDeclaration,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\EntityDeclaration.cs,MatchAttributesAndModifiers,The length of the statement  "			return (this.Modifiers == Modifiers.Any || this.Modifiers == o.Modifiers) && this.Attributes.DoMatch (o.Attributes' match); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeHelper,The length of the statement  "				if (trr != null || (localTypeArguments.Count == 0 && resolver.IsVariableReferenceWithSameType(rr' typeDef.Name' out trr))) { " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,IsValidNamespace,The length of the statement  "			NamespaceResolveResult nrr = resolver.ResolveSimpleName(firstNamespacePart' EmptyList<IType>.Instance) as NamespaceResolveResult; " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,The length of the statement  "			return new CastExpression(ConvertType(type)' new PrimitiveExpression(CSharpPrimitiveCast.Cast(enumBaseTypeCode' val' false))); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEntity,The length of the statement  "					return ConvertAccessor(accessor' accessor.AccessorOwner != null ? accessor.AccessorOwner.Accessibility : Accessibility.None' false); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeDefinition,The length of the statement  "			int outerTypeParameterCount = (typeDefinition.DeclaringTypeDefinition == null) ? 0 : typeDefinition.DeclaringTypeDefinition.TypeParameterCount; " is 143.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertDelegate,The length of the statement  "				decl.Attributes.AddRange (invokeMethod.ReturnTypeAttributes.Select ((a) => new AttributeSection (ConvertAttribute (a)) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,GenerateBodyBlock,The length of the statement  "					new ThrowStatement(new ObjectCreateExpression(ConvertType(new TopLevelTypeName("System"' "NotImplementedException"' 0)))) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAccessor,The length of the statement  "					decl.Attributes.AddRange (accessor.Parameters.Last ().Attributes.Select ((a) => new AttributeSection (ConvertAttribute (a)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The length of the statement  "			if (method.IsExtensionMethod && method.ReducedFrom == null && decl.Parameters.Any() && decl.Parameters.First().ParameterModifier == ParameterModifier.None) " is 155.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The length of the statement  "			if (this.ShowTypeParameters && this.ShowTypeParameterConstraints && !method.IsOverride && !method.IsExplicitInterfaceImplementation) { " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeParameterConstraint,The length of the statement  "			if (!tp.HasDefaultConstructorConstraint && !tp.HasReferenceTypeConstraint && !tp.HasValueTypeConstraint && tp.DirectBaseTypes.All(IsObjectOrValueType)) { " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching,Repeat,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\PatternMatching\Repeat.cs,DoMatchCollection,The length of the statement  "			return false; // never do a normal (single-element) match; always make the caller look at the results on the back-tracking stack. " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "			if ((ConversionFlags & ConversionFlags.ShowParameterList) == ConversionFlags.ShowParameterList && HasParameters(symbol)) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "				writer.WriteToken(symbol.SymbolKind == SymbolKind.Indexer ? Roles.LBracket : Roles.LPar' symbol.SymbolKind == SymbolKind.Indexer ? "[" : "("); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertSymbol,The length of the statement  "				writer.WriteToken(symbol.SymbolKind == SymbolKind.Indexer ? Roles.RBracket : Roles.RPar' symbol.SymbolKind == SymbolKind.Indexer ? "]" : ")"); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.ShowAccessibility = (ConversionFlags & ConversionFlags.ShowAccessibility) == ConversionFlags.ShowAccessibility; " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedTypeNames) != ConversionFlags.UseFullyQualifiedTypeNames; " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,CreateAstBuilder,The length of the statement  "			astBuilder.ShowParameterNames = (ConversionFlags & ConversionFlags.ShowParameterNames) == ConversionFlags.ShowParameterNames; " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteTypeDeclarationName,The length of the statement  "			} else if ((ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) == ConversionFlags.UseFullyQualifiedEntityNames) { " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteMemberDeclarationName,The length of the statement  "			if ((ConversionFlags & ConversionFlags.ShowDeclaringType) == ConversionFlags.ShowDeclaringType && member.DeclaringType != null) { " is 129.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,WriteMemberDeclarationName,The length of the statement  "			if ((ConversionFlags & ConversionFlags.ShowTypeParameterList) == ConversionFlags.ShowTypeParameterList && member.SymbolKind == SymbolKind.Method) { " is 147.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertType,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) != ConversionFlags.UseFullyQualifiedEntityNames; " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertType,The length of the statement  "			astBuilder.AlwaysUseShortTypeNames = (ConversionFlags & ConversionFlags.UseFullyQualifiedEntityNames) != ConversionFlags.UseFullyQualifiedEntityNames; " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,StartNode,The length of the statement  "			Debug.Assert(containerStack.Count == 0 || node.Parent == containerStack.Peek() || containerStack.Peek().NodeType == NodeType.Pattern); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,Semicolon,The length of the statement  "			if (!(role == ForStatement.InitializerRole || role == ForStatement.IteratorRole || role == UsingStatement.ResourceAcquisitionRole)) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,GetCallChainLengthLimited,The length of the statement  "			while (node.Target is InvocationExpression invocation && invocation.Target is MemberReferenceExpression mre && callChainLength < 4) { " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitAnonymousMethodExpression,The length of the statement  "				WriteCommaSeparatedListInParenthesis(anonymousMethodExpression.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 123.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitConstructorDeclaration,The length of the statement  "			WriteCommaSeparatedListInParenthesis(constructorDeclaration.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitOperatorDeclaration,The length of the statement  "				WriteToken(OperatorDeclaration.GetToken(operatorDeclaration.OperatorType)' OperatorDeclaration.GetRole(operatorDeclaration.OperatorType)); " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,MaybeNewLinesAfterUsings,The length of the statement  "			if ((node is UsingDeclaration || node is UsingAliasDeclaration) && !(nextSibling is UsingDeclaration || nextSibling is UsingAliasDeclaration)) { " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitDocumentationReference,The length of the statement  "					WriteCommaSeparatedListInParenthesis(documentationReference.Parameters' policy.SpaceWithinMethodDeclarationParentheses); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,TokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\ITokenWriter.cs,Create,The length of the statement  "			return new InsertSpecialsDecorator(new InsertRequiredSpacesDecorator(new TextWriterTokenWriter(writer) { IndentationString = indentation })); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,TokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\ITokenWriter.cs,CreateWriterThatSetsLocationsInAST,The length of the statement  "			return new InsertSpecialsDecorator(new InsertRequiredSpacesDecorator(new InsertMissingTokensDecorator(target' target))); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor,TokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\ITokenWriter.cs,WrapInWriterThatSetsLocationsInAST,The length of the statement  "			return new InsertSpecialsDecorator(new InsertRequiredSpacesDecorator(new InsertMissingTokensDecorator(writer' (ILocatable)writer))); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackGenericArrayInterface,The length of the statement  "				if (tc == KnownTypeCode.IListOfT || tc == KnownTypeCode.ICollectionOfT || tc == KnownTypeCode.IEnumerableOfT || tc == KnownTypeCode.IReadOnlyListOfT) { " is 151.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "			var selected = operators.Where(op => op.SourceType.Equals(mostSpecificSource) && op.TargetType.Equals(mostSpecificTarget)).ToList(); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "				return Conversion.UserDefinedConversion(selected[0].Method' isLifted: selected[0].IsLifted' isImplicit: isImplicit' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 285.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "				return Conversion.UserDefinedConversion(op.Method' isLifted: op.IsLifted' isImplicit: isImplicit' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 267.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,SelectOperator,The length of the statement  "			return Conversion.UserDefinedConversion(selected[0].Method' isLifted: selected[0].IsLifted' isImplicit: isImplicit' isAmbiguous: true' conversionBeforeUserDefinedOperator: ExplicitConversion(source' mostSpecificSource)' conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget' target)); " is 304.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "				var mostSpecificSource = operators.Any(op => op.SourceType.Equals(fromType)) ? fromType : FindMostEncompassedType(operators.Select(op => op.SourceType)); " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "					return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: true' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 238.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "				var mostSpecificTarget = operators.Any(op => op.TargetType.Equals(toType)) ? toType : FindMostEncompassingType(operators.Select(op => op.TargetType)); " is 150.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedImplicitConversion,The length of the statement  "						return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: true' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 238.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					var operatorsWithSourceEncompassingFromType = operators.Where(op => IsEncompassedBy(fromType' op.SourceType) || ImplicitConstantExpressionConversion(fromResult' NullableType.GetUnderlyingType(op.SourceType))).ToList(); " is 218.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: false' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 239.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "					mostSpecificTarget = FindMostEncompassingType(operators.Where(op => IsEncompassedBy(op.TargetType' toType)).Select(op => op.TargetType)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UserDefinedExplicitConversion,The length of the statement  "						return Conversion.UserDefinedConversion(operators[0].Method' isImplicit: false' isLifted: operators[0].IsLifted' isAmbiguous: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 239.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "				opFilter = m => m.IsStatic && m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1; " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "					isApplicable = (IsEncompassingOrEncompassedBy(fromType' sourceType) || ImplicitConstantExpressionConversion(fromResult' sourceType)) " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetApplicableConversionOperators,The length of the statement  "					IType liftedTargetType = NullableType.IsNonNullableValueType(targetType) ? NullableType.Create(compilation' targetType) : targetType; " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,MethodGroupConversion,The length of the statement  "			var or = rr.PerformOverloadResolution(compilation' args' allowExpandingParams: false' allowOptionalParameters: false' conversions: this); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithContext,The length of the statement  "			return new CSharpResolver(compilation' conversions' newContext' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 180.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithCheckForOverflow,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithIsWithinLambdaExpression,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' objectInitializerStack); " is 177.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithLocalVariableStack,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' stack' objectInitializerStack); " is 164.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,WithObjectInitializerStack,The length of the statement  "			return new CSharpResolver(compilation' conversions' context' checkForOverflow' isWithinLambdaExpression' currentTypeDefinitionCache' localVariableStack' stack); " is 160.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "					return new AwaitResolveResult(SpecialType.Dynamic' new DynamicInvocationResolveResult(new DynamicMemberResolveResult(expression' "GetAwaiter")' DynamicInvocationType.Invocation' EmptyList<ResolveResult>.Instance)' SpecialType.Dynamic' null' null' null); " is 253.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						ResolveResult getAwaiterMethodGroup = ResolveMemberAccess(expression' "GetAwaiter"' EmptyList<IType>.Instance' NameLookupMode.InvocationTarget); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						ResolveResult getAwaiterInvocation = ResolveInvocation(getAwaiterMethodGroup' new ResolveResult[0]' argumentNames: null' allowOptionalParameters: false); " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var getResultMethodGroup = lookup.Lookup(getAwaiterInvocation' "GetResult"' EmptyList<IType>.Instance' true) as MethodGroupResolveResult; " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							var getResultOR = getResultMethodGroup.PerformOverloadResolution(compilation' new ResolveResult[0]' allowExtensionMethods: false' conversions: conversions); " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							getResultMethod = getResultOR.FoundApplicableCandidate ? getResultOR.GetBestCandidateWithSubstitutedTypeArguments() as IMethod : null; " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var isCompletedProperty = (isCompletedRR is MemberResolveResult ? ((MemberResolveResult)isCompletedRR).Member as IProperty : null); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						if (isCompletedProperty != null && (!isCompletedProperty.ReturnType.IsKnownType(KnownTypeCode.Boolean) || !isCompletedProperty.CanGet)) " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var interfaceOnCompleted = compilation.FindType(KnownTypeCode.INotifyCompletion).GetMethods().FirstOrDefault(x => x.Name == "OnCompleted"); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var interfaceUnsafeOnCompleted = compilation.FindType(KnownTypeCode.ICriticalNotifyCompletion).GetMethods().FirstOrDefault(x => x.Name == "UnsafeOnCompleted"); " is 159.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						var candidates = getAwaiterInvocation.Type.GetMethods().Where(x => x.ImplementedInterfaceMembers.Select(y => y.MemberDefinition).Contains(interfaceUnsafeOnCompleted)).ToList(); " is 176.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "							candidates = getAwaiterInvocation.Type.GetMethods().Where(x => x.ImplementedInterfaceMembers.Select(y => y.MemberDefinition).Contains(interfaceOnCompleted)).ToList(); " is 166.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "						return new AwaitResolveResult(awaitResultType' getAwaiterInvocation' getAwaiterInvocation.Type' isCompletedProperty' onCompletedMethod' getResultMethod); " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "				return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' UnaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The length of the statement  "					return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' UnaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 140.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "				// - If inputs aren't compile-time constants' we don't evaluate anything' so again it doesn't matter that we don't short-circuit " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "				return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' BinaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The length of the statement  "					return CreateResolveResultForUserDefinedOperator(userDefinedOperatorOR' BinaryOperatorExpression.GetLinqNodeType(op' this.CheckForOverflow)); " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumSubtraction,The length of the statement  "				var rr = ResolveBinaryOperator(BinaryOperatorType.Subtract' ResolveCast(elementType' lhs)' ResolveCast(elementType' rhs)); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumOperator,The length of the statement  "					if (rr.IsCompileTimeConstant) // only report result if it's a constant; use the regular OperatorResolveResult codepath otherwise " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The length of the statement  "			} else if (isNullable && rhs.Type.Kind == TypeKind.Null && lhsCode >= TypeCode.Boolean && lhsCode <= TypeCode.Decimal) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The length of the statement  "			bool parameterizeResultType = !(typeArguments.Count != 0 && typeArguments.All(t => t.Kind == TypeKind.UnboundTypeArgument)); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The length of the statement  "					r = LookInCurrentUsingScope(identifier' typeArguments' lookupMode == NameLookupMode.TypeInUsingDeclaration' parameterizeResultType); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveMemberAccess,The length of the statement  "			bool parameterizeResultType = !(typeArguments.Count != 0 && typeArguments.All(t => t.Kind == TypeKind.UnboundTypeArgument)); " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveMemberAccess,The length of the statement  "					return new MethodGroupResolveResult(target' identifier' EmptyList<MethodListWithDeclaringType>.Instance' typeArguments) { " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,IsEligibleExtensionMethod,The length of the statement  "			return IsEligibleExtensionMethod(compilation' CSharpConversions.Get(compilation)' targetType' method' useTypeInference' out outInferredTypes); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new DynamicInvocationResolveResult(target' DynamicInvocationType.Invocation' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "					// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable method. " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "					var applicableMethods = mgrr.MethodsGroupedByDeclaringType.SelectMany(m => m' (x' m) => new { x.DeclaringType' Method = m }).Where(x => OverloadResolution.IsApplicable(or2.AddCandidate(x.Method))).ToList(); " is 206.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "						return new DynamicInvocationResolveResult(new MethodGroupResolveResult(actualTarget' mgrr.MethodName' l' mgrr.TypeArguments)' DynamicInvocationType.Invocation' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 215.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				OverloadResolution or = mgrr.PerformOverloadResolution(compilation' arguments' argumentNames' checkForOverflow: checkForOverflow' conversions: conversions' allowOptionalParameters: allowOptionalParameters); " is 206.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "						return or.CreateResolveResult(new TypeResolveResult(mgrr.TargetType)' returnTypeOverride: isDynamic ? SpecialType.Dynamic : null); " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new UnknownMethodResolveResult(umrr.TargetType' umrr.MemberName' umrr.TypeArguments' CreateParameters(arguments' argumentNames)); " is 136.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveInvocation,The length of the statement  "				return new UnknownMethodResolveResult(CurrentTypeDefinition' uirr.Identifier' EmptyList<IType>.Instance' CreateParameters(arguments' argumentNames)); " is 149.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "				// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable indexer. " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "				var applicableIndexers = indexers.SelectMany(x => x).Where(m => OverloadResolution.IsApplicable(or2.AddCandidate(m))).ToList(); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The length of the statement  "					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames)); " is 137.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The length of the statement  "				// If we have dynamic arguments' we need to represent the invocation as a dynamic invocation if there is more than one applicable constructor. " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveObjectCreation,The length of the statement  "				return new DynamicInvocationResolveResult(new MethodGroupResolveResult(null' allApplicable[0].Name' new[] { new MethodListWithDeclaringType(type' allApplicable) }' null)' DynamicInvocationType.ObjectCreation' AddArgumentNamesIfNecessary(arguments' argumentNames)' initializerStatements); " is 287.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveCondition,The length of the statement  "					c = Conversion.UserDefinedConversion(opTrue' isImplicit: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 170.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveConditionFalse,The length of the statement  "					c = Conversion.UserDefinedConversion(opFalse' isImplicit: true' conversionBeforeUserDefinedOperator: Conversion.None' conversionAfterUserDefinedOperator: Conversion.None); " is 171.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,The length of the statement  "					var nestedTypes = type.GetNestedTypes(options: GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,GetAccessibleMembers,The length of the statement  "					AddMembers(type' entityGroup.OfType<IMember>()' allowProtectedAccess' lookupGroups' false' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupType,The length of the statement  "						nestedTypes = type.GetNestedTypes(filter' GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,Lookup,The length of the statement  "				AddMembers(type' members' allowProtectedAccess' lookupGroups' false' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MemberLookup,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs,LookupIndexers,The length of the statement  "				AddMembers(type' members' allowProtectedAccess' lookupGroups' true' ref typeBaseTypes' ref newMethods' ref newNonMethod); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,MethodGroupResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs,PerformOverloadResolution,The length of the statement  "			Log.WriteLine("Overload resolution finished' best candidate is {0}."' or.GetBestCandidateWithSubstitutedTypeArguments()); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,AddMethodLists,The length of the statement  "					Log.WriteLine("  Skipping methods in {0} because they are hidden by an applicable method in a derived type"' methodLists[i].DeclaringType); " is 139.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,RunTypeInference,The length of the statement  "				candidate.InferredTypes = ti.InferTypeArguments(candidate.TypeParameters' arguments' candidate.ParameterTypes' out success' classTypeArguments); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,The length of the statement  "			return ValidateConstraints(typeParameter' typeArgument' substitution' CSharpConversions.Get(typeParameter.Owner.Compilation)); " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The length of the statement  "					if ((brrr.IsOut && !candidate.Parameters[parameterIndex].IsOut) || (brrr.IsRef && !candidate.Parameters[parameterIndex].IsRef)) " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The length of the statement  "					if (!(c == Conversion.IdentityConversion || c == Conversion.ImplicitReferenceConversion || c == Conversion.BoxingConversion)) " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,GetArgumentsWithConversions,The length of the statement  "						argument = new NamedArgumentResolveResult(bestCandidateForNamedArguments.Parameters[parameterIndex]' argument' bestCandidateForNamedArguments); " is 143.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CreateResolveResult,The length of the statement  "				this.IsExtensionMethodInvocation ? new TypeResolveResult(member.DeclaringType ?? SpecialType.UnknownType) : targetResolveResult' " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeLowerBoundInference,The length of the statement  "					if (pU != null && object.Equals(pU.GetDefinition()' pV.GetDefinition()) && pU.TypeParameterCount == pV.TypeParameterCount) { " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeUpperBoundInference,The length of the statement  "					if (pV != null && object.Equals(pU.GetDefinition()' pV.GetDefinition()) && pU.TypeParameterCount == pV.TypeParameterCount) { " is 124.
Long Statement,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,FindTypesInBounds,The length of the statement  "			if (candidateTypes.Count == 1 || !(algorithm == TypeInferenceAlgorithm.Improved || algorithm == TypeInferenceAlgorithm.ImprovedReturnAllResults)) " is 145.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,InitializeContext,The length of the statement  "			var currentContext = new CSharpTypeResolveContext(context.TypeSystem.MainAssembly' usingScope.Resolve(context.TypeSystem.Compilation)' context.DecompiledTypeDefinition); " is 169.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitNamespaceDeclaration,The length of the statement  "			var currentContext = new CSharpTypeResolveContext(previousContext.CurrentAssembly' usingScope.Resolve(previousContext.Compilation)); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "			if (method == null || !method.IsExtensionMethod || mre == null || !(mre.Target is TypeReferenceExpression) || !invocationExpression.Arguments.Any()) " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "			var rr = resolver.ResolveMemberAccess(target' method.Name' typeArguments' NameLookupMode.InvocationTarget) as MethodGroupResolveResult; " is 135.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "			var or = rr.PerformOverloadResolution(resolver.CurrentTypeResolveContext.Compilation' args' allowExtensionMethods: true); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The length of the statement  "				firstArgument = firstArgument.ReplaceWith(expr => new CastExpression(context.TypeSystemAstBuilder.ConvertType(method.Parameters[0].Type)' expr.Detach())); " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,Run,The length of the statement  "			// After all queries were decompiled' detect degenerate queries (queries not property terminated with 'select' or 'group') " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) }); " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() }); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) }); " is 148.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,NormalizeBlockStatements,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\NormalizeBlockStatements.cs,DoTransform,The length of the statement  "				if (statement is BlockStatement b && b.Statements.Count == 1 && IsAllowedAsEmbeddedStatement(b.Statements.First()' parent)) { " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,VisitAssignmentExpression,The length of the statement  "							type = (assignment.Operator == AssignmentOperatorType.Add) ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement; " is 127.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PrettifyAssignments,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs,IsWithoutSideEffects,The length of the statement  "			return left is ThisReferenceExpression || left is IdentifierExpression || left is TypeReferenceExpression || left is BaseReferenceExpression; " is 141.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DecimalConstantTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DecimalConstantTransform.cs,VisitFieldDeclaration,The length of the statement  "			if ((fieldDeclaration.Modifiers & staticReadOnly) == staticReadOnly && decimalType.IsMatch(fieldDeclaration.ReturnType)) { " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,EnsureExpressionStatementsAreValid,The length of the statement  "						AssignVariableNames.GenerateVariableName(function' type' stmt.Expression.Annotations.OfType<ILInstruction>().Where(AssignVariableNames.IsSupportedInstruction).FirstOrDefault()) " is 176.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,ResolveCollisions,The length of the statement  "					if (v.InsertionPoint.nextNode.Parent is ForStatement f && v.InsertionPoint.nextNode == f.Initializers.FirstOrDefault() && IsMatchingAssignment(v' out _)) " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,IsMatchingAssignment,The length of the statement  "			assignment = v.InsertionPoint.nextNode as AssignmentExpression ?? (v.InsertionPoint.nextNode as ExpressionStatement)?.Expression as AssignmentExpression; " is 153.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,DeclareVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs,IsMatchingAssignment,The length of the statement  "			if (assignment != null && assignment.Operator == AssignmentOperatorType.Assign && assignment.Left.IsMatch(expectedExpr)) " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceUsingDeclarations,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUsingDeclarations.cs,Run,The length of the statement  "				var insertionPoint = rootNode.Children.LastOrDefault(n => n is PreProcessorDirective p && p.Type == PreProcessorDirectiveType.Define); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUsingDeclarations.cs,VisitNamespaceDeclaration,The length of the statement  "				var currentContext = new CSharpTypeResolveContext(previousContext.CurrentAssembly' usingScope.Resolve(previousContext.Compilation)); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ForStatementUsesVariable,The length of the statement  "			if (statement.Iterators.Any(i => i.DescendantsAndSelf.OfType<IdentifierExpression>().Any(ie => ie.GetILVariable() == variable))) " is 128.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The length of the statement  "			if (!itemVariable.IsSingleDefinition || (itemVariable.CaptureScope != null && itemVariable.CaptureScope != loopContainer)) " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The length of the statement  "				VariableType = context.Settings.AnonymousTypes && itemVariable.Type.ContainsAnonymousType() ? new SimpleType("var") : context.TypeSystemAstBuilder.ConvertType(itemVariable.Type)' " is 178.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The length of the statement  "			if (!MatchForeachOnMultiDimArray(upperBounds' collection' stmt' out var foreachVariable' out var statements' out var lowerBounds)) " is 130.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The length of the statement  "				VariableType = context.Settings.AnonymousTypes && itemVariable.Type.ContainsAnonymousType() ? new SimpleType("var") : context.TypeSystemAstBuilder.ConvertType(itemVariable.Type)' " is 178.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformAutomaticProperties,The length of the statement  "			PropertyDefinition cecilProperty = context.TypeSystem.GetCecil(property.GetSymbol() as IProperty) as PropertyDefinition; " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ReplaceBackingFieldUsage,The length of the statement  "					var property = field.DeclaringTypeDefinition.GetProperties(p => p.Name == propertyName' GetMemberOptions.IgnoreInheritedMembers).FirstOrDefault(); " is 146.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,ReplaceEventFieldAnnotation,The length of the statement  "			var @event = field.DeclaringType.GetEvents(ev => ev.Name == field.Name' GetMemberOptions.IgnoreInheritedMembers).SingleOrDefault(); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformAutomaticEvents,The length of the statement  "				IField field = eventDef.DeclaringType.GetFields(f => f.Name == ev.Name' GetMemberOptions.IgnoreInheritedMembers).SingleOrDefault(); " is 131.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtorsNotChainingWithThis = instanceCtors.Where(ctor => !thisCallPattern.IsMatch(ctor.Body.Statements.FirstOrDefault())).ToArray(); " is 142.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "					if (!(fieldOrPropertyOrEvent is IField) && !(fieldOrPropertyOrEvent is IProperty) && !(fieldOrPropertyOrEvent is IEvent)) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "						if (!instanceCtorsNotChainingWithThis[0].Body.First().IsMatch(instanceCtorsNotChainingWithThis[i].Body.FirstOrDefault())) " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ConvertConstructorCallIntoInitializerVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "			var staticCtor = members.OfType<ConstructorDeclaration>().FirstOrDefault(c => (c.Modifiers & Modifiers.Static) == Modifiers.Static); " is 132.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,TypePattern,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs,DoMatch,The length of the statement  "			if (ct != null && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any()) { " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "			if (method.Name == "Concat" && method.DeclaringType.FullName == "System.String" && CheckArgumentsForStringConcat(arguments)) { " is 126.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "									oldArg.ReplaceWith(new MemberReferenceExpression(new TypeReferenceExpression(declaringType)' field.Name).CopyAnnotationsFrom(oldArg)); " is 134.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "					if (method.TypeArguments.Count == 1 && arguments.Length == 0 && method.TypeArguments[0].Kind == TypeKind.TypeParameter) { " is 121.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "						invocationExpression.ReplaceWith(new ObjectCreateExpression(context.TypeSystemAstBuilder.ConvertType(method.TypeArguments.First()))); " is 133.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "					Expression newNode = new MemberReferenceExpression(new TypeReferenceExpression(m.Get<AstType>("declaringType").Single().Detach())' method.Name); " is 144.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "					newNode = new InvocationExpression(newNode' method.Parameters.Select(p => new TypeReferenceExpression(context.TypeSystemAstBuilder.ConvertType(p.Type)))); " is 154.
Long Statement,ICSharpCode.Decompiler.CSharp.Transforms,AddXmlDocumentationTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddXmlDocumentationTransform.cs,Run,The length of the statement  "				string[] msg = (" Exception while reading XmlDoc: " + ex).Split(new[] { '\r'' '\n' }' StringSplitOptions.RemoveEmptyEntries); " is 125.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,ConstantExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\ConstantValues.cs,MapToNestedCompilation,The length of the statement  "				nestedContext = nestedContext.WithUsingScope(context.CurrentUsingScope.UnresolvedUsingScope.Resolve(nestedCompilation)); " is 120.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,ConstantCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\ConstantValues.cs,EqualsForInterning,The length of the statement  "				&& this.targetType == cast.targetType && this.expression == cast.expression && this.allowNullableConstants == cast.allowNullableConstants; " is 138.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithCurrentTypeDefinition,The length of the statement  "			return new CSharpTypeResolveContext(assembly' currentUsingScope' typeDefinition' currentMember' methodTypeParameterNames); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithCurrentMember,The length of the statement  "			return new CSharpTypeResolveContext(assembly' currentUsingScope' currentTypeDefinition' member' methodTypeParameterNames); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,CSharpTypeResolveContext,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\CSharpTypeResolveContext.cs,WithUsingScope,The length of the statement  "			return new CSharpTypeResolveContext(assembly' usingScope' currentTypeDefinition' currentMember' methodTypeParameterNames); " is 122.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,TypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\TypeOrNamespaceReference.cs,Resolve,The length of the statement  "				ctx = new CSharpTypeResolveContext(context.CurrentAssembly ?? context.Compilation.MainAssembly' null' context.CurrentTypeDefinition' context.CurrentMember); " is 156.
Long Statement,ICSharpCode.Decompiler.CSharp.TypeSystem,UsingScope,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\UsingScope.cs,Resolve,The length of the statement  "				var csContext = new CSharpTypeResolveContext(compilation.MainAssembly' parent != null ? parent.Resolve(compilation) : null); " is 124.
Long Statement,ICSharpCode.Decompiler,DotNetCorePathFinder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\DotNetCorePathFinder.cs,GetClosestVersionFolder,The length of the statement  "			foreach (var folder in new DirectoryInfo(basePath).GetDirectories().Select(d => ConvertToVersion(d.Name)).Where(v => v.Item1 != null).OrderByDescending(v => v.Item1)) { " is 168.
Long Statement,ICSharpCode.Decompiler,TextTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentMemberReference,The length of the statement  "			if (node is IdentifierExpression && node.Role == Roles.TargetExpression && node.Parent is InvocationExpression && symbol is IMember member) { " is 141.
Long Statement,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,IsAnonymousType,The length of the statement  "			if (string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))) { " is 145.
Long Statement,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetDefaultMemberName,The length of the statement  "					if (ca.Constructor.DeclaringType.Name == "DefaultMemberAttribute" && ca.Constructor.DeclaringType.Namespace == "System.Reflection" " is 130.
Long Statement,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,GetSpecializingTypeSystem,The length of the statement  "			if (decompilationContext.CurrentTypeDefinition != null && decompilationContext.CurrentTypeDefinition.TypeParameterCount > 0) " is 124.
Long Statement,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,GetSpecializingTypeSystem,The length of the statement  "			if ((classTypeParameters != null && classTypeParameters.Count > 0) || (methodTypeParameters != null && methodTypeParameters.Count > 0)) " is 135.
Long Statement,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,GetSpecializingTypeSystem,The length of the statement  "				return new SpecializingDecompilerTypeSystem(typeSystem' new TypeParameterSubstitution(classTypeParameters' methodTypeParameters)); " is 130.
Long Statement,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,IsAnonymousType,The length of the statement  "			if (string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))) { " is 145.
Long Statement,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,GetIdString,The length of the statement  "			if (member.IsExplicitInterfaceImplementation && member.Name.IndexOf('.') < 0 && member.ImplementedInterfaceMembers.Count == 1) { " is 128.
Long Statement,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The length of the statement  "			while (pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')) " is 120.
Long Statement,ICSharpCode.Decompiler.IL,LdFlda,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LdFlda.cs,CheckInvariant,The length of the statement  "			Debug.Assert(field.DeclaringType.IsReferenceType == true ? (target.ResultType == StackType.O) : (target.ResultType == StackType.I || target.ResultType == StackType.Ref)); " is 170.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\CallIndirect.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTreeCast.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(Blocks.All(b => b.Kind == BlockKind.ControlFlow)); // this also implies that the blocks don't use FinalInstruction " is 127.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL,Leave,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(phase <= ILPhase.InILReader || phase == ILPhase.InAsyncAwait || value.ResultType == targetContainer.ResultType); " is 125.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.ControlFlow | condition.Flags | SemanticHelper.CombineBranches(trueInst.Flags' falseInst.Flags); " is 120.
Long Statement,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,IsInConditionSlot,The length of the statement  "			if (slot == IfInstruction.TrueInstSlot || slot == IfInstruction.FalseInstSlot || slot == NullCoalescingInstruction.FallbackInstSlot) " is 132.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The length of the statement  "			Debug.Assert(this.IsLifted ? (value.ResultType == StackType.O) : (value.ResultType == StackType.I4 || value.ResultType == StackType.I8)); " is 137.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchCompEquals,The length of the statement  "			if (this.MatchLogicNot(out var arg) && arg is Comp nestedComp && nestedComp.Kind == ComparisonKind.Inequality && !nestedComp.IsLifted) { " is 136.
Long Statement,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchCompNotEquals,The length of the statement  "			if (this.MatchLogicNot(out var arg) && arg is Comp nestedComp && nestedComp.Kind == ComparisonKind.Equality && !nestedComp.IsLifted) { " is 134.
Long Statement,ICSharpCode.Decompiler.IL,SemanticHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\SemanticHelper.cs,MayReorder,The length of the statement  "			if (ConflictingPair(inst1' inst2' InstructionFlags.MayReadLocals' InstructionFlags.MayWriteLocals | InstructionFlags.SideEffect)) " is 129.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateContainerStructure,The length of the statement  "				handlerBlock.ILRange = new Interval(eh.HandlerStart.Offset' eh.HandlerEnd != null ? eh.HandlerEnd.Offset : body.CodeSize); " is 122.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateContainerStructure,The length of the statement  "				if (eh.HandlerType == Mono.Cecil.Cil.ExceptionHandlerType.Fault || eh.HandlerType == Mono.Cecil.Cil.ExceptionHandlerType.Finally) { " is 131.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,CreateContainerStructure,The length of the statement  "				tryInstructionList = tryInstructionList.OrderBy(tc => tc.TryBlock.ILRange.Start).ThenByDescending(tc => tc.TryBlock.ILRange.End).ToList(); " is 138.
Long Statement,ICSharpCode.Decompiler.IL,BlockBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\BlockBuilder.cs,FinalizeCurrentBlock,The length of the statement  "				if (currentBlock.Instructions.LastOrDefault() is SwitchInstruction switchInst && switchInst.Sections.Last().Body.MatchNop()) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,ReadInstructions,The length of the statement  "					var v = new ILVariable(VariableKind.Exception' typeSystem.Compilation.FindType(KnownTypeCode.Object)' eh.HandlerStart.Offset) { " is 127.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcI4(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 177.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcI8(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcF4(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,Neg,The length of the statement  "					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub' new LdcF8(0)' Pop()' checkForOverflow: false' sign: Sign.None)); " is 132.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The length of the statement  "						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type); " is 151.
Long Statement,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeConditionalBranch,The length of the statement  "						Sign.None' new Conv(condition' PrimitiveType.I' false' Sign.None)' new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None)); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchWhileLoop,The length of the statement  "			while (loopBody.Instructions.Last() is Leave leave && loopBody.Instructions.SecondToLastOrDefault() is IfInstruction nestedIf && nestedIf.FalseInst.MatchNop()) { " is 161.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileLoop,The length of the statement  "			(List<IfInstruction> conditions' ILInstruction exit' bool swap' bool split' bool unwrap) = AnalyzeDoWhileConditions(loop); " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,AnalyzeDoWhileConditions,The length of the statement  "					var split = conditionBlock == loop.EntryPoint || conditionBlock.Instructions.Count > conditions.Count + 1; // + 1 is the final leave/branch. " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,The length of the statement  "						var specializingTypeSystem = this.context.TypeSystem.GetSpecializingTypeSystem(this.context.TypeSystem.Compilation.TypeResolveContext); " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The length of the statement  "			if (!condition.MatchLogicNot(out var getHasValue) || !NullableLiftingTransform.MatchHasValueCall(getHasValue' out ILVariable target1) || target1 != tmp) " is 152.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The length of the statement  "			var sections = new List<SwitchSection>(values.SelectWithIndex((index' b) => new SwitchSection { Labels = new LongSet(index)' Body = new Branch(b.Item2) })); " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The length of the statement  "			sections.Add(new SwitchSection { Labels = new LongSet(new LongInterval(0' sections.Count)).Invert()' Body = new Branch(currentCaseBlock) }); " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "				instructions[i - 1].MatchStLoc(out var switchValueVar' out var switchValue) && switchValueVar.Type.IsKnownType(KnownTypeCode.String))) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// if (comp(volatile.ldobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600000c-1) != ldnull)) br caseNullBlock " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			if (nextBlock.Instructions.Count != 2 || !nextBlock.Instructions[0].MatchIfInstruction(out condition' out var tryGetValueBlockJump)) " is 132.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// volatile.stobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600003f-1' ldloc dict) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			if (!ExtractStringValuesFromInitBlock(dictInitBlock' out var stringValues' tryGetValueBlock' dictionaryType' dictField)) " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "			// if (logic.not(call TryGetValue(volatile.ldobj System.Collections.Generic.Dictionary`2[[System.String]'[System.Int32]](ldsflda $$method0x600000c-1)' ldloc switchValueVar' ldloca switchIndexVar))) br defaultBlock " is 213.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The length of the statement  "				MatchDictionaryFieldLoad(c.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField))) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchDictionaryFieldLoad,The length of the statement  "				(dictField.IsCompilerGeneratedOrIsInCompilerGeneratedClass() || dictField.Name.StartsWith("$$method"' StringComparison.Ordinal)); " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!switchHead.Instructions[3].MatchBranch(out var getItemBlock) || !nullCaseBlockBranch.MatchBranch(out var nullCaseBlock)) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			// stloc tmp2(call get_Item(volatile.ldobj System.Collections.Hashtable(ldsflda $$method0x600003f - 1)' ldloc switchVariable)) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(getItemBlock.Instructions[0].MatchStLoc(out var tmp2' out var getItem) && getItem is Call getItemCall && getItemCall.Method.Name == "get_Item")) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!getItemBlock.Instructions[3].MatchBranch(out var switchBlock) || !defaultBlockBranch.MatchBranch(out var defaultBlock)) " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(getItemCall.Arguments.Count == 2 && MatchDictionaryFieldLoad(getItemCall.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField)) && " is 180.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "			if (!(switchBlock.Instructions[0] is SwitchInstruction switchInst && switchInst.Value.MatchLdObj(out var target' out var ldobjType) && " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The length of the statement  "				target.MatchUnbox(out var arg' out var unboxType) && arg.MatchLdLoc(switchVariable2) && ldobjType.IsKnownType(KnownTypeCode.Int32) && unboxType.Equals(ldobjType))) " is 163.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "			var newSwitch = new SwitchInstruction(new StringToInt(switchValueInst' stringValues.Select(item => item.Item2).ToArray())); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The length of the statement  "			newSwitch.Sections.AddRange(stringValues.Select(section => new SwitchSection { Labels = new Util.LongSet(section.Item1)' Body = new Branch(section.Item3) })); " is 158.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynCaseBlockHead,The length of the statement  "			} else if (condition.MatchLogicNot(out condition) && MatchStringEqualityComparison(condition' switchValueVar' out stringValue)) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchComputeStringHashCall,The length of the statement  "			if (!(value is Call c && c.Arguments.Count == 1 && c.Method.Name == "ComputeStringHash" && c.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass())) " is 151.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MightBeExpressionTree,The length of the statement  "			if (call.Parent is CallInstruction parentCall && parentCall.Method.FullName == "System.Linq.Expressions.Expression.Quote") " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MightBeExpressionTree,The length of the statement  "			if (!(IsEmptyParameterList(call.Arguments[1]) || (call.Arguments[1] is Block block && block.Kind == BlockKind.ArrayInitializer))) " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,IsEmptyParameterList,The length of the statement  "			if (inst is CallInstruction emptyCall && emptyCall.Method.FullName == "System.Array.Empty" && emptyCall.Arguments.Count == 0) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,The length of the statement  "			if (parameterReferenceVar.Type == null || parameterReferenceVar.Type.FullName != "System.Linq.Expressions.ParameterExpression") " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,The length of the statement  "			if (!(parameterMethod.Name == "Parameter" && parameterMethod.DeclaringType.FullName == "System.Linq.Expressions.Expression")) " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The length of the statement  "			if (instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1) " is 216.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The length of the statement  "			if (!ReadParameters(instruction.Arguments[1]' parameterList' parameterVariablesList' new SimpleTypeResolveContext(context.Function.Method))) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The length of the statement  "			bool isQuotedLambda = instruction.Parent is CallInstruction call && call.Method.FullName == "System.Linq.Expressions.Expression.Quote"; " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ReadParameters,The length of the statement  "						parameters.Add(new DefaultUnresolvedParameter(value.Item1.ToTypeReference()' value.Item2).CreateResolvedParameter(resolveContext)); " is 131.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,UnwrapExpressionTree,The length of the statement  "			if (delegateType is ParameterizedType pt && pt.FullName == "System.Linq.Expressions.Expression" && pt.TypeArguments.Count == 1) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The length of the statement  "			if (NullableType.IsNullable(trueInstType) && conversions.ImplicitConversion(fallbackInstType' trueInstTypeNonNullable).IsValid) { " is 129.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The length of the statement  "				kind = NullableType.IsNullable(fallbackInstType) ? NullCoalescingKind.Nullable : NullCoalescingKind.NullableWithValueFallback; " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "			if (invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)) { " is 163.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "			var rr = resolver.ResolveBinaryOperator(kind.ToBinaryOperatorType()' new ResolveResult(leftType)' new ResolveResult(rightType)) as OperatorResolveResult; " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "				return (new Call(rr.UserDefinedOperatorMethod) { Arguments = { left' right } }' rr.UserDefinedOperatorMethod.ReturnType); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String)); " is 244.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String)); " is 246.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The length of the statement  "			return (new Comp(kind' NullableType.IsNullable(leftType) ? ComparisonLiftingKind.CSharp : ComparisonLiftingKind.None' leftType.GetStackType()' leftType.GetSign()' left' right)' resultType); " is 189.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The length of the statement  "				if (arguments[i] is CallInstruction elementInit && elementInit.Method.FullName == "System.Linq.Expressions.Expression.ElementInit") { " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewArrayInit,The length of the statement  "			var variable = function.RegisterVariable(VariableKind.InitializerTarget' new ArrayType(context.BlockContext.TypeSystem.Compilation' type)); " is 139.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNotOperator,The length of the statement  "					return (argumentType.IsKnownType(KnownTypeCode.Boolean) ? Comp.LogicNot(argument) : (ILInstruction)new BitNot(argument)' argumentType); " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(tryFinally) || (la.IsDescendantOf(tryFinally.TryBlock) && !ILInlining.IsUsedAsThisPointerInCall(la)))) " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			if (!(tryFinally.FinallyBlock is BlockContainer container) || !MatchDisposeBlock(container' storeInst.Variable' storeInst.Value.MatchLdNull())) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsing,The length of the statement  "			block.Instructions[i - 1] = new UsingInstruction(storeInst.Variable' storeInst.Value' tryFinally.TryBlock) { ILRange = storeInst.ILRange }; " is 139.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (!(tryFinally.TryBlock is BlockContainer tryContainer && tryContainer.EntryPoint.Instructions.FirstOrDefault() is StLoc storeInst)) " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (storeInst.Variable.AddressInstructions.Any(la => !la.IsDescendantOf(tryFinally) || (la.IsDescendantOf(tryFinally.TryBlock) && !ILInlining.IsUsedAsThisPointerInCall(la)))) " is 174.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,TransformUsingVB,The length of the statement  "			if (!(tryFinally.FinallyBlock is BlockContainer container) || !MatchDisposeBlock(container' storeInst.Variable' storeInst.Value.MatchLdNull())) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,CheckResourceType,The length of the statement  "			if (!type.GetMethods(m => m.Name == "GetEnumerator" && m.TypeParameters.Count == 0 && m.Parameters.Count == 0).Any(m => ImplementsForeachPattern(m.ReturnType))) " is 160.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,ImplementsForeachPattern,The length of the statement  "			if (!type.GetMethods(m => m.Name == "MoveNext" && m.TypeParameters.Count == 0 && m.Parameters.Count == 0).Any(m => m.ReturnType.IsKnownType(KnownTypeCode.Boolean))) " is 164.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The length of the statement  "				if (!isinst.MatchIsInst(out var load' out var disposableType) || !load.MatchLdLoc(objVar) || !disposableType.IsKnownType(KnownTypeCode.IDisposable)) " is 148.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The length of the statement  "				if (!(firstArg.MatchUnboxAny(out var innerArg1' out var unboxType) && unboxType.IsKnownType(KnownTypeCode.IDisposable))) { " is 122.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The length of the statement  "					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) { " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The length of the statement  "						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) { " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The length of the statement  "			string baseName = valueContext != null ? GetNameFromInstruction(valueContext) ?? GetNameByType(type) : GetNameByType(type); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The length of the statement  "				if (catchBlock.Filter is BlockContainer container && MatchCatchWhenEntryPoint(container' container.EntryPoint' out var exceptionType' out var exceptionSlot' out var whenConditionBlock)) { " is 187.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The length of the statement  "				if (!entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock)) " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The length of the statement  "				if (!entryPoint.Instructions[1].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock)) " is 145.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || tryContainer.EntryPoint.Instructions.Count == 0 || tryContainer.EntryPoint.IncomingEdgeCount != 1) " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' null' objectStore.Variable)) " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV4,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || !MatchLockEntryPoint(tryContainer.EntryPoint' flagStore.Variable' out StLoc objectStore)) " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV4,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 1] is StLoc flagStore) || !(block.Instructions[i - 2] is StLoc objectStore)) " is 152.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!objectStore.Variable.IsSingleDefinition || !flagStore.Variable.Type.IsKnownType(KnownTypeCode.Boolean) || !flagStore.Value.MatchLdcI4(0)) " is 142.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(body.TryBlock is BlockContainer tryContainer) || !MatchLockEntryPoint(tryContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The length of the statement  "			if (!(body.FinallyBlock is BlockContainer finallyContainer) || !MatchExitBlock(finallyContainer.EntryPoint' flagStore.Variable' objectStore.Variable)) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The length of the statement  "				if (!(cond.MatchLdLoc(flag) || (cond.MatchCompNotEquals(out var left' out var right) && left.MatchLdLoc(flag) && right.MatchLdcI4(0))) || !MatchExitBlock(trueBlock' obj)) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The length of the statement  "			} else if (newComparisonKind == ComparisonKind.Equality && !hasValueTestNegated && MatchHasValueCall(hasValueTest' out ILVariable v)) { " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The length of the statement  "			} else if (newComparisonKind == ComparisonKind.Inequality && hasValueTestNegated && MatchHasValueCall(hasValueTest' out v)) { " is 125.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The length of the statement  "				var newInst = new Comp(comp.Kind' ComparisonLiftingKind.ThreeValuedLogic' comp.InputType' comp.Sign' arg' comp.Right.Clone()) { " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The length of the statement  "			if (inst.MatchStLoc(out var v' out var initInst) && (v.Kind == VariableKind.Local || v.Kind == VariableKind.StackSlot)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The length of the statement  "						if (DelegateConstruction.IsDelegateConstruction(newObjInst) || DelegateConstruction.IsPotentialClosure(context' newObjInst)) " is 124.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodCallOnVariable,The length of the statement  "			if (inst.MatchLdFld(out var target' out _) || inst.MatchStFld(out target' out _' out _) || inst.MatchLdFlda(out target' out _)) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "			if (instructions[pos] is StLoc stloc && stloc.Variable.Kind == VariableKind.Local && stloc.Variable.IsSingleDefinition) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "				if (stloc.Value.Descendants.OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))) " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsPartOfInitializer,The length of the statement  "			(var kind' var newPath' var values' var targetVariable) = AccessPathElement.GetAccessPath(instructions[pos]' rootType' possibleIndexVariables); " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The length of the statement  "			if (kind != AccessPathKind.Invalid && values.SelectMany(v => v.Descendants).OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))) " is 184.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,IsMethodApplicable,The length of the statement  "			return targetType.GetAllBaseTypes().Any(i => i.IsKnownType(KnownTypeCode.IEnumerable) || i.IsKnownType(KnownTypeCode.IEnumerableOfT)); " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,BlockILTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\BlockTransform.cs,ToString,The length of the statement  "			return $"{nameof(BlockILTransform)} ({string.Join("' "' PreOrderTransforms.Concat(PostOrderTransforms).Select(t => t.GetType().Name))})"; " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,BlockILTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\BlockTransform.cs,Run,The length of the statement  "				throw new InvalidOperationException("Reentrancy detected. Transforms (and the CSharpDecompiler) are neither neither thread-safe nor re-entrant."); " is 146.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithField,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdsFld(out IField field) || !right.MatchLdNull()) " is 148.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithField,The length of the statement  "			if (!storeInst.MatchStsFld(out IField field2' out ILInstruction value) || !field.Equals(field2) || !field.IsCompilerGeneratedOrIsInCompilerGeneratedClass()) " is 156.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable v) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable s) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The length of the statement  "			if (!inst.Condition.MatchCompEquals(out ILInstruction left' out ILInstruction right) || !left.MatchLdLoc(out ILVariable s) || !right.MatchLdNull()) " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The length of the statement  "			if (!stobj.Target.MatchLdFlda(out var _' out var field1) || !ldobj.Target.MatchLdFlda(out var __' out var field2) || !field1.Equals(field2)) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,RunOnSingleStatment,The length of the statement  "			new ExpressionTransforms().Run(parent' statement.ChildIndex' new StatementTransformContext(new BlockTransformContext(context))); " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitConv,The length of the statement  "			if (inst.Argument.MatchLdLen(StackType.I' out ILInstruction array) && inst.TargetType.IsIntegerType() && !inst.CheckForOverflow) { " is 130.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformCatchVariable,The length of the statement  "			if (!exceptionSlotLoad.MatchLdLoc(handler.Variable) || !handler.Variable.IsSingleDefinition || handler.Variable.LoadCount != 1) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,LoopingBlockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LoopingTransform.cs,Run,The length of the statement  "				throw new InvalidOperationException("LoopingBlockTransform already running. Transforms (and the CSharpDecompiler) are neither neither thread-safe nor re-entrant."); " is 164.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,Run,The length of the statement  "				function.AcceptVisitor(new TransformDisplayClassUsages(function' target' target.Variable.CaptureScope' orphanedVariableInits' translatedDisplayClasses)); " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,IsAnonymousMethod,The length of the statement  "			if (!(method.IsCompilerGeneratedOrIsInCompilerGeneratedClass() || IsPotentialClosure(decompiledTypeDefinition' method.DeclaringTypeDefinition))) " is 144.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,TransformDelegateConstruction,The length of the statement  "				function.AcceptVisitor(new ReplaceDelegateTargetVisitor(target' function.Variables.SingleOrDefault(v => v.Index == -1 && v.Kind == VariableKind.Parameter))); " is 157.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformDisplayClassUsages,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,VisitCompoundAssignmentInstruction,The length of the statement  "					inst.ReplaceWith(new StLoc(v' new BinaryNumericInstruction(inst.Operator' inst.Target' inst.Value' inst.CheckForOverflow' inst.Sign))); " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "				if (ForwardScanInitializeArrayRuntimeHelper(body' pos + 1' v' elementType' arrayLength' out values' out initArrayPos)) { " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "					if (HandleSimpleArrayInitializer(body' pos + 1' v' elementType' arrayLength[0]' out values' out instructionsToRemove)) { " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "					if (HandleJaggedArrayInitializer(body' pos + 1' v' elementType' arrayLength[0]' out ILVariable finalStore' out values' out instructionsToRemove)) { " is 147.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The length of the statement  "						block.Instructions.AddRange(values.SelectWithIndex((i' value) => StElem(new LdLoc(tempStore)' new[] { new LdcI4(i) }' value' elementType))); " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The length of the statement  "				if (!block.Instructions[i].MatchStObj(out ILInstruction target' out ILInstruction value' out IType type) || value.Descendants.OfType<IInstructionWithVariableOperand>().Any(inst => inst.Variable == store)) " is 204.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The length of the statement  "				if (ldelem == null || !ldelem.Array.MatchLdLoc(store) || ldelem.Indices.Count != 1 || !ldelem.Indices[0].MatchLdcI4(out index)) " is 127.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The length of the statement  "				bool hasTemporaryCopy = block.Instructions[pos].MatchStLoc(out ILVariable temp' out ILInstruction storeLoad) && storeLoad.MatchLdLoc(store); " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The length of the statement  "			if (finalInstruction == null || !finalInstruction.MatchStObj(out tempAccess' out tempArrayLoad' out type) || !tempArrayLoad.MatchLdLoc(out initializerStore)) " is 157.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The length of the statement  "			if (elemLoad == null || !elemLoad.Array.MatchLdLoc(store) || elemLoad.Indices.Count != 1 || !elemLoad.Indices[0].MatchLdcI4(index)) " is 131.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The length of the statement  "			return nextInstruction != null && nextInstruction.MatchStLoc(initializerStore' out initializer) && initializer.OpCode == OpCode.Block; " is 134.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchInitializeArrayCall,The length of the statement  "			if (method.DeclaringTypeDefinition == null || method.DeclaringTypeDefinition.FullName != "System.Runtime.CompilerServices.RuntimeHelpers") " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI4((int)d[i])); " is 120.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI4((int)unchecked((sbyte)d[i]))); " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI4((int)BitConverter.ToInt16(d' i))); " is 142.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI4((int)BitConverter.ToUInt16(d' i))); " is 143.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI4(BitConverter.ToInt32(d' i))); " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcI8(BitConverter.ToInt64(d' i))); " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcF4(BitConverter.ToSingle(d' i))); " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DecodeArrayInitializer,The length of the statement  "					return DecodeArrayInitializer(initialValue' array' arrayLength' output' typeCode' type' (d' i) => new LdcF8(BitConverter.ToDouble(d' i))); " is 138.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,ValidateCompoundAssign,The length of the statement  "			if (conv != null && !(conv.TargetType == targetType.ToPrimitiveType() && conv.CheckForOverflow == binary.CheckForOverflow)) " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,MatchingGetterAndSetterCalls,The length of the statement  "			if (getterCall == null || setterCall == null || !IsSameMember(getterCall.Method.AccessorOwner' setterCall.Method.AccessorOwner)) " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorLocal,The length of the statement  "			if (inst == null || nextInst == null || !inst.Value.MatchLdLoc(out var loadVar) || !ILVariableEqualityComparer.Instance.Equals(loadVar' nextInst.Variable)) " is 155.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorLocal,The length of the statement  "			if ((binary.Operator != BinaryNumericOperator.Add && binary.Operator != BinaryNumericOperator.Sub) || !binary.Left.MatchLdLoc(inst.Variable) || !binary.Right.MatchLdcI4(1)) " is 172.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorLocal,The length of the statement  "			assignment.Instructions.Add(new StLoc(loadVar' new BinaryNumericInstruction(binary.Operator' new LdLoc(tempStore)' new LdcI4(1)' binary.CheckForOverflow' binary.Sign))); " is 169.
Long Statement,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperator,The length of the statement  "			inst.Value = new CompoundAssignmentInstruction(binary' inst.Value' binary.Right' targetType' CompoundAssignmentType.EvaluatesToOldValue); " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanUpBodyOfMoveNext,The length of the statement  "			foreach (var stloc in function.Descendants.OfType<StLoc>().Where(s => s.Variable.IsSingleDefinition && s.Value.MatchLdThis()).ToList()) { " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "					stobj System.Runtime.CompilerServices.AsyncVoidMethodBuilder(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<AwaitYield>d__3.<>t__builder](ldloca V_0)' call Create()) " is 185.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "					stobj System.Int32(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<AwaitYield>d__3.<>1__state](ldloca V_0)' ldc.i4 -1) " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "					stloc V_1(ldobj System.Runtime.CompilerServices.AsyncVoidMethodBuilder(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<AwaitYield>d__3.<>t__builder](ldloc V_0))) " is 180.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "			if (!(loadStateMachineForBuilderExpr.MatchLdLocRef(stateMachineVar) || loadStateMachineForBuilderExpr.MatchLdLoc(stateMachineVar))) " is 131.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "				if (!(init is NewObj newobj && newobj.Arguments.Count == 0 && newobj.Method.DeclaringTypeDefinition == stateMachineType)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			// stobj System.Int32(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<SimpleBoolTaskMethod>d__7.<>1__state](ldloc this)' ldc.i4 -2) " is 150.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			// call SetResult(ldflda [Field ICSharpCode.Decompiler.Tests.TestCases.Pretty.Async+<SimpleBoolTaskMethod>d__7.<>t__builder](ldloc this)' ldloc result) " is 151.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,InlineBodyOfMoveNext,The length of the statement  "			function.Variables.AddRange(function.Descendants.OfType<IInstructionWithVariableOperand>().Select(inst => inst.Variable).Distinct()); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The length of the statement  "			if (!(getAwaiterCall.Method.Name == "GetAwaiter" && (!getAwaiterCall.Method.IsStatic || getAwaiterCall.Method.IsExtensionMethod))) " is 130.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The length of the statement  "				// {stobj System.Runtime.CompilerServices.TaskAwaiter`1[[System.Int32]](ldflda <>u__$awaiter4(ldloc this)' ldloc V_6) at IL_0163} " is 129.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The length of the statement  "			if (block.Instructions[pos] is StLoc stlocM1 && stlocM1.Value.MatchLdcI4(initialState) && stlocM1.Variable.Kind == VariableKind.StackSlot) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CleanDoFinallyBodies,The length of the statement  "			if (entryPoint != null && entryPoint.Instructions[0].MatchStLoc(doFinallyBodies' out var value) && value.MatchLdcI4(1)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,GetBodyEntryPoint,The length of the statement  "			while (entryPoint.Instructions[0].MatchBranch(out var targetBlock) && targetBlock.IncomingEdgeCount == 1 && targetBlock.Parent == body) { " is 137.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,Run,The length of the statement  "			function.Variables.AddRange(newBody.Descendants.OfType<IInstructionWithVariableOperand>().Select(inst => inst.Variable).Distinct()); " is 132.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			foreach (var stloc in moveNextFunction.Descendants.OfType<StLoc>().Where(s => s.Variable.IsSingleDefinition && s.Value.MatchLdThis()).ToList()) { " is 145.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "			if (body.Blocks.Count == 1 && body.Blocks[0].Instructions.Count == 1 && body.Blocks[0].Instructions[0] is TryFault tryFault) { " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The length of the statement  "						if (ifInst.Condition.MatchLogicNot(out var arg) && arg.MatchLdLoc(out var v) && v.Type.IsKnownType(KnownTypeCode.Boolean)) { " is 124.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,PropagateCopiesOfFields,The length of the statement  "			var mutableFields = body.Descendants.OfType<LdFlda>().Where(ldflda => ldflda.Parent.OpCode != OpCode.LdObj).Select(ldflda => ldflda.Field).ToHashSet(); " is 151.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,The length of the statement  "				inst.ReplaceWith(new InvalidExpression("stateMachine") { ExpectedResultType = inst.ResultType' ILRange = inst.ILRange }); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,The length of the statement  "						Debug.Assert(blockState[branch.TargetBlock.ChildIndex] == stateAfterBranch || blockState[branch.TargetBlock.ChildIndex] == 0); " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,HandleIfInstruction,The length of the statement  "					if (targetBlock.Instructions.Count == 1 && targetBlock.Instructions[0].MatchIfInstruction(out nestedCondition' out nestedTrueInst)) { " is 133.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,UnpackBlockContainingOnlyBranch,The length of the statement  "			if (block != null && block.Instructions.Count == 1 && block.FinalInstruction is Nop && IsBranchOrLeave(block.Instructions[0])) " is 126.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,SimplifyBranchChains,The length of the statement  "				} else if (targetBlock.Instructions.Count == 1 && targetBlock.Instructions[0] is Leave leave && leave.Value.MatchNop()) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The length of the statement  "			if (block.Instructions.Count > 1 && block.Instructions[block.Instructions.Count - 2].HasFlag(InstructionFlags.MayBranch)) " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The length of the statement  "			if (!(block.Instructions.SecondToLastOrDefault() is StLoc deadStore && block.Instructions[block.Instructions.Count - 3] is StLoc tempStore)) " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The length of the statement  "			if (!(deadStore.Value.MatchLdLoc(tempStore.Variable) && tempStore.Variable.IsSingleDefinition && tempStore.Variable.LoadCount == 1)) " is 132.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,Run,The length of the statement  "					if (stloc != null && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,SplitBlocksAtWritesToPinnedLocals,The length of the statement  "					if (inst.MatchStLoc(out v) && v.Kind == VariableKind.PinnedLocal && block.Instructions[j + 1].OpCode != OpCode.Branch) { " is 120.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The length of the statement  "			if (!(condition != null && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull())) " is 139.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The length of the statement  "			if (inst is Conv conv && conv.Kind == ConversionKind.StopGCTracking && conv.Argument.MatchLdLoc(oldVar) && conv.ResultType == newVar.StackType) { " is 145.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The length of the statement  "				if ((inst is LdLoc || inst is StLoc) && !IsSlotAcceptingBothManagedAndUnmanagedPointers(inst.SlotInfo) && oldVar.StackType != StackType.I) { " is 140.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,The length of the statement  "			// stloc nativeVar(add(ldloc nativeVar' conv i4->i <sign extend>(call [Accessor System.Runtime.CompilerServices.RuntimeHelpers.get_OffsetToStringData():System.Int32]()))) " is 170.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,The length of the statement  "			while (entryPoint.IncomingEdgeCount == 1 && entryPoint.Instructions.Count == 1 && entryPoint.Instructions[0].MatchBranch(out var targetBlock)) { " is 144.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeSwitch,The length of the statement  "				if (matchValues.Count() > 1 && section.Body.MatchBranch(out var targetBlock) && AnalyzeBlock(targetBlock' matchValues)) { " is 121.
Long Statement,ICSharpCode.Decompiler.IL.ControlFlow,SwitchDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchDetection.cs,SortSwitchSections,The length of the statement  "			sw.Sections.ReplaceList(sw.Sections.OrderBy(s => (s.Body as Branch)?.TargetILOffset).ThenBy(s => s.Labels.Values.FirstOrDefault())); " is 132.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CallInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return Arguments.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | InstructionFlags.MayThrow | InstructionFlags.SideEffect; " is 135.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions' o.Instructions' ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction' ref match); " is 185.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.init.PerformMatch(o.init' ref match) && this.body.PerformMatch(o.body' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,BinaryNumericInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted; " is 221.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator; " is 222.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,BitNot,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType; " is 146.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.condition.PerformMatch(o.condition' ref match) && this.trueInst.PerformMatch(o.trueInst' ref match) && this.falseInst.PerformMatch(o.falseInst' ref match); " is 180.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.valueInst.PerformMatch(o.valueInst' ref match) && this.fallbackInst.PerformMatch(o.fallbackInst' ref match); " is 133.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,SwitchInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value' ref match) && Patterns.ListMatch.DoMatch(this.Sections' o.Sections' ref match); " is 153.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,SwitchSection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.body.PerformMatch(o.body' ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel; " is 136.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryCatch,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && Patterns.ListMatch.DoMatch(Handlers' o.Handlers' ref match); " is 128.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.filter.PerformMatch(o.filter' ref match) && this.body.PerformMatch(o.body' ref match) && variable == o.variable; " is 137.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && TryBlock.PerformMatch(o.TryBlock' ref match) && finallyBlock.PerformMatch(o.finallyBlock' ref match); " is 121.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.onExpression.PerformMatch(o.onExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 123.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return InstructionFlags.MayWriteLocals | resourceExpression.Flags | body.Flags | InstructionFlags.ControlFlow | InstructionFlags.SideEffect; " is 140.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression' ref match) && this.body.PerformMatch(o.body' ref match); " is 161.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Left.PerformMatch(o.Left' ref match) && this.Right.PerformMatch(o.Right' ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind; " is 192.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,CallIndirect,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments' o.Arguments' ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer' ref match); " is 175.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted; " is 214.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.destAddress.PerformMatch(o.destAddress' ref match) && this.sourceAddress.PerformMatch(o.sourceAddress' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 254.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.address.PerformMatch(o.address' ref match) && this.value.PerformMatch(o.value' ref match) && this.size.PerformMatch(o.size' ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 230.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 159.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.target.PerformMatch(o.target' ref match) && this.value.PerformMatch(o.value' ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix; " is 206.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,ComputeFlags,The length of the statement  "			return array.Flags | Indices.Aggregate(InstructionFlags.None' (f' arg) => f | arg.Flags) | (DelayExceptions ? InstructionFlags.None : InstructionFlags.MayThrow); " is 161.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,LdElema,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array' ref match) && Patterns.ListMatch.DoMatch(this.Indices' o.Indices' ref match) && IsReadOnly == o.IsReadOnly; " is 183.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.IL.Patterns,ExpressionTreeCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,PerformMatch,The length of the statement  "			return o != null && this.Argument.PerformMatch(o.Argument' ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked; " is 126.
Long Statement,ICSharpCode.Decompiler.FlowAnalysis,Dominance,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The length of the statement  "						for (var runner = p; runner != j.ImmediateDominator && runner != j && runner != null; runner = runner.ImmediateDominator) { " is 123.
Long Statement,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "			ILNameSyntax syntaxForElementTypes = syntax == ILNameSyntax.SignatureNoNamedTypeParameters ? syntax : ILNameSyntax.Signature; " is 125.
Long Statement,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "				} else if ((syntax == ILNameSyntax.Signature || syntax == ILNameSyntax.SignatureNoNamedTypeParameters) && name != null) { " is 121.
Long Statement,ICSharpCode.Decompiler.Disassembler,ILStructure,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,The length of the statement  "			if (this.Type == ILStructureType.Loop && newStructure.Type == ILStructureType.Loop && newStructure.StartOffset == this.StartOffset) " is 131.
Long Statement,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The length of the statement  "				if (childIndex < s.Children.Count && s.Children[childIndex].StartOffset <= offset && offset < s.Children[childIndex].EndOffset) { " is 129.
Long Statement,ICSharpCode.Decompiler.Disassembler,MethodBodyDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteInstruction,The length of the statement  "						output.WriteLine($"(line {sp.StartLine}' col {sp.StartColumn}) to (line {sp.EndLine}' col {sp.EndColumn}) in {sp.Document?.Url}"); " is 130.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodHeaderInternal,The length of the statement  "			WriteFlags(method.ImplAttributes & ~(MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask)' methodImpl); " is 120.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodBlock,The length of the statement  "			CloseBlock("end of method " + DisassemblerHelpers.Escape(method.DeclaringType.Name) + "::" + DisassemblerHelpers.Escape(method.Name)); " is 134.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,The length of the statement  "			const FieldAttributes hasXAttributes = FieldAttributes.HasDefault | FieldAttributes.HasFieldMarshal | FieldAttributes.HasFieldRVA; " is 130.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "			const TypeAttributes masks = TypeAttributes.ClassSemanticMask | TypeAttributes.VisibilityMask | TypeAttributes.LayoutMask | TypeAttributes.StringFormatMask; " is 156.
Long Statement,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteAssemblyReferences,The length of the statement  "					output.WriteLine(".ver {0}:{1}:{2}:{3}"' aref.Version.Major' aref.Version.Minor' aref.Version.Build' aref.Version.Revision); " is 124.
Long Statement,ICSharpCode.Decompiler.Semantics,ByReferenceResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\ByReferenceResolveResult.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} {1} {2}]"' GetType().Name' IsOut ? "out" : "ref"' ElementType); " is 120.
Long Statement,ICSharpCode.Decompiler.Semantics,Conversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,UserDefinedConversion,The length of the statement  "			return new UserDefinedConv(isImplicit' operatorMethod' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous); " is 151.
Long Statement,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,Equals,The length of the statement  "				return o != null && isLifted == o.isLifted && isImplicit == o.isImplicit && isValid == o.isValid && method.Equals(o.method); " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem,AssemblyLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AssemblyLoader.cs,Create,The length of the statement  "					return (AssemblyLoader)Assembly.Load ("ICSharpCode.Decompiler.Cecil").CreateInstance ("ICSharpCode.Decompiler.TypeSystem.CecilLoader"); " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem,AssemblyLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AssemblyLoader.cs,Create,The length of the statement  "					return (AssemblyLoader)Assembly.Load ("ICSharpCode.Decompiler.IKVM").CreateInstance ("ICSharpCode.Decompiler.TypeSystem.IkvmLoader"); " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,LoadModule,The length of the statement  "			this.currentAssembly = new DefaultUnresolvedAssembly(assemblyDefinition != null ? assemblyDefinition.Name.FullName : moduleDefinition.Name); " is 140.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,CreateType,The length of the statement  "				return TypeParameterReference.Create(typeGP.Owner is MethodReference ? SymbolKind.Method : SymbolKind.TypeDefinition' typeGP.Position); " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,CreateType,The length of the statement  "					return interningProvider.Intern(new GetClassTypeReference(GetAssemblyReference(type.Scope)' ns' name' typeParameterCount)); " is 123.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "				var assemblyVersion = new DefaultUnresolvedAttribute(assemblyVersionAttributeTypeRef' new[] { KnownTypeReference.String }); " is 123.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "				assemblyVersion.PositionalArguments.Add(CreateSimpleConstantValue(KnownTypeReference.String' assembly.Name.Version.ToString())); " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "					dllImport.AddNamedFieldArgument("CallingConvention"' CreateSimpleConstantValue(callingConventionTypeRef' (int)callingConvention)); " is 130.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "			LayoutKind defaultLayoutKind = (typeDefinition.IsValueType && !typeDefinition.IsEnum) ? LayoutKind.Sequential: LayoutKind.Auto; " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "			if (layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0) { " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "				DefaultUnresolvedAttribute structLayout = new DefaultUnresolvedAttribute(structLayoutAttributeTypeRef' new[] { layoutKindTypeRef }); " is 132.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "					structLayout.AddNamedFieldArgument("Pack"' CreateSimpleConstantValue(KnownTypeReference.Int32' (int)typeDefinition.PackingSize)); " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "					structLayout.AddNamedFieldArgument("Size"' CreateSimpleConstantValue(KnownTypeReference.Int32' (int)typeDefinition.ClassSize)); " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The length of the statement  "				DefaultUnresolvedAttribute fieldOffset = new DefaultUnresolvedAttribute(fieldOffsetAttributeTypeRef' new[] { KnownTypeReference.Int32 }); " is 137.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ConvertMarshalInfo,The length of the statement  "			DefaultUnresolvedAttribute attr = new DefaultUnresolvedAttribute(marshalAsAttributeTypeRef' new[] { unmanagedTypeTypeRef }); " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ConvertMarshalInfo,The length of the statement  "				attr.AddNamedFieldArgument("SafeArraySubType"' CreateSimpleConstantValue(typeof(VarEnum).ToTypeReference()' (int)sami.ElementType)); " is 132.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ConvertMarshalInfo,The length of the statement  "					attr.AddNamedFieldArgument("SizeParamIndex"' CreateSimpleConstantValue(KnownTypeReference.Int16' (short)ami.SizeParameterIndex)); " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ConvertMarshalInfo,The length of the statement  "					attr.AddNamedFieldArgument("MarshalType"' CreateSimpleConstantValue(KnownTypeReference.String' cmi.ManagedType.FullName)); " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,InitMembers,The length of the statement  "							} else if (property.Name.EndsWith(".Item"' StringComparison.Ordinal) && (property.GetMethod ?? property.SetMethod).HasOverrides) { " is 130.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,HasExtensionAttribute,The length of the statement  "					if (attr.AttributeType.Name == "ExtensionAttribute" && attr.AttributeType.Namespace == "System.Runtime.CompilerServices") " is 121.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The length of the statement  "			// DecimalConstantAttribute has the arguments (byte scale' byte sign' uint hi' uint mid' uint low) or (byte scale' byte sign' int hi' int mid' int low) " is 151.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The length of the statement  "			// Both of these invoke the Decimal constructor (int lo' int mid' int hi' bool isNegative' byte scale) with explicit argument conversions if required. " is 150.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The length of the statement  "			if (!ctorArgs.Select(a => a.GetType()).SequenceEqual(new[] { typeof(byte)' typeof(byte)' typeof(int)' typeof(int)' typeof(int) })) " is 130.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ReadField,The length of the statement  "				var decConstant = field.CustomAttributes.FirstOrDefault(a => a.AttributeType.FullName == "System.Runtime.CompilerServices.DecimalConstantAttribute"); " is 149.
Long Statement,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,ReadProperty,The length of the statement  "				p.Accessibility = MergePropertyAccessibility (GetAccessibility (property.GetMethod.Attributes)' GetAccessibility (property.SetMethod.Attributes)); " is 146.
Long Statement,ICSharpCode.Decompiler.TypeSystem,DecompilerTypeSystem,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DecompilerTypeSystem.cs,CreateFakeMethod,The length of the statement  "					m.TypeParameters.Add(new DefaultUnresolvedTypeParameter(SymbolKind.Method' i' methodReference.GenericParameters[i].Name)); " is 122.
Long Statement,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetAccessors(m => m.Name == member.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 145.
Long Statement,ICSharpCode.Decompiler.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetMembers(m => m.Name == member.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 143.
Long Statement,ICSharpCode.Decompiler.TypeSystem,SpecialType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\SpecialType.cs,Equals,The length of the statement  "			// However' an unknown type with additional information is not considered to be equal to the SpecialType with TypeKind.Unknown. " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TopLevelTypeName,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TopLevelTypeName.cs,Equals,The length of the statement  "			return this.namespaceName == other.namespaceName && this.name == other.name && this.typeParameterCount == other.typeParameterCount; " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TopLevelTypeName,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TopLevelTypeName.cs,GetHashCode,The length of the statement  "			return (name != null ? name.GetHashCode() : 0) ^ (namespaceName != null ? namespaceName.GetHashCode() : 0) ^ typeParameterCount; " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var classTypeArguments = f.classTypeArguments != null ? GetComposedTypeArguments(f.classTypeArguments' g) : g.classTypeArguments; " is 129.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var methodTypeArguments = f.methodTypeArguments != null ? GetComposedTypeArguments(f.methodTypeArguments' g) : g.methodTypeArguments; " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,CreateResolvedAttributes,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedAttribute' IAttribute>(context' attributes' (c' a) => a.CreateResolvedAttribute(c)); " is 141.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,CreateResolvedTypeParameters,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedTypeParameter' ITypeParameter>(context' typeParameters' (c' a) => a.CreateResolvedTypeParameter(c)); " is 157.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,CreateResolvedParameters,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedParameter' IParameter>(context' parameters' (c' a) => a.CreateResolvedParameter(c)); " is 141.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs,Resolve,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IConstantValue' ResolveResult>(context' constantValues' (c' t) => t.Resolve(c)); " is 126.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,IsCompatibleTypeForMemoryAccess,The length of the statement  "			if (memoryStackType == accessStackType && memoryStackType.IsIntegerType() && GetSize(memoryType) == GetSize(accessType)) " is 120.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,IsBaseMethod,The length of the statement  "				if (!parentMethod.HasParameters || !childMethod.HasParameters || parentMethod.Parameters.Count != childMethod.Parameters.Count) " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,IsBaseProperty,The length of the statement  "				if (!parentProperty.HasParameters || !childProperty.HasParameters || parentProperty.Parameters.Count != childProperty.Parameters.Count) " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,MatchMethod,The length of the statement  "				if (!mCandidate.HasGenericParameters || !mMethod.HasGenericParameters || mCandidate.GenericParameters.Count != mMethod.GenericParameters.Count) " is 143.
Long Statement,ICSharpCode.Decompiler.TypeSystem,TypesHierarchyHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypesHierarchyHelpers.cs,MatchInterfaceMethod,The length of the statement  "				var methodContext = new GenericContext<TypeDefinition>(interfaceContextType.Resolve()' ((GenericInstanceType)interfaceContextType).GenericArguments); " is 149.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The length of the statement  "			} else if (unresolved.IsStatic || !unresolved.IsPublic || DeclaringTypeDefinition == null || DeclaringTypeDefinition.Kind == TypeKind.Interface) { " is 146.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The length of the statement  "				result = result.Where(item => !otherMembers.Any(m => m.IsExplicitInterfaceImplementation && m.ImplementedInterfaceMembers.Contains(item))).ToArray(); " is 149.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The length of the statement  "			return Resolve(ExtendContextForType(context' this.DeclaringTypeDefinition)' this.SymbolKind' this.Name' interfaceTypeReference); " is 128.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,CurrentAssemblyReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultAssemblyReference.cs,Resolve,The length of the statement  "					throw new ArgumentException("A reference to the current assembly cannot be resolved in the compilation's global type resolve context."); " is 136.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultMemberReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultMemberReference.cs,EqualsForInterning,The length of the statement  "			return o != null && symbolKind == o.symbolKind && typeReference == o.typeReference && name == o.name && parameterTypes == o.parameterTypes; " is 139.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,ParameterReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultParameter.cs,Resolve,The length of the statement  "			return new DefaultParameter(type.Resolve(context)' name' region: region' isRef: isRef' isOut: isOut' isParams: isParams' isOptional: isOptional' defaultValue: defaultValue); " is 173.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The length of the statement  "				if (kind == TypeKind.Class && !this.IsStatic && !unresolvedMembers.Any(m => m.SymbolKind == SymbolKind.Constructor && !m.IsStatic) " is 130.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,ToTypeReference,The length of the statement  "				return new NestedTypeReference(declTypeDef.ToTypeReference()' this.Name' this.TypeParameterCount - declTypeDef.TypeParameterCount); " is 131.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,EqualsForInterning,The length of the statement  "				defaultValue == p.defaultValue && region == p.region && (flags & ~1) == (p.flags & ~1) && ListEquals(attributes' p.attributes); " is 127.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,ListEquals,The length of the statement  "			return (list1 ?? EmptyList<IUnresolvedAttribute>.Instance).SequenceEqual(list2 ?? EmptyList<IUnresolvedAttribute>.Instance); " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedTypeParameter.cs,CreateResolvedTypeParameter,The length of the statement  "				this.HasValueTypeConstraint' this.HasReferenceTypeConstraint' this.HasDefaultConstructorConstraint' this.Constraints.Resolve(context) " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,ExplicitInterfaceImplementationMemberReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\ExplicitInterfaceImplementationMemberReference.cs,Resolve,The length of the statement  "			IMember interfaceMember = interfaceMemberReference.Resolve(context.WithCurrentTypeDefinition(declaringType.GetDefinition())); " is 125.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,ExplicitInterfaceImplementationMemberReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\ExplicitInterfaceImplementationMemberReference.cs,Resolve,The length of the statement  "			return members.FirstOrDefault(m => m.ImplementedInterfaceMembers.Count == 1 && interfaceMember.Equals(m.ImplementedInterfaceMembers[0])); " is 137.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetNestedTypesImpl,The length of the statement  "				if (totalTypeParameterCount == 0 || (options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions) { " is 135.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetAccessorsImpl,The length of the statement  "			return GetConstructorsOrAccessorsImpl(baseType' baseType.GetAccessors(filter' options | declaredMembers)' filter' options); " is 123.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetConstructorsImpl,The length of the statement  "			return GetConstructorsOrAccessorsImpl(baseType' baseType.GetConstructors(filter' options | declaredMembers)' filter' options); " is 126.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,NestedTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\NestedTypeReference.cs,EqualsForInterning,The length of the statement  "			return o != null && declaringTypeRef == o.declaringTypeRef && name == o.name && additionalTypeParameterCount == o.additionalTypeParameterCount; " is 143.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,ToReference,The length of the statement  "			//   If this member is specialized using open generic types' the resulting member reference will need to be looked up in an appropriate generic context. " is 152.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "			return this.baseMember.Equals(other.baseMember) && this.substitutionWithoutSpecializedTypeParameters.Equals(other.substitutionWithoutSpecializedTypeParameters); " is 160.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedTypeParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "				// Compare the owner' not the substitution' because the substitution may contain this specialized type parameter recursively " is 124.
Long Statement,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The length of the statement  "				TypeParameterReference[] arr = (ownerType == SymbolKind.TypeDefinition) ? classTypeParameterReferences : methodTypeParameterReferences; " is 135.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The conditional expression  "callOpCode == OpCode.CallVirt  					&& constrainedTo == null  					&& target.Expression is CastExpression cast  					&& target.ResolveResult is ConversionResolveResult conversion  					&& target.Type.IsKnownType(KnownTypeCode.Object)  					&& conversion.Conversion.IsBoxingConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,Build,The conditional expression  "arg.ResolveResult is ArrayCreateResolveResult acrr &&  						acrr.SizeArguments.Count == 1 &&  						acrr.SizeArguments[0].IsCompileTimeConstant &&  						acrr.SizeArguments[0].ConstantValue is int length"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "Expression is CastExpression cast  							&& (type.IsKnownType(KnownTypeCode.Object) && conversion.Conversion.IsBoxingConversion  								|| conversion.Conversion.IsAnonymousFunctionConversion  								|| (conversion.Conversion.IsImplicit && (conversion.Conversion.IsUserDefined || targetType.IsKnownType(KnownTypeCode.Decimal)))  							)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "Expression is ObjectCreateExpression oce && conversion.Conversion.IsMethodGroupConversion  									&& oce.Arguments.Count == 1 && expressionBuilder.settings.UseImplicitMethodGroupConversion"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The conditional expression  "targetType.Kind == TypeKind.Pointer && type.IsKnownType(KnownTypeCode.Char)  			   || targetType.IsKnownType(KnownTypeCode.Char) && type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,MemberIsHidden,The conditional expression  "method.IsGetter || method.IsSetter || method.IsAddOn || method.IsRemoveOn"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The conditional expression  "enumDec.Initializer is PrimitiveExpression primitive && initValue > 9 && ((initValue & (initValue - 1)) == 0 || (initValue & (initValue + 1)) == 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitBitNot,The conditional expression  "argUType.GetStackType().GetSize() < inst.UnderlyingResultType.GetSize()  			    || argUType.Kind == TypeKind.Enum && argUType.IsSmallIntegerType()  				|| argUType.GetStackType() == StackType.I  				|| argUType.IsKnownType(KnownTypeCode.Boolean)  				|| argUType.IsKnownType(KnownTypeCode.Char)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitStLoc,The conditional expression  "inst.Variable.Kind == VariableKind.StackSlot && inst.Variable.IsSingleDefinition  			    && inst.Variable.StackType == translatedValue.Type.GetStackType()  			    && translatedValue.Type.Kind != TypeKind.Null && !loadedVariablesSet.Contains(inst.Variable)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The conditional expression  "rr == null || rr.IsError || rr.UserDefinedOperatorMethod != null  			    || NullableType.GetUnderlyingType(rr.Operands[0].Type).GetStackType() != inst.InputType"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateCeq,The conditional expression  "rr == null || rr.IsError || rr.UserDefinedOperatorMethod != null  					|| NullableType.GetUnderlyingType(rr.Operands[0].Type).GetStackType() != inst.InputType"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,GetPointerArithmeticOffset,The conditional expression  "elementSize > 0 && mul.Right.MatchLdcI(elementSize.Value)  					|| mul.Right.UnwrapConv(ConversionKind.SignExtend) is SizeOf sizeOf && sizeOf.Type.Equals(pointerType.ElementType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleBinaryNumeric,The conditional expression  "rr.IsError || NullableType.GetUnderlyingType(rr.Type).GetStackType() != inst.UnderlyingResultType  			    || !IsCompatibleWithSign(left.Type' inst.Sign) || !IsCompatibleWithSign(right.Type' inst.Sign)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ValueMightBeOversized,The conditional expression  "stackType == StackType.I && orr.OperatorType == ExpressionType.Subtract  					&& orr.Operands.Count == 2  					&& orr.Operands[0].Type.Kind == TypeKind.Pointer  					&& orr.Operands[1].Type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,VisitLdFlda,The conditional expression  "settings.FixedBuffers && inst.Field.Name == "FixedElementField"  				&& inst.Target is LdFlda nestedLdFlda  				&& CSharpDecompiler.IsFixedField(nestedLdFlda.Field' out var elementType' out _)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The conditional expression  "stloc == null || final == null || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,MakeInitializerAssignment,The conditional expression  "values.Count == 1 && !(values[0] is AssignmentExpression) && !(method.SymbolKind == SymbolKind.Method && method.Name == "Add")"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateArrayInitializer,The conditional expression  "stloc == null || final == null || !stloc.Value.MatchNewArr(out type) || stloc.Variable != final.Variable || stloc.Variable.Kind != VariableKind.InitializerTarget"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslatePostfixOperator,The conditional expression  "targetInst == null || inst == null || (inst.Operator != BinaryNumericOperator.Add && inst.Operator != BinaryNumericOperator.Sub)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,InvertConditionInternal,The conditional expression  "(bOp.Operator == BinaryOperatorType.Equality) || (bOp.Operator == BinaryOperatorType.InEquality) || (bOp.Operator == BinaryOperatorType.GreaterThan)  					|| (bOp.Operator == BinaryOperatorType.GreaterThanOrEqual) || (bOp.Operator == BinaryOperatorType.LessThan) ||   					(bOp.Operator == BinaryOperatorType.LessThanOrEqual)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,AddParensForUnaryExpressionIfRequired,The conditional expression  "(expression is BinaryOperatorExpression) ||  			    (expression is AssignmentExpression) ||  			    (expression is CastExpression) ||  			    (expression is AsExpression) ||  			    (expression is IsExpression) ||  			    (expression is LambdaExpression) ||  			    (expression is ConditionalExpression)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,SyntaxTree,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxTree.cs,GetTypes,The conditional expression  "!(child is Statement || child is Expression) &&  					    (child.Role != Roles.TypeMemberRole || ((child is TypeDeclaration || child is DelegateDeclaration) && includeInnerTypes))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The conditional expression  "method.IsExtensionMethod && method.ReducedFrom == null && decl.Parameters.Any() && decl.Parameters.First().ParameterModifier == ParameterModifier.None"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertMethod,The conditional expression  "this.ShowTypeParameters && this.ShowTypeParameterConstraints && !method.IsOverride && !method.IsExplicitInterfaceImplementation"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertTypeParameterConstraint,The conditional expression  "!tp.HasDefaultConstructorConstraint && !tp.HasReferenceTypeConstraint && !tp.HasValueTypeConstraint && tp.DirectBaseTypes.All(IsObjectOrValueType)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,MaybeNewLinesAfterUsings,The conditional expression  "(node is UsingDeclaration || node is UsingAliasDeclaration) && !(nextSibling is UsingDeclaration || nextSibling is UsingAliasDeclaration)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertRequiredSpacesDecorator,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertRequiredSpacesDecorator.cs,WriteToken,The conditional expression  "lastWritten == LastWritten.Plus && token[0] == '+' ||  			    lastWritten == LastWritten.Minus && token[0] == '-' ||  			    lastWritten == LastWritten.Ampersand && token[0] == '&' ||  			    lastWritten == LastWritten.QuestionMark && token[0] == '?' ||  			    lastWritten == LastWritten.Division && token[0] == '*'"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackGenericArrayInterface,The conditional expression  "tc == KnownTypeCode.IListOfT || tc == KnownTypeCode.ICollectionOfT || tc == KnownTypeCode.IEnumerableOfT || tc == KnownTypeCode.IReadOnlyListOfT"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackExpressionTreeType,The conditional expression  "pt != null && pt.TypeParameterCount == 1 && pt.Name == "Expression" && pt.Namespace == "System.Linq.Expressions""  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,UnpackTask,The conditional expression  "pt != null && pt.TypeParameterCount == 1 && pt.Name == "Task" && pt.Namespace == "System.Threading.Tasks""  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveUnaryOperator,The conditional expression  "(code >= TypeCode.Char && code <= TypeCode.Decimal) || type.Kind == TypeKind.Enum || type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The conditional expression  "lhsType.Kind == TypeKind.Null && rhsType.IsReferenceType == false  			    || lhsType.IsReferenceType == false && rhsType.Kind == TypeKind.Null"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveBinaryOperator,The conditional expression  "lhsType.Kind == TypeKind.Null && IsNullableTypeOrNonValueType(rhs.Type)  							           || IsNullableTypeOrNonValueType(lhs.Type) && rhsType.Kind == TypeKind.Null"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumComparison,The conditional expression  "lhs.IsCompileTimeConstant && rhs.IsCompileTimeConstant && !isNullable && elementType.Kind != TypeKind.Enum"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,HandleEnumSubtraction,The conditional expression  "lhs.IsCompileTimeConstant && rhs.IsCompileTimeConstant && !isNullable && elementType.Kind != TypeKind.Enum"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "isNullable && lhs.Type.Kind == TypeKind.Null && rhsCode >= TypeCode.Boolean && rhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "isNullable && rhs.Type.Kind == TypeKind.Null && lhsCode >= TypeCode.Boolean && lhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,BinaryNumericPromotion,The conditional expression  "lhsCode >= TypeCode.Char && lhsCode <= TypeCode.Decimal  			    && rhsCode >= TypeCode.Char && rhsCode <= TypeCode.Decimal"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,AdjustArrayAccessArguments,The conditional expression  "!(TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.Int32)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.UInt32)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.Int64)) ||  				      TryConvert(ref arguments[i]' compilation.FindType(KnownTypeCode.UInt64)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The conditional expression  "(brrr.IsOut && !candidate.Parameters[parameterIndex].IsOut) || (brrr.IsRef && !candidate.Parameters[parameterIndex].IsRef)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,CheckApplicability,The conditional expression  "(!c.IsValid && !c.IsUserDefined && !c.IsMethodGroupConversion) && parameterType.Kind != TypeKind.Unknown"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,GetDelegateOrExpressionTreeSignature,The conditional expression  "pt != null && pt.TypeParameterCount == 1 && pt.Name == "Expression"  			    && pt.Namespace == "System.Linq.Expressions""  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Resolver,TypeInference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs,MakeExactInference,The conditional expression  "pU != null && pV != null  			    && object.Equals(pU.GetDefinition()' pV.GetDefinition())  			    && pU.TypeParameterCount == pV.TypeParameterCount"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceExtensionMethods,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceExtensionMethods.cs,VisitInvocationExpression,The conditional expression  "method == null || !method.IsExtensionMethod || mre == null || !(mre.Target is TypeReferenceExpression) || !invocationExpression.Arguments.Any()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The conditional expression  "!itemVariable.IsSingleDefinition  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,TypePattern,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs,DoMatch,The conditional expression  "ct != null && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceUnsafeModifier,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUnsafeModifier.cs,VisitUnaryOperatorExpression,The conditional expression  "bop != null && bop.Operator == BinaryOperatorType.Add   					&& bop.GetResolveResult() is OperatorResolveResult orr  					&& orr.Operands.FirstOrDefault()?.Type.Kind == TypeKind.Pointer"  is complex.
Complex Conditional,ICSharpCode.Decompiler,TextTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentMemberReference,The conditional expression  "node is IdentifierExpression && node.Role == Roles.TargetExpression && node.Parent is InvocationExpression && symbol is IMember member"  is complex.
Complex Conditional,ICSharpCode.Decompiler,TextTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Output\TextTokenWriter.cs,GetCurrentLocalDefinition,The conditional expression  "node is ParameterDeclaration || node is VariableInitializer || node is CatchClause || node is ForeachStatement"  is complex.
Complex Conditional,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,IsAnonymousType,The conditional expression  "string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))"  is complex.
Complex Conditional,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,GetSpecializingTypeSystem,The conditional expression  "(classTypeParameters != null && classTypeParameters.Count > 0) || (methodTypeParameters != null && methodTypeParameters.Count > 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler,NRExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\NRExtensions.cs,IsAnonymousType,The conditional expression  "string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ReadTypeName,The conditional expression  "pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLogicNot,The conditional expression  "this is Comp comp && comp.Kind == ComparisonKind.Equality  				&& comp.LiftingKind == ComparisonLiftingKind.None  				&& comp.Right.MatchLdcI4(0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchCompEquals,The conditional expression  "this.MatchLogicNot(out var arg) && arg is Comp nestedComp && nestedComp.Kind == ComparisonKind.Inequality && !nestedComp.IsLifted"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchCompNotEquals,The conditional expression  "this.MatchLogicNot(out var arg) && arg is Comp nestedComp && nestedComp.Kind == ComparisonKind.Equality && !nestedComp.IsLifted"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLdFld,The conditional expression  "this is LdObj ldobj && ldobj.Target is LdFlda ldflda && ldobj.UnalignedPrefix == 0 && !ldobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchLdsFld,The conditional expression  "this is LdObj ldobj && ldobj.Target is LdsFlda ldsflda && ldobj.UnalignedPrefix == 0 && !ldobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchStsFld,The conditional expression  "this is StObj stobj && stobj.Target is LdsFlda ldsflda && stobj.UnalignedPrefix == 0 && !stobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL,ILInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,MatchStFld,The conditional expression  "this is StObj stobj && stobj.Target is LdFlda ldflda && stobj.UnalignedPrefix == 0 && !stobj.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,EarlyExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\EarlyExpressionTransforms.cs,StObjToStLoc,The conditional expression  "inst.Target.MatchLdLoca(out ILVariable v)  				&& TypeUtils.IsCompatibleTypeForMemoryAccess(new ByReferenceType(v.Type)' inst.Type)  				&& inst.UnalignedPrefix == 0  				&& !inst.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,EarlyExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\EarlyExpressionTransforms.cs,LdObjToLdLoc,The conditional expression  "inst.Target.MatchLdLoca(out ILVariable v)  				&& TypeUtils.IsCompatibleTypeForMemoryAccess(new ByReferenceType(v.Type)' inst.Type)  				&& inst.UnalignedPrefix == 0  				&& !inst.IsVolatile"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The conditional expression  "i >= 2 && instructions[i - 2].MatchStLoc(otherSwitchValueVar' out switchValue)  					&& otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The conditional expression  "!(condition.MatchCompEquals(out var left' out var right) && right.MatchLdNull()  				&& ((SemanticHelper.IsPure(switchValue.Flags) && left.Match(switchValue).Success) || left.MatchLdLoc(switchValueVar)))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The conditional expression  "!(condition.MatchLogicNot(out var arg) && arg is Call c && c.Method.Name == "TryGetValue" &&  				MatchDictionaryFieldLoad(c.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The conditional expression  "!(block.Instructions[i + 1].MatchStObj(out var loadField' out var dictVarLoad' out var dictType) &&  				dictType.Equals(dictionaryType) && loadField.MatchLdsFlda(out var dictField) && dictField.Equals(dictionaryField) &&  				dictVarLoad.MatchLdLoc(dictVar))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The conditional expression  "!(getItemCall.Arguments.Count == 2 && MatchDictionaryFieldLoad(getItemCall.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField)) &&  				getItemCall.Arguments[1].MatchLdLoc(switchVariable2)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The conditional expression  "!(switchBlock.Instructions[0] is SwitchInstruction switchInst && switchInst.Value.MatchLdObj(out var target' out var ldobjType) &&  				target.MatchUnbox(out var arg' out var unboxType) && arg.MatchLdLoc(switchVariable2) && ldobjType.IsKnownType(KnownTypeCode.Int32) && unboxType.Equals(ldobjType))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The conditional expression  "i > 1 && instructions[i - 2].MatchStLoc(switchValueLoad.Variable' out var switchValueTmp) &&  				switchValueLoad.Variable.IsSingleDefinition && switchValueLoad.Variable.LoadCount == switchInst.Sections.Count"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchComputeStringHashCall,The conditional expression  "!(value is Call c && c.Arguments.Count == 1 && c.Method.Name == "ComputeStringHash" && c.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass())"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchStringEqualityComparison,The conditional expression  "condition is Call c && c.Method.IsOperator && c.Method.Name == "op_Equality"  				&& c.Method.DeclaringType.IsKnownType(KnownTypeCode.String) && c.Arguments.Count == 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The conditional expression  "instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameByType,The conditional expression  "name.Length >= 3 && name[0] == 'I' && char.IsUpper(name[1]) && char.IsLower(name[2])"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The conditional expression  "name.Length > 1 && name[0] == '_' && (char.IsLetter(name[1]) || name[1] == '_')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The conditional expression  "(left.MatchLdNull() && right.MatchLdLoc(temp)) || (right.MatchLdNull() && left.MatchLdLoc(temp))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The conditional expression  "!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 2] is StLoc objectStore) ||  				!objectStore.Value.MatchLdLoc(out var tempVar) || !MatchCall(block.Instructions[i - 1] as Call' "Enter"' tempVar)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The conditional expression  "!(cond.MatchLdLoc(flag) || (cond.MatchCompNotEquals(out var left' out var right) && left.MatchLdLoc(flag) && right.MatchLdcI4(0))) || !MatchExitBlock(trueBlock' obj)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The conditional expression  "call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != 2"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The conditional expression  "call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != variables.Length"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchCompOrDecimal,The conditional expression  "inst is Call call && call.Method.IsOperator && call.Arguments.Count == 2 && !call.IsLifted"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpEqualityComparison,The conditional expression  "left != null && right != null && leftBits[0] && rightBits[0]  					&& SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpComparison,The conditional expression  "left != null && right != null && SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,The conditional expression  "left != null && right != null && leftBits[0] && rightBits[0]  				&& SemanticHelper.IsPure(left.Flags) && SemanticHelper.IsPure(right.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftNormal,The conditional expression  "trueInst is Call call && !call.IsLifted  					&& CSharp.Resolver.CSharpOperators.IsComparisonOperator(call.Method)  					&& falseInst.MatchLdcI4(call.Method.Name == "op_Inequality" ? 1 : 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The conditional expression  "inst is Comp comp && !comp.IsLifted && comp.Kind == ComparisonKind.Equality  				&& MatchGetValueOrDefault(comp.Left' out ILVariable v)  				&& NullableType.GetUnderlyingType(v.Type).IsKnownType(KnownTypeCode.Boolean)  				&& comp.Right.MatchLdcI4(0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,NullCoalescingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullCoalescingTransform.cs,TransformRefTypes,The conditional expression  "condition.MatchCompEquals(out var left' out var right) && left.MatchLdLoc(stloc.Variable) && right.MatchLdNull()  				&& trueInst.MatchStLoc(stloc.Variable' out var fallbackValue)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The conditional expression  "kind != AccessPathKind.Invalid && values.SelectMany(v => v.Descendants).OfType<IInstructionWithVariableOperand>().Any(ld => ld.Variable == target && (ld is LdLoc || ld is LdLoca))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The conditional expression  "v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynInStaticWithLocal,The conditional expression  "storeBeforeIf == null || storeInst == null || storeBeforeIf.Variable != s || storeInst.Variable != s"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationRoslynWithLocal,The conditional expression  "storeBeforeIf == null || storeInst == null || storeBeforeIf.Variable != s || storeInst.Variable != s"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,The conditional expression  "inst.Kind == ComparisonKind.Inequality && inst.LiftingKind == ComparisonLiftingKind.None  				&& inst.Right.MatchLdcI4(0) && (IfInstruction.IsInConditionSlot(inst) || inst.Left is Comp)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitComp,The conditional expression  "rightWithoutConv.MatchLdcI4(0)  			    && inst.Sign == Sign.Unsigned  			    && (inst.Kind == ComparisonKind.GreaterThan || inst.Kind == ComparisonKind.LessThanOrEqual)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,CleanUpArrayIndices,The conditional expression  "index is Conv conv && conv.ResultType == StackType.I  					&& (conv.Kind == ConversionKind.Truncate && conv.CheckForOverflow  						|| conv.Kind == ConversionKind.ZeroExtend || conv.Kind == ConversionKind.SignExtend)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The conditional expression  "args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitIfInstruction,The conditional expression  "inst.TrueInst.MatchLdcI4(0) && !inst.FalseInst.MatchLdcI4(0)  				|| inst.FalseInst.MatchLdcI4(1) && !inst.TrueInst.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleSimpleArrayInitializer,The conditional expression  "ldelem == null || !ldelem.Array.MatchLdLoc(store) || ldelem.Indices.Count != 1 || !ldelem.Indices[0].MatchLdcI4(out index)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchJaggedArrayStore,The conditional expression  "elemLoad == null || !elemLoad.Array.MatchLdLoc(store) || elemLoad.Indices.Count != 1 || !elemLoad.Indices[0].MatchLdcI4(index)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorLocal,The conditional expression  "inst == null || nextInst == null || !inst.Value.MatchLdLoc(out var loadVar) || !ILVariableEqualityComparer.Instance.Equals(loadVar' nextInst.Variable)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformPostIncDecOperatorLocal,The conditional expression  "(binary.Operator != BinaryNumericOperator.Add && binary.Operator != BinaryNumericOperator.Sub) || !binary.Left.MatchLdLoc(inst.Variable) || !binary.Right.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchCall,The conditional expression  "inst is CallInstruction call && (call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt)  				&& call.Method.Name == name && !call.Method.IsStatic"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The conditional expression  "((BlockContainer)mainTryCatch.TryBlock).EntryPoint.Instructions[0] is StLoc initDoFinallyBodies  				&& initDoFinallyBodies.Variable.Kind == VariableKind.Local  				&& initDoFinallyBodies.Variable.Type.IsKnownType(KnownTypeCode.Boolean)  				&& initDoFinallyBodies.Value.MatchLdcI4(1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchStateAssignment,The conditional expression  "inst.MatchStFld(out var target' out var field' out var value)  				&& target.MatchLdThis()  				&& field.MemberDefinition == stateField  				&& value.MatchLdcI4(out newState)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,FinalizeInlineMoveNext,The conditional expression  "block.Instructions[i].MatchStLoc(out var v' out var value)  						&& v.IsSingleDefinition && v.LoadCount == 0  						&& value.MatchLdLoc(cachedStateVar)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The conditional expression  "pos > 0 && block.Instructions[pos - 1] is StLoc stloc  				&& stloc.Variable.Kind == VariableKind.Local && stloc.Variable.Index == cachedStateVar.Index  				&& StackSlotValue(stloc.Value).MatchLdcI4(state)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The conditional expression  "pos > 0 && block.Instructions[pos - 1] is StLoc stloc2  				&& stloc2.Variable.IsSingleDefinition && stloc2.Variable.LoadCount == 0  				&& stloc2.Variable.Kind == VariableKind.StackSlot  				&& SemanticHelper.IsPure(stloc2.Value.Flags)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The conditional expression  "block.Instructions[pos].MatchStFld(out target' out field' out value)  				&& target.MatchLdThis()  				&& field.Equals(awaiterField)  				&& value.OpCode == OpCode.DefaultValue"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The conditional expression  "block.Instructions[pos].MatchStLoc(out var variable' out value) && value.OpCode == OpCode.DefaultValue  					&& block.Instructions[pos + 1].MatchStFld(out target' out field' out value)  					&& field.Equals(awaiterField)  					&& value.MatchLdLoc(variable)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,StateRangeAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\StateRangeAnalysis.cs,AssignStateRanges,The conditional expression  "stobj.MatchStFld(out var target' out var field' out var value)  							&& target.MatchLdThis() && field.MemberDefinition == stateField && value.MatchLdcI4(-1)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,The conditional expression  "body.Instructions[pos].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdLoc(var2 ?? var1)  					&& (value.MatchLdcI4(-2) || value.MatchLdcI4(0))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCtor,The conditional expression  "inst.MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdThis()  					&& value.MatchLdLoc(out var arg)  					&& arg.Kind == VariableKind.Parameter && arg.Index == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The conditional expression  "body.Instructions[0].MatchStLoc(out var v' out var ldfld)  					&& ldfld.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis()  					&& body.Instructions[1].MatchReturn(out var retVal)  					&& retVal.MatchLdLoc(v)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "!(faultBlock.Instructions.Count == 2  					&& faultBlock.Instructions[0] is Call call  					&& context.TypeSystem.GetCecil(call.Method) == disposeMethod  					&& call.Arguments.Count == 1  					&& call.Arguments[0].MatchLdThis()  					&& faultBlock.Instructions[1].MatchLeave(faultBlockContainer))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "body.EntryPoint.Instructions[0] is StLoc stloc  					&& stloc.Value.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis() && field.Type.IsKnownType(KnownTypeCode.Int32)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,PropagateCopiesOfFields,The conditional expression  "body.EntryPoint.Instructions[i] is StLoc store  					&& store.Variable.IsSingleDefinition  					&& store.Value is LdObj ldobj  					&& ldobj.Target is LdFlda ldflda  					&& ldflda.Target.MatchLdThis()"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "oldInst is Call call && call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  						&& finallyMethodToStateRange.ContainsKey((IMethod)call.Method.MemberDefinition)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "!(oldBlock.Instructions[i + 1].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdThis()  					&& field.MemberDefinition == stateField  					&& value.MatchLdcI4(out int newState))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ReconstructTryFinallyBlocks,The conditional expression  "Block.GetPredecessor(branch) is Call call  							&& call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  							&& call.Method.Name == "System.IDisposable.Dispose""  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,GetNewState,The conditional expression  "block.Instructions[0].MatchStFld(out var target' out var field' out var value)  				&& target.MatchLdThis()  				&& field.MemberDefinition.Equals(stateField)  				&& value.MatchLdcI4(out int newState)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,GetNewState,The conditional expression  "block.Instructions[0] is Call call  				&& call.Arguments.Count == 1 && call.Arguments[0].MatchLdThis()  				&& decompiledFinallyMethods.TryGetValue((IMethod)call.Method.MemberDefinition' out var finallyMethod)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,HandleIfInstruction,The conditional expression  "trueBlock != null && trueBlock.Instructions.Count == 1  					&& trueBlock.FinalInstruction is Nop  					&& trueBlock.Instructions[0].MatchIfInstruction(out nestedCondition' out nestedTrueInst)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ConditionDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ConditionDetection.cs,UnpackBlockContainingOnlyBranch,The conditional expression  "block != null && block.Instructions.Count == 1 && block.FinalInstruction is Nop && IsBranchOrLeave(block.Instructions[0])"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,InlineVariableInReturnBlock,The conditional expression  "value.MatchLdLoc(out ILVariable v)  					&& v.IsSingleDefinition && v.LoadCount == 1 && block.Instructions[0].MatchStLoc(v' out ILInstruction inst)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,Run,The conditional expression  "stloc != null && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The conditional expression  "!(condition != null && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull())"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ProcessPinnedRegion,The conditional expression  "body.EntryPoint.IncomingEdgeCount == 1  				    && body.EntryPoint.Instructions.Count == 3  				    && body.EntryPoint.Instructions[0].MatchStLoc(out nativeVar' out initInst)  				    && nativeVar.Type.GetStackType() == StackType.I  				    && nativeVar.StoreCount == 2  				    && initInst.UnwrapConv(ConversionKind.StopGCTracking).MatchLdLoc(pinnedRegion.Variable)  				    && IsBranchOnNull(body.EntryPoint.Instructions[1]' nativeVar' out targetBlock)  				    && targetBlock.Parent == body  					&& body.EntryPoint.Instructions[2].MatchBranch(out adjustOffsetToStringData)  				    && adjustOffsetToStringData.Parent == body && adjustOffsetToStringData.IncomingEdgeCount == 1  					&& IsOffsetToStringDataBlock(adjustOffsetToStringData' nativeVar' targetBlock)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ProcessPinnedRegion,The conditional expression  "nativeVar.Kind == VariableKind.StackSlot && nativeVar.LoadCount == 1  					    && body.EntryPoint.Instructions[0].MatchStLoc(out otherVar' out otherVarInit)  					    && otherVarInit.MatchLdLoc(nativeVar)  					    && otherVar.IsSingleDefinition"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The conditional expression  "inst is Conv conv && conv.Kind == ConversionKind.StopGCTracking && conv.Argument.MatchLdLoc(oldVar) && conv.ResultType == newVar.StackType"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ReplacePinnedVar,The conditional expression  "(inst is LdLoc || inst is StLoc) && !IsSlotAcceptingBothManagedAndUnmanagedPointers(inst.SlotInfo) && oldVar.StackType != StackType.I"  is complex.
Complex Conditional,ICSharpCode.Decompiler.IL.ControlFlow,DetectExitPoints,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ExitPoints.cs,GetExit,The conditional expression  "slot == TryInstruction.TryBlockSlot  				|| slot == TryCatchHandler.BodySlot  				|| slot == TryCatch.HandlerSlot  				|| slot == PinnedRegion.BodySlot"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.Decompiler.FlowAnalysis,Dominance,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The conditional expression  "j.IsReachable && (j.Predecessors.Count >= 2 || (j.Predecessors.Count >= 1 && j.ImmediateDominator == null))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.Disassembler,DisassemblerHelpers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs,EscapeString,The conditional expression  "char.IsControl(ch) || char.IsSurrogate(ch) || (char.IsWhiteSpace(ch) && ch != ' ')"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The conditional expression  "layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,InitNestedTypes,The conditional expression  "this.IncludeInternalMembers  				    || visibility == TypeAttributes.NestedPublic  				    || visibility == TypeAttributes.NestedFamily  				    || visibility == TypeAttributes.NestedFamORAssem"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,MergePropertyAccessibility,The conditional expression  "left == Accessibility.Protected && right == Accessibility.Internal ||  			    left == Accessibility.Internal && right == Accessibility.Protected"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,Equals,The conditional expression  "x == null || y == null || x.SymbolKind != y.SymbolKind || !nameComparer.Equals(x.Name' y.Name)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The conditional expression  "unresolved.IsStatic || !unresolved.IsPublic || DeclaringTypeDefinition == null || DeclaringTypeDefinition.Kind == TypeKind.Interface"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,BaseTypeCollector,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BaseTypeCollector.cs,CollectBaseTypes,The conditional expression  "SkipImplementedInterfaces && def != null && def.Kind != TypeKind.Interface && def.Kind != TypeKind.TypeParameter"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The conditional expression  "kind == TypeKind.Class && !this.IsStatic && !unresolvedMembers.Any(m => m.SymbolKind == SymbolKind.Constructor && !m.IsStatic)  				    || kind == TypeKind.Enum || kind == TypeKind.Struct"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,CalculateDirectBaseTypes,The conditional expression  "!hasNonInterface && !(this.Name == "Object" && this.Namespace == "System" && this.TypeParameterCount == 0)"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs,GetMethodsImpl,The conditional expression  "(options & GetMemberOptions.ReturnMemberDefinitions) == 0  			    && (pt != null || (methodTypeArguments != null && methodTypeArguments.Count > 0))"  is complex.
Complex Conditional,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The conditional expression  "index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)"  is complex.
Virtual Method Call from Constructor,ICSharpCode.Decompiler.IL,ChildrenEnumerator,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\ILInstruction.cs,ChildrenEnumerator,The constructor "ChildrenEnumerator" calls a virtual method "GetChildCount".
Virtual Method Call from Constructor,ICSharpCode.Decompiler.TypeSystem,LazyCecilTypeDefinition,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,LazyCecilTypeDefinition,The constructor "LazyCecilTypeDefinition" calls a virtual method "ApplyInterningProvider".
Empty Catch Block,ICSharpCode.Decompiler,DecompilerException,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler,DecompilerException,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DecompilerException.cs,GetStackTrace,The method has an empty catch block.
Empty Catch Block,ICSharpCode.Decompiler,DotNetCorePathFinder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\DotNetCorePathFinder.cs,FindDotNetExeDirectory,The method has an empty catch block.
Magic Number,ICSharpCode.Decompiler.CSharp,CallBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CallBuilder.cs,IsDelegateEqualityComparison,The following statement contains a magic number: return method.IsOperator  				&& method.DeclaringType.IsKnownType(KnownTypeCode.Delegate)  				&& (method.Name == "op_Equality" || method.Name == "op_Inequality")  				&& arguments.Count == 2  				&& arguments[0].Type.Kind == TypeKind.Delegate  				&& arguments[1].Type.Equals(arguments[0].Type);
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,GenerateConvHelper,The following statement contains a magic number: method.Body = new BlockStatement {  				new IfElseStatement {  					Condition = new BinaryOperatorExpression {  						Left = new MemberReferenceExpression(new TypeReferenceExpression(typeSystemAstBuilder.ConvertType(typeSystem.Compilation.FindType(KnownTypeCode.IntPtr)))' "Size")'  						Operator = BinaryOperatorType.Equality'  						Right = new PrimitiveExpression(4)  					}'  					TrueStatement = new BlockStatement { // 32-bit  						new ReturnStatement(  							new CastExpression(  								method.ReturnType.Clone()'  								intermediate32  							)  						)  					}'  					FalseStatement = new BlockStatement { // 64-bit  						new ReturnStatement(  							new CastExpression(  								method.ReturnType.Clone()'  								intermediate64  							)  						)  					}'  				}  			};
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The following statement contains a magic number: if (decompilationContext.CurrentTypeDefinition.Kind == TypeKind.Enum) {  				var index = decompilationContext.CurrentTypeDefinition.Members.IndexOf(field);  				long previousValue = -1;  				if (index > 0) {  					var previousMember = (IField)decompilationContext.CurrentTypeDefinition.Members[index - 1];  					previousValue = (long)CSharpPrimitiveCast.Cast(TypeCode.Int64' previousMember.ConstantValue' false);  				}  				long initValue = (long)CSharpPrimitiveCast.Cast(TypeCode.Int64' field.ConstantValue' false);  				var enumDec = new EnumMemberDeclaration { Name = field.Name };  				if (decompilationContext.CurrentTypeDefinition.Attributes.Any(a => a.AttributeType.FullName == "System.FlagsAttribute")) {  					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue);  					if (enumDec.Initializer is PrimitiveExpression primitive && initValue > 9)  						primitive.SetValue(initValue' $"0x{initValue:X}");  				} else if (previousValue + 1 != initValue) {  					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue);  					if (enumDec.Initializer is PrimitiveExpression primitive && initValue > 9 && ((initValue & (initValue - 1)) == 0 || (initValue & (initValue + 1)) == 0)) {  						primitive.SetValue(initValue' $"0x{initValue:X}");  					}  				}  				enumDec.Attributes.AddRange(field.Attributes.Select(a => new AttributeSection(typeSystemAstBuilder.ConvertAttribute(a))));  				enumDec.AddAnnotation(new Semantics.MemberResolveResult(null' field));  				return enumDec;  			}
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,DoDecompile,The following statement contains a magic number: if (decompilationContext.CurrentTypeDefinition.Kind == TypeKind.Enum) {  				var index = decompilationContext.CurrentTypeDefinition.Members.IndexOf(field);  				long previousValue = -1;  				if (index > 0) {  					var previousMember = (IField)decompilationContext.CurrentTypeDefinition.Members[index - 1];  					previousValue = (long)CSharpPrimitiveCast.Cast(TypeCode.Int64' previousMember.ConstantValue' false);  				}  				long initValue = (long)CSharpPrimitiveCast.Cast(TypeCode.Int64' field.ConstantValue' false);  				var enumDec = new EnumMemberDeclaration { Name = field.Name };  				if (decompilationContext.CurrentTypeDefinition.Attributes.Any(a => a.AttributeType.FullName == "System.FlagsAttribute")) {  					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue);  					if (enumDec.Initializer is PrimitiveExpression primitive && initValue > 9)  						primitive.SetValue(initValue' $"0x{initValue:X}");  				} else if (previousValue + 1 != initValue) {  					enumDec.Initializer = typeSystemAstBuilder.ConvertConstantValue(decompilationContext.CurrentTypeDefinition.EnumUnderlyingType' field.ConstantValue);  					if (enumDec.Initializer is PrimitiveExpression primitive && initValue > 9 && ((initValue & (initValue - 1)) == 0 || (initValue & (initValue + 1)) == 0)) {  						primitive.SetValue(initValue' $"0x{initValue:X}");  					}  				}  				enumDec.Attributes.AddRange(field.Attributes.Select(a => new AttributeSection(typeSystemAstBuilder.ConvertAttribute(a))));  				enumDec.AddAnnotation(new Semantics.MemberResolveResult(null' field));  				return enumDec;  			}
Magic Number,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,IsFixedField,The following statement contains a magic number: if (attr != null && attr.PositionalArguments.Count == 2) {  				if (attr.PositionalArguments[0] is TypeOfResolveResult trr && attr.PositionalArguments[1].ConstantValue is int length) {  					type = trr.ReferencedType;  					elementCount = length;  					return true;  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ShouldDisplayAsHex,The following statement contains a magic number: if (value <= 9)  				return false;
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ValueMightBeOversized,The following statement contains a magic number: if (rr is OperatorResolveResult orr) {  				if (stackType == StackType.I && orr.OperatorType == ExpressionType.Subtract  					&& orr.Operands.Count == 2  					&& orr.Operands[0].Type.Kind == TypeKind.Pointer  					&& orr.Operands[1].Type.Kind == TypeKind.Pointer)  				{  					// Even though a pointer subtraction produces a value of type long in C#'  					// the value will always fit in a native int.  					return false;  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The following statement contains a magic number: foreach (var inst in block.Instructions.Skip(1)) {  				if (inst is StLoc indexStore) {  					indexVariables.Add(indexStore.Variable' indexStore.Value);  					continue;  				}  				var info = IL.Transforms.AccessPathElement.GetAccessPath(inst' initObjRR.Type);  				if (info.Kind == IL.Transforms.AccessPathKind.Invalid) continue;  				if (currentPath == null) {  					currentPath = info.Path;  				} else {  					int minLen = Math.Min(currentPath.Count' info.Path.Count);  					int firstDifferenceIndex = 0;  					while (firstDifferenceIndex < minLen && info.Path[firstDifferenceIndex] == currentPath[firstDifferenceIndex])  						firstDifferenceIndex++;  					while (elementsStack.Count - 1 > firstDifferenceIndex) {  						var methodElement = currentPath[elementsStack.Count - 1];  						var pathElement = currentPath[elementsStack.Count - 2];  						var values = elementsStack.Pop();  						elementsStack.Peek().Add(MakeInitializerAssignment(methodElement.Member' pathElement' values' indexVariables));  					}  					currentPath = info.Path;  				}  				while (elementsStack.Count < currentPath.Count)  					elementsStack.Push(new List<Expression>());  				var lastElement = currentPath.Last();  				var memberRR = new MemberResolveResult(initObjRR' lastElement.Member);  				switch (info.Kind) {  					case IL.Transforms.AccessPathKind.Adder:  						elementsStack.Peek().Add(MakeInitializerElements(info.Values' ((IMethod)lastElement.Member).Parameters));  						break;  					case IL.Transforms.AccessPathKind.Setter:  						if (lastElement.Indices?.Length > 0) {  							var indexer = new IndexerExpression(null' lastElement.Indices.SelectArray(i => Translate(i is LdLoc ld ? indexVariables[ld.Variable] : i).Expression))  								.WithILInstruction(inst).WithRR(memberRR);  							elementsStack.Peek().Add(Assignment(indexer' Translate(info.Values.Single())));  						} else {  							var target = new IdentifierExpression(lastElement.Member.Name)  								.WithILInstruction(inst).WithRR(memberRR);  							elementsStack.Peek().Add(Assignment(target' Translate(info.Values.Single())));  						}  						break;  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The following statement contains a magic number: while (elementsStack.Count > 1) {  				var methodElement = currentPath[elementsStack.Count - 1];  				var pathElement = currentPath[elementsStack.Count - 2];  				var values = elementsStack.Pop();  				elementsStack.Peek().Add(MakeInitializerAssignment(methodElement.Member' pathElement' values' indexVariables));  			}
Magic Number,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,UnwrapNestedContainerIfPossible,The following statement contains a magic number: if (nestedBlock.Instructions.Count != 2 ||  				!(nestedBlock.Instructions[0] is BlockContainer nestedContainer) ||  				!(nestedBlock.Instructions[1] is Leave leave))  				return container;
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,DebugToString,The following statement contains a magic number: if (text.Length > 100)  				return text.Substring(0' 97) + "...";  			else  				return text;
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AstNode,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs,DebugToString,The following statement contains a magic number: if (text.Length > 100)  				return text.Substring(0' 97) + "...";  			else  				return text;
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,PrimitiveExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\PrimitiveExpression.cs,AdvanceLocation,The following statement contains a magic number: fixed (char* start = str) {  				char* p = start;  				char* endPtr = start + str.Length;  				while (p < endPtr) {  					var nl = NewLine.GetDelimiterLength(*p' () => {  						char* nextp = p + 1;  						if (nextp < endPtr)  							return *nextp;  						return '\0';  					});  					if (nl > 0) {  						line++;  						col = 1;  						if (nl == 2)  							p++;  					} else {  						col++;  					}  					p++;  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TextLocation,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (191 * column.GetHashCode() ^ line.GetHashCode());
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TextLocationConverter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs,ConvertFrom,The following statement contains a magic number: if (value is string) {  				string[] parts = ((string)value).Split(';'' ''');  				if (parts.Length == 2) {  					return new TextLocation(int.Parse(parts[0])' int.Parse(parts[1]));  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The following statement contains a magic number: if (st != null && st.Identifier.EndsWith("Attribute"' StringComparison.Ordinal)) {  				st.Identifier = st.Identifier.Substring(0' st.Identifier.Length - 9);  			} else if (mt != null && mt.MemberName.EndsWith("Attribute"' StringComparison.Ordinal)) {  				mt.MemberName = mt.MemberName.Substring(0' mt.MemberName.Length - 9);  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertAttribute,The following statement contains a magic number: if (st != null && st.Identifier.EndsWith("Attribute"' StringComparison.Ordinal)) {  				st.Identifier = st.Identifier.Substring(0' st.Identifier.Length - 9);  			} else if (mt != null && mt.MemberName.EndsWith("Attribute"' StringComparison.Ordinal)) {  				mt.MemberName = mt.MemberName.Substring(0' mt.MemberName.Length - 9);  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Syntax,AbstractAnnotatable,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs,AddAnnotation,The following statement contains a magic number: if (list == null) {  				// we need to transform the old annotation into a list  				list = new AnnotationList (4);  				list.Add (oldAnnotation);  				list.Add (annotation);  				if (Interlocked.CompareExchange (ref this.annotations' list' oldAnnotation) != oldAnnotation) {  					// the transformation failed (some other thread wrote to this.annotations first)  					goto retry;  				}  			} else {  				// once there's a list' use simple locking  				lock (list) {  					list.Add (annotation);  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpAmbience,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs,ConvertVariable,The following statement contains a magic number: return astNode.ToString().TrimEnd(';'' '\r'' '\n'' (char)8232);
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,GetCallChainLengthLimited,The following statement contains a magic number: while (node.Target is InvocationExpression invocation && invocation.Target is MemberReferenceExpression mre && callChainLength < 4) {  				node = mre;  				callChainLength++;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,InsertNewLineWhenInMethodCallChain,The following statement contains a magic number: if (callChainLength < 3) return;
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,InsertNewLineWhenInMethodCallChain,The following statement contains a magic number: if (callChainLength == 3)  				writer.Indent();
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitInvocationExpression,The following statement contains a magic number: if (!(invocationExpression.Parent is MemberReferenceExpression)) {  				if (invocationExpression.Target is MemberReferenceExpression mre) {  					if (GetCallChainLengthLimited(mre) >= 3)  						writer.Unindent();  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,GetPrecedence,The following statement contains a magic number: if (boe != null) {  				switch (boe.Operator) {  					case BinaryOperatorType.Multiply:  					case BinaryOperatorType.Divide:  					case BinaryOperatorType.Modulus:  						return 13; // multiplicative  					case BinaryOperatorType.Add:  					case BinaryOperatorType.Subtract:  						return 12; // additive  					case BinaryOperatorType.ShiftLeft:  					case BinaryOperatorType.ShiftRight:  						return 11;  					case BinaryOperatorType.GreaterThan:  					case BinaryOperatorType.GreaterThanOrEqual:  					case BinaryOperatorType.LessThan:  					case BinaryOperatorType.LessThanOrEqual:  						return RelationalAndTypeTesting;  					case BinaryOperatorType.Equality:  					case BinaryOperatorType.InEquality:  						return Equality;  					case BinaryOperatorType.BitwiseAnd:  						return 8;  					case BinaryOperatorType.ExclusiveOr:  						return 7;  					case BinaryOperatorType.BitwiseOr:  						return 6;  					case BinaryOperatorType.ConditionalAnd:  						return 5;  					case BinaryOperatorType.ConditionalOr:  						return 4;  					case BinaryOperatorType.NullCoalescing:  						return 3;  					default:  						throw new NotSupportedException("Invalid value for BinaryOperatorType");  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WriteComment,The following statement contains a magic number: switch (commentType) {  				case CommentType.SingleLine:  					textWriter.Write("//");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLine:  					textWriter.Write("/*");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 2;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				case CommentType.Documentation:  					textWriter.Write("///");  					textWriter.WriteLine(content);  					column = 1;  					line++;  					needsIndent = true;  					isAtStartOfLine = true;  					break;  				case CommentType.MultiLineDocumentation:  					textWriter.Write("/**");  					textWriter.Write(content);  					textWriter.Write("*/");  					column += 3;  					UpdateEndLocation(content' ref line' ref column);  					column += 2;  					isAtStartOfLine = false;  					break;  				default:  					textWriter.Write(content);  					column += content.Length;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value == null) {  				// usually NullReferenceExpression should be used for this' but we'll handle it anyways  				textWriter.Write("null");  				column += 4;  				return;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is bool) {  				if ((bool)value) {  					textWriter.Write("true");  					column += 4;  				} else {  					textWriter.Write("false");  					column += 5;  				}  				return;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is bool) {  				if ((bool)value) {  					textWriter.Write("true");  					column += 4;  				} else {  					textWriter.Write("false");  					column += 5;  				}  				return;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is string) {  				string tmp = "\"" + ConvertString(value.ToString()) + "\"";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is char) {  				string tmp = "'" + ConvertCharLiteral((char)value) + "'";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is decimal) {  				string str = ((decimal)value).ToString(NumberFormatInfo.InvariantInfo) + "m";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is float) {  				float f = (float)value;  				if (float.IsInfinity(f) || float.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("float");  					column += 5;  					WriteToken(Roles.Dot' ".");  					if (float.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (float.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == float.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  					column++;  				}  				var str = f.ToString("R"' NumberFormatInfo.InvariantInfo) + "f";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is double) {  				double f = (double)value;  				if (double.IsInfinity(f) || double.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("double");  					column += 6;  					WriteToken(Roles.Dot' ".");  					if (double.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (double.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == double.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  				}  				string number = f.ToString("R"' NumberFormatInfo.InvariantInfo);  				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0) {  					number += ".0";  				}  				textWriter.Write(number);  			} else if (value is IFormattable) {  				StringBuilder b = new StringBuilder ();  //				if (primitiveExpression.LiteralFormat == LiteralFormat.HexadecimalNumber) {  //					b.Append("0x");  //					b.Append(((IFormattable)val).ToString("x"' NumberFormatInfo.InvariantInfo));  //				} else {  					b.Append(((IFormattable)value).ToString(null' NumberFormatInfo.InvariantInfo));  //				}  				if (value is uint || value is ulong) {  					b.Append("u");  				}  				if (value is long || value is ulong) {  					b.Append("L");  				}  				textWriter.Write(b.ToString());  				column += b.Length;  			} else {  				textWriter.Write(value.ToString());  				column += value.ToString().Length;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is string) {  				string tmp = "\"" + ConvertString(value.ToString()) + "\"";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is char) {  				string tmp = "'" + ConvertCharLiteral((char)value) + "'";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is decimal) {  				string str = ((decimal)value).ToString(NumberFormatInfo.InvariantInfo) + "m";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is float) {  				float f = (float)value;  				if (float.IsInfinity(f) || float.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("float");  					column += 5;  					WriteToken(Roles.Dot' ".");  					if (float.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (float.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == float.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  					column++;  				}  				var str = f.ToString("R"' NumberFormatInfo.InvariantInfo) + "f";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is double) {  				double f = (double)value;  				if (double.IsInfinity(f) || double.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("double");  					column += 6;  					WriteToken(Roles.Dot' ".");  					if (double.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (double.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == double.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  				}  				string number = f.ToString("R"' NumberFormatInfo.InvariantInfo);  				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0) {  					number += ".0";  				}  				textWriter.Write(number);  			} else if (value is IFormattable) {  				StringBuilder b = new StringBuilder ();  //				if (primitiveExpression.LiteralFormat == LiteralFormat.HexadecimalNumber) {  //					b.Append("0x");  //					b.Append(((IFormattable)val).ToString("x"' NumberFormatInfo.InvariantInfo));  //				} else {  					b.Append(((IFormattable)value).ToString(null' NumberFormatInfo.InvariantInfo));  //				}  				if (value is uint || value is ulong) {  					b.Append("u");  				}  				if (value is long || value is ulong) {  					b.Append("L");  				}  				textWriter.Write(b.ToString());  				column += b.Length;  			} else {  				textWriter.Write(value.ToString());  				column += value.ToString().Length;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is string) {  				string tmp = "\"" + ConvertString(value.ToString()) + "\"";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is char) {  				string tmp = "'" + ConvertCharLiteral((char)value) + "'";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is decimal) {  				string str = ((decimal)value).ToString(NumberFormatInfo.InvariantInfo) + "m";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is float) {  				float f = (float)value;  				if (float.IsInfinity(f) || float.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("float");  					column += 5;  					WriteToken(Roles.Dot' ".");  					if (float.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (float.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == float.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  					column++;  				}  				var str = f.ToString("R"' NumberFormatInfo.InvariantInfo) + "f";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is double) {  				double f = (double)value;  				if (double.IsInfinity(f) || double.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("double");  					column += 6;  					WriteToken(Roles.Dot' ".");  					if (double.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (double.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == double.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  				}  				string number = f.ToString("R"' NumberFormatInfo.InvariantInfo);  				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0) {  					number += ".0";  				}  				textWriter.Write(number);  			} else if (value is IFormattable) {  				StringBuilder b = new StringBuilder ();  //				if (primitiveExpression.LiteralFormat == LiteralFormat.HexadecimalNumber) {  //					b.Append("0x");  //					b.Append(((IFormattable)val).ToString("x"' NumberFormatInfo.InvariantInfo));  //				} else {  					b.Append(((IFormattable)value).ToString(null' NumberFormatInfo.InvariantInfo));  //				}  				if (value is uint || value is ulong) {  					b.Append("u");  				}  				if (value is long || value is ulong) {  					b.Append("L");  				}  				textWriter.Write(b.ToString());  				column += b.Length;  			} else {  				textWriter.Write(value.ToString());  				column += value.ToString().Length;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveValue,The following statement contains a magic number: if (value is string) {  				string tmp = "\"" + ConvertString(value.ToString()) + "\"";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is char) {  				string tmp = "'" + ConvertCharLiteral((char)value) + "'";  				column += tmp.Length;  				textWriter.Write(tmp);  			} else if (value is decimal) {  				string str = ((decimal)value).ToString(NumberFormatInfo.InvariantInfo) + "m";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is float) {  				float f = (float)value;  				if (float.IsInfinity(f) || float.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("float");  					column += 5;  					WriteToken(Roles.Dot' ".");  					if (float.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (float.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == float.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  					column++;  				}  				var str = f.ToString("R"' NumberFormatInfo.InvariantInfo) + "f";  				column += str.Length;  				textWriter.Write(str);  			} else if (value is double) {  				double f = (double)value;  				if (double.IsInfinity(f) || double.IsNaN(f)) {  					// Strictly speaking' these aren't PrimitiveExpressions;  					// but we still support writing these to make life easier for code generators.  					textWriter.Write("double");  					column += 6;  					WriteToken(Roles.Dot' ".");  					if (double.IsPositiveInfinity(f)) {  						textWriter.Write("PositiveInfinity");  						column += "PositiveInfinity".Length;  					} else if (double.IsNegativeInfinity(f)) {  						textWriter.Write("NegativeInfinity");  						column += "NegativeInfinity".Length;  					} else {  						textWriter.Write("NaN");  						column += 3;  					}  					return;  				}  				if (f == 0 && 1 / f == double.NegativeInfinity) {  					// negative zero is a special case  					// (again' not a primitive expression' but it's better to handle  					// the special case here than to do it in all code generators)  					textWriter.Write("-");  				}  				string number = f.ToString("R"' NumberFormatInfo.InvariantInfo);  				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0) {  					number += ".0";  				}  				textWriter.Write(number);  			} else if (value is IFormattable) {  				StringBuilder b = new StringBuilder ();  //				if (primitiveExpression.LiteralFormat == LiteralFormat.HexadecimalNumber) {  //					b.Append("0x");  //					b.Append(((IFormattable)val).ToString("x"' NumberFormatInfo.InvariantInfo));  //				} else {  					b.Append(((IFormattable)value).ToString(null' NumberFormatInfo.InvariantInfo));  //				}  				if (value is uint || value is ulong) {  					b.Append("u");  				}  				if (value is long || value is ulong) {  					b.Append("L");  				}  				textWriter.Write(b.ToString());  				column += b.Length;  			} else {  				textWriter.Write(value.ToString());  				column += value.ToString().Length;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,WritePrimitiveType,The following statement contains a magic number: if (type == "new") {  				textWriter.Write("()");  				column += 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,IsSubtypeOf,The following statement contains a magic number: if (subtypeCheckNestingDepth > 10) {  				// Subtyping in C# is undecidable  				// (see "On Decidability of Nominal Subtyping with Variance" by Andrew J. Kennedy and Benjamin C. Pierce)'  				// so we'll prevent infinite recursions by putting a limit on the nesting depth of variance conversions.  				  				// No real C# code should use generics nested more than 10 levels deep' and even if they do' most of  				// those nestings should not involve variance.  				return false;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,The following statement contains a magic number: if (lambda != null) {  				if (!lambda.IsAnonymousMethod) {  					t1 = UnpackExpressionTreeType(t1);  					t2 = UnpackExpressionTreeType(t2);  				}  				IMethod m1 = t1.GetDelegateInvokeMethod();  				IMethod m2 = t2.GetDelegateInvokeMethod();  				if (m1 == null || m2 == null)  					return 0;  				if (m1.Parameters.Count != m2.Parameters.Count)  					return 0;  				IType[] parameterTypes = new IType[m1.Parameters.Count];  				for (int i = 0; i < parameterTypes.Length; i++) {  					parameterTypes[i] = m1.Parameters[i].Type;  					if (!parameterTypes[i].Equals(m2.Parameters[i].Type))  						return 0;  				}  				if (lambda.HasParameterList && parameterTypes.Length != lambda.Parameters.Count)  					return 0;  				  				IType ret1 = m1.ReturnType;  				IType ret2 = m2.ReturnType;  				if (ret1.Kind == TypeKind.Void && ret2.Kind != TypeKind.Void)  					return 2;  				if (ret1.Kind != TypeKind.Void && ret2.Kind == TypeKind.Void)  					return 1;  				  				IType inferredRet = lambda.GetInferredReturnType(parameterTypes);  				int r = BetterConversion(inferredRet' ret1' ret2);  				if (r == 0 && lambda.IsAsync) {  					ret1 = UnpackTask(ret1);  					ret2 = UnpackTask(ret2);  					inferredRet = UnpackTask(inferredRet);  					if (ret1 != null && ret2 != null && inferredRet != null)  						r = BetterConversion(inferredRet' ret1' ret2);  				}  				return r;  			} else {  				return BetterConversion(resolveResult.Type' t1' t2);  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversion,The following statement contains a magic number: if (ident2 && !ident1)  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversionTarget,The following statement contains a magic number: if (t2To1 && !t1To2)  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,BetterConversionTarget,The following statement contains a magic number: if (IsBetterIntegralType(t2Code' t1Code))  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,TypePair,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetHashCode,The following statement contains a magic number: unchecked {  					return 1000000007 * FromType.GetHashCode() + 1000000009 * ToType.GetHashCode();  				}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,TypePair,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,GetHashCode,The following statement contains a magic number: unchecked {  					return 1000000007 * FromType.GetHashCode() + 1000000009 * ToType.GetHashCode();  				}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpOperators.cs,IsComparisonOperator,The following statement contains a magic number: return m.IsOperator && m.Parameters.Count == 2  				&& (OperatorDeclaration.GetOperatorType(m.Name)?.IsComparisonOperator() ?? false);
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following statement contains a magic number: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveAssignment,The following statement contains a magic number: if (opResult == null || opResult.Operands.Count != 2)  				return bopResult;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (c1.ErrorCount > 0 && c2.ErrorCount == 0)  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: for (int i = 0; i < arguments.Length; i++) {  				int p1 = c1.ArgumentToParameterMap[i];  				int p2 = c2.ArgumentToParameterMap[i];  				if (p1 >= 0 && p2 < 0) {  					c1IsBetter = true;  				} else if (p1 < 0 && p2 >= 0) {  					c2IsBetter = true;  				} else if (p1 >= 0 && p2 >= 0) {  					if (!conversions.IdentityConversion(c1.ParameterTypes[p1]' c2.ParameterTypes[p2]))  						parameterTypesEqual = false;  					switch (conversions.BetterConversion(arguments[i]' c1.ParameterTypes[p1]' c2.ParameterTypes[p2])) {  						case 1:  							c1IsBetter = true;  							break;  						case 2:  							c2IsBetter = true;  							break;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && c2IsBetter)  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (c1.ErrorCount > c2.ErrorCount) return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && !c2IsBetter && parameterTypesEqual) {  				// we need the tie-breaking rules  				  				// non-generic methods are better  				if (!c1.IsGenericMethod && c2.IsGenericMethod)  					return 1;  				else if (c1.IsGenericMethod && !c2.IsGenericMethod)  					return 2;  				  				// non-expanded members are better  				if (!c1.IsExpandedForm && c2.IsExpandedForm)  					return 1;  				else if (c1.IsExpandedForm && !c2.IsExpandedForm)  					return 2;  				  				// prefer the member with less arguments mapped to the params-array  				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);  				if (r < 0) return 1;  				else if (r > 0) return 2;  				  				// prefer the member where no default values need to be substituted  				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)  					return 1;  				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)  					return 2;  				  				// compare the formal parameters  				r = MoreSpecificFormalParameters(c1' c2);  				if (r != 0)  					return r;  				  				// prefer non-lifted operators  				ILiftedOperator lift1 = c1.Member as ILiftedOperator;  				ILiftedOperator lift2 = c2.Member as ILiftedOperator;  				if (lift1 == null && lift2 != null)  					return 1;  				if (lift1 != null && lift2 == null)  					return 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && !c2IsBetter && parameterTypesEqual) {  				// we need the tie-breaking rules  				  				// non-generic methods are better  				if (!c1.IsGenericMethod && c2.IsGenericMethod)  					return 1;  				else if (c1.IsGenericMethod && !c2.IsGenericMethod)  					return 2;  				  				// non-expanded members are better  				if (!c1.IsExpandedForm && c2.IsExpandedForm)  					return 1;  				else if (c1.IsExpandedForm && !c2.IsExpandedForm)  					return 2;  				  				// prefer the member with less arguments mapped to the params-array  				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);  				if (r < 0) return 1;  				else if (r > 0) return 2;  				  				// prefer the member where no default values need to be substituted  				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)  					return 1;  				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)  					return 2;  				  				// compare the formal parameters  				r = MoreSpecificFormalParameters(c1' c2);  				if (r != 0)  					return r;  				  				// prefer non-lifted operators  				ILiftedOperator lift1 = c1.Member as ILiftedOperator;  				ILiftedOperator lift2 = c2.Member as ILiftedOperator;  				if (lift1 == null && lift2 != null)  					return 1;  				if (lift1 != null && lift2 == null)  					return 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && !c2IsBetter && parameterTypesEqual) {  				// we need the tie-breaking rules  				  				// non-generic methods are better  				if (!c1.IsGenericMethod && c2.IsGenericMethod)  					return 1;  				else if (c1.IsGenericMethod && !c2.IsGenericMethod)  					return 2;  				  				// non-expanded members are better  				if (!c1.IsExpandedForm && c2.IsExpandedForm)  					return 1;  				else if (c1.IsExpandedForm && !c2.IsExpandedForm)  					return 2;  				  				// prefer the member with less arguments mapped to the params-array  				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);  				if (r < 0) return 1;  				else if (r > 0) return 2;  				  				// prefer the member where no default values need to be substituted  				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)  					return 1;  				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)  					return 2;  				  				// compare the formal parameters  				r = MoreSpecificFormalParameters(c1' c2);  				if (r != 0)  					return r;  				  				// prefer non-lifted operators  				ILiftedOperator lift1 = c1.Member as ILiftedOperator;  				ILiftedOperator lift2 = c2.Member as ILiftedOperator;  				if (lift1 == null && lift2 != null)  					return 1;  				if (lift1 != null && lift2 == null)  					return 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && !c2IsBetter && parameterTypesEqual) {  				// we need the tie-breaking rules  				  				// non-generic methods are better  				if (!c1.IsGenericMethod && c2.IsGenericMethod)  					return 1;  				else if (c1.IsGenericMethod && !c2.IsGenericMethod)  					return 2;  				  				// non-expanded members are better  				if (!c1.IsExpandedForm && c2.IsExpandedForm)  					return 1;  				else if (c1.IsExpandedForm && !c2.IsExpandedForm)  					return 2;  				  				// prefer the member with less arguments mapped to the params-array  				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);  				if (r < 0) return 1;  				else if (r > 0) return 2;  				  				// prefer the member where no default values need to be substituted  				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)  					return 1;  				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)  					return 2;  				  				// compare the formal parameters  				r = MoreSpecificFormalParameters(c1' c2);  				if (r != 0)  					return r;  				  				// prefer non-lifted operators  				ILiftedOperator lift1 = c1.Member as ILiftedOperator;  				ILiftedOperator lift2 = c2.Member as ILiftedOperator;  				if (lift1 == null && lift2 != null)  					return 1;  				if (lift1 != null && lift2 == null)  					return 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following statement contains a magic number: if (!c1IsBetter && !c2IsBetter && parameterTypesEqual) {  				// we need the tie-breaking rules  				  				// non-generic methods are better  				if (!c1.IsGenericMethod && c2.IsGenericMethod)  					return 1;  				else if (c1.IsGenericMethod && !c2.IsGenericMethod)  					return 2;  				  				// non-expanded members are better  				if (!c1.IsExpandedForm && c2.IsExpandedForm)  					return 1;  				else if (c1.IsExpandedForm && !c2.IsExpandedForm)  					return 2;  				  				// prefer the member with less arguments mapped to the params-array  				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);  				if (r < 0) return 1;  				else if (r > 0) return 2;  				  				// prefer the member where no default values need to be substituted  				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)  					return 1;  				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)  					return 2;  				  				// compare the formal parameters  				r = MoreSpecificFormalParameters(c1' c2);  				if (r != 0)  					return r;  				  				// prefer non-lifted operators  				ILiftedOperator lift1 = c1.Member as ILiftedOperator;  				ILiftedOperator lift2 = c2.Member as ILiftedOperator;  				if (lift1 == null && lift2 != null)  					return 1;  				if (lift1 != null && lift2 == null)  					return 2;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following statement contains a magic number: if (r > 0) return 1;  			else if (r < 0) return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following statement contains a magic number: foreach (var pair in t1.Zip(t2' (a'b) => new { Item1 = a' Item2 = b })) {  				switch (MoreSpecificFormalParameter(pair.Item1' pair.Item2)) {  					case 1:  						c1IsBetter = true;  						break;  					case 2:  						c2IsBetter = true;  						break;  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following statement contains a magic number: if (!c1IsBetter && c2IsBetter)  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameter,The following statement contains a magic number: if ((t1 is ITypeParameter) && !(t2 is ITypeParameter))  				return 2;
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,IntroduceQueryExpressions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(body.Detach()' parameterName) });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = WrapExpressionInParenthesesIfNecessary(((Expression)lambda.Body).Detach()' parameterName) });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,FixNameCollisions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\FixNameCollisions.cs,PickNewName,The following statement contains a magic number: for (int num = 2;; num++) {  				string newName = name + num;  				if (!memberNames.Contains(newName))  					return newName;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The following statement contains a magic number: if (indexVariable.StoreCount != 2 || indexVariable.LoadCount != 3 || indexVariable.AddressCount != 0)  				return null;
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnArray,The following statement contains a magic number: if (indexVariable.StoreCount != 2 || indexVariable.LoadCount != 3 || indexVariable.AddressCount != 0)  				return null;
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The following statement contains a magic number: if (!itemVariable.IsSingleDefinition  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0))  				return null;
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,TransformForeachOnMultiDimArray,The following statement contains a magic number: if (!itemVariable.IsSingleDefinition  				|| !upperBounds.All(ub => ub.IsSingleDefinition && ub.LoadCount == 1)  				|| !lowerBounds.All(lb => lb.StoreCount == 2 && lb.LoadCount == 3 && lb.AddressCount == 0))  				return null;
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (expr != null) {  				CheckedUncheckedAnnotation annotation = expr.Annotation<CheckedUncheckedAnnotation>();  				if (annotation != null) {  					// If the annotation requires this node to be in a specific context' add a huge cost to the other context  					// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  					// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  					if (annotation.IsChecked)  						result.CostInUncheckedContext += new Cost(10000' 0);  					else  						result.CostInCheckedContext += new Cost(10000' 0);  				}  				// Embed this node in an checked/unchecked expression:  				if (expr.Parent is ExpressionStatement) {  					// We cannot use checked/unchecked for top-level-expressions.  				} else if (expr.Role.IsValid(Expression.Null)) {  					// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  					if (result.CostInCheckedContext + new Cost(0' 1) < result.CostInUncheckedContext) {  						result.CostInUncheckedContext = result.CostInCheckedContext + new Cost(0' 1);  						result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new InsertedExpression(expr' true);  					} else if (result.CostInUncheckedContext + new Cost(0' 1) < result.CostInCheckedContext) {  						result.CostInCheckedContext = result.CostInUncheckedContext + new Cost(0' 1);  						result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new InsertedExpression(expr' false);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,AddCheckedBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (expr != null) {  				CheckedUncheckedAnnotation annotation = expr.Annotation<CheckedUncheckedAnnotation>();  				if (annotation != null) {  					// If the annotation requires this node to be in a specific context' add a huge cost to the other context  					// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  					// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  					if (annotation.IsChecked)  						result.CostInUncheckedContext += new Cost(10000' 0);  					else  						result.CostInCheckedContext += new Cost(10000' 0);  				}  				// Embed this node in an checked/unchecked expression:  				if (expr.Parent is ExpressionStatement) {  					// We cannot use checked/unchecked for top-level-expressions.  				} else if (expr.Role.IsValid(Expression.Null)) {  					// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  					if (result.CostInCheckedContext + new Cost(0' 1) < result.CostInUncheckedContext) {  						result.CostInUncheckedContext = result.CostInCheckedContext + new Cost(0' 1);  						result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new InsertedExpression(expr' true);  					} else if (result.CostInUncheckedContext + new Cost(0' 1) < result.CostInCheckedContext) {  						result.CostInCheckedContext = result.CostInUncheckedContext + new Cost(0' 1);  						result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new InsertedExpression(expr' false);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: switch (method.FullName) {  				case "System.Type.GetTypeFromHandle":  					if (arguments.Length == 1) {  						if (typeHandleOnTypeOfPattern.IsMatch(arguments[0])) {  							Expression target = ((MemberReferenceExpression)arguments[0]).Target;  							target.CopyInstructionsFrom(invocationExpression);  							invocationExpression.ReplaceWith(target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo.GetFieldFromHandle":  					if (arguments.Length == 1) {  						MemberReferenceExpression mre = arguments[0] as MemberReferenceExpression;  						if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation>() != null) {  							invocationExpression.ReplaceWith(mre.Target);  							return;  						}  					} else if (arguments.Length == 2) {  						MemberReferenceExpression mre1 = arguments[0] as MemberReferenceExpression;  						MemberReferenceExpression mre2 = arguments[1] as MemberReferenceExpression;  						if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation>() != null) {  							if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  								Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single();  								FieldReference field = oldArg.Annotation<FieldReference>();  								if (field != null) {  									AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach();  									oldArg.ReplaceWith(new MemberReferenceExpression(new TypeReferenceExpression(declaringType)' field.Name).CopyAnnotationsFrom(oldArg));  									invocationExpression.ReplaceWith(mre1.Target);  									return;  								}  							}  						}  					}  					break;  				case "System.Activator.CreateInstance":  					if (method.TypeArguments.Count == 1 && arguments.Length == 0 && method.TypeArguments[0].Kind == TypeKind.TypeParameter) {  						invocationExpression.ReplaceWith(new ObjectCreateExpression(context.TypeSystemAstBuilder.ConvertType(method.TypeArguments.First())));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: if (bop != null && arguments.Length == 2) {  				invocationExpression.Arguments.Clear(); // detach arguments from invocationExpression  				invocationExpression.ReplaceWith(  					new BinaryOperatorExpression(arguments[0]' bop.Value' arguments[1]).CopyAnnotationsFrom(invocationExpression)  				);  				return;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,CheckArgumentsForStringConcat,The following statement contains a magic number: if (arguments.Length < 2)  				return false;
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,AttributeTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\AttributeTypeReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				return withoutSuffix.GetHashCode() + 715613 * withSuffix.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,IncrementConstantValue,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\ConstantValues.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				return baseValue.GetHashCode() * 33 ^ incrementAmount;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,ConstantCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\ConstantValues.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				return targetType.GetHashCode() + expression.GetHashCode() * 1018829;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * target.GetHashCode();  				hashCode += 1000000033 * identifier.GetHashCode();  				hashCode += 1000000087 * typeArguments.GetHashCode();  				hashCode += 1000000021 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * target.GetHashCode();  				hashCode += 1000000033 * identifier.GetHashCode();  				hashCode += 1000000087 * typeArguments.GetHashCode();  				hashCode += 1000000021 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * target.GetHashCode();  				hashCode += 1000000033 * identifier.GetHashCode();  				hashCode += 1000000087 * typeArguments.GetHashCode();  				hashCode += 1000000021 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,MemberTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * target.GetHashCode();  				hashCode += 1000000033 * identifier.GetHashCode();  				hashCode += 1000000087 * typeArguments.GetHashCode();  				hashCode += 1000000021 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000021 * identifier.GetHashCode();  				hashCode += 1000000033 * typeArguments.GetHashCode();  				hashCode += 1000000087 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000021 * identifier.GetHashCode();  				hashCode += 1000000033 * typeArguments.GetHashCode();  				hashCode += 1000000087 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler.CSharp.TypeSystem,SimpleTypeOrNamespaceReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				hashCode += 1000000021 * identifier.GetHashCode();  				hashCode += 1000000033 * typeArguments.GetHashCode();  				hashCode += 1000000087 * (int)lookupMode;  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,FindAssemblyFile,The following statement contains a magic number: switch (targetFramework[0]) {  				case ".NETCoreApp":  				case ".NETStandard":  					if (targetFramework.Length != 2)  						return ResolveInternal(name);  					if (dotNetCorePathFinder == null) {  						var version = targetFramework[1].Length == 3 ? targetFramework[1] + ".0" : targetFramework[1];  						dotNetCorePathFinder = new DotNetCorePathFinder(mainAssemblyFileName' TargetFramework' version);  					}  					file = dotNetCorePathFinder.TryResolveDotNetCore(name);  					if (file != null)  						return file;  					return ResolveInternal(name);  				default:  					return ResolveInternal(name);  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,FindAssemblyFile,The following statement contains a magic number: switch (targetFramework[0]) {  				case ".NETCoreApp":  				case ".NETStandard":  					if (targetFramework.Length != 2)  						return ResolveInternal(name);  					if (dotNetCorePathFinder == null) {  						var version = targetFramework[1].Length == 3 ? targetFramework[1] + ".0" : targetFramework[1];  						dotNetCorePathFinder = new DotNetCorePathFinder(mainAssemblyFileName' TargetFramework' version);  					}  					file = dotNetCorePathFinder.TryResolveDotNetCore(name);  					if (file != null)  						return file;  					return ResolveInternal(name);  				default:  					return ResolveInternal(name);  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (DetectMono()) {  				if (version.Major == 1)  					path = Path.Combine(path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine(path' "2.1");  					else  						path = Path.Combine(path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine(path' "4.0");  				else {  					if (throwOnError)  						throw new NotSupportedException("Version not supported: " + version);  					return null;  				}  			} else {  				switch (version.Major) {  					case 1:  						if (version.MajorRevision == 3300)  							path = Path.Combine(path' "v1.0.3705");  						else  							path = Path.Combine(path' "v1.0.5000.0");  						break;  					case 2:  						path = Path.Combine(path' "v2.0.50727");  						break;  					case 4:  						path = Path.Combine(path' "v4.0.30319");  						break;  					default:  						if (throwOnError)  							throw new NotSupportedException("Version not supported: " + version);  						return null;  				}  			}
Magic Number,ICSharpCode.Decompiler,UniversalAssemblyResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\UniversalAssemblyResolver.cs,GetGacPaths,The following statement contains a magic number: var paths = new List<string>(2);
Magic Number,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetPushDelta,The following statement contains a magic number: switch (code.StackBehaviourPush) {  				case StackBehaviour.Push0:  					return 0;    				case StackBehaviour.Push1:  				case StackBehaviour.Pushi:  				case StackBehaviour.Pushi8:  				case StackBehaviour.Pushr4:  				case StackBehaviour.Pushr8:  				case StackBehaviour.Pushref:  					return 1;    				case StackBehaviour.Push1_push1:  					return 2;    				case StackBehaviour.Varpush:  					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					return IsVoid (method.ReturnType) ? 0 : 1;  			}
Magic Number,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Magic Number,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: if (memberIdString.Length < 2 || memberIdString[1] != ':')  				throw new ReflectionNameParseException(0' "Missing type tag");
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: int pos = 2;
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,ParseTypeName,The following statement contains a magic number: if (typeName.StartsWith("T:"' StringComparison.Ordinal))  				pos = 2;
Magic Number,ICSharpCode.Decompiler.Documentation,IdStringProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs,FindEntity,The following statement contains a magic number: if (idString.StartsWith("T:"' StringComparison.Ordinal)) {  				return ParseTypeName(idString.Substring(2)).Resolve(context).GetDefinition();  			} else {  				return ParseMemberIdString(idString).Resolve(context);  			}
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocKeyProvider.cs,FindMemberByKey,The following statement contains a magic number: if (key == null || key.Length < 2 || key[1] != ':')  				return null;
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocKeyProvider.cs,FindMemberByKey,The following statement contains a magic number: switch (key[0]) {  				case 'T':  					return FindType(module' key.Substring(2));  				case 'F':  					return FindMember(module' key' type => type.Fields);  				case 'P':  					return FindMember(module' key' type => type.Properties);  				case 'E':  					return FindMember(module' key' type => type.Events);  				case 'M':  					return FindMember(module' key' type => type.Methods);  				default:  					return null;  			}
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocKeyProvider.cs,FindMember,The following statement contains a magic number: TypeDefinition type = FindType(module' key.Substring(2' dotPos - 2));
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocKeyProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocKeyProvider.cs,FindMember,The following statement contains a magic number: TypeDefinition type = FindType(module' key.Substring(2' dotPos - 2));
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following statement contains a magic number: while (reader.Read()) {  				switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}  			}
Magic Number,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int h = 0;  				foreach (char c in key) {  					h = (h << 5) - h + c;  				}  				return h;  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadHexDigit,The following statement contains a magic number: switch (char.ToUpper(this.scanner.Read())) {  				case '0':  					return 0;    				case '1':  					return 1;    				case '2':  					return 2;    				case '3':  					return 3;    				case '4':  					return 4;    				case '5':  					return 5;    				case '6':  					return 6;    				case '7':  					return 7;    				case '8':  					return 8;    				case '9':  					return 9;    				case 'A':  					return 10;    				case 'B':  					return 11;    				case 'C':  					return 12;    				case 'D':  					return 13;    				case 'E':  					return 14;    				case 'F':  					return 15;    				default:  					throw new JsonParseException(  						ErrorType.InvalidOrUnexpectedCharacter'  						errorPosition);  			}
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 4096;
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 256;
Magic Number,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadUnicodeLiteral,The following statement contains a magic number: value += this.ReadHexDigit() * 16;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\UsingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\LockInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\NullCoalescingInstruction.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following statement contains a magic number: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SortBlocks,The following statement contains a magic number: if (Blocks.Count < 2)  				return;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryFinally,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,TryFault,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL,InstructionCollection<T>,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions\InstructionCollection.cs,SecondToLastOrDefault,The following statement contains a magic number: return list.Count > 1 ? list[list.Count - 2] : null;
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeInstruction,The following statement contains a magic number: switch (cecilInst.OpCode.Code) {  				case Cil.Code.Constrained:  					return DecodeConstrainedCall();  				case Cil.Code.Readonly:  					return DecodeReadonly();  				case Cil.Code.Tail:  					return DecodeTailCall();  				case Cil.Code.Unaligned:  					return DecodeUnaligned();  				case Cil.Code.Volatile:  					return DecodeVolatile();  				case Cil.Code.Add:  					return BinaryNumeric(BinaryNumericOperator.Add);  				case Cil.Code.Add_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Signed);  				case Cil.Code.Add_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Add' true' Sign.Unsigned);  				case Cil.Code.And:  					return BinaryNumeric(BinaryNumericOperator.BitAnd);  				case Cil.Code.Arglist:  					return Push(new Arglist());  				case Cil.Code.Beq:  					return DecodeComparisonBranch(false' ComparisonKind.Equality);  				case Cil.Code.Beq_S:  					return DecodeComparisonBranch(true' ComparisonKind.Equality);  				case Cil.Code.Bge:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual);  				case Cil.Code.Bge_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bge_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThanOrEqual' un: true);  				case Cil.Code.Bgt:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan);  				case Cil.Code.Bgt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Bgt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.GreaterThan' un: true);  				case Cil.Code.Ble:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual);  				case Cil.Code.Ble_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Ble_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThanOrEqual' un: true);  				case Cil.Code.Blt:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan);  				case Cil.Code.Blt_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan);  				case Cil.Code.Blt_Un:  					return DecodeComparisonBranch(false' ComparisonKind.LessThan' un: true);  				case Cil.Code.Blt_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.LessThan' un: true);  				case Cil.Code.Bne_Un:  					return DecodeComparisonBranch(false' ComparisonKind.Inequality' un: true);  				case Cil.Code.Bne_Un_S:  					return DecodeComparisonBranch(true' ComparisonKind.Inequality' un: true);  				case Cil.Code.Br:  					return DecodeUnconditionalBranch(false);  				case Cil.Code.Br_S:  					return DecodeUnconditionalBranch(true);  				case Cil.Code.Break:  					return new DebugBreak();  				case Cil.Code.Brfalse:  					return DecodeConditionalBranch(false' true);  				case Cil.Code.Brfalse_S:  					return DecodeConditionalBranch(true' true);  				case Cil.Code.Brtrue:  					return DecodeConditionalBranch(false' false);  				case Cil.Code.Brtrue_S:  					return DecodeConditionalBranch(true' false);  				case Cil.Code.Call:  					return DecodeCall(OpCode.Call);  				case Cil.Code.Callvirt:  					return DecodeCall(OpCode.CallVirt);  				case Cil.Code.Calli:  					return DecodeCallIndirect();  				case Cil.Code.Ceq:  					return Push(Comparison(ComparisonKind.Equality));  				case Cil.Code.Cgt:  					return Push(Comparison(ComparisonKind.GreaterThan));  				case Cil.Code.Cgt_Un:  					return Push(Comparison(ComparisonKind.GreaterThan' un: true));  				case Cil.Code.Clt:  					return Push(Comparison(ComparisonKind.LessThan));  				case Cil.Code.Clt_Un:  					return Push(Comparison(ComparisonKind.LessThan' un: true));  				case Cil.Code.Ckfinite:  					return new Ckfinite(Peek());  				case Cil.Code.Conv_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' false' Sign.None));  				case Cil.Code.Conv_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' false' Sign.None));  				case Cil.Code.Conv_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' false' Sign.None));  				case Cil.Code.Conv_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' false' Sign.None));  				case Cil.Code.Conv_R4:  					return Push(new Conv(Pop()' PrimitiveType.R4' false' Sign.Signed));  				case Cil.Code.Conv_R8:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Signed));  				case Cil.Code.Conv_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' false' Sign.None));  				case Cil.Code.Conv_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' false' Sign.None));  				case Cil.Code.Conv_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' false' Sign.None));  				case Cil.Code.Conv_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' false' Sign.None));  				case Cil.Code.Conv_I:  					return Push(new Conv(Pop()' PrimitiveType.I' false' Sign.None));  				case Cil.Code.Conv_U:  					return Push(new Conv(Pop()' PrimitiveType.U' false' Sign.None));  				case Cil.Code.Conv_R_Un:  					return Push(new Conv(Pop()' PrimitiveType.R8' false' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I1:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I2:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I4:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I8:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U1:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U2:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U4:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U8:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_U:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Signed));  				case Cil.Code.Conv_Ovf_I1_Un:  					return Push(new Conv(Pop()' PrimitiveType.I1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I2_Un:  					return Push(new Conv(Pop()' PrimitiveType.I2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I4_Un:  					return Push(new Conv(Pop()' PrimitiveType.I4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I8_Un:  					return Push(new Conv(Pop()' PrimitiveType.I8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U1_Un:  					return Push(new Conv(Pop()' PrimitiveType.U1' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U2_Un:  					return Push(new Conv(Pop()' PrimitiveType.U2' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U4_Un:  					return Push(new Conv(Pop()' PrimitiveType.U4' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U8_Un:  					return Push(new Conv(Pop()' PrimitiveType.U8' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_I_Un:  					return Push(new Conv(Pop()' PrimitiveType.I' true' Sign.Unsigned));  				case Cil.Code.Conv_Ovf_U_Un:  					return Push(new Conv(Pop()' PrimitiveType.U' true' Sign.Unsigned));  				case Cil.Code.Cpblk:  					return new Cpblk(size: Pop(StackType.I4)' sourceAddress: PopPointer()' destAddress: PopPointer());  				case Cil.Code.Div:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Signed);  				case Cil.Code.Div_Un:  					return BinaryNumeric(BinaryNumericOperator.Div' false' Sign.Unsigned);  				case Cil.Code.Dup:  					return Push(Peek());  				case Cil.Code.Endfilter:  					return new Leave(null' Pop());  				case Cil.Code.Endfinally:  					return new Leave(null);  				case Cil.Code.Initblk:  					return new Initblk(size: Pop(StackType.I4)' value: Pop(StackType.I4)' address: PopPointer());  				case Cil.Code.Jmp:  					return DecodeJmp();  				case Cil.Code.Ldarg:  				case Cil.Code.Ldarg_S:  					return Push(Ldarg(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldarg_0:  					return Push(Ldarg(0));  				case Cil.Code.Ldarg_1:  					return Push(Ldarg(1));  				case Cil.Code.Ldarg_2:  					return Push(Ldarg(2));  				case Cil.Code.Ldarg_3:  					return Push(Ldarg(3));  				case Cil.Code.Ldarga:  				case Cil.Code.Ldarga_S:  					return Push(Ldarga(((ParameterDefinition)cecilInst.Operand).Sequence));  				case Cil.Code.Ldc_I4:  					return Push(new LdcI4((int)cecilInst.Operand));  				case Cil.Code.Ldc_I8:  					return Push(new LdcI8((long)cecilInst.Operand));  				case Cil.Code.Ldc_R4:  					return Push(new LdcF4((float)cecilInst.Operand));  				case Cil.Code.Ldc_R8:  					return Push(new LdcF8((double)cecilInst.Operand));  				case Cil.Code.Ldc_I4_M1:  					return Push(new LdcI4(-1));  				case Cil.Code.Ldc_I4_0:  					return Push(new LdcI4(0));  				case Cil.Code.Ldc_I4_1:  					return Push(new LdcI4(1));  				case Cil.Code.Ldc_I4_2:  					return Push(new LdcI4(2));  				case Cil.Code.Ldc_I4_3:  					return Push(new LdcI4(3));  				case Cil.Code.Ldc_I4_4:  					return Push(new LdcI4(4));  				case Cil.Code.Ldc_I4_5:  					return Push(new LdcI4(5));  				case Cil.Code.Ldc_I4_6:  					return Push(new LdcI4(6));  				case Cil.Code.Ldc_I4_7:  					return Push(new LdcI4(7));  				case Cil.Code.Ldc_I4_8:  					return Push(new LdcI4(8));  				case Cil.Code.Ldc_I4_S:  					return Push(new LdcI4((sbyte)cecilInst.Operand));  				case Cil.Code.Ldnull:  					return Push(new LdNull());  				case Cil.Code.Ldstr:  					return Push(DecodeLdstr());  				case Cil.Code.Ldftn:  					return Push(new LdFtn(ReadAndDecodeMethodReference()));  				case Cil.Code.Ldind_I1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.SByte)));  				case Cil.Code.Ldind_I2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int16)));  				case Cil.Code.Ldind_I4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int32)));  				case Cil.Code.Ldind_I8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Int64)));  				case Cil.Code.Ldind_U1:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Byte)));  				case Cil.Code.Ldind_U2:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt16)));  				case Cil.Code.Ldind_U4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.UInt32)));  				case Cil.Code.Ldind_R4:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Single)));  				case Cil.Code.Ldind_R8:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Double)));  				case Cil.Code.Ldind_I:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.IntPtr)));  				case Cil.Code.Ldind_Ref:  					return Push(new LdObj(PopPointer()' compilation.FindType(KnownTypeCode.Object)));  				case Cil.Code.Ldloc:  				case Cil.Code.Ldloc_S:  					return Push(Ldloc(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Ldloc_0:  					return Push(Ldloc(0));  				case Cil.Code.Ldloc_1:  					return Push(Ldloc(1));  				case Cil.Code.Ldloc_2:  					return Push(Ldloc(2));  				case Cil.Code.Ldloc_3:  					return Push(Ldloc(3));  				case Cil.Code.Ldloca:  				case Cil.Code.Ldloca_S:  					return Push(Ldloca(((Cil.VariableDefinition)cecilInst.Operand).Index));  				case Cil.Code.Leave:  					return DecodeUnconditionalBranch(false' isLeave: true);  				case Cil.Code.Leave_S:  					return DecodeUnconditionalBranch(true' isLeave: true);  				case Cil.Code.Localloc:  					return Push(new LocAlloc(Pop()));  				case Cil.Code.Mul:  					return BinaryNumeric(BinaryNumericOperator.Mul' false' Sign.None);  				case Cil.Code.Mul_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Signed);  				case Cil.Code.Mul_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Mul' true' Sign.Unsigned);  				case Cil.Code.Neg:  					return Neg();  				case Cil.Code.Newobj:  					return DecodeCall(OpCode.NewObj);  				case Cil.Code.Nop:  					return new Nop();  				case Cil.Code.Not:  					return Push(new BitNot(Pop()));  				case Cil.Code.Or:  					return BinaryNumeric(BinaryNumericOperator.BitOr);  				case Cil.Code.Pop:  					Pop();  					return new Nop() { Kind = NopKind.Pop };  				case Cil.Code.Rem:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Signed);  				case Cil.Code.Rem_Un:  					return BinaryNumeric(BinaryNumericOperator.Rem' false' Sign.Unsigned);  				case Cil.Code.Ret:  					return Return();  				case Cil.Code.Shl:  					return BinaryNumeric(BinaryNumericOperator.ShiftLeft' false' Sign.None);  				case Cil.Code.Shr:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Signed);  				case Cil.Code.Shr_Un:  					return BinaryNumeric(BinaryNumericOperator.ShiftRight' false' Sign.Unsigned);  				case Cil.Code.Starg:  				case Cil.Code.Starg_S:  					return Starg(((ParameterDefinition)cecilInst.Operand).Sequence);  				case Cil.Code.Stind_I1:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stind_I2:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stind_I4:  					return new StObj(value: Pop(StackType.I4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stind_I8:  					return new StObj(value: Pop(StackType.I8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stind_R4:  					return new StObj(value: Pop(StackType.F4)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stind_R8:  					return new StObj(value: Pop(StackType.F8)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stind_I:  					return new StObj(value: Pop(StackType.I)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stind_Ref:  					return new StObj(value: Pop(StackType.O)' target: PopPointer()' type: compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stloc:  				case Cil.Code.Stloc_S:  					return Stloc(((Cil.VariableDefinition)cecilInst.Operand).Index);  				case Cil.Code.Stloc_0:  					return Stloc(0);  				case Cil.Code.Stloc_1:  					return Stloc(1);  				case Cil.Code.Stloc_2:  					return Stloc(2);  				case Cil.Code.Stloc_3:  					return Stloc(3);  				case Cil.Code.Sub:  					return BinaryNumeric(BinaryNumericOperator.Sub' false' Sign.None);  				case Cil.Code.Sub_Ovf:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Signed);  				case Cil.Code.Sub_Ovf_Un:  					return BinaryNumeric(BinaryNumericOperator.Sub' true' Sign.Unsigned);  				case Cil.Code.Switch:  					return DecodeSwitch();  				case Cil.Code.Xor:  					return BinaryNumeric(BinaryNumericOperator.BitXor);  				case Cil.Code.Box:  					{  						var type = ReadAndDecodeTypeReference();  						return Push(new Box(Pop(type.GetStackType())' type));  					}  				case Cil.Code.Castclass:  					return Push(new CastClass(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Cpobj:  					{  						var type = ReadAndDecodeTypeReference();  						var ld = new LdObj(PopPointer()' type);  						return new StObj(PopPointer()' ld' type);  					}  				case Cil.Code.Initobj:  					return InitObj(PopPointer()' ReadAndDecodeTypeReference());  				case Cil.Code.Isinst:  					return Push(new IsInst(Pop(StackType.O)' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldelem_Any:  					return LdElem(ReadAndDecodeTypeReference());  				case Cil.Code.Ldelem_I1:  					return LdElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Ldelem_I2:  					return LdElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Ldelem_I4:  					return LdElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Ldelem_I8:  					return LdElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Ldelem_U1:  					return LdElem(compilation.FindType(KnownTypeCode.Byte));  				case Cil.Code.Ldelem_U2:  					return LdElem(compilation.FindType(KnownTypeCode.UInt16));  				case Cil.Code.Ldelem_U4:  					return LdElem(compilation.FindType(KnownTypeCode.UInt32));  				case Cil.Code.Ldelem_R4:  					return LdElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Ldelem_R8:  					return LdElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Ldelem_I:  					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Ldelem_Ref:  					return LdElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Ldelema:  					return Push(new LdElema(indices: Pop()' array: Pop()' type: ReadAndDecodeTypeReference()));  				case Cil.Code.Ldfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdFlda(PopLdFldTarget(field)' field) { DelayExceptions = true }' field.Type));  					}  				case Cil.Code.Ldflda:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdFlda(PopFieldTarget(field)' field));  					}  				case Cil.Code.Stfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdFlda(PopFieldTarget(field)' field) { DelayExceptions = true }' type: field.Type);  					}  				case Cil.Code.Ldlen:  					return Push(new LdLen(StackType.I' Pop()));  				case Cil.Code.Ldobj:  					return Push(new LdObj(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Ldsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return Push(new LdObj(new LdsFlda(field)' field.Type));  					}  				case Cil.Code.Ldsflda:  					return Push(new LdsFlda(ReadAndDecodeFieldReference()));  				case Cil.Code.Stsfld:  					{  						var field = ReadAndDecodeFieldReference();  						return new StObj(value: Pop(field.Type.GetStackType())' target: new LdsFlda(field)' type: field.Type);  					}  				case Cil.Code.Ldtoken:  					return Push(LdToken(ReadAndDecodeMetadataToken()));  				case Cil.Code.Ldvirtftn:  					return Push(new LdVirtFtn(Pop()' ReadAndDecodeMethodReference()));  				case Cil.Code.Mkrefany:  					return Push(new MakeRefAny(PopPointer()' ReadAndDecodeTypeReference()));  				case Cil.Code.Newarr:  					return Push(new NewArr(ReadAndDecodeTypeReference()' Pop()));  				case Cil.Code.Refanytype:  					return Push(new RefAnyType(Pop()));  				case Cil.Code.Refanyval:  					return Push(new RefAnyValue(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Rethrow:  					return new Rethrow();  				case Cil.Code.Sizeof:  					return Push(new SizeOf(ReadAndDecodeTypeReference()));  				case Cil.Code.Stelem_Any:  					return StElem(ReadAndDecodeTypeReference());  				case Cil.Code.Stelem_I1:  					return StElem(compilation.FindType(KnownTypeCode.SByte));  				case Cil.Code.Stelem_I2:  					return StElem(compilation.FindType(KnownTypeCode.Int16));  				case Cil.Code.Stelem_I4:  					return StElem(compilation.FindType(KnownTypeCode.Int32));  				case Cil.Code.Stelem_I8:  					return StElem(compilation.FindType(KnownTypeCode.Int64));  				case Cil.Code.Stelem_R4:  					return StElem(compilation.FindType(KnownTypeCode.Single));  				case Cil.Code.Stelem_R8:  					return StElem(compilation.FindType(KnownTypeCode.Double));  				case Cil.Code.Stelem_I:  					return StElem(compilation.FindType(KnownTypeCode.IntPtr));  				case Cil.Code.Stelem_Ref:  					return StElem(compilation.FindType(KnownTypeCode.Object));  				case Cil.Code.Stobj:  				{  					var type = ReadAndDecodeTypeReference();  					return new StObj(value: Pop(type.GetStackType())' target: PopPointer()' type: type);  				}  				case Cil.Code.Throw:  					return new Throw(Pop());  				case Cil.Code.Unbox:  					return Push(new Unbox(Pop()' ReadAndDecodeTypeReference()));  				case Cil.Code.Unbox_Any:  					return Push(new UnboxAny(Pop()' ReadAndDecodeTypeReference()));  				default:  					return new InvalidBranch("Unknown opcode: " + cecilInst.OpCode.ToString());  			}
Magic Number,ICSharpCode.Decompiler.IL,ILReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILReader.cs,DecodeCall,The following statement contains a magic number: switch (method.DeclaringType.Kind) {  				case TypeKind.Array:  					var elementType = ((ArrayType)method.DeclaringType).ElementType;  					if (opCode == OpCode.NewObj)  						return Push(new NewArr(elementType' arguments));  					if (method.Name == "Set") {  						var target = arguments[0];  						var value = arguments.Last();  						var indices = arguments.Skip(1).Take(arguments.Length - 2).ToArray();  						return new StObj(new LdElema(elementType' target' indices)' value' elementType);  					}  					if (method.Name == "Get") {  						var target = arguments[0];  						var indices = arguments.Skip(1).ToArray();  						return Push(new LdObj(new LdElema(elementType' target' indices)' elementType));  					}  					if (method.Name == "Address") {  						var target = arguments[0];  						var indices = arguments.Skip(1).ToArray();  						return Push(new LdElema(elementType' target' indices));  					}  					Warn("Unknown method called on array type: " + method.Name);  					goto default;  				default:  					var call = CallInstruction.Create(opCode' method);  					call.ILStackWasEmpty = currentStack.IsEmpty;  					call.ConstrainedTo = constrainedPrefix;  					call.Arguments.AddRange(arguments);  					if (call.ResultType != StackType.Void)  						return Push(call);  					return call;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,GetSize,The following statement contains a magic number: switch (type) {  				case PrimitiveType.I1:  				case PrimitiveType.U1:  					return 1;  				case PrimitiveType.I2:  				case PrimitiveType.U2:  					return 2;  				case PrimitiveType.I4:  				case PrimitiveType.U4:  				case PrimitiveType.R4:  					return 4;  				case PrimitiveType.I8:  				case PrimitiveType.R8:  				case PrimitiveType.U8:  					return 8;  				case PrimitiveType.I:  				case PrimitiveType.U:  				case PrimitiveType.Ref:  					return TypeUtils.NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.IL,ILTypeExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ILTypeExtensions.cs,IsSmallIntegerType,The following statement contains a magic number: return GetSize(type) < 4;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchWhileLoop,The following statement contains a magic number: if (loop.EntryPoint.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,CollectConditions,The following statement contains a magic number: int i = block.Instructions.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The following statement contains a magic number: if (block.Instructions.Count < 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchDoWhileConditionBlock,The following statement contains a magic number: if (last.MatchReturn(out _) && ifInstruction.TrueInst is Block nestedConditionBlock) {  				if (nestedConditionBlock.Instructions.Count < 2)  					return false;  				last = nestedConditionBlock.Instructions.Last();  				ifInstruction = nestedConditionBlock.Instructions.SecondToLastOrDefault() as IfInstruction;  				if (ifInstruction == null || !ifInstruction.FalseInst.MatchNop())  					return false;  				unwrapCondtionBlock = true;  				conditionBlock = nestedConditionBlock;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,The following statement contains a magic number: if (loop.EntryPoint.IncomingEdgeCount != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,The following statement contains a magic number: if (incrementBlock != null) {  				// we found a possible increment block' just make sure' that there are at least three blocks:  				// - condition block  				// - loop body  				// - increment block  				if (incrementBlock.Instructions.Count <= 1 || loop.Blocks.Count < 3)  					return false;  				context.Step("Transform to for loop"' loop);  				// move the block to the end of the loop:  				loop.Blocks.MoveElementToEnd(incrementBlock);  				loop.Kind = ContainerKind.For;  			} else {  				// we need to move the increment statements into its own block:  				// last must be a branch entry-point  				var last = whileLoopBody.Instructions.LastOrDefault();  				var secondToLast = whileLoopBody.Instructions.SecondToLastOrDefault();  				if (last == null || secondToLast == null)  					return false;  				if (!last.MatchBranch(loop.EntryPoint))  					return false;  				// we only deal with 'numeric' increments  				if (!MatchIncrement(secondToLast' out var incrementVariable))  					return false;  				// the increment variable must be local/stack variable  				if (incrementVariable.Kind == VariableKind.Parameter)  					return false;  				// split conditions:  				var conditions = new List<ILInstruction>();  				SplitConditions(whileCondition.Condition' conditions);  				IfInstruction forCondition = null;  				int numberOfConditions = 0;  				foreach (var condition in conditions) {  					// the increment variable must be used in the condition  					if (!condition.Descendants.Any(inst => inst.MatchLdLoc(incrementVariable)))  						break;  					// condition should not contain an assignment  					if (condition.Descendants.Any(IsAssignment))  						break;  					if (forCondition == null) {  						forCondition = new IfInstruction(condition' whileCondition.TrueInst' whileCondition.FalseInst);  					} else {  						forCondition.Condition = IfInstruction.LogicAnd(forCondition.Condition' condition);  					}  					numberOfConditions++;  				}  				if (numberOfConditions == 0)  					return false;  				context.Step("Transform to for loop"' loop);  				// split condition block:  				whileCondition.ReplaceWith(forCondition);  				ExpressionTransforms.RunOnSingleStatment(forCondition' context);  				for (int i = conditions.Count - 1; i >= numberOfConditions; i--) {  					IfInstruction inst;  					whileLoopBody.Instructions.Insert(0' inst = new IfInstruction(Comp.LogicNot(conditions[i])' new Leave(loop)));  					ExpressionTransforms.RunOnSingleStatment(inst' context);  				}  				// create a new increment block and add it at the end:  				int secondToLastIndex = secondToLast.ChildIndex;  				var newIncremenBlock = new Block();  				loop.Blocks.Add(newIncremenBlock);  				// move the increment instruction:  				newIncremenBlock.Instructions.Add(secondToLast);  				newIncremenBlock.Instructions.Add(last);  				newIncremenBlock.AddILRange(secondToLast.ILRange);  				whileLoopBody.Instructions.RemoveRange(secondToLastIndex' 2);  				whileLoopBody.Instructions.Add(new Branch(newIncremenBlock));  				// complete transform.  				loop.Kind = ContainerKind.For;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,HighLevelLoopTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\HighLevelLoopTransform.cs,MatchForLoop,The following statement contains a magic number: if (incrementBlock != null) {  				// we found a possible increment block' just make sure' that there are at least three blocks:  				// - condition block  				// - loop body  				// - increment block  				if (incrementBlock.Instructions.Count <= 1 || loop.Blocks.Count < 3)  					return false;  				context.Step("Transform to for loop"' loop);  				// move the block to the end of the loop:  				loop.Blocks.MoveElementToEnd(incrementBlock);  				loop.Kind = ContainerKind.For;  			} else {  				// we need to move the increment statements into its own block:  				// last must be a branch entry-point  				var last = whileLoopBody.Instructions.LastOrDefault();  				var secondToLast = whileLoopBody.Instructions.SecondToLastOrDefault();  				if (last == null || secondToLast == null)  					return false;  				if (!last.MatchBranch(loop.EntryPoint))  					return false;  				// we only deal with 'numeric' increments  				if (!MatchIncrement(secondToLast' out var incrementVariable))  					return false;  				// the increment variable must be local/stack variable  				if (incrementVariable.Kind == VariableKind.Parameter)  					return false;  				// split conditions:  				var conditions = new List<ILInstruction>();  				SplitConditions(whileCondition.Condition' conditions);  				IfInstruction forCondition = null;  				int numberOfConditions = 0;  				foreach (var condition in conditions) {  					// the increment variable must be used in the condition  					if (!condition.Descendants.Any(inst => inst.MatchLdLoc(incrementVariable)))  						break;  					// condition should not contain an assignment  					if (condition.Descendants.Any(IsAssignment))  						break;  					if (forCondition == null) {  						forCondition = new IfInstruction(condition' whileCondition.TrueInst' whileCondition.FalseInst);  					} else {  						forCondition.Condition = IfInstruction.LogicAnd(forCondition.Condition' condition);  					}  					numberOfConditions++;  				}  				if (numberOfConditions == 0)  					return false;  				context.Step("Transform to for loop"' loop);  				// split condition block:  				whileCondition.ReplaceWith(forCondition);  				ExpressionTransforms.RunOnSingleStatment(forCondition' context);  				for (int i = conditions.Count - 1; i >= numberOfConditions; i--) {  					IfInstruction inst;  					whileLoopBody.Instructions.Insert(0' inst = new IfInstruction(Comp.LogicNot(conditions[i])' new Leave(loop)));  					ExpressionTransforms.RunOnSingleStatment(inst' context);  				}  				// create a new increment block and add it at the end:  				int secondToLastIndex = secondToLast.ChildIndex;  				var newIncremenBlock = new Block();  				loop.Blocks.Add(newIncremenBlock);  				// move the increment instruction:  				newIncremenBlock.Instructions.Add(secondToLast);  				newIncremenBlock.Instructions.Add(last);  				newIncremenBlock.AddILRange(secondToLast.ILRange);  				whileLoopBody.Instructions.RemoveRange(secondToLastIndex' 2);  				whileLoopBody.Instructions.Add(new Branch(newIncremenBlock));  				// complete transform.  				loop.Kind = ContainerKind.For;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ProxyCallReplacer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ProxyCallReplacer.cs,Run,The following statement contains a magic number: foreach (var inst in function.Descendants.OfType<CallInstruction>()) {  				MethodDefinition methodDef = context.TypeSystem.GetCecil(inst.Method) as MethodDefinition;  				if (methodDef != null && methodDef.Body != null) {  					if (inst.Method.IsCompilerGeneratedOrIsInCompilerGeneratedClass()) {  						// partially copied from CSharpDecompiler  						var specializingTypeSystem = this.context.TypeSystem.GetSpecializingTypeSystem(this.context.TypeSystem.Compilation.TypeResolveContext);  						var ilReader = new ILReader(specializingTypeSystem);  						System.Threading.CancellationToken cancellationToken = new System.Threading.CancellationToken();  						var proxyFunction = ilReader.ReadIL(methodDef.Body' cancellationToken);  						var transformContext = new ILTransformContext(proxyFunction' specializingTypeSystem' this.context.Settings) {  							CancellationToken = cancellationToken  						};  						foreach (var transform in CSharp.CSharpDecompiler.GetILTransforms()) {  							if (transform.GetType() != typeof(ProxyCallReplacer)) { // don't call itself on itself  								cancellationToken.ThrowIfCancellationRequested();  								transform.Run(proxyFunction' transformContext);  							}  						}    						if (!(proxyFunction.Body is BlockContainer blockContainer))  							return;  						if (blockContainer.Blocks.Count != 1)  							return;  						var block = blockContainer.Blocks[0];  						Call call = null;  						if (block.Instructions.Count == 1) {  							// leave IL_0000 (call Test(ldloc this' ldloc A_1))  							if (!block.Instructions[0].MatchLeave(blockContainer' out ILInstruction returnValue))  								return;  							call = returnValue as Call;  						} else if (block.Instructions.Count == 2) {  							// call Test(ldloc this' ldloc A_1)  							// leave IL_0000(nop)  							call = block.Instructions[0] as Call;  							if (!block.Instructions[1].MatchLeave(blockContainer' out ILInstruction returnValue))  								return;  							if (!returnValue.MatchNop())  								return;  						}  						if (call == null) {  							return;  						}  						if (call.Method.IsConstructor)  							return;    						// check if original arguments are only correct ldloc calls  						for (int i = 0; i < call.Arguments.Count; i++) {  							var originalArg = call.Arguments[i];  							if (!originalArg.MatchLdLoc(out ILVariable var) ||  								var.Kind != VariableKind.Parameter ||  								var.Index != i - 1) {  								return;  							}  						}    						Call newInst = (Call)call.Clone();    						newInst.Arguments.ReplaceList(inst.Arguments);  						inst.ReplaceWith(newInst);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,InlineReturnTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\InlineReturnTransform.cs,CanModifyInstructions,The following statement contains a magic number: foreach (var inst in returnVar.StoreInstructions) {  				if (!(inst is StLoc store))  					return false;  				if (!(store.Parent is Block storeBlock))  					return false;  				if (store.ChildIndex + 2 != storeBlock.Instructions.Count)  					return false;  				if (!(storeBlock.Instructions[store.ChildIndex + 1] is Branch br))  					return false;  				if (br.TargetBlock != leaveBlock)  					return false;  				var targetBlockContainer = BlockContainer.FindClosestContainer(store);  				if (targetBlockContainer == null)  					return false;  				instructionsToModify.Add((targetBlockContainer' leaveBlock' br));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: foreach (var block in function.Descendants.OfType<Block>()) {  				bool changed = false;  				for (int i = block.Instructions.Count - 1; i >= 0; i--) {  					SwitchInstruction newSwitch;  					if (MatchSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i + 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i - 2' 3);  						i -= 2;  						changed = true;  						continue;  					}  					if (MatchRoslynSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i - 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i' 2);  						i--;  						changed = true;  						continue;  					}  				}  				if (!changed) continue;  				SwitchDetection.SimplifySwitchInstruction(block);  				if (block.Parent is BlockContainer container)  					changedContainers.Add(container);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: foreach (var block in function.Descendants.OfType<Block>()) {  				bool changed = false;  				for (int i = block.Instructions.Count - 1; i >= 0; i--) {  					SwitchInstruction newSwitch;  					if (MatchSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i + 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i - 2' 3);  						i -= 2;  						changed = true;  						continue;  					}  					if (MatchRoslynSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i - 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i' 2);  						i--;  						changed = true;  						continue;  					}  				}  				if (!changed) continue;  				SwitchDetection.SimplifySwitchInstruction(block);  				if (block.Parent is BlockContainer container)  					changedContainers.Add(container);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: foreach (var block in function.Descendants.OfType<Block>()) {  				bool changed = false;  				for (int i = block.Instructions.Count - 1; i >= 0; i--) {  					SwitchInstruction newSwitch;  					if (MatchSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i + 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i - 2' 3);  						i -= 2;  						changed = true;  						continue;  					}  					if (MatchRoslynSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i - 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i' 2);  						i--;  						changed = true;  						continue;  					}  				}  				if (!changed) continue;  				SwitchDetection.SimplifySwitchInstruction(block);  				if (block.Parent is BlockContainer container)  					changedContainers.Add(container);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,Run,The following statement contains a magic number: foreach (var block in function.Descendants.OfType<Block>()) {  				bool changed = false;  				for (int i = block.Instructions.Count - 1; i >= 0; i--) {  					SwitchInstruction newSwitch;  					if (MatchSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i + 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i - 2' 3);  						i -= 2;  						changed = true;  						continue;  					}  					if (MatchRoslynSwitchOnNullable(block.Instructions' i' out newSwitch)) {  						block.Instructions[i - 1].ReplaceWith(newSwitch);  						block.Instructions.RemoveRange(i' 2);  						i--;  						changed = true;  						continue;  					}  				}  				if (!changed) continue;  				SwitchDetection.SimplifySwitchInstruction(block);  				if (block.Parent is BlockContainer container)  					changedContainers.Add(container);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: if (i < 2) return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: if (!instructions[i - 2].MatchStLoc(out var tmp' out var ldloca) ||  				!instructions[i - 1].MatchStLoc(out var switchVariable' out var getValueOrDefault) ||  				!instructions[i].MatchIfInstruction(out var condition' out var trueInst))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchSwitchOnNullable,The following statement contains a magic number: if (!tmp.IsSingleDefinition || tmp.LoadCount != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The following statement contains a magic number: if (tmp.StoreCount != 1 || tmp.AddressCount != 2 || tmp.LoadCount != 0)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnNullableTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnNullableTransform.cs,MatchRoslynSwitchOnNullable,The following statement contains a magic number: switch (switchBlock.Instructions.Count) {  				case 2: {  					// this is the normal case described by the pattern above  					if (!switchBlock.Instructions[0].MatchStLoc(out var switchVar' out var getValueOrDefault))  						return false;  					if (!switchVar.IsSingleDefinition || switchVar.LoadCount != 1)  						return false;  					if (!NullableLiftingTransform.MatchGetValueOrDefault(getValueOrDefault' tmp))  						return false;  					if (!(switchBlock.Instructions[1] is SwitchInstruction si))  						return false;  					switchInst = si;  					break;  				}  				case 1: {  					// this is the special case where `call GetValueOrDefault(ldloca tmp)` is inlined into the switch.  					if (!(switchBlock.Instructions[0] is SwitchInstruction si))  						return false;  					if (!NullableLiftingTransform.MatchGetValueOrDefault(si.Value' tmp))  						return false;  					switchInst = si;  					break;  				}  				default: {  					return false;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (instructions[i - 1].MatchStLoc(switchValueVar' out switchValue)) {  				// stloc switchValueVar(switchValue)  				// if (call op_Equality(ldloc switchValueVar' ldstr value)) br firstBlock  			} else if (instructions[i - 1] is StLoc stloc && stloc.Value.MatchLdLoc(switchValueVar)) {  				// in case of optimized legacy code there are two stlocs:  				// stloc otherSwitchValueVar(ldloc switchValue)  				// stloc switchValueVar(ldloc otherSwitchValueVar)  				// if (call op_Equality(ldloc otherSwitchValueVar' ldstr value)) br firstBlock  				var otherSwitchValueVar = switchValueVar;  				switchValueVar = stloc.Variable;  				if (i >= 2 && instructions[i - 2].MatchStLoc(otherSwitchValueVar' out switchValue)  					&& otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 2)  				{  					extraLoad = true;  				} else {  					switchValue = new LdLoc(otherSwitchValueVar);  				}  			} else {  				switchValue = new LdLoc(switchValueVar);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (instructions[i - 1].MatchStLoc(switchValueVar' out switchValue)) {  				// stloc switchValueVar(switchValue)  				// if (call op_Equality(ldloc switchValueVar' ldstr value)) br firstBlock  			} else if (instructions[i - 1] is StLoc stloc && stloc.Value.MatchLdLoc(switchValueVar)) {  				// in case of optimized legacy code there are two stlocs:  				// stloc otherSwitchValueVar(ldloc switchValue)  				// stloc switchValueVar(ldloc otherSwitchValueVar)  				// if (call op_Equality(ldloc otherSwitchValueVar' ldstr value)) br firstBlock  				var otherSwitchValueVar = switchValueVar;  				switchValueVar = stloc.Variable;  				if (i >= 2 && instructions[i - 2].MatchStLoc(otherSwitchValueVar' out switchValue)  					&& otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 2)  				{  					extraLoad = true;  				} else {  					switchValue = new LdLoc(otherSwitchValueVar);  				}  			} else {  				switchValue = new LdLoc(switchValueVar);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (instructions[i - 1].MatchStLoc(switchValueVar' out switchValue)) {  				// stloc switchValueVar(switchValue)  				// if (call op_Equality(ldloc switchValueVar' ldstr value)) br firstBlock  			} else if (instructions[i - 1] is StLoc stloc && stloc.Value.MatchLdLoc(switchValueVar)) {  				// in case of optimized legacy code there are two stlocs:  				// stloc otherSwitchValueVar(ldloc switchValue)  				// stloc switchValueVar(ldloc otherSwitchValueVar)  				// if (call op_Equality(ldloc otherSwitchValueVar' ldstr value)) br firstBlock  				var otherSwitchValueVar = switchValueVar;  				switchValueVar = stloc.Variable;  				if (i >= 2 && instructions[i - 2].MatchStLoc(otherSwitchValueVar' out switchValue)  					&& otherSwitchValueVar.IsSingleDefinition && otherSwitchValueVar.LoadCount == 2)  				{  					extraLoad = true;  				} else {  					switchValue = new LdLoc(otherSwitchValueVar);  				}  			} else {  				switchValue = new LdLoc(switchValueVar);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (values.Count < 3)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (extraLoad) {  				instructions[i - 2].ReplaceWith(inst);  				instructions.RemoveRange(i - 1' 3);  				i -= 2;  			} else {  				if (keepAssignmentBefore) {  					instructions[i].ReplaceWith(inst);  					instructions.RemoveAt(i + 1);  				} else {  					instructions[i - 1].ReplaceWith(inst);  					instructions.RemoveRange(i' 2);  					i--;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (extraLoad) {  				instructions[i - 2].ReplaceWith(inst);  				instructions.RemoveRange(i - 1' 3);  				i -= 2;  			} else {  				if (keepAssignmentBefore) {  					instructions[i].ReplaceWith(inst);  					instructions.RemoveAt(i + 1);  				} else {  					instructions[i - 1].ReplaceWith(inst);  					instructions.RemoveRange(i' 2);  					i--;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (extraLoad) {  				instructions[i - 2].ReplaceWith(inst);  				instructions.RemoveRange(i - 1' 3);  				i -= 2;  			} else {  				if (keepAssignmentBefore) {  					instructions[i].ReplaceWith(inst);  					instructions.RemoveAt(i + 1);  				} else {  					instructions[i - 1].ReplaceWith(inst);  					instructions.RemoveRange(i' 2);  					i--;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,SimplifyCascadingIfStatements,The following statement contains a magic number: if (extraLoad) {  				instructions[i - 2].ReplaceWith(inst);  				instructions.RemoveRange(i - 1' 3);  				i -= 2;  			} else {  				if (keepAssignmentBefore) {  					instructions[i].ReplaceWith(inst);  					instructions.RemoveAt(i + 1);  				} else {  					instructions[i - 1].ReplaceWith(inst);  					instructions.RemoveRange(i' 2);  					i--;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchCaseBlock,The following statement contains a magic number: if (currentBlock.IncomingEdgeCount != 1 || currentBlock.Instructions.Count != 2)  				return null;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (nextBlock.Instructions.Count != 2 || !nextBlock.Instructions[0].MatchIfInstruction(out condition' out var tryGetValueBlockJump))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (dictInitBlock.IncomingEdgeCount != 1 || dictInitBlock.Instructions.Count < 3)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (tryGetValueBlock.IncomingEdgeCount != 2 || tryGetValueBlock.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (tryGetValueBlock.IncomingEdgeCount != 2 || tryGetValueBlock.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (!c.Arguments[1].MatchLdLoc(switchValueVar) || !c.Arguments[2].MatchLdLoca(out var switchIndexVar))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (switchValueVar.LoadCount > 2) {  				switchValue = new LdLoc(switchValueVar);  				keepAssignmentBefore = true;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (keepAssignmentBefore) {  				// delete if (comp(ldloc switchValueVar == ldnull))  				instructions.RemoveAt(i);  				i--;  			} else {  				// delete both the if and the assignment before  				instructions.RemoveRange(i - 1' 2);  				i -= 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithDict,The following statement contains a magic number: if (keepAssignmentBefore) {  				// delete if (comp(ldloc switchValueVar == ldnull))  				instructions.RemoveAt(i);  				i--;  			} else {  				// delete both the if and the assignment before  				instructions.RemoveRange(i - 1' 2);  				i -= 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: if (newObj.Arguments.Count == 2) {  				if (!newObj.Arguments[0].MatchLdcI4(out valuesLength))  					return false;  				if (!newObj.Arguments[1].MatchLdcF4(0.5f))  					return false;  			} else if (newObj.Arguments.Count == 1) {  				if (!newObj.Arguments[0].MatchLdcI4(out valuesLength))  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,ExtractStringValuesFromInitBlock,The following statement contains a magic number: return block.Instructions[i + 2].MatchBranch(targetBlock);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: if (!(inst is Call c && c.Method.Name == "Add" && c.Arguments.Count == 3))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: return (c.Arguments[2].MatchLdcI4(index) || (c.Arguments[2].MatchBox(out var arg' out _) && arg.MatchLdcI4(index)));
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchAddCall,The following statement contains a magic number: return (c.Arguments[2].MatchLdcI4(index) || (c.Arguments[2].MatchBox(out var arg' out _) && arg.MatchLdcI4(index)));
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,IsStringToIntDictionary,The following statement contains a magic number: if (dictionaryType.TypeArguments.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (tableInitBlock.IncomingEdgeCount != 1 || tableInitBlock.Instructions.Count < 3)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (switchHead.Instructions.Count != 4 || switchHead.IncomingEdgeCount != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (switchHead.Instructions.Count != 4 || switchHead.IncomingEdgeCount != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (!switchHead.Instructions[2].MatchIfInstruction(out condition' out var nullCaseBlockBranch))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (!switchHead.Instructions[3].MatchBranch(out var getItemBlock) || !nullCaseBlockBranch.MatchBranch(out var nullCaseBlock))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (getItemBlock.IncomingEdgeCount != 1 || getItemBlock.Instructions.Count != 4)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (!getItemBlock.Instructions[2].MatchIfInstruction(out condition' out var defaultBlockBranch))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (!getItemBlock.Instructions[3].MatchBranch(out var switchBlock) || !defaultBlockBranch.MatchBranch(out var defaultBlock))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchLegacySwitchOnStringWithHashtable,The following statement contains a magic number: if (!(getItemCall.Arguments.Count == 2 && MatchDictionaryFieldLoad(getItemCall.Arguments[0]' IsStringToIntDictionary' out var dictField2' out _) && dictField2.Equals(dictField)) &&  				getItemCall.Arguments[1].MatchLdLoc(switchVariable2))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: if (i > 1 && instructions[i - 2].MatchStLoc(switchValueLoad.Variable' out var switchValueTmp) &&  				switchValueLoad.Variable.IsSingleDefinition && switchValueLoad.Variable.LoadCount == switchInst.Sections.Count)  			{  				switchValueInst = switchValueTmp;  				keepAssignmentBefore = false;  			} else {  				keepAssignmentBefore = true;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: if (keepAssignmentBefore) {  				instructions.RemoveAt(i - 1);  				i--;  			} else {  				instructions.RemoveRange(i - 2' 2);  				i -= 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: if (keepAssignmentBefore) {  				instructions.RemoveAt(i - 1);  				i--;  			} else {  				instructions.RemoveRange(i - 2' 2);  				i -= 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynSwitchOnString,The following statement contains a magic number: if (keepAssignmentBefore) {  				instructions.RemoveAt(i - 1);  				i--;  			} else {  				instructions.RemoveRange(i - 2' 2);  				i -= 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchRoslynCaseBlockHead,The following statement contains a magic number: if (target.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,SwitchOnStringTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SwitchOnStringTransform.cs,MatchStringEqualityComparison,The following statement contains a magic number: if (condition is Call c && c.Method.IsOperator && c.Method.Name == "op_Equality"  				&& c.Method.DeclaringType.IsKnownType(KnownTypeCode.String) && c.Arguments.Count == 2)  			{  				left = c.Arguments[0];  				right = c.Arguments[1];  				return left.MatchLdLoc(out variable) && right.MatchLdStr(out stringValue);  			} else if (condition.MatchCompEqualsNull(out var arg)) {  				stringValue = null;  				return arg.MatchLdLoc(out variable);  			} else {  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MightBeExpressionTree,The following statement contains a magic number: if (!(inst is CallInstruction call  				&& call.Method.FullName == "System.Linq.Expressions.Expression.Lambda"  				&& call.Arguments.Count == 2))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchParameterVariableAssignment,The following statement contains a magic number: if (!(init is CallInstruction initCall && initCall.Arguments.Count == 2))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLambda,The following statement contains a magic number: if (instruction.Method.Name != "Lambda" || instruction.Arguments.Count != 2 || instruction.Method.ReturnType.FullName != "System.Linq.Expressions.Expression" || instruction.Method.ReturnType.TypeArguments.Count != 1)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertArrayIndex,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBinaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					if (op == BinaryNumericOperator.ShiftLeft || op == BinaryNumericOperator.ShiftRight) {  						if (!rightType.IsKnownType(KnownTypeCode.Int32))  							return (null' SpecialType.UnknownType);  					} else {  						if (!rightType.Equals(leftType))  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' right' isChecked == true' leftType.GetSign())' leftType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBind,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (MatchGetMethodFromHandle(invocation.Arguments[0]' out var member)) {  				// static method  				if (invocation.Arguments.Count != 2 || !MatchArgumentList(invocation.Arguments[1]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(1));  				}  			} else if (MatchGetMethodFromHandle(invocation.Arguments[1]' out member)) {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(2));  				}  				if (!invocation.Arguments[0].MatchLdNull()) {  					(target' targetType) = ConvertInstruction(invocation.Arguments[0]);  					if (target == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (MatchGetMethodFromHandle(invocation.Arguments[0]' out var member)) {  				// static method  				if (invocation.Arguments.Count != 2 || !MatchArgumentList(invocation.Arguments[1]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(1));  				}  			} else if (MatchGetMethodFromHandle(invocation.Arguments[1]' out member)) {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(2));  				}  				if (!invocation.Arguments[0].MatchLdNull()) {  					(target' targetType) = ConvertInstruction(invocation.Arguments[0]);  					if (target == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (MatchGetMethodFromHandle(invocation.Arguments[0]' out var member)) {  				// static method  				if (invocation.Arguments.Count != 2 || !MatchArgumentList(invocation.Arguments[1]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(1));  				}  			} else if (MatchGetMethodFromHandle(invocation.Arguments[1]' out member)) {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(2));  				}  				if (!invocation.Arguments[0].MatchLdNull()) {  					(target' targetType) = ConvertInstruction(invocation.Arguments[0]);  					if (target == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (MatchGetMethodFromHandle(invocation.Arguments[0]' out var member)) {  				// static method  				if (invocation.Arguments.Count != 2 || !MatchArgumentList(invocation.Arguments[1]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(1));  				}  			} else if (MatchGetMethodFromHandle(invocation.Arguments[1]' out member)) {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  					arguments = new List<ILInstruction>(invocation.Arguments.Skip(2));  				}  				if (!invocation.Arguments[0].MatchLdNull()) {  					(target' targetType) = ConvertInstruction(invocation.Arguments[0]);  					if (target == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCall,The following statement contains a magic number: if (method.FullName == "System.Reflection.MethodInfo.CreateDelegate" && method.Parameters.Count == 2) {  				if (!MatchGetMethodFromHandle(target' out var targetMethod))  					return (null' SpecialType.UnknownType);  				if (!MatchGetTypeFromHandle(arguments[0]' out var delegateType))  					return (null' SpecialType.UnknownType);  				return (new NewObj(delegateType.GetConstructors().Single()) {  					Arguments = { arguments[1]' new LdFtn((IMethod)targetMethod) }  				}' delegateType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCast,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCoalesce,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)) {  				if (isLifted != 0) {  					method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  				}  				return (new Call((IMethod)method) { Arguments = { left' right } }' method.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)) {  				if (isLifted != 0) {  					method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  				}  				return (new Call((IMethod)method) { Arguments = { left' right } }' method.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (invocation.Arguments.Count == 4 && invocation.Arguments[2].MatchLdcI4(out var isLifted) && MatchGetMethodFromHandle(invocation.Arguments[3]' out var method)) {  				if (isLifted != 0) {  					method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  				}  				return (new Call((IMethod)method) { Arguments = { left' right } }' method.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (leftType.IsKnownType(KnownTypeCode.String) && rightType.IsKnownType(KnownTypeCode.String)) {  				IMethod operatorMethod;  				switch (kind) {  					case ComparisonKind.Equality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					case ComparisonKind.Inequality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					default:  						return (null' SpecialType.UnknownType);  				}  				return (new Call(operatorMethod) { Arguments = { left' right } }' operatorMethod.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertComparison,The following statement contains a magic number: if (leftType.IsKnownType(KnownTypeCode.String) && rightType.IsKnownType(KnownTypeCode.String)) {  				IMethod operatorMethod;  				switch (kind) {  					case ComparisonKind.Equality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Equality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					case ComparisonKind.Inequality:  						operatorMethod = leftType.GetMethods(m => m.IsOperator && m.Name == "op_Inequality" && m.Parameters.Count == 2).FirstOrDefault(m => m.Parameters[0].Type.IsKnownType(KnownTypeCode.String) && m.Parameters[1].Type.IsKnownType(KnownTypeCode.String));  						if (operatorMethod == null)  							return (null' SpecialType.UnknownType);  						break;  					default:  						return (null' SpecialType.UnknownType);  				}  				return (new Call(operatorMethod) { Arguments = { left' right } }' operatorMethod.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCondition,The following statement contains a magic number: if (invocation.Arguments.Count != 3)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertCondition,The following statement contains a magic number: var (falseInst' falseInstType) = ConvertInstruction(invocation.Arguments[2]);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertElementInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertField,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInvoke,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The following statement contains a magic number: if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var member)) {  				if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  					return (null' SpecialType.UnknownType);  			} else {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments))  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertListInit,The following statement contains a magic number: if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var member)) {  				if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  					return (null' SpecialType.UnknownType);  			} else {  				if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments))  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertLogicOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					var resultType = context.TypeSystem.Compilation.FindType(KnownTypeCode.Boolean);  					return (and ? IfInstruction.LogicAnd(left' right) : IfInstruction.LogicOr(left' right)' resultType);  				case 3:  					if (!MatchGetMethodFromHandle(invocation.Arguments[2]' out method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				case 4:  					if (!invocation.Arguments[2].MatchLdcI4(out var isLifted))  						return (null' SpecialType.UnknownType);  					if (!MatchGetMethodFromHandle(invocation.Arguments[3]' out method))  						return (null' SpecialType.UnknownType);  					if (isLifted != 0)  						method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);  					return (new Call((IMethod)method) {  						Arguments = { left' right }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertMemberInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewArrayBounds,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewArrayInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args2 = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args2.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args2);  					return (newObj' member.DeclaringType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args2 = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args2.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args2);  					return (newObj' member.DeclaringType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNotOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					return (argumentType.IsKnownType(KnownTypeCode.Boolean) ? Comp.LogicNot(argument) : (ILInstruction)new BitNot(argument)' argumentType);  				case 2:  					if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { argument }  					}' method.ReturnType);  				default:  					return (null' SpecialType.UnknownType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  				arguments = new List<ILInstruction>();  			} else {  				for (int i = 0; i < arguments.Count; i++) {  					arguments[i] = ConvertInstruction(arguments[i]).Item1;  					if (arguments[i] == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertProperty,The following statement contains a magic number: if (invocation.Arguments.Count != 3 || !MatchArgumentList(invocation.Arguments[2]' out arguments)) {  				arguments = new List<ILInstruction>();  			} else {  				for (int i = 0; i < arguments.Count; i++) {  					arguments[i] = ConvertInstruction(arguments[i]).Item1;  					if (arguments[i] == null)  						return (null' SpecialType.UnknownType);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertTypeAs,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertTypeIs,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  				return (null' SpecialType.UnknownType);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertUnaryNumericOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					ILInstruction left;  					switch (argument.ResultType) {  						case StackType.I4:  							left = new LdcI4(0);  							break;  						case StackType.I8:  							left = new LdcI8(0);  							break;  						case StackType.I:  							left = new Conv(new LdcI4(0)' PrimitiveType.I' false' Sign.None);  							break;  						case StackType.F4:  							left = new LdcF4(0);  							break;  						case StackType.F8:  							left = new LdcF8(0);  							break;  						default:  							return (null' SpecialType.UnknownType);  					}  					return (new BinaryNumericInstruction(op' left' argument' isChecked == true' argumentType.GetSign())' argumentType);  				case 2:  					if (!MatchGetMethodFromHandle(invocation.Arguments[1]' out var method))  						return (null' SpecialType.UnknownType);  					return (new Call((IMethod)method) {  						Arguments = { argument }  					}' method.ReturnType);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchConstantCall,The following statement contains a magic number: if (inst is CallInstruction call && call.Method.FullName == "System.Linq.Expressions.Expression.Constant") {  				value = call.Arguments[0];  				if (call.Arguments.Count == 2)  					return MatchGetTypeFromHandle(call.Arguments[1]' out type);  				type = value.InferType();  				return true;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetMethodFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetConstructorFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetFieldFromHandle,The following statement contains a magic number: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: if (entryPoint.Instructions.Count < 2 || entryPoint.Instructions.Count > 3 || entryPoint.IncomingEdgeCount != 1)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: if (entryPoint.Instructions.Count < 2 || entryPoint.Instructions.Count > 3 || entryPoint.IncomingEdgeCount != 1)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int leaveIndex = entryPoint.Instructions.Count == 2 ? 1 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int leaveIndex = entryPoint.Instructions.Count == 2 ? 1 : 2;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int checkIndex = entryPoint.Instructions.Count == 2 ? 0 : 1;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: int castIndex = entryPoint.Instructions.Count == 3 ? 0 : -1;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,UsingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\UsingTransform.cs,MatchDisposeBlock,The following statement contains a magic number: if (castIndex > -1) {  				if (!entryPoint.Instructions[castIndex].MatchStLoc(out var tempVar' out var isinst))  					return false;  				if (!isinst.MatchIsInst(out var load' out var disposableType) || !load.MatchLdLoc(objVar) || !disposableType.IsKnownType(KnownTypeCode.IDisposable))  					return false;  				if (tempVar.StoreCount != 1 || tempVar.LoadCount != 2)  					return false;  				objVar = tempVar;  				isReference = true;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following statement contains a magic number: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = m.Parameters.ElementAtOrDefault((!(call is NewObj) && !m.IsStatic) ? i - 1 : i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = m.Parameters.ElementAtOrDefault((!(call is NewObj) && !m.IsStatic) ? i - 1 : i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = m.Parameters.ElementAtOrDefault((!(call is NewObj) && !m.IsStatic) ? i - 1 : i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following statement contains a magic number: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = m.Parameters.ElementAtOrDefault((!(call is NewObj) && !m.IsStatic) ? i - 1 : i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameByType,The following statement contains a magic number: if (type is ArrayType) {  				name = "array";  			} else if (type is PointerType) {  				name = "ptr";  			} else if (type.Kind == TypeKind.TypeParameter || type.Kind == TypeKind.Unknown) {  				name = "val";  			} else if (type.Kind == TypeKind.ByReference) {  				name = "reference";  			} else if (type.IsAnonymousType()) {  				name = "anon";  			} else if (type.Name.EndsWith("Exception"' StringComparison.Ordinal)) {  				name = "ex";  			} else if (!typeNameToVariableNameDict.TryGetValue(type.FullName' out name)) {  				name = type.Name;  				// remove the 'I' for interfaces  				if (name.Length >= 3 && name[0] == 'I' && char.IsUpper(name[1]) && char.IsLower(name[2]))  					name = name.Substring(1);  				name = CleanUpVariableName(name);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameByType,The following statement contains a magic number: if (type is ArrayType) {  				name = "array";  			} else if (type is PointerType) {  				name = "ptr";  			} else if (type.Kind == TypeKind.TypeParameter || type.Kind == TypeKind.Unknown) {  				name = "val";  			} else if (type.Kind == TypeKind.ByReference) {  				name = "reference";  			} else if (type.IsAnonymousType()) {  				name = "anon";  			} else if (type.Name.EndsWith("Exception"' StringComparison.Ordinal)) {  				name = "ex";  			} else if (!typeNameToVariableNameDict.TryGetValue(type.FullName' out name)) {  				name = type.Name;  				// remove the 'I' for interfaces  				if (name.Length >= 3 && name[0] == 'I' && char.IsUpper(name[1]) && char.IsLower(name[2]))  					name = name.Substring(1);  				name = CleanUpVariableName(name);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The following statement contains a magic number: if (name.Length > 2 && name.StartsWith("m_"' StringComparison.Ordinal))  				name = name.Substring(2);  			else if (name.Length > 1 && name[0] == '_' && (char.IsLetter(name[1]) || name[1] == '_'))  				name = name.Substring(1);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,CleanUpVariableName,The following statement contains a magic number: if (name.Length > 2 && name.StartsWith("m_"' StringComparison.Ordinal))  				name = name.Substring(2);  			else if (name.Length > 1 && name[0] == '_' && (char.IsLetter(name[1]) || name[1] == '_'))  				name = name.Substring(1);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateForeachVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					} else {  						proposedName = baseName;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					} else {  						proposedName = baseName;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GenerateVariableName,The following statement contains a magic number: if (!string.IsNullOrEmpty(baseName)) {  				if (!IsPlural(baseName' ref proposedName)) {  					if (baseName.Length > 4 && baseName.EndsWith("List"' StringComparison.Ordinal)) {  						proposedName = baseName.Substring(0' baseName.Length - 4);  					} else if (baseName.Equals("list"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = "item";  					} else if (baseName.EndsWith("children"' StringComparison.OrdinalIgnoreCase)) {  						proposedName = baseName.Remove(baseName.Length - 3);  					} else {  						proposedName = baseName;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The following statement contains a magic number: foreach (var catchBlock in function.Descendants.OfType<TryCatchHandler>()) {  				if (catchBlock.Filter is BlockContainer container && MatchCatchWhenEntryPoint(container' container.EntryPoint' out var exceptionType' out var exceptionSlot' out var whenConditionBlock)) {  					// set exceptionType  					catchBlock.Variable.Type = exceptionType;  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(isinst exceptionType(ldloc exceptionVar))  					//   if (comp(ldloc temp != ldnull)) br whenConditionBlock  					//   br falseBlock  					// }  					// =>  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(ldloc exceptionSlot)    					//   br whenConditionBlock  					// }  					var instructions = container.EntryPoint.Instructions;  					if (instructions.Count == 3) {  						// stloc temp(isinst exceptionType(ldloc exceptionVar))  						// if (comp(ldloc temp != ldnull)) br whenConditionBlock  						// br falseBlock  						((StLoc)instructions[0]).Value = exceptionSlot;  						instructions[1].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(2);  						container.SortBlocks(deleteUnreachableBlocks: true);  					} else if (instructions.Count == 2) {  						// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  						// br falseBlock  						instructions[0].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(1);  						container.SortBlocks(deleteUnreachableBlocks: true);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The following statement contains a magic number: foreach (var catchBlock in function.Descendants.OfType<TryCatchHandler>()) {  				if (catchBlock.Filter is BlockContainer container && MatchCatchWhenEntryPoint(container' container.EntryPoint' out var exceptionType' out var exceptionSlot' out var whenConditionBlock)) {  					// set exceptionType  					catchBlock.Variable.Type = exceptionType;  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(isinst exceptionType(ldloc exceptionVar))  					//   if (comp(ldloc temp != ldnull)) br whenConditionBlock  					//   br falseBlock  					// }  					// =>  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(ldloc exceptionSlot)    					//   br whenConditionBlock  					// }  					var instructions = container.EntryPoint.Instructions;  					if (instructions.Count == 3) {  						// stloc temp(isinst exceptionType(ldloc exceptionVar))  						// if (comp(ldloc temp != ldnull)) br whenConditionBlock  						// br falseBlock  						((StLoc)instructions[0]).Value = exceptionSlot;  						instructions[1].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(2);  						container.SortBlocks(deleteUnreachableBlocks: true);  					} else if (instructions.Count == 2) {  						// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  						// br falseBlock  						instructions[0].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(1);  						container.SortBlocks(deleteUnreachableBlocks: true);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,Run,The following statement contains a magic number: foreach (var catchBlock in function.Descendants.OfType<TryCatchHandler>()) {  				if (catchBlock.Filter is BlockContainer container && MatchCatchWhenEntryPoint(container' container.EntryPoint' out var exceptionType' out var exceptionSlot' out var whenConditionBlock)) {  					// set exceptionType  					catchBlock.Variable.Type = exceptionType;  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(isinst exceptionType(ldloc exceptionVar))  					//   if (comp(ldloc temp != ldnull)) br whenConditionBlock  					//   br falseBlock  					// }  					// =>  					// Block entryPoint (incoming: 1)  {  					//   stloc temp(ldloc exceptionSlot)    					//   br whenConditionBlock  					// }  					var instructions = container.EntryPoint.Instructions;  					if (instructions.Count == 3) {  						// stloc temp(isinst exceptionType(ldloc exceptionVar))  						// if (comp(ldloc temp != ldnull)) br whenConditionBlock  						// br falseBlock  						((StLoc)instructions[0]).Value = exceptionSlot;  						instructions[1].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(2);  						container.SortBlocks(deleteUnreachableBlocks: true);  					} else if (instructions.Count == 2) {  						// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  						// br falseBlock  						instructions[0].ReplaceWith(new Branch(whenConditionBlock));  						instructions.RemoveAt(1);  						container.SortBlocks(deleteUnreachableBlocks: true);  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The following statement contains a magic number: if (entryPoint.Instructions.Count == 3) {  				// stloc temp(isinst exceptionType(ldloc exceptionVar))  				// if (comp(ldloc temp != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchStLoc(out var temp' out var isinst) ||  					temp.Kind != VariableKind.StackSlot || !isinst.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (!entryPoint.Instructions[1].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if ((left.MatchLdNull() && right.MatchLdLoc(temp)) || (right.MatchLdNull() && left.MatchLdLoc(temp))) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			} else if (entryPoint.Instructions.Count == 2) {  				// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[1].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if (!left.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (right.MatchLdNull()) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The following statement contains a magic number: if (entryPoint.Instructions.Count == 3) {  				// stloc temp(isinst exceptionType(ldloc exceptionVar))  				// if (comp(ldloc temp != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchStLoc(out var temp' out var isinst) ||  					temp.Kind != VariableKind.StackSlot || !isinst.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (!entryPoint.Instructions[1].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if ((left.MatchLdNull() && right.MatchLdLoc(temp)) || (right.MatchLdNull() && left.MatchLdLoc(temp))) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			} else if (entryPoint.Instructions.Count == 2) {  				// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[1].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if (!left.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (right.MatchLdNull()) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchCatchWhenEntryPoint,The following statement contains a magic number: if (entryPoint.Instructions.Count == 3) {  				// stloc temp(isinst exceptionType(ldloc exceptionVar))  				// if (comp(ldloc temp != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchStLoc(out var temp' out var isinst) ||  					temp.Kind != VariableKind.StackSlot || !isinst.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (!entryPoint.Instructions[1].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[2].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if ((left.MatchLdNull() && right.MatchLdLoc(temp)) || (right.MatchLdNull() && left.MatchLdLoc(temp))) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			} else if (entryPoint.Instructions.Count == 2) {  				// if (comp(isinst exceptionType(ldloc exceptionVar) != ldnull)) br whenConditionBlock  				// br falseBlock  				if (!entryPoint.Instructions[0].MatchIfInstruction(out var condition' out var branch))  					return false;  				if (!condition.MatchCompNotEquals(out var left' out var right))  					return false;  				if (!entryPoint.Instructions[1].MatchBranch(out var falseBlock) || !MatchFalseBlock(container' falseBlock' out var returnVar' out var exitBlock))  					return false;  				if (!left.MatchIsInst(out exceptionSlot' out exceptionType))  					return false;  				if (!exceptionSlot.MatchLdLoc(out var exceptionVar) || exceptionVar.Kind != VariableKind.Exception)  					return false;  				if (right.MatchLdNull()) {  					return branch.MatchBranch(out whenConditionBlock);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchFalseBlock,The following statement contains a magic number: if (falseBlock.IncomingEdgeCount != 1 || falseBlock.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DetectCatchWhenConditionBlocks,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DetectCatchWhenConditionBlocks.cs,MatchExitBlock,The following statement contains a magic number: if (exitBlock.IncomingEdgeCount != 2 || exitBlock.Instructions.Count != 1)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: if (i < 2) return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: if (!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 2] is StLoc objectStore) ||  				!objectStore.Value.MatchLdLoc(out var tempVar) || !MatchCall(block.Instructions[i - 1] as Call' "Enter"' tempVar))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockV2,The following statement contains a magic number: block.Instructions.RemoveAt(i - 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: if (i < 2) return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: if (!(block.Instructions[i] is TryFinally body) || !(block.Instructions[i - 1] is StLoc flagStore) || !(block.Instructions[i - 2] is StLoc objectStore))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: if (objectStore.Variable.LoadCount > 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,TransformLockRoslyn,The following statement contains a magic number: block.Instructions.RemoveAt(i - 2);
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchExitBlock,The following statement contains a magic number: if (entryPoint.Instructions.Count != 2 || entryPoint.IncomingEdgeCount != 1)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The following statement contains a magic number: if (call == null || call.Method.Name != methodName || call.Method.DeclaringType.FullName != ThreadingMonitor ||  				call.Method.TypeArguments.Count != 0 || call.Arguments.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,LockTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\LockTransform.cs,MatchCall,The following statement contains a magic number: if (variables.Length == 2) {  				if (!call.Arguments[1].MatchLdLoca(variables[1]))  					return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,RunStatements,The following statement contains a magic number: if (pos != block.Instructions.Count - 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,MatchCompOrDecimal,The following statement contains a magic number: if (inst is Comp comp && !comp.IsLifted) {  				result.Kind = comp.Kind;  				result.Left = comp.Left;  				result.Right = comp.Right;  				return true;  			} else if (inst is Call call && call.Method.IsOperator && call.Arguments.Count == 2 && !call.IsLifted) {  				switch (call.Method.Name) {  					case "op_Equality":  						result.Kind = ComparisonKind.Equality;  						break;  					case "op_Inequality":  						result.Kind = ComparisonKind.Inequality;  						break;  					case "op_LessThan":  						result.Kind = ComparisonKind.LessThan;  						break;  					case "op_LessThanOrEqual":  						result.Kind = ComparisonKind.LessThanOrEqual;  						break;  					case "op_GreaterThan":  						result.Kind = ComparisonKind.GreaterThan;  						break;  					case "op_GreaterThanOrEqual":  						result.Kind = ComparisonKind.GreaterThanOrEqual;  						break;  					default:  						return false;  				}  				result.Left = call.Arguments[0];  				result.Right = call.Arguments[1];  				return call.Method.DeclaringType.IsKnownType(KnownTypeCode.Decimal);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,LiftCSharpUserEqualityComparison,The following statement contains a magic number: if (!(call.Method.IsOperator && call.Arguments.Count == 2))  				return null;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,NullableLiftingTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\NullableLiftingTransform.cs,DoLift,The following statement contains a magic number: if (MatchGetValueOrDefault(inst' out ILVariable inputVar)) {  				// n.GetValueOrDefault() lifted => n.  				BitSet foundIndices = new BitSet(nullableVars.Count);  				for (int i = 0; i < nullableVars.Count; i++) {  					if (nullableVars[i] == inputVar) {  						foundIndices[i] = true;  					}  				}  				if (foundIndices.Any())  					return (new LdLoc(inputVar) { ILRange = inst.ILRange }' foundIndices);  				else  					return (null' null);  			} else if (inst is Conv conv) {  				var (arg' bits) = DoLift(conv.Argument);  				if (arg != null) {  					if (conv.HasDirectFlag(InstructionFlags.MayThrow) && !bits.All(0' nullableVars.Count)) {  						// Cannot execute potentially-throwing instruction unless all  						// the nullableVars are arguments to the instruction  						// (thus causing it not to throw when any of them is null).  						return (null' null);  					}  					var newInst = new Conv(arg' conv.InputType' conv.InputSign' conv.TargetType' conv.CheckForOverflow' isLifted: true) {  						ILRange = conv.ILRange  					};  					return (newInst' bits);  				}  			} else if (inst is BitNot bitnot) {  				var (arg' bits) = DoLift(bitnot.Argument);  				if (arg != null) {  					var newInst = new BitNot(arg' isLifted: true' stackType: bitnot.ResultType) {  						ILRange = bitnot.ILRange  					};  					return (newInst' bits);  				}  			} else if (inst is BinaryNumericInstruction binary) {  				var (left' right' bits) = DoLiftBinary(binary.Left' binary.Right' SpecialType.UnknownType' SpecialType.UnknownType);  				if (left != null && right != null) {  					if (binary.HasDirectFlag(InstructionFlags.MayThrow) && !bits.All(0' nullableVars.Count)) {  						// Cannot execute potentially-throwing instruction unless all  						// the nullableVars are arguments to the instruction  						// (thus causing it not to throw when any of them is null).  						return (null' null);  					}  					var newInst = new BinaryNumericInstruction(  						binary.Operator' left' right'  						binary.LeftInputType' binary.RightInputType'  						binary.CheckForOverflow' binary.Sign'  						isLifted: true  					) {  						ILRange = binary.ILRange  					};  					return (newInst' bits);  				}  			} else if (inst is Comp comp && !comp.IsLifted && comp.Kind == ComparisonKind.Equality  				&& MatchGetValueOrDefault(comp.Left' out ILVariable v)  				&& NullableType.GetUnderlyingType(v.Type).IsKnownType(KnownTypeCode.Boolean)  				&& comp.Right.MatchLdcI4(0)  			) {  				// C# doesn't support ComparisonLiftingKind.ThreeValuedLogic'  				// except for operator! on bool?.  				var (arg' bits) = DoLift(comp.Left);  				Debug.Assert(arg != null);  				var newInst = new Comp(comp.Kind' ComparisonLiftingKind.ThreeValuedLogic' comp.InputType' comp.Sign' arg' comp.Right.Clone()) {  					ILRange = comp.ILRange  				};  				return (newInst' bits);  			} else if (inst is Call call && call.Method.IsOperator) {  				// Lifted user-defined operators' except for comparison operators (as those return bool' not bool?)  				var liftedOperator = CSharp.Resolver.CSharpOperators.LiftUserDefinedOperator(call.Method);  				if (liftedOperator == null || !NullableType.IsNullable(liftedOperator.ReturnType))  					return (null' null);  				ILInstruction[] newArgs;  				BitSet newBits;  				if (call.Arguments.Count == 1) {  					var (arg' bits) = DoLift(call.Arguments[0]);  					newArgs = new[] { arg };  					newBits = bits;  				} else if (call.Arguments.Count == 2) {  					var (left' right' bits) = DoLiftBinary(call.Arguments[0]' call.Arguments[1]'  						call.Method.Parameters[0].Type' call.Method.Parameters[1].Type);  					newArgs = new[] { left' right };  					newBits = bits;  				} else {  					return (null' null);  				}  				if (newBits == null || !newBits.All(0' nullableVars.Count)) {  					// all nullable vars must be involved when calling a method (side effect)  					return (null' null);  				}  				var newInst = new Call(liftedOperator) {  					ConstrainedTo = call.ConstrainedTo'  					IsTail = call.IsTail'  					ILStackWasEmpty = call.ILStackWasEmpty'  					ILRange = call.ILRange  				};  				newInst.Arguments.AddRange(newArgs);  				return (newInst' newBits);  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetAccessPath,The following statement contains a magic number: while (instruction != null) {  				switch (instruction) {  					case CallInstruction call:  						if (!(call is CallVirt || call is Call)) goto default;  						method = call.Method;  						if (!IsMethodApplicable(method' call.Arguments' rootType)) goto default;  						instruction = call.Arguments[0];  						if (method.IsAccessor) {  							var property = method.AccessorOwner as IProperty;  							var isGetter = property?.Getter == method;  							var indices = call.Arguments.Skip(1).Take(call.Arguments.Count - (isGetter ? 1 : 2)).ToArray();  							if (possibleIndexVariables != null) {  								// Mark all index variables as used  								foreach (var index in indices.OfType<IInstructionWithVariableOperand>()) {  									if (possibleIndexVariables.TryGetValue(index.Variable' out var info))  										possibleIndexVariables[index.Variable] = (-1' info.Value);  								}  							}  							path.Insert(0' new AccessPathElement(method.AccessorOwner' indices));  						} else {  							path.Insert(0' new AccessPathElement(method));  						}  						if (values == null) {  							if (method.IsAccessor) {  								kind = AccessPathKind.Setter;  								values = new List<ILInstruction> { call.Arguments.Last() };  							} else {  								kind = AccessPathKind.Adder;  								values = new List<ILInstruction>(call.Arguments.Skip(1));  								if (values.Count == 0)  									goto default;  							}  						}  						break;  					case LdObj ldobj: {  						if (ldobj.Target is LdFlda ldflda) {  							path.Insert(0' new AccessPathElement(ldflda.Field));  							instruction = ldflda.Target;  							break;  						}  						goto default;  					}  					case StObj stobj: {  						if (stobj.Target is LdFlda ldflda) {  							path.Insert(0' new AccessPathElement(ldflda.Field));  							instruction = ldflda.Target;  							if (values == null) {  								values = new List<ILInstruction>(new[] { stobj.Value });  								kind = AccessPathKind.Setter;  							}  							break;  						}  						goto default;  					}  					case LdLoc ldloc:  						target = ldloc.Variable;  						instruction = null;  						break;  					case LdLoca ldloca:  						target = ldloca.Variable;  						instruction = null;  						break;  					case LdFlda ldflda:  						path.Insert(0' new AccessPathElement(ldflda.Field));  						instruction = ldflda.Target;  						break;  					default:  						kind = AccessPathKind.Invalid;  						instruction = null;  						break;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,AccessPathElement,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (Member != null)  					hashCode += 1000000007 * Member.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,CachedDelegateInitialization,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\CachedDelegateInitialization.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (v.StoreCount != 2 || v.StoreInstructions.Count != 2 || v.LoadCount != 2 || v.AddressCount != 0)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  				int val;  				if (args[0].MatchLdcI4(out val)) {  					result = new LdcDecimal(val);  					return true;  				}  			} else if (args.Count == 5) {  				int lo' mid' hi' isNegative' scale;  				if (args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale))  				{  					result = new LdcDecimal(new decimal(lo' mid' hi' isNegative != 0' (byte)scale));  					return true;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  				int val;  				if (args[0].MatchLdcI4(out val)) {  					result = new LdcDecimal(val);  					return true;  				}  			} else if (args.Count == 5) {  				int lo' mid' hi' isNegative' scale;  				if (args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale))  				{  					result = new LdcDecimal(new decimal(lo' mid' hi' isNegative != 0' (byte)scale));  					return true;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  				int val;  				if (args[0].MatchLdcI4(out val)) {  					result = new LdcDecimal(val);  					return true;  				}  			} else if (args.Count == 5) {  				int lo' mid' hi' isNegative' scale;  				if (args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale))  				{  					result = new LdcDecimal(new decimal(lo' mid' hi' isNegative != 0' (byte)scale));  					return true;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  				int val;  				if (args[0].MatchLdcI4(out val)) {  					result = new LdcDecimal(val);  					return true;  				}  			} else if (args.Count == 5) {  				int lo' mid' hi' isNegative' scale;  				if (args[0].MatchLdcI4(out lo) && args[1].MatchLdcI4(out mid) &&  				    args[2].MatchLdcI4(out hi) && args[3].MatchLdcI4(out isNegative) &&  				    args[4].MatchLdcI4(out scale))  				{  					result = new LdcDecimal(new decimal(lo' mid' hi' isNegative != 0' (byte)scale));  					return true;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following statement contains a magic number: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following statement contains a magic number: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,DelegateConstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\DelegateConstruction.cs,IsDelegateConstruction,The following statement contains a magic number: if (inst == null || inst.Arguments.Count != 2 || inst.Method.DeclaringType.Kind != TypeKind.Delegate)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransform,The following statement contains a magic number: if (pos >= body.Instructions.Count - 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The following statement contains a magic number: for (int i = 0; i < length; i++) {  				// 1. Instruction: (optional) temporary copy of store  				bool hasTemporaryCopy = block.Instructions[pos].MatchStLoc(out ILVariable temp' out ILInstruction storeLoad) && storeLoad.MatchLdLoc(store);  				if (hasTemporaryCopy) {  					if (!MatchJaggedArrayStore(block' pos + 1' temp' i' out initializer' out type))  						return false;  				} else {  					if (!MatchJaggedArrayStore(block' pos' store' i' out initializer' out type))  						return false;  				}  				values[i] = initializer;  				int inc = hasTemporaryCopy ? 3 : 2;  				pos += inc;  				instructionsToRemove += inc;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,HandleJaggedArrayInitializer,The following statement contains a magic number: for (int i = 0; i < length; i++) {  				// 1. Instruction: (optional) temporary copy of store  				bool hasTemporaryCopy = block.Instructions[pos].MatchStLoc(out ILVariable temp' out ILInstruction storeLoad) && storeLoad.MatchLdLoc(store);  				if (hasTemporaryCopy) {  					if (!MatchJaggedArrayStore(block' pos + 1' temp' i' out initializer' out type))  						return false;  				} else {  					if (!MatchJaggedArrayStore(block' pos' store' i' out initializer' out type))  						return false;  				}  				values[i] = initializer;  				int inc = hasTemporaryCopy ? 3 : 2;  				pos += inc;  				instructionsToRemove += inc;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,DoTransformMultiDim,The following statement contains a magic number: if (pos >= body.Instructions.Count - 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,MatchInitializeArrayCall,The following statement contains a magic number: if (call == null || call.Arguments.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformArrayInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformArrayInitializers.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException(nameof(elementType));  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,The following statement contains a magic number: if (block.Instructions[pos + 1] is StLoc localStore) { // with extra local  				if (localStore.Variable.Kind != VariableKind.Local || !localStore.Value.MatchLdLoc(inst.Variable))  					return false;  				// if we're using an extra local' we'll delete "s"' so check that that doesn't have any additional uses  				if (!(inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 2))  					return false;  				local = localStore.Variable;  				nextPos = pos + 2;  			} else {  				local = inst.Variable;  				localStore = null;  				nextPos = pos + 1;  			}
Magic Number,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,TransformInlineAssignmentStObjOrCall,The following statement contains a magic number: if (block.Instructions[pos + 1] is StLoc localStore) { // with extra local  				if (localStore.Variable.Kind != VariableKind.Local || !localStore.Value.MatchLdLoc(inst.Variable))  					return false;  				// if we're using an extra local' we'll delete "s"' so check that that doesn't have any additional uses  				if (!(inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 2))  					return false;  				local = localStore.Variable;  				nextPos = pos + 2;  			} else {  				local = inst.Variable;  				localStore = null;  				nextPos = pos + 1;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (body.Count < 5)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!(body[body.Count - 2] is Call startCall))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (startCall.Arguments.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!body[body.Count - 3].MatchStLoc(builderVar' out var loadBuilderExpr))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!MatchStFld(body[body.Count - 4]' stateMachineVar' out stateField' out var initialStateExpr))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!MatchStFld(body[body.Count - 5]' stateMachineVar' out var builderField3' out var builderInitialization))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: for (; pos < body.Count - 5; pos++) {  				// stfld StateMachine.field(ldloca stateMachine' ldvar(param))  				if (!MatchStFld(body[pos]' stateMachineVar' out var field' out var fieldInit))  					return false;  				if (!fieldInit.MatchLdLoc(out var v))  					return false;  				if (v.Kind != VariableKind.Parameter)  					return false;  				fieldToParameterMap[field] = v;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (blockContainer.Blocks.Count != 2)  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (setResultAndExitBlock.Instructions.Count != 3)  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (methodType == AsyncMethodType.TaskOfT) {  				if (args.Count != 2)  					throw new SymbolicAnalysisFailedException();  				if (!args[1].MatchLdLoc(out resultVar))  					throw new SymbolicAnalysisFailedException();  			} else {  				resultVar = null;  				if (args.Count != 1)  					throw new SymbolicAnalysisFailedException();  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (!setResultAndExitBlock.Instructions[2].MatchLeave(blockContainer))  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (catchBlock?.Instructions.Count != 4)  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (!MatchCall(catchBlock.Instructions[2]' "SetException"' out var args))  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (args.Count != 2)  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (!catchBlock.Instructions[3].MatchLeave((BlockContainer)moveNextFunction.Body))  				throw new SymbolicAnalysisFailedException();
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: int pos = block.Instructions.Count - 2;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: if (callArgs.Count != 3)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: if (callArgs[2].MatchLdThis()) {  				// OK (if state machine is a struct)  				pos--;  			} else if (callArgs[2].MatchLdLoca(out var tempVar)) {  				// Roslyn' non-optimized uses a class for the state machine.  				// stloc tempVar(ldloc this)  				// call AwaitUnsafeOnCompleted(ldflda <>t__builder](ldloc this)' ldloca awaiter' ldloca tempVar)  				if (!(pos > 0 && block.Instructions[pos - 1].MatchStLoc(tempVar' out var tempVal)))  					return false;  				if (!tempVal.MatchLdThis())  					return false;  				pos -= 2;  			} else {  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: if (callArgs[2].MatchLdThis()) {  				// OK (if state machine is a struct)  				pos--;  			} else if (callArgs[2].MatchLdLoca(out var tempVar)) {  				// Roslyn' non-optimized uses a class for the state machine.  				// stloc tempVar(ldloc this)  				// call AwaitUnsafeOnCompleted(ldflda <>t__builder](ldloc this)' ldloca awaiter' ldloca tempVar)  				if (!(pos > 0 && block.Instructions[pos - 1].MatchStLoc(tempVar' out var tempVal)))  					return false;  				if (!tempVal.MatchLdThis())  					return false;  				pos -= 2;  			} else {  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,AnalyzeAwaitBlock,The following statement contains a magic number: if (callArgs[2].MatchLdThis()) {  				// OK (if state machine is a struct)  				pos--;  			} else if (callArgs[2].MatchLdLoca(out var tempVar)) {  				// Roslyn' non-optimized uses a class for the state machine.  				// stloc tempVar(ldloc this)  				// call AwaitUnsafeOnCompleted(ldflda <>t__builder](ldloc this)' ldloca awaiter' ldloca tempVar)  				if (!(pos > 0 && block.Instructions[pos - 1].MatchStLoc(tempVar' out var tempVal)))  					return false;  				if (!tempVal.MatchLdThis())  					return false;  				pos -= 2;  			} else {  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: if (block.Instructions.Count < 3)  				return;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: if (!(block.Instructions[block.Instructions.Count - 3] is StLoc stLocAwaiter))  				return;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: if (!block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst))  				return;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: block.Instructions.RemoveAt(block.Instructions.Count - 3);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,DetectAwaitPattern,The following statement contains a magic number: block.Instructions.RemoveAt(block.Instructions.Count - 2);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckAwaitBlock,The following statement contains a magic number: if (block.Instructions.Count < 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckAwaitBlock,The following statement contains a magic number: if (block.Instructions[pos] is StLoc stloc && stloc.Variable.IsSingleDefinition) {  				if (!block.Instructions[pos + 1].MatchStFld(out var target' out stackField' out var value))  					return false;  				if (!target.MatchLdThis())  					return false;  				pos += 2;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,AsyncAwaitDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\AsyncAwaitDecompiler.cs,CheckResumeBlock,The following statement contains a magic number: if (block.Instructions[pos].MatchStFld(out target' out field' out value)  				&& target.MatchLdThis()  				&& field.Equals(awaiterField)  				&& value.OpCode == OpCode.DefaultValue)  			{  				pos++;  			} else {  				// {stloc V_6(default.value System.Runtime.CompilerServices.TaskAwaiter)}  				// {stobj System.Runtime.CompilerServices.TaskAwaiter`1[[System.Int32]](ldflda <>u__$awaiter4(ldloc this)' ldloc V_6) at IL_0163}  				if (block.Instructions[pos].MatchStLoc(out var variable' out value) && value.OpCode == OpCode.DefaultValue  					&& block.Instructions[pos + 1].MatchStFld(out target' out field' out value)  					&& field.Equals(awaiterField)  					&& value.MatchLdLoc(variable)) {  					pos += 2;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,The following statement contains a magic number: if (isCompiledWithMono) {  				// Mono initializes the state field separately:  				// (but not if it's left at the default value 0)  				if (body.Instructions[pos].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdLoc(var2 ?? var1)  					&& (value.MatchLdcI4(-2) || value.MatchLdcI4(0)))  				{  					stateField = (IField)field.MemberDefinition;  					isCompiledWithMono = true;  					pos++;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,MatchEnumeratorCreationNewObj,The following statement contains a magic number: if (!(initialState == -2 || initialState == 0))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The following statement contains a magic number: if (body.Instructions.Count == 1) {  				// release builds directly return the current field  				// ret(ldfld F(ldloc(this)))  				if (body.Instructions[0].MatchReturn(out var retVal)  					&& retVal.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis()) {  					currentField = (IField)field.MemberDefinition;  				}  			} else if (body.Instructions.Count == 2) {  				// debug builds store the return value in a temporary  				// stloc V = ldfld F(ldloc(this))  				// ret(ldloc V)  				if (body.Instructions[0].MatchStLoc(out var v' out var ldfld)  					&& ldfld.MatchLdFld(out var target' out var field)  					&& target.MatchLdThis()  					&& body.Instructions[1].MatchReturn(out var retVal)  					&& retVal.MatchLdLoc(v)) {  					currentField = (IField)field.MemberDefinition;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (body.Blocks.Count == 1 && body.Blocks[0].Instructions.Count == 1 && body.Blocks[0].Instructions[0] is TryFault tryFault) {  				body = (BlockContainer)tryFault.TryBlock;  				var faultBlockContainer = tryFault.FaultBlock as BlockContainer;  				if (faultBlockContainer?.Blocks.Count != 1)  					throw new SymbolicAnalysisFailedException("Unexpected number of blocks in MoveNext() fault block");  				var faultBlock = faultBlockContainer.Blocks.Single();  				if (!(faultBlock.Instructions.Count == 2  					&& faultBlock.Instructions[0] is Call call  					&& context.TypeSystem.GetCecil(call.Method) == disposeMethod  					&& call.Arguments.Count == 1  					&& call.Arguments[0].MatchLdThis()  					&& faultBlock.Instructions[1].MatchLeave(faultBlockContainer))) {  					throw new SymbolicAnalysisFailedException("Unexpected fault block contents in MoveNext()");  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (isCompiledWithMono) {  				// Mono uses skipFinallyBodies; find out which variable that is:  				foreach (var tryFinally in body.Descendants.OfType<TryFinally>()) {  					if ((tryFinally.FinallyBlock as BlockContainer)?.EntryPoint.Instructions[0] is IfInstruction ifInst) {  						if (ifInst.Condition.MatchLogicNot(out var arg) && arg.MatchLdLoc(out var v) && v.Type.IsKnownType(KnownTypeCode.Boolean)) {  							bool isInitializedInEntryBlock = false;  							for (int i = 0; i < 3; i++) {  								if (body.EntryPoint.Instructions.ElementAtOrDefault(i) is StLoc stloc  									&& stloc.Variable == v && stloc.Value.MatchLdcI4(0))  								{  									isInitializedInEntryBlock = true;  									break;  								}  							}  							if (isInitializedInEntryBlock) {  								skipFinallyBodies = v;  								break;  							}  						}  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The following statement contains a magic number: void ConvertBranchAfterYieldReturn(Block newBlock' Block oldBlock' int i)  			{  				if (!(oldBlock.Instructions[i + 1].MatchStFld(out var target' out var field' out var value)  					&& target.MatchLdThis()  					&& field.MemberDefinition == stateField  					&& value.MatchLdcI4(out int newState))) {  					newBlock.Instructions.Add(new InvalidBranch("Unable to find new state assignment for yield return"));  					return;  				}  				int pos = i + 2;  				if (oldBlock.Instructions[pos].MatchStLoc(skipFinallyBodies' out value)) {  					if (!value.MatchLdcI4(1)) {  						newBlock.Instructions.Add(new InvalidExpression {  							ExpectedResultType = StackType.Void'  							Message = "Unexpected assignment to skipFinallyBodies"  						});  					}  					pos++;  				}  				if (oldBlock.Instructions[pos].MatchReturn(out var retVal) && retVal.MatchLdcI4(1)) {  					// OK' found return directly after state assignment  				} else if (oldBlock.Instructions[pos].MatchBranch(out var targetBlock)   					&& targetBlock.Instructions[0].MatchReturn(out retVal) && retVal.MatchLdcI4(1)) {  					// OK' jump to common return block (e.g. on Mono)  				} else {  					newBlock.Instructions.Add(new InvalidBranch("Unable to find 'return true' for yield return"));  					return;  				}  				newBlock.Instructions.Add(MakeGoTo(newState));  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,InlineVariableInReturnBlock,The following statement contains a magic number: if (block.Instructions.Count == 2 && block.Instructions[1].MatchReturn(out ILInstruction value)) {  				var ret = (Leave)block.Instructions[1];  				if (value.MatchLdLoc(out ILVariable v)  					&& v.IsSingleDefinition && v.LoadCount == 1 && block.Instructions[0].MatchStLoc(v' out ILInstruction inst)) {  					context.Step("Inline variable in return block"' block);  					inst.AddILRange(ret.Value.ILRange);  					inst.AddILRange(block.Instructions[0].ILRange);  					ret.Value = inst;  					block.Instructions.RemoveAt(0);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: if (block.Instructions.Count > 1 && block.Instructions[block.Instructions.Count - 2].HasFlag(InstructionFlags.MayBranch))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: if (targetBlock.ILRange.Start < block.ILRange.Start && IsDeadTrueStore(block)) {  				// The C# compiler generates a dead store for the condition of while (true) loops.  				block.Instructions.RemoveRange(block.Instructions.Count - 3' 2);  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,CombineBlockWithNextBlock,The following statement contains a magic number: if (targetBlock.ILRange.Start < block.ILRange.Start && IsDeadTrueStore(block)) {  				// The C# compiler generates a dead store for the condition of while (true) loops.  				block.Instructions.RemoveRange(block.Instructions.Count - 3' 2);  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The following statement contains a magic number: if (block.Instructions.Count < 3) return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,ControlFlowSimplification,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\ControlFlowSimplification.cs,IsDeadTrueStore,The following statement contains a magic number: if (!(block.Instructions.SecondToLastOrDefault() is StLoc deadStore && block.Instructions[block.Instructions.Count - 3] is StLoc tempStore))  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,DetectNullSafeArrayToPointer,The following statement contains a magic number: for (int i = 0; i < container.Blocks.Count; i++) {  				var block = container.Blocks[i];  				ILVariable v' p;  				Block targetBlock;  				if (IsNullSafeArrayToPointerPattern(block' out v' out p' out targetBlock)) {  					block.Instructions[block.Instructions.Count - 2] = new StLoc(p' new ArrayToPointer(new LdLoc(v)));  					((Branch)block.Instructions.Last()).TargetBlock = targetBlock;  					modified = true;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerPattern,The following statement contains a magic number: if (v.Kind == VariableKind.StackSlot) {  				// If the variable is a stack slot' that might be due to an inline assignment'  				// so check the previous instruction:  				var previous = block.Instructions.ElementAtOrDefault(block.Instructions.Count - 3) as StLoc;  				if (previous != null && previous.Value.MatchLdLoc(v)) {  					// stloc V(ldloc S)  					// if (comp(ldloc S == ldnull)) ...  					v = previous.Variable;  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullBlock,The following statement contains a magic number: return block.Instructions.Count == 2  				&& block.Instructions[0].MatchIfInstruction(out condition' out trueInst)  				&& condition.UnwrapConv(ConversionKind.Truncate).MatchLdLen(StackType.I' out array)  				&& array.MatchLdLoc(v)  				&& trueInst.MatchBranch(out notNullAndNotEmptyBlock)  				&& notNullAndNotEmptyBlock.Parent == block.Parent  				&& IsNullSafeArrayToPointerNotNullAndNotEmptyBlock(notNullAndNotEmptyBlock' v' p' targetBlock)  				&& block.Instructions[1].MatchBranch(nullOrEmptyBlock);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNotNullAndNotEmptyBlock,The following statement contains a magic number: return block.Instructions.Count == 2  				&& block.Instructions[0].MatchStLoc(p' out value)  				&& value.OpCode == OpCode.LdElema  				&& ((LdElema)value).Array.MatchLdLoc(v)  				&& ((LdElema)value).Indices.All(i => i.MatchLdcI4(0))  				&& block.Instructions[1].MatchBranch(targetBlock);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsNullSafeArrayToPointerNullOrEmptyBlock,The following statement contains a magic number: return block.Instructions.Count == 2  				&& block.Instructions[0].MatchStLoc(out p' out value)  				&& p.Kind == VariableKind.PinnedLocal  				&& IsNullOrZero(value)  				&& block.Instructions[1].MatchBranch(out targetBlock);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,CreatePinnedRegion,The following statement contains a magic number: for (int i = 0; i < sourceContainer.Blocks.Count; i++) {  				if (reachedEdgesPerBlock[i] > 0) {  					var innerBlock = sourceContainer.Blocks[i];  					Branch br = innerBlock.Instructions.LastOrDefault() as Branch;  					if (br != null && br.TargetContainer == sourceContainer && reachedEdgesPerBlock[br.TargetBlock.ChildIndex] == 0) {  						// branch that leaves body.  						// Should have an instruction that resets the pin; delete that instruction:  						StLoc innerStLoc = innerBlock.Instructions.SecondToLastOrDefault() as StLoc;  						if (innerStLoc != null && innerStLoc.Variable == stLoc.Variable && IsNullOrZero(innerStLoc.Value)) {  							innerBlock.Instructions.RemoveAt(innerBlock.Instructions.Count - 2);  						}  					}  					  					body.Blocks.Add(innerBlock); // move block into body  					sourceContainer.Blocks[i] = new Block(); // replace with dummy block  					// we'll delete the dummy block later  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ProcessPinnedRegion,The following statement contains a magic number: if (pinnedRegion.Variable.Type.Kind == TypeKind.ByReference) {  				// C# doesn't support a "by reference" variable' so replace it with a native pointer  				ILVariable oldVar = pinnedRegion.Variable;  				ILVariable newVar = new ILVariable(  					VariableKind.PinnedLocal'  					new PointerType(((ByReferenceType)oldVar.Type).ElementType)'  					oldVar.Index);  				newVar.Name = oldVar.Name;  				newVar.HasGeneratedName = oldVar.HasGeneratedName;  				oldVar.Function.Variables.Add(newVar);  				ReplacePinnedVar(oldVar' newVar' pinnedRegion);  			} else if (pinnedRegion.Variable.Type.IsKnownType(KnownTypeCode.String)) {  				// fixing a string  				ILVariable nativeVar;  				ILInstruction initInst;  				// stloc nativeVar(conv o->i (ldloc pinnedVar))  				// if (comp(ldloc nativeVar == conv i4->i <sign extend>(ldc.i4 0))) br targetBlock  				// br adjustOffsetToStringData  				Block targetBlock' adjustOffsetToStringData;  				if (body.EntryPoint.IncomingEdgeCount == 1  				    && body.EntryPoint.Instructions.Count == 3  				    && body.EntryPoint.Instructions[0].MatchStLoc(out nativeVar' out initInst)  				    && nativeVar.Type.GetStackType() == StackType.I  				    && nativeVar.StoreCount == 2  				    && initInst.UnwrapConv(ConversionKind.StopGCTracking).MatchLdLoc(pinnedRegion.Variable)  				    && IsBranchOnNull(body.EntryPoint.Instructions[1]' nativeVar' out targetBlock)  				    && targetBlock.Parent == body  					&& body.EntryPoint.Instructions[2].MatchBranch(out adjustOffsetToStringData)  				    && adjustOffsetToStringData.Parent == body && adjustOffsetToStringData.IncomingEdgeCount == 1  					&& IsOffsetToStringDataBlock(adjustOffsetToStringData' nativeVar' targetBlock))  				{  					// remove old entry point  					body.Blocks.RemoveAt(0);  					body.Blocks.RemoveAt(adjustOffsetToStringData.ChildIndex);  					// make targetBlock the new entry point  					body.Blocks.RemoveAt(targetBlock.ChildIndex);  					body.Blocks.Insert(0' targetBlock);  					pinnedRegion.Init = new ArrayToPointer(pinnedRegion.Init);  					  					ILVariable otherVar;  					ILInstruction otherVarInit;  					// In optimized builds' the 'nativeVar' may end up being a stack slot'  					// and only gets assigned to a real variable after the offset adjustment.  					if (nativeVar.Kind == VariableKind.StackSlot && nativeVar.LoadCount == 1  					    && body.EntryPoint.Instructions[0].MatchStLoc(out otherVar' out otherVarInit)  					    && otherVarInit.MatchLdLoc(nativeVar)  					    && otherVar.IsSingleDefinition)  					{  						body.EntryPoint.Instructions.RemoveAt(0);  						nativeVar = otherVar;  					}  					ILVariable newVar;  					if (nativeVar.Kind == VariableKind.Local) {  						newVar = new ILVariable(VariableKind.PinnedLocal' nativeVar.Type' nativeVar.Index);  						newVar.Name = nativeVar.Name;  						newVar.HasGeneratedName = nativeVar.HasGeneratedName;  						nativeVar.Function.Variables.Add(newVar);  						ReplacePinnedVar(nativeVar' newVar' pinnedRegion);  					} else {  						newVar = nativeVar;  					}  					ReplacePinnedVar(pinnedRegion.Variable' newVar' pinnedRegion);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ProcessPinnedRegion,The following statement contains a magic number: if (pinnedRegion.Variable.Type.Kind == TypeKind.ByReference) {  				// C# doesn't support a "by reference" variable' so replace it with a native pointer  				ILVariable oldVar = pinnedRegion.Variable;  				ILVariable newVar = new ILVariable(  					VariableKind.PinnedLocal'  					new PointerType(((ByReferenceType)oldVar.Type).ElementType)'  					oldVar.Index);  				newVar.Name = oldVar.Name;  				newVar.HasGeneratedName = oldVar.HasGeneratedName;  				oldVar.Function.Variables.Add(newVar);  				ReplacePinnedVar(oldVar' newVar' pinnedRegion);  			} else if (pinnedRegion.Variable.Type.IsKnownType(KnownTypeCode.String)) {  				// fixing a string  				ILVariable nativeVar;  				ILInstruction initInst;  				// stloc nativeVar(conv o->i (ldloc pinnedVar))  				// if (comp(ldloc nativeVar == conv i4->i <sign extend>(ldc.i4 0))) br targetBlock  				// br adjustOffsetToStringData  				Block targetBlock' adjustOffsetToStringData;  				if (body.EntryPoint.IncomingEdgeCount == 1  				    && body.EntryPoint.Instructions.Count == 3  				    && body.EntryPoint.Instructions[0].MatchStLoc(out nativeVar' out initInst)  				    && nativeVar.Type.GetStackType() == StackType.I  				    && nativeVar.StoreCount == 2  				    && initInst.UnwrapConv(ConversionKind.StopGCTracking).MatchLdLoc(pinnedRegion.Variable)  				    && IsBranchOnNull(body.EntryPoint.Instructions[1]' nativeVar' out targetBlock)  				    && targetBlock.Parent == body  					&& body.EntryPoint.Instructions[2].MatchBranch(out adjustOffsetToStringData)  				    && adjustOffsetToStringData.Parent == body && adjustOffsetToStringData.IncomingEdgeCount == 1  					&& IsOffsetToStringDataBlock(adjustOffsetToStringData' nativeVar' targetBlock))  				{  					// remove old entry point  					body.Blocks.RemoveAt(0);  					body.Blocks.RemoveAt(adjustOffsetToStringData.ChildIndex);  					// make targetBlock the new entry point  					body.Blocks.RemoveAt(targetBlock.ChildIndex);  					body.Blocks.Insert(0' targetBlock);  					pinnedRegion.Init = new ArrayToPointer(pinnedRegion.Init);  					  					ILVariable otherVar;  					ILInstruction otherVarInit;  					// In optimized builds' the 'nativeVar' may end up being a stack slot'  					// and only gets assigned to a real variable after the offset adjustment.  					if (nativeVar.Kind == VariableKind.StackSlot && nativeVar.LoadCount == 1  					    && body.EntryPoint.Instructions[0].MatchStLoc(out otherVar' out otherVarInit)  					    && otherVarInit.MatchLdLoc(nativeVar)  					    && otherVar.IsSingleDefinition)  					{  						body.EntryPoint.Instructions.RemoveAt(0);  						nativeVar = otherVar;  					}  					ILVariable newVar;  					if (nativeVar.Kind == VariableKind.Local) {  						newVar = new ILVariable(VariableKind.PinnedLocal' nativeVar.Type' nativeVar.Index);  						newVar.Name = nativeVar.Name;  						newVar.HasGeneratedName = nativeVar.HasGeneratedName;  						nativeVar.Function.Variables.Add(newVar);  						ReplacePinnedVar(nativeVar' newVar' pinnedRegion);  					} else {  						newVar = nativeVar;  					}  					ReplacePinnedVar(pinnedRegion.Variable' newVar' pinnedRegion);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,ProcessPinnedRegion,The following statement contains a magic number: if (pinnedRegion.Variable.Type.Kind == TypeKind.ByReference) {  				// C# doesn't support a "by reference" variable' so replace it with a native pointer  				ILVariable oldVar = pinnedRegion.Variable;  				ILVariable newVar = new ILVariable(  					VariableKind.PinnedLocal'  					new PointerType(((ByReferenceType)oldVar.Type).ElementType)'  					oldVar.Index);  				newVar.Name = oldVar.Name;  				newVar.HasGeneratedName = oldVar.HasGeneratedName;  				oldVar.Function.Variables.Add(newVar);  				ReplacePinnedVar(oldVar' newVar' pinnedRegion);  			} else if (pinnedRegion.Variable.Type.IsKnownType(KnownTypeCode.String)) {  				// fixing a string  				ILVariable nativeVar;  				ILInstruction initInst;  				// stloc nativeVar(conv o->i (ldloc pinnedVar))  				// if (comp(ldloc nativeVar == conv i4->i <sign extend>(ldc.i4 0))) br targetBlock  				// br adjustOffsetToStringData  				Block targetBlock' adjustOffsetToStringData;  				if (body.EntryPoint.IncomingEdgeCount == 1  				    && body.EntryPoint.Instructions.Count == 3  				    && body.EntryPoint.Instructions[0].MatchStLoc(out nativeVar' out initInst)  				    && nativeVar.Type.GetStackType() == StackType.I  				    && nativeVar.StoreCount == 2  				    && initInst.UnwrapConv(ConversionKind.StopGCTracking).MatchLdLoc(pinnedRegion.Variable)  				    && IsBranchOnNull(body.EntryPoint.Instructions[1]' nativeVar' out targetBlock)  				    && targetBlock.Parent == body  					&& body.EntryPoint.Instructions[2].MatchBranch(out adjustOffsetToStringData)  				    && adjustOffsetToStringData.Parent == body && adjustOffsetToStringData.IncomingEdgeCount == 1  					&& IsOffsetToStringDataBlock(adjustOffsetToStringData' nativeVar' targetBlock))  				{  					// remove old entry point  					body.Blocks.RemoveAt(0);  					body.Blocks.RemoveAt(adjustOffsetToStringData.ChildIndex);  					// make targetBlock the new entry point  					body.Blocks.RemoveAt(targetBlock.ChildIndex);  					body.Blocks.Insert(0' targetBlock);  					pinnedRegion.Init = new ArrayToPointer(pinnedRegion.Init);  					  					ILVariable otherVar;  					ILInstruction otherVarInit;  					// In optimized builds' the 'nativeVar' may end up being a stack slot'  					// and only gets assigned to a real variable after the offset adjustment.  					if (nativeVar.Kind == VariableKind.StackSlot && nativeVar.LoadCount == 1  					    && body.EntryPoint.Instructions[0].MatchStLoc(out otherVar' out otherVarInit)  					    && otherVarInit.MatchLdLoc(nativeVar)  					    && otherVar.IsSingleDefinition)  					{  						body.EntryPoint.Instructions.RemoveAt(0);  						nativeVar = otherVar;  					}  					ILVariable newVar;  					if (nativeVar.Kind == VariableKind.Local) {  						newVar = new ILVariable(VariableKind.PinnedLocal' nativeVar.Type' nativeVar.Index);  						newVar.Name = nativeVar.Name;  						newVar.HasGeneratedName = nativeVar.HasGeneratedName;  						nativeVar.Function.Variables.Add(newVar);  						ReplacePinnedVar(nativeVar' newVar' pinnedRegion);  					} else {  						newVar = nativeVar;  					}  					ReplacePinnedVar(pinnedRegion.Variable' newVar' pinnedRegion);  				}  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,DetectPinnedRegions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs,IsOffsetToStringDataBlock,The following statement contains a magic number: return block.Instructions.Count == 2  				&& block.Instructions[0].MatchStLoc(nativeVar' out value)  				&& value.MatchBinaryNumericInstruction(BinaryNumericOperator.Add' out left' out right)  				&& left.MatchLdLoc(nativeVar)  				&& IsOffsetToStringDataCall(right)  				&& block.Instructions[1].MatchBranch(targetBlock);
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,PrepareReverseCFG,The following statement contains a magic number: if (multipleNodesTreatedAsExitNodes)  				exitNodeArity = 2; // more than 1  			else if (nodeTreatedAsExitNode != null)  				exitNodeArity = 1;  			else  				exitNodeArity = 0;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,LoopDetection,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\LoopDetection.cs,IsPossibleForeachLoop,The following statement contains a magic number: if (loopHead.Instructions.Count != 2)  				return false;
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: if (block.Instructions.Count >= 2  				&& block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)  				&& AnalyzeCondition(condition' out trueValues)  			) {  				if (!(tailOnly || block.Instructions.Count == 2))  					return false;  				trueValues = trueValues.IntersectWith(inputValues);  				Block trueBlock;  				if (trueInst.MatchBranch(out trueBlock) && AnalyzeBlock(trueBlock' trueValues)) {  					// OK' true block was further analyzed.  					InnerBlocks.Add(trueBlock);  				} else {  					// Create switch section for trueInst.  					AddSection(trueValues' trueInst);  				}  			} else if (block.Instructions.Last() is SwitchInstruction switchInst) {  				if (!(tailOnly || block.Instructions.Count == 1))  					return false;  				if (AnalyzeSwitch(switchInst' inputValues)) {  					ContainsILSwitch = true; // OK  					return true;  				} else { // switch analysis failed (e.g. switchVar mismatch)  					return false;  				}  			} else { // unknown inst  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: if (block.Instructions.Count >= 2  				&& block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)  				&& AnalyzeCondition(condition' out trueValues)  			) {  				if (!(tailOnly || block.Instructions.Count == 2))  					return false;  				trueValues = trueValues.IntersectWith(inputValues);  				Block trueBlock;  				if (trueInst.MatchBranch(out trueBlock) && AnalyzeBlock(trueBlock' trueValues)) {  					// OK' true block was further analyzed.  					InnerBlocks.Add(trueBlock);  				} else {  					// Create switch section for trueInst.  					AddSection(trueValues' trueInst);  				}  			} else if (block.Instructions.Last() is SwitchInstruction switchInst) {  				if (!(tailOnly || block.Instructions.Count == 1))  					return false;  				if (AnalyzeSwitch(switchInst' inputValues)) {  					ContainsILSwitch = true; // OK  					return true;  				} else { // switch analysis failed (e.g. switchVar mismatch)  					return false;  				}  			} else { // unknown inst  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.ControlFlow,SwitchAnalysis,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\SwitchAnalysis.cs,AnalyzeBlock,The following statement contains a magic number: if (block.Instructions.Count >= 2  				&& block.Instructions[block.Instructions.Count - 2].MatchIfInstruction(out var condition' out var trueInst)  				&& AnalyzeCondition(condition' out trueValues)  			) {  				if (!(tailOnly || block.Instructions.Count == 2))  					return false;  				trueValues = trueValues.IntersectWith(inputValues);  				Block trueBlock;  				if (trueInst.MatchBranch(out trueBlock) && AnalyzeBlock(trueBlock' trueValues)) {  					// OK' true block was further analyzed.  					InnerBlocks.Add(trueBlock);  				} else {  					// Create switch section for trueInst.  					AddSection(trueValues' trueInst);  				}  			} else if (block.Instructions.Last() is SwitchInstruction switchInst) {  				if (!(tailOnly || block.Instructions.Count == 1))  					return false;  				if (AnalyzeSwitch(switchInst' inputValues)) {  					ContainsILSwitch = true; // OK  					return true;  				} else { // switch analysis failed (e.g. switchVar mismatch)  					return false;  				}  			} else { // unknown inst  				return false;  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,BinaryInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,PinnedRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,CompoundAssignmentInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.condition;  				case 1:  					return this.trueInst;  				case 2:  					return this.falseInst;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Condition = value;  					break;  				case 1:  					this.TrueInst = value;  					break;  				case 2:  					this.FalseInst = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,IfInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return ConditionSlot;  				case 1:  					return TrueInstSlot;  				case 2:  					return FalseInstSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,NullCoalescingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,TryCatchHandler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,LockInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,UsingInstruction,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.destAddress;  				case 1:  					return this.sourceAddress;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.DestAddress = value;  					break;  				case 1:  					this.SourceAddress = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Cpblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return DestAddressSlot;  				case 1:  					return SourceAddressSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 3;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChild,The following statement contains a magic number: switch (index) {  				case 0:  					return this.address;  				case 1:  					return this.value;  				case 2:  					return this.size;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,SetChild,The following statement contains a magic number: switch (index) {  				case 0:  					this.Address = value;  					break;  				case 1:  					this.Value = value;  					break;  				case 2:  					this.Size = value;  					break;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,Initblk,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildSlot,The following statement contains a magic number: switch (index) {  				case 0:  					return AddressSlot;  				case 1:  					return ValueSlot;  				case 2:  					return SizeSlot;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,ICSharpCode.Decompiler.IL.Patterns,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.IL.Patterns,StObj,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,GetChildCount,The following statement contains a magic number: return 2;
Magic Number,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar != null && nextChar () == LF)  					return 2;  				return 1;  			}
Magic Number,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar == LF)  					return 2;  				return 1;  			}
Magic Number,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar != null && nextChar () == LF) {  					length = 2;  					type = UnicodeNewline.CRLF;  				} else {  					length = 1;  					type = UnicodeNewline.CR;    				}  				return true;  			}
Magic Number,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar == LF) {  					length = 2;  					type = UnicodeNewline.CRLF;  				} else {  					length = 1;  					type = UnicodeNewline.CR;    				}  				return true;  			}
Magic Number,ICSharpCode.Decompiler.Util,BitSet,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\BitSet.cs,ToString,The following statement contains a magic number: for (int i = 0; i < words.Length * BitsPerWord; i++) {  				if (this[i]) {  					if (b.Length > 1)  						b.Append("' ");  					if (b.Length > 500) {  						b.Append("...");  						break;  					}  					b.Append(i);  				}  			}
Magic Number,ICSharpCode.Decompiler.Util,Interval,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\Interval.cs,GetHashCode,The following statement contains a magic number: return Start ^ End ^ (End << 7);
Magic Number,ICSharpCode.Decompiler.Util,LongInterval,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\Interval.cs,GetHashCode,The following statement contains a magic number: return (Start ^ End ^ (End << 7)).GetHashCode();
Magic Number,ICSharpCode.Decompiler.Util,LongSet,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\LongSet.cs,upper_bound,The following statement contains a magic number: while (max >= min) {  				int m = min + (max - min) / 2;  				LongInterval i = Intervals[m];  				if (val < i.Start) {  					max = m - 1;  					continue;  				}  				if (val > i.End) {  					min = m + 1;  					continue;  				}  				return m + 1;  			}
Magic Number,ICSharpCode.Decompiler.FlowAnalysis,Dominance,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,ComputeDominance,The following statement contains a magic number: do {  				changed = false;  				  				cancellationToken.ThrowIfCancellationRequested();  				  				// For all nodes b except the entry point (in reverse post-order)  				for (int i = nodes.Count - 2; i >= 0; i--) {  					ControlFlowNode b = nodes[i];  					// Compute new immediate dominator:  					ControlFlowNode newIdom = null;  					foreach (var p in b.Predecessors) {  						// Ignore predecessors that were not processed yet  						if (p.ImmediateDominator != null) {  							if (newIdom == null)  								newIdom = p;  							else  								newIdom = FindCommonDominator(p' newIdom);  						}  					}  					// The reverse post-order ensures at least one of our predecessors was processed.  					Debug.Assert(newIdom != null);  					if (newIdom != b.ImmediateDominator) {  						b.ImmediateDominator = newIdom;  						changed = true;  					}  				}  			} while(changed);
Magic Number,ICSharpCode.Decompiler.FlowAnalysis,Dominance,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\FlowAnalysis\Dominance.cs,MarkNodesWithReachableExits,The following statement contains a magic number: foreach (var j in cfg) {  				// If j is a join-point (more than one incoming edge):  				// `j.IsReachable && j.ImmediateDominator == null` is the root node' which counts as an extra incoming edge  				if (j.IsReachable && (j.Predecessors.Count >= 2 || (j.Predecessors.Count >= 1 && j.ImmediateDominator == null))) {  					// Add j to frontier of all predecessors and their dominators up to j's immediate dominator.  					foreach (var p in j.Predecessors) {  						for (var runner = p; runner != j.ImmediateDominator && runner != j && runner != null; runner = runner.ImmediateDominator) {  							nonEmpty.Set(runner.UserIndex);  						}  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.Disassembler,ReflectionDisassembler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ReflectionDisassembler.cs,WriteBlob,The following statement contains a magic number: for (int i = 0; i < blob.Length; i++) {  				if (i % 16 == 0 && i < blob.Length - 1) {  					output.WriteLine();  				} else {  					output.Write(' ');  				}  				output.Write(blob[i].ToString("x2"));  			}
Magic Number,ICSharpCode.Decompiler.Semantics,NumericOrEnumerationConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.Decompiler.Semantics,NumericOrEnumerationConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.Semantics,UserDefinedConv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.Decompiler.TypeSystem,AnonymousType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = resolvedProperties.Count;  				foreach (var p in resolvedProperties) {  					hashCode *= 31;  					hashCode += p.Name.GetHashCode() ^ p.ReturnType.GetHashCode();  				}  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,AnonymousTypeProperty,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: return declaringType.GetHashCode() ^ unchecked(27 * this.Name.GetHashCode());
Magic Number,ICSharpCode.Decompiler.TypeSystem,AnonymousTypeAccessor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: return owner.DeclaringType.GetHashCode() ^ unchecked(27 * this.Name.GetHashCode());
Magic Number,ICSharpCode.Decompiler.TypeSystem,ArrayType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ArrayType.cs,GetHashCode,The following statement contains a magic number: return unchecked(elementType.GetHashCode() * 71681 + dimensions);
Magic Number,ICSharpCode.Decompiler.TypeSystem,AssemblyQualifiedTypeName,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\AssemblyQualifiedTypeName.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (AssemblyName != null)  					hashCode += 1000000007 * AssemblyName.GetHashCode();  				hashCode += TypeName.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,ByReferenceType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725813;
Magic Number,ICSharpCode.Decompiler.TypeSystem,ByReferenceTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725814;
Magic Number,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: if (attribute.ConstructorArguments.Count != 5)  				return null;
Magic Number,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: return new decimal((int)ctorArgs[4]' (int)ctorArgs[3]' (int)ctorArgs[2]' (byte)ctorArgs[1] != 0' (byte)ctorArgs[0]);
Magic Number,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: return new decimal((int)ctorArgs[4]' (int)ctorArgs[3]' (int)ctorArgs[2]' (byte)ctorArgs[1] != 0' (byte)ctorArgs[0]);
Magic Number,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,TryDecodeDecimalConstantAttribute,The following statement contains a magic number: return new decimal((int)ctorArgs[4]' (int)ctorArgs[3]' (int)ctorArgs[2]' (byte)ctorArgs[1] != 0' (byte)ctorArgs[0]);
Magic Number,ICSharpCode.Decompiler.TypeSystem,DomRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,DomRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,DomRegion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,FullTypeNameComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\FullTypeName.cs,GetHashCode,The following statement contains a magic number: unchecked {  				for (int i = 0; i < obj.NestingLevel; i++) {  					hash *= 31;  					hash += NameComparer.GetHashCode(obj.Name) ^ obj.TypeParameterCount;  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,IntersectionType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\IntersectionType.cs,IntersectionType,The following statement contains a magic number: Debug.Assert(types.Length >= 2);
Magic Number,ICSharpCode.Decompiler.TypeSystem,IntersectionType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\IntersectionType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var t in types) {  					hashCode *= 7137517;  					hashCode += t.GetHashCode();  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var ta in typeArguments) {  					hashCode *= 1000000007;  					hashCode += 1000000009 * ta.GetHashCode();  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var ta in typeArguments) {  					hashCode *= 1000000007;  					hashCode += 1000000009 * ta.GetHashCode();  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterizedTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				foreach (ITypeReference t in typeArguments) {  					hashCode *= 27;  					hashCode += t.GetHashCode();  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,ParameterListComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (IParameter p in obj) {  					hashCode *= 27;  					IType type = p.Type.AcceptVisitor(normalizationVisitor);  					hashCode += type.GetHashCode();  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);  				IParameterizedMember pm = obj as IParameterizedMember;  				if (pm != null) {  					hash *= 27;  					hash += ParameterListComparer.Instance.GetHashCode(pm.Parameters);  					IMethod m = pm as IMethod;  					if (m != null)  						hash += m.TypeParameters.Count;  				}  				return hash;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,SignatureComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);  				IParameterizedMember pm = obj as IParameterizedMember;  				if (pm != null) {  					hash *= 27;  					hash += ParameterListComparer.Instance.GetHashCode(pm.Parameters);  					IMethod m = pm as IMethod;  					if (m != null)  						hash += m.TypeParameters.Count;  				}  				return hash;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,PointerType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\PointerType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725811;
Magic Number,ICSharpCode.Decompiler.TypeSystem,PointerTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\PointerType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725812;
Magic Number,ICSharpCode.Decompiler.TypeSystem,SpecialType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\SpecialType.cs,GetHashCode,The following statement contains a magic number: return 81625621 ^ (int)kind;
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeParameterSubstitution.cs,TypeListHashCode,The following statement contains a magic number: unchecked {  				int hashCode = 1;  				foreach (var element in obj) {  					hashCode *= 27;  					hashCode += element.GetHashCode();  				}  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (type) {  				case StackType.I4:  					return 4;  				case StackType.I8:  					return 8;  				case StackType.I:  				case StackType.Ref:  					return NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following statement contains a magic number: switch (type) {  				case StackType.I4:  					return 4;  				case StackType.I8:  					return 8;  				case StackType.I:  				case StackType.Ref:  					return NativeIntSize;  				default:  					return 0;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,IsSmallIntegerType,The following statement contains a magic number: return size > 0 && size < 4;
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,GetBlobHashCode,The following statement contains a magic number: unchecked {  				int hash = 0;  				foreach (byte b in blob) {  					hash *= 257;  					hash += b;  				}  				return hash;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt16,The following statement contains a magic number: unchecked {  				ushort value =(ushort)(buffer[position]  				                       |(buffer[position + 1] << 8));  				position += 2;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt16,The following statement contains a magic number: unchecked {  				ushort value =(ushort)(buffer[position]  				                       |(buffer[position + 1] << 8));  				position += 2;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadUInt64,The following statement contains a magic number: unchecked {  				uint low = ReadUInt32();  				uint high = ReadUInt32();    				return(((ulong) high) << 32) | low;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadSingle,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(4);  					Array.Reverse(bytes);  					return BitConverter.ToSingle(bytes' 0);  				}    				float value = BitConverter.ToSingle(buffer' position);  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadSingle,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(4);  					Array.Reverse(bytes);  					return BitConverter.ToSingle(bytes' 0);  				}    				float value = BitConverter.ToSingle(buffer' position);  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadDouble,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(8);  					Array.Reverse(bytes);  					return BitConverter.ToDouble(bytes' 0);  				}    				double value = BitConverter.ToDouble(buffer' position);  				position += 8;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\BlobReader.cs,ReadDouble,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(8);  					Array.Reverse(bytes);  					return BitConverter.ToDouble(bytes' 0);  				}    				double value = BitConverter.ToDouble(buffer' position);  				position += 8;  				return value;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,GetClassTypeReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\GetClassTypeReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				return 33 * assembly.GetHashCode() + fullTypeName.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,ListComparer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SimpleInterningProvider.cs,GetHashCode,The following statement contains a magic number: unchecked {  					foreach (object o in obj) {  						hashCode *= 27;  						hashCode += RuntimeHelpers.GetHashCode(o);  					}  				}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMember,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs,Create,The following statement contains a magic number: if (index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)) {  				TypeParameterReference[] arr = (ownerType == SymbolKind.TypeDefinition) ? classTypeParameterReferences : methodTypeParameterReferences;  				TypeParameterReference result = LazyInit.VolatileRead(ref arr[index]);  				if (result == null) {  					result = LazyInit.GetOrSet(ref arr[index]' new TypeParameterReference(ownerType' index));  				}  				return result;  			} else {  				return new TypeParameterReference(ownerType' index);  			}
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,UnknownType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Magic Number,ICSharpCode.Decompiler.TypeSystem.Implementation,UnknownType,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Missing Default,ICSharpCode.Decompiler.CSharp,TranslatedExpression,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\TranslatedExpression.cs,ConvertTo,The following switch statement is missing a default case: switch (ResolveResult) {  						case ConversionResolveResult conversion: {  							if (Expression is CastExpression cast  							&& (type.IsKnownType(KnownTypeCode.Object) && conversion.Conversion.IsBoxingConversion  								|| conversion.Conversion.IsAnonymousFunctionConversion  								|| (conversion.Conversion.IsImplicit && (conversion.Conversion.IsUserDefined || targetType.IsKnownType(KnownTypeCode.Decimal)))  							)) {  								return this.UnwrapChild(cast.Expression);  							} else if (Expression is ObjectCreateExpression oce && conversion.Conversion.IsMethodGroupConversion  									&& oce.Arguments.Count == 1 && expressionBuilder.settings.UseImplicitMethodGroupConversion) {  								return this.UnwrapChild(oce.Arguments.Single());  							}  							break;  						}  						case InvocationResolveResult invocation: {  							if (Expression is ObjectCreateExpression oce && oce.Arguments.Count == 1 && invocation.Type.IsKnownType(KnownTypeCode.NullableOfT)) {  								return this.UnwrapChild(oce.Arguments.Single());  							}  							break;  						}  					}
Missing Default,ICSharpCode.Decompiler.CSharp,CSharpDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs,ConvertType,The following switch statement is missing a default case: switch (name) {  								case "SByte":  									return new Syntax.PrimitiveType("sbyte");  								case "Int16":  									return new Syntax.PrimitiveType("short");  								case "Int32":  									return new Syntax.PrimitiveType("int");  								case "Int64":  									return new Syntax.PrimitiveType("long");  								case "Byte":  									return new Syntax.PrimitiveType("byte");  								case "UInt16":  									return new Syntax.PrimitiveType("ushort");  								case "UInt32":  									return new Syntax.PrimitiveType("uint");  								case "UInt64":  									return new Syntax.PrimitiveType("ulong");  								case "String":  									return new Syntax.PrimitiveType("string");  								case "Single":  									return new Syntax.PrimitiveType("float");  								case "Double":  									return new Syntax.PrimitiveType("double");  								case "Decimal":  									return new Syntax.PrimitiveType("decimal");  								case "Char":  									return new Syntax.PrimitiveType("char");  								case "Boolean":  									return new Syntax.PrimitiveType("bool");  								case "Void":  									return new Syntax.PrimitiveType("void");  								case "Object":  									return new Syntax.PrimitiveType("object");  							}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ConvertConstantValue,The following switch statement is missing a default case: switch (rr.Type.GetDefinition()?.KnownTypeCode) {  						case KnownTypeCode.SByte:  						case KnownTypeCode.Byte:  						case KnownTypeCode.Int16:  						case KnownTypeCode.UInt16:  							expr = new CastExpression(new PrimitiveType(KnownTypeReference.GetCSharpNameByTypeCode(rr.Type.GetDefinition().KnownTypeCode))' expr);  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,ShouldDisplayAsHex,The following switch statement is missing a default case: switch (parent) {  				case BinaryNumericInstruction bni:  					if (bni.Operator == BinaryNumericOperator.BitAnd  						|| bni.Operator == BinaryNumericOperator.BitOr  						|| bni.Operator == BinaryNumericOperator.BitXor)  						return true;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateComp,The following switch statement is missing a default case: switch (inst.InputType) {  				case StackType.I: // In order to generate valid C# we need to treat (U)IntPtr as (U)Int64 in comparisons.  				case StackType.I8:  					inputType = inst.Sign == Sign.Unsigned ? KnownTypeCode.UInt64 : KnownTypeCode.Int64;  					break;  				case StackType.I4:  					inputType = inst.Sign == Sign.Unsigned ? KnownTypeCode.UInt32 : KnownTypeCode.Int32;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,HandleCompoundAssignment,The following switch statement is missing a default case: switch (op) {  					case AssignmentOperatorType.Add:  					case AssignmentOperatorType.Subtract: {  							IType targetType = NullableType.GetUnderlyingType(target.Type).GetEnumUnderlyingType();  							if (NullableType.IsNullable(value.Type)) {  								targetType = NullableType.Create(compilation' targetType);  							}  							value = value.ConvertTo(targetType' this' inst.CheckForOverflow' allowImplicitConversion: true);  							break;  						}  					case AssignmentOperatorType.Multiply:  					case AssignmentOperatorType.Divide:  					case AssignmentOperatorType.Modulus:  					case AssignmentOperatorType.BitwiseAnd:  					case AssignmentOperatorType.BitwiseOr:  					case AssignmentOperatorType.ExclusiveOr: {  							IType targetType = NullableType.GetUnderlyingType(target.Type);  							if (NullableType.IsNullable(value.Type)) {  								targetType = NullableType.Create(compilation' targetType);  							}  							value = value.ConvertTo(targetType' this' inst.CheckForOverflow' allowImplicitConversion: true);  							break;  						}  				}
Missing Default,ICSharpCode.Decompiler.CSharp,ExpressionBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs,TranslateObjectAndCollectionInitializer,The following switch statement is missing a default case: switch (info.Kind) {  					case IL.Transforms.AccessPathKind.Adder:  						elementsStack.Peek().Add(MakeInitializerElements(info.Values' ((IMethod)lastElement.Member).Parameters));  						break;  					case IL.Transforms.AccessPathKind.Setter:  						if (lastElement.Indices?.Length > 0) {  							var indexer = new IndexerExpression(null' lastElement.Indices.SelectArray(i => Translate(i is LdLoc ld ? indexVariables[ld.Variable] : i).Expression))  								.WithILInstruction(inst).WithRR(memberRR);  							elementsStack.Peek().Add(Assignment(indexer' Translate(info.Values.Single())));  						} else {  							var target = new IdentifierExpression(lastElement.Member.Name)  								.WithILInstruction(inst).WithRR(memberRR);  							elementsStack.Peek().Add(Assignment(target' Translate(info.Values.Single())));  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The following switch statement is missing a default case: switch (instToReplace.Parent) {  				case CastClass cc:  					type = cc.Type;  					instToReplace = cc;  					break;  				case UnboxAny ua:  					type = ua.Type;  					instToReplace = ua;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,TransformToForeach,The following switch statement is missing a default case: switch (transformation) {  				case RequiredGetCurrentTransformation.UseExistingVariable:  					foreachVariable.Type = type;  					foreachVariable.Kind = VariableKind.ForeachLocal;  					foreachVariable.Name = AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>()' foreachVariable);  					break;  				case RequiredGetCurrentTransformation.IntroduceNewVariable:  					foreachVariable = currentFunction.RegisterVariable(  						VariableKind.ForeachLocal' type'  						AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>())  					);  					instToReplace.ReplaceWith(new LdLoc(foreachVariable));  					body.Instructions.Insert(0' new StLoc(foreachVariable' instToReplace));  					break;  				case RequiredGetCurrentTransformation.IntroduceNewVariableAndLocalCopy:  					foreachVariable = currentFunction.RegisterVariable(  						VariableKind.ForeachLocal' type'  						AssignVariableNames.GenerateForeachVariableName(currentFunction' collectionExpr.Annotation<ILInstruction>())  					);  					var localCopyVariable = currentFunction.RegisterVariable(  						VariableKind.Local' type'  						AssignVariableNames.GenerateVariableName(currentFunction' type)  					);  					instToReplace.Parent.ReplaceWith(new LdLoca(localCopyVariable));  					body.Instructions.Insert(0' new StLoc(localCopyVariable' new LdLoc(foreachVariable)));  					body.Instructions.Insert(0' new StLoc(foreachVariable' instToReplace));  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,StatementBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs,ConvertLoop,The following switch statement is missing a default case: switch (container.Kind) {  				case ContainerKind.Loop:  					continueTarget = container.EntryPoint;  					blockStatement = ConvertBlockContainer(container' true);  					Debug.Assert(continueCount < container.EntryPoint.IncomingEdgeCount);  					Debug.Assert(blockStatement.Statements.First() is LabelStatement);  					if (container.EntryPoint.IncomingEdgeCount == continueCount + 1) {  						// Remove the entrypoint label if all jumps to the label were replaced with 'continue;' statements  						blockStatement.Statements.First().Remove();  					}    					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt)  						continueStmt.Remove();  					return new WhileStatement(new PrimitiveExpression(true)' blockStatement);  				case ContainerKind.While:  					continueTarget = container.EntryPoint;  					if (!container.MatchConditionBlock(continueTarget' out condition' out loopBody))  						throw new NotSupportedException("Invalid condition block in while loop.");  					blockStatement = ConvertAsBlock(loopBody);  					if (!loopBody.HasFlag(InstructionFlags.EndPointUnreachable))  						blockStatement.Add(new BreakStatement());  					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.Skip(1).Except(new[] { loopBody })' true);  					Debug.Assert(continueCount < container.EntryPoint.IncomingEdgeCount);  					if (continueCount + 1 < container.EntryPoint.IncomingEdgeCount) {  						// There's an incoming edge to the entry point (=while condition) that wasn't represented as "continue;"  						// -> emit a real label  						// We'll also remove any "continue;" in front of the label' as it's redundant.  						if (blockStatement.LastOrDefault() is ContinueStatement)  							blockStatement.Last().Remove();  						blockStatement.Add(new LabelStatement { Label = container.EntryPoint.Label });  					}    					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt2)  						continueStmt2.Remove();  					return new WhileStatement(exprBuilder.TranslateCondition(condition)' blockStatement);  				case ContainerKind.DoWhile:  					continueTarget = container.Blocks.Last();  					if (!container.MatchConditionBlock(continueTarget' out condition' out _))  						throw new NotSupportedException("Invalid condition block in do-while loop.");  					blockStatement = ConvertBlockContainer(new BlockStatement()' container' container.Blocks.SkipLast(1)' true);  					if (continueTarget.IncomingEdgeCount == continueCount) {  						// Remove the entrypoint label if all jumps to the label were replaced with 'continue;' statements  						blockStatement.Statements.First().Remove();  					}  					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt3)  						continueStmt3.Remove();  					if (blockStatement.Statements.Count == 0) {  						return new WhileStatement {  							Condition = exprBuilder.TranslateCondition(condition)'  							EmbeddedStatement = blockStatement  						};  					}  					return new DoWhileStatement {  						EmbeddedStatement = blockStatement'  						Condition = exprBuilder.TranslateCondition(condition)  					};  				case ContainerKind.For:  					continueTarget = container.Blocks.Last();  					if (!container.MatchConditionBlock(container.EntryPoint' out condition' out loopBody))  						throw new NotSupportedException("Invalid condition block in for loop.");  					blockStatement = ConvertAsBlock(loopBody);  					if (!loopBody.HasFlag(InstructionFlags.EndPointUnreachable))  						blockStatement.Add(new BreakStatement());  					if (!container.MatchIncrementBlock(continueTarget))  						throw new NotSupportedException("Invalid increment block in for loop.");  					blockStatement = ConvertBlockContainer(blockStatement' container' container.Blocks.SkipLast(1).Skip(1).Except(new[] { loopBody })' true);  					var forStmt = new ForStatement() {  						Condition = exprBuilder.TranslateCondition(condition)'  						EmbeddedStatement = blockStatement  					};  					if (blockStatement.LastOrDefault() is ContinueStatement continueStmt4)  						continueStmt4.Remove();  					for (int i = 0; i < continueTarget.Instructions.Count - 1; i++) {  						forStmt.Iterators.Add(Convert(continueTarget.Instructions[i]));  					}  					if (continueTarget.IncomingEdgeCount > continueCount)  						blockStatement.Add(new LabelStatement { Label = continueTarget.Label });  					return forStmt;  			}
Missing Default,ICSharpCode.Decompiler.CSharp,WholeProjectDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\WholeProjectDecompiler.cs,WriteProjectFile,The following switch statement is missing a default case: switch (frameworkIdentifier) {  							case ".NETPortable":  								languageTargets = LanguageTargets.Portable;  								break;  						}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,NegateRelationalOperator,The following switch statement is missing a default case: switch (op) {  				case BinaryOperatorType.GreaterThan:  					return BinaryOperatorType.LessThanOrEqual;  				case BinaryOperatorType.GreaterThanOrEqual:  					return BinaryOperatorType.LessThan;  				case BinaryOperatorType.Equality:  					return BinaryOperatorType.InEquality;  				case BinaryOperatorType.InEquality:  					return BinaryOperatorType.Equality;  				case BinaryOperatorType.LessThan:  					return BinaryOperatorType.GreaterThanOrEqual;  				case BinaryOperatorType.LessThanOrEqual:  					return BinaryOperatorType.GreaterThan;  				case BinaryOperatorType.ConditionalOr:  					return BinaryOperatorType.ConditionalAnd;  				case BinaryOperatorType.ConditionalAnd:  					return BinaryOperatorType.ConditionalOr;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,CSharpUtil,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\CSharpUtil.cs,NegateConditionOperator,The following switch statement is missing a default case: switch (op) {  				case BinaryOperatorType.ConditionalOr:  					return BinaryOperatorType.ConditionalAnd;  				case BinaryOperatorType.ConditionalAnd:  					return BinaryOperatorType.ConditionalOr;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Syntax,TypeSystemAstBuilder,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs,ConvertEnumValue,The following switch statement is missing a default case: switch (enumBaseTypeCode) {  					case TypeCode.Byte:  					case TypeCode.SByte:  						negatedEnumValue &= byte.MaxValue;  						break;  					case TypeCode.Int16:  					case TypeCode.UInt16:  						negatedEnumValue &= ushort.MaxValue;  						break;  					case TypeCode.Int32:  					case TypeCode.UInt32:  						negatedEnumValue &= uint.MaxValue;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitUndocumentedExpression,The following switch statement is missing a default case: switch (undocumentedExpression.UndocumentedExpressionType) {  				case UndocumentedExpressionType.ArgList:  				case UndocumentedExpressionType.ArgListAccess:  					WriteKeyword(UndocumentedExpression.ArglistKeywordRole);  					break;  				case UndocumentedExpressionType.MakeRef:  					WriteKeyword(UndocumentedExpression.MakerefKeywordRole);  					break;  				case UndocumentedExpressionType.RefType:  					WriteKeyword(UndocumentedExpression.ReftypeKeywordRole);  					break;  				case UndocumentedExpressionType.RefValue:  					WriteKeyword(UndocumentedExpression.RefvalueKeywordRole);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitQueryOrdering,The following switch statement is missing a default case: switch (queryOrdering.Direction) {  				case QueryOrderingDirection.Ascending:  					Space();  					WriteKeyword(QueryOrdering.AscendingKeywordRole);  					break;  				case QueryOrderingDirection.Descending:  					Space();  					WriteKeyword(QueryOrdering.DescendingKeywordRole);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,CSharpOutputVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs,VisitParameterDeclaration,The following switch statement is missing a default case: switch (parameterDeclaration.ParameterModifier) {  				case ParameterModifier.Ref:  					WriteKeyword(ParameterDeclaration.RefModifierRole);  					break;  				case ParameterModifier.Out:  					WriteKeyword(ParameterDeclaration.OutModifierRole);  					break;  				case ParameterModifier.Params:  					WriteKeyword(ParameterDeclaration.ParamsModifierRole);  					break;  				case ParameterModifier.This:  					WriteKeyword(ParameterDeclaration.ThisModifierRole);  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,InsertParenthesesVisitor,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs,VisitCastExpression,The following switch statement is missing a default case: switch (typeCode) {  					case TypeCode.SByte:  						if ((sbyte)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int16:  						if ((short)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int32:  						if ((int)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Int64:  						if ((long)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Single:  						if ((float)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Double:  						if ((double)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  					case TypeCode.Decimal:  						if ((decimal)pe.Value < 0)  							Parenthesize(castExpression.Expression);  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.OutputVisitor,TextWriterTokenWriter,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs,UpdateEndLocation,The following switch statement is missing a default case: switch (ch) {  					case '\r':  						if (i + 1 < content.Length && content[i + 1] == '\n')  							i++;  						goto case '\n';  					case '\n':  						line++;  						column = 0;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpConversions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs,ImplicitConstantExpressionConversion,The following switch statement is missing a default case: switch (toTypeCode) {  					case TypeCode.SByte:  						return val >= SByte.MinValue && val <= SByte.MaxValue;  					case TypeCode.Byte:  						return val >= Byte.MinValue && val <= Byte.MaxValue;  					case TypeCode.Int16:  						return val >= Int16.MinValue && val <= Int16.MaxValue;  					case TypeCode.UInt16:  						return val >= UInt16.MinValue && val <= UInt16.MaxValue;  					case TypeCode.UInt32:  						return val >= 0;  					case TypeCode.UInt64:  						return val >= 0;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,UnaryNumericPromotion,The following switch statement is missing a default case: switch (op) {  				case UnaryOperatorType.Minus:  					if (code == TypeCode.UInt32) {  						type = compilation.FindType(KnownTypeCode.Int64);  						return Convert(expression' MakeNullable(type' isNullable)'  						               isNullable ? Conversion.ImplicitNullableConversion : Conversion.ImplicitNumericConversion);  					}  					goto case UnaryOperatorType.Plus;  				case UnaryOperatorType.Plus:  				case UnaryOperatorType.BitNot:  					if (code >= TypeCode.Char && code <= TypeCode.UInt16) {  						type = compilation.FindType(KnownTypeCode.Int32);  						return Convert(expression' MakeNullable(type' isNullable)'  						               isNullable ? Conversion.ImplicitNullableConversion : Conversion.ImplicitNumericConversion);  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,LookupSimpleNameOrTypeName,The following switch statement is missing a default case: switch (lookupMode) {  						case NameLookupMode.Expression:  							cache = currentTypeDefinitionCache.SimpleNameLookupCacheExpression;  							break;  						case NameLookupMode.InvocationTarget:  							cache = currentTypeDefinitionCache.SimpleNameLookupCacheInvocationTarget;  							break;  						case NameLookupMode.Type:  							cache = currentTypeDefinitionCache.SimpleTypeLookupCache;  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveIndexer,The following switch statement is missing a default case: switch (target.Type.Kind) {  				case TypeKind.Dynamic:  					return new DynamicInvocationResolveResult(target' DynamicInvocationType.Indexing' AddArgumentNamesIfNecessary(arguments' argumentNames));  					  				case TypeKind.Array:  				case TypeKind.Pointer:  					// 7.6.6.1 Array access / 18.5.3 Pointer element access  					AdjustArrayAccessArguments(arguments);  					return new ArrayAccessResolveResult(((TypeWithElementType)target.Type).ElementType' target' arguments);  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,CSharpResolver,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs,ResolveSizeOf,The following switch statement is missing a default case: switch (ReflectionHelper.GetTypeCode(typeForConstant)) {  				case TypeCode.Boolean:  				case TypeCode.SByte:  				case TypeCode.Byte:  					size = 1;  					break;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					size = 2;  					break;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					size = 4;  					break;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					size = 8;  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ValidateConstraints,The following switch statement is missing a default case: switch (typeArgument.Kind) { // void' null' and pointers cannot be used as type arguments  				case TypeKind.Void:  				case TypeKind.Null:  				case TypeKind.Pointer:  					return false;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,BetterFunctionMember,The following switch statement is missing a default case: switch (conversions.BetterConversion(arguments[i]' c1.ParameterTypes[p1]' c2.ParameterTypes[p2])) {  						case 1:  							c1IsBetter = true;  							break;  						case 2:  							c2IsBetter = true;  							break;  					}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,MoreSpecificFormalParameters,The following switch statement is missing a default case: switch (MoreSpecificFormalParameter(pair.Item1' pair.Item2)) {  					case 1:  						c1IsBetter = true;  						break;  					case 2:  						c2IsBetter = true;  						break;  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Resolver,OverloadResolution,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs,ConsiderIfNewCandidateIsBest,The following switch statement is missing a default case: switch (BetterFunctionMember(candidate' bestCandidate)) {  					case 0:  						// Overwrite 'bestCandidateAmbiguousWith' so that API users can  						// detect the set of all ambiguous methods if they look at  						// bestCandidateAmbiguousWith after each step.  						bestCandidateAmbiguousWith = candidate;  						break;  					case 1:  						bestCandidate = candidate;  						bestCandidateWasValidated = false;  						bestCandidateAmbiguousWith = null;  						break;  						// case 2: best candidate stays best  				}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,PatternStatementTransform,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs,VisitBinaryOperatorExpression,The following switch statement is missing a default case: switch (boe1.Operator) {  				case BinaryOperatorType.ConditionalAnd:  				case BinaryOperatorType.ConditionalOr:  					// a && (b && c) ==> (a && b) && c  					var boe2 = boe1.Right as BinaryOperatorExpression;  					if (boe2 != null && boe2.Operator == boe1.Operator) {  						// make boe2 the parent and boe1 the child  						var b = boe2.Left.Detach();  						boe1.ReplaceWith(boe2.Detach());  						boe2.Left = boe1;  						boe1.Right = b;  						return base.VisitBinaryOperatorExpression(boe2);  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.CSharp.Transforms,ReplaceMethodCallsWithOperators,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following switch statement is missing a default case: switch (method.FullName) {  				case "System.Type.GetTypeFromHandle":  					if (arguments.Length == 1) {  						if (typeHandleOnTypeOfPattern.IsMatch(arguments[0])) {  							Expression target = ((MemberReferenceExpression)arguments[0]).Target;  							target.CopyInstructionsFrom(invocationExpression);  							invocationExpression.ReplaceWith(target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo.GetFieldFromHandle":  					if (arguments.Length == 1) {  						MemberReferenceExpression mre = arguments[0] as MemberReferenceExpression;  						if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation>() != null) {  							invocationExpression.ReplaceWith(mre.Target);  							return;  						}  					} else if (arguments.Length == 2) {  						MemberReferenceExpression mre1 = arguments[0] as MemberReferenceExpression;  						MemberReferenceExpression mre2 = arguments[1] as MemberReferenceExpression;  						if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation>() != null) {  							if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  								Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single();  								FieldReference field = oldArg.Annotation<FieldReference>();  								if (field != null) {  									AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach();  									oldArg.ReplaceWith(new MemberReferenceExpression(new TypeReferenceExpression(declaringType)' field.Name).CopyAnnotationsFrom(oldArg));  									invocationExpression.ReplaceWith(mre1.Target);  									return;  								}  							}  						}  					}  					break;  				case "System.Activator.CreateInstance":  					if (method.TypeArguments.Count == 1 && arguments.Length == 0 && method.TypeArguments[0].Kind == TypeKind.TypeParameter) {  						invocationExpression.ReplaceWith(new ObjectCreateExpression(context.TypeSystemAstBuilder.ConvertType(method.TypeArguments.First())));  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetPushDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPush) {  				case StackBehaviour.Push0:  					return 0;    				case StackBehaviour.Push1:  				case StackBehaviour.Pushi:  				case StackBehaviour.Pushi8:  				case StackBehaviour.Pushr4:  				case StackBehaviour.Pushr8:  				case StackBehaviour.Pushref:  					return 1;    				case StackBehaviour.Push1_push1:  					return 2;    				case StackBehaviour.Varpush:  					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					return IsVoid (method.ReturnType) ? 0 : 1;  			}
Missing Default,ICSharpCode.Decompiler,CecilExtensions,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\CecilExtensions.cs,GetPopDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Missing Default,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadXmlDoc,The following switch statement is missing a default case: switch (reader.LocalName) {  							case "members":  								ReadMembersSection(reader' linePosMapper' indexList);  								break;  						}
Missing Default,ICSharpCode.Decompiler.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}
Missing Default,LightJson.Serialization,JsonReader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\DotNetCore\LightJson\Serialization\JsonReader.cs,ReadNumber,The following switch statement is missing a default case: switch (next) {  					case '+':  					case '-':  						builder.Append(this.scanner.Read());  						break;  				}
Missing Default,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Kind) {  				case ContainerKind.Loop:  					output.Write("(while-true) ");  					break;  				case ContainerKind.Switch:  					output.Write("(switch) ");  					break;  				case ContainerKind.While:  					output.Write("(while) ");  					break;  				case ContainerKind.DoWhile:  					output.Write("(do-while) ");  					break;  				case ContainerKind.For:  					output.Write("(for) ");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,BlockContainer,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following switch statement is missing a default case: switch (Kind) {  				case ContainerKind.Normal:  					break;  				case ContainerKind.Loop:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					break;  				case ContainerKind.Switch:  					Debug.Assert(EntryPoint.Instructions.Count == 1);  					Debug.Assert(EntryPoint.Instructions[0] is SwitchInstruction);  					break;  				case ContainerKind.While:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  				case ContainerKind.DoWhile:  					Debug.Assert(EntryPoint.IncomingEdgeCount > 1);  					Debug.Assert(Blocks.Count >= 2);  					Debug.Assert(MatchConditionBlock(Blocks.Last()' out _' out bodyStartBlock));  					Debug.Assert(bodyStartBlock == EntryPoint);  					break;  				case ContainerKind.For:  					Debug.Assert(EntryPoint.IncomingEdgeCount == 2);  					Debug.Assert(Blocks.Count >= 3);  					Debug.Assert(MatchConditionBlock(EntryPoint' out _' out bodyStartBlock));  					Debug.Assert(MatchIncrementBlock(Blocks.Last()));  					Debug.Assert(bodyStartBlock == Blocks[1]);  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Block,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,CheckInvariant,The following switch statement is missing a default case: switch (this.Kind) {  				case BlockKind.ControlFlow:  					Debug.Assert(finalInstruction.OpCode == OpCode.Nop);  					break;  				case BlockKind.CallInlineAssign:  					Debug.Assert(MatchInlineAssignBlock(out _' out _));  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Sign) {  				case Sign.Signed:  					output.Write(".signed");  					break;  				case Sign.Unsigned:  					output.Write(".unsigned");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Comp,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (LiftingKind) {  				case ComparisonLiftingKind.CSharp:  					output.Write(".lifted[C#]");  					break;  				case ComparisonLiftingKind.ThreeValuedLogic:  					output.Write(".lifted[3VL]");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL,Conv,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Instructions.cs,WriteTo,The following switch statement is missing a default case: switch (Kind) {  				case ConversionKind.SignExtend:  					output.Write("<sign extend>");  					break;  				case ConversionKind.ZeroExtend:  					output.Write("<zero extend>");  					break;  				case ConversionKind.Invalid:  					output.Write("<invalid>");  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertInstruction,The following switch statement is missing a default case: switch (invocation.Method.Name) {  							case "Add":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Add' false);  							case "AddChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Add' true);  							case "And":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitAnd);  							case "AndAlso":  								return ConvertLogicOperator(invocation' true);  							case "ArrayAccess":  							case "ArrayIndex":  								return ConvertArrayIndex(invocation);  							case "ArrayLength":  								return ConvertArrayLength(invocation);  							case "Call":  								return ConvertCall(invocation);  							case "Coalesce":  								return ConvertCoalesce(invocation);  							case "Condition":  								return ConvertCondition(invocation);  							case "Constant":  								return ConvertConstant(invocation);  							case "Convert":  								return ConvertCast(invocation' false);  							case "ConvertChecked":  								return ConvertCast(invocation' true);  							case "Divide":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Div);  							case "Equal":  								return ConvertComparison(invocation' ComparisonKind.Equality);  							case "ExclusiveOr":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitXor);  							case "Field":  								return ConvertField(invocation);  							case "GreaterThan":  								return ConvertComparison(invocation' ComparisonKind.GreaterThan);  							case "GreaterThanOrEqual":  								return ConvertComparison(invocation'  ComparisonKind.GreaterThanOrEqual);  							case "Invoke":  								return ConvertInvoke(invocation);  							case "Lambda":  								return ConvertLambda(invocation);  							case "LeftShift":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.ShiftLeft);  							case "LessThan":  								return ConvertComparison(invocation' ComparisonKind.LessThan);  							case "LessThanOrEqual":  								return ConvertComparison(invocation' ComparisonKind.LessThanOrEqual);  							case "ListInit":  								return ConvertListInit(invocation);  							case "MemberInit":  								return ConvertMemberInit(invocation);  							case "Modulo":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Rem);  							case "Multiply":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Mul' false);  							case "MultiplyChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Mul' true);  							case "Negate":  								return ConvertUnaryNumericOperator(invocation' BinaryNumericOperator.Sub' false);  							case "NegateChecked":  								return ConvertUnaryNumericOperator(invocation' BinaryNumericOperator.Sub' true);  							case "New":  								return ConvertNewObject(invocation);  							case "NewArrayBounds":  								return ConvertNewArrayBounds(invocation);  							case "NewArrayInit":  								return ConvertNewArrayInit(invocation);  							case "Not":  								return ConvertNotOperator(invocation);  							case "NotEqual":  								return ConvertComparison(invocation' ComparisonKind.Inequality);  							case "OnesComplement":  								return ConvertNotOperator(invocation);  							case "Or":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.BitOr);  							case "OrElse":  								return ConvertLogicOperator(invocation' false);  							case "Property":  								return ConvertProperty(invocation);  							case "Quote":  								if (invocation.Arguments.Count == 1)  									return ConvertInstruction(invocation.Arguments.Single());  								else  									return (null' SpecialType.UnknownType);  							case "RightShift":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.ShiftRight);  							case "Subtract":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Sub' false);  							case "SubtractChecked":  								return ConvertBinaryNumericOperator(invocation' BinaryNumericOperator.Sub' true);  							case "TypeAs":  								return ConvertTypeAs(invocation);  							case "TypeIs":  								return ConvertTypeIs(invocation);  						}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertBind,The following switch statement is missing a default case: switch (member) {  				case IMethod method:  					return (new Call(method) { Arguments = { new LdLoc(targetVariable)' value } }' method.ReturnType);  				case IField field:  					return (new StObj(new LdFlda(new LdLoc(targetVariable)' (IField)member)' value' member.ReturnType)' field.ReturnType);  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,ConvertNewObject,The following switch statement is missing a default case: switch (invocation.Arguments.Count) {  				case 1:  					if (MatchGetTypeFromHandle(invocation.Arguments[0]' out var type)) {  						var ctor = type.GetConstructors(c => c.Parameters.Count == 0).FirstOrDefault();  						if (ctor == null)  							return (null' SpecialType.UnknownType);  						return (new NewObj(ctor)' type);  					}  					if (MatchGetConstructorFromHandle(invocation.Arguments[0]' out member)) {  						return (new NewObj((IMethod)member)' member.DeclaringType);  					}  					return (null' SpecialType.UnknownType);  				case 2:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args);  					return (newObj' member.DeclaringType);  				case 3:  					if (!MatchGetConstructorFromHandle(invocation.Arguments[0]' out member))  						return (null' SpecialType.UnknownType);  					if (!MatchArgumentList(invocation.Arguments[1]' out arguments))  						return (null' SpecialType.UnknownType);  					var args2 = arguments.SelectArray(arg => ConvertInstruction(arg).Item1);  					if (args2.Any(a => a == null))  						return (null' SpecialType.UnknownType);  					newObj = new NewObj((IMethod)member);  					newObj.Arguments.AddRange(args2);  					return (newObj' member.DeclaringType);  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetMethodFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetConstructorFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformExpressionTrees,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs,MatchGetFieldFromHandle,The following switch statement is missing a default case: switch (call.Arguments.Count) {  				case 1:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					break;  				case 2:  					if (!call.Arguments[0].MatchLdMemberToken(out member))  						return false;  					if (!call.Arguments[1].MatchLdTypeToken(out var genericType))  						return false;  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameFromInstruction,The following switch statement is missing a default case: switch (inst) {  				case LdObj ldobj:  					return GetNameFromInstruction(ldobj.Target);  				case LdFlda ldflda:  					return CleanUpVariableName(ldflda.Field.Name);  				case LdsFlda ldsflda:  					return CleanUpVariableName(ldsflda.Field.Name);  				case CallInstruction call:  					if (call is NewObj) break;  					IMethod m = call.Method;  					if (m.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && m.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(m.Name.Substring(4));  					} else if (m.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(m.Name.Substring(3));  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,AssignVariableNames,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\AssignVariableNames.cs,GetNameForArgument,The following switch statement is missing a default case: switch (parent) {  				case StObj stobj:  					IField field;  					if (stobj.Target is LdFlda ldflda)  						field = ldflda.Field;  					else if (stobj.Target is LdsFlda ldsflda)  						field = ldsflda.Field;  					else  						break;  					return CleanUpVariableName(field.Name);  				case CallInstruction call:  					IMethod m = call.Method;  					if (m.Parameters.Count == 1 && i == call.Arguments.Count - 1) {  						// argument might be value of a setter  						if (m.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(m.Name.Substring(4));  						} else if (m.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && m.Name.Length >= 4 && char.IsUpper(m.Name[3])) {  							return CleanUpVariableName(m.Name.Substring(3));  						}  					}  					var p = m.Parameters.ElementAtOrDefault((!(call is NewObj) && !m.IsStatic) ? i - 1 : i);  					if (p != null && !string.IsNullOrEmpty(p.Name))  						return CleanUpVariableName(p.Name);  					break;  				case Leave ret:  					return "result";  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformCollectionAndObjectInitializers,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs,DoTransform,The following switch statement is missing a default case: switch (body.Instructions[i + pos]) {  						case CallInstruction call:  							if (!(call is CallVirt || call is Call)) continue;  							var newCall = (CallInstruction)call.Clone();  							var newTarget = newCall.Arguments[0];  							foreach (var load in newTarget.Descendants.OfType<IInstructionWithVariableOperand>())  								if ((load is LdLoc || load is LdLoca) && load.Variable == v)  									load.Variable = finalSlot;  							initializerBlock.Instructions.Add(newCall);  							break;  						case StObj stObj:  							var newStObj = (StObj)stObj.Clone();  							foreach (var load in newStObj.Target.Descendants.OfType<IInstructionWithVariableOperand>())  								if ((load is LdLoc || load is LdLoca) && load.Variable == v)  									load.Variable = finalSlot;  							initializerBlock.Instructions.Add(newStObj);  							break;  						case StLoc stLoc:  							var newStLoc = (StLoc)stLoc.Clone();  							initializerBlock.Instructions.Add(newStLoc);  							break;  					}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,ILInlining,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ILInlining.cs,NonAggressiveInlineInto,The following switch statement is missing a default case: switch (inlinedExpression.OpCode) {  				case OpCode.DefaultValue:  				case OpCode.StObj:  				case OpCode.CompoundAssignmentInstruction:  				case OpCode.Await:  					return true;  				case OpCode.LdLoc:  					if (v.StateMachineField == null && ((LdLoc)inlinedExpression).Variable.StateMachineField != null) {  						// Roslyn likes to put the result of fetching a state machine field into a temporary variable'  						// so inline more aggressively in such cases.  						return true;  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,ExpressionTransforms,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\ExpressionTransforms.cs,VisitBinaryNumericInstruction,The following switch statement is missing a default case: switch (inst.Operator) {  				case BinaryNumericOperator.ShiftLeft:  				case BinaryNumericOperator.ShiftRight:  					if (inst.Right.MatchBinaryNumericInstruction(BinaryNumericOperator.BitAnd' out var lhs' out var rhs)  						&& rhs.MatchLdcI4(inst.ResultType == StackType.I8 ? 63 : 31))  					{  						// a << (b & 31) => a << b  						context.Step("Combine bit.and into shift"' inst);  						inst.Right = lhs;  					}  					break;  			}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,SplitVariables,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\SplitVariables.cs,AddressUsedOnlyForReading,The following switch statement is missing a default case: switch (call.Method.Name) {  							case "get_HasValue":  							case "get_Value":  							case "GetValueOrDefault":  								return true;  						}
Missing Default,ICSharpCode.Decompiler.IL.Transforms,TransformAssignment,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs,IsImplicitTruncation,The following switch statement is missing a default case: switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode) {  					case KnownTypeCode.Boolean:  						return !(val == 0 || val == 1);  					case KnownTypeCode.Byte:  						return !(val >= byte.MinValue && val <= byte.MaxValue);  					case KnownTypeCode.SByte:  						return !(val >= sbyte.MinValue && val <= sbyte.MaxValue);  					case KnownTypeCode.Int16:  						return !(val >= short.MinValue && val <= short.MaxValue);  					case KnownTypeCode.UInt16:  					case KnownTypeCode.Char:  						return !(val >= ushort.MinValue && val <= ushort.MaxValue);  				}
Missing Default,ICSharpCode.Decompiler.IL.ControlFlow,YieldReturnDecompiler,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\IL\ControlFlow\YieldReturnDecompiler.cs,ConvertBody,The following switch statement is missing a default case: switch (inst) {  					case Branch branch:  						if (branch.TargetContainer == oldBody) {  							branch.TargetBlock = newBody.Blocks[branch.TargetBlock.ChildIndex];  						}  						break;  					case Leave leave:  						if (leave.MatchReturn(out var value)) {  							if (value.MatchLdLoc(out var v) && v.IsSingleDefinition  								&& v.StoreInstructions.SingleOrDefault() is StLoc stloc) {  								returnStores.Add(stloc);  								value = stloc.Value;  							}  							if (value.MatchLdcI4(0)) {  								// yield break  								leave.ReplaceWith(new Leave(newBody) { ILRange = leave.ILRange });  							} else {  								leave.ReplaceWith(new InvalidBranch("Unexpected return in MoveNext()") { ILRange = leave.ILRange });  							}  						} else {  							if (leave.TargetContainer == oldBody) {  								leave.TargetContainer = newBody;  							}  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  				case CR:  				if (nextChar != null && nextChar () == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  				case LF:  				return UnicodeNewline.LF;  				case NEL:  				return UnicodeNewline.NEL;  				case VT:  				return UnicodeNewline.VT;  				case FF:  				return UnicodeNewline.FF;  				case LS:  				return UnicodeNewline.LS;  				case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.Decompiler.Util,NewLine,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  			case CR:  				if (nextChar == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  			case LF:  				return UnicodeNewline.LF;  			case NEL:  				return UnicodeNewline.NEL;  			case VT:  				return UnicodeNewline.VT;  			case FF:  				return UnicodeNewline.FF;  			case LS:  				return UnicodeNewline.LS;  			case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}
Missing Default,ICSharpCode.Decompiler.Util,CSharpPrimitiveCast,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Util\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}
Missing Default,ICSharpCode.Decompiler.Disassembler,ILStructure,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Disassembler\ILStructure.cs,FindAllBranches,The following switch statement is missing a default case: switch (inst.OpCode.OperandType) {  					case OperandType.InlineBrTarget:  					case OperandType.ShortInlineBrTarget:  						result.Add(new KeyValuePair<Instruction' Instruction>(inst' (Instruction)inst.Operand));  						break;  					case OperandType.InlineSwitch:  						foreach (Instruction target in (Instruction[])inst.Operand)  							result.Add(new KeyValuePair<Instruction' Instruction>(inst' target));  						break;  				}
Missing Default,ICSharpCode.Decompiler.Semantics,BuiltinConversion,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\Conversion.cs,ToString,The following switch statement is missing a default case: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Missing Default,ICSharpCode.Decompiler.Semantics,MemberResolveResult,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\Semantics\MemberResolveResult.cs,ComputeType,The following switch statement is missing a default case: switch (member.SymbolKind) {  				case SymbolKind.Constructor:  					return member.DeclaringType ?? SpecialType.UnknownType;  				case SymbolKind.Field:  					if (((IField)member).IsFixed)  						return new PointerType(member.ReturnType);  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The following switch statement is missing a default case: switch (info.Attributes & PInvokeAttributes.CharSetMask) {  					case PInvokeAttributes.CharSetAnsi:  						charSet = CharSet.Ansi;  						break;  					case PInvokeAttributes.CharSetAuto:  						charSet = CharSet.Auto;  						break;  					case PInvokeAttributes.CharSetUnicode:  						charSet = CharSet.Unicode;  						break;  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.LayoutMask) {  				case TypeAttributes.SequentialLayout:  					layoutKind = LayoutKind.Sequential;  					break;  				case TypeAttributes.ExplicitLayout:  					layoutKind = LayoutKind.Explicit;  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.StringFormatMask) {  				case TypeAttributes.AnsiClass:  					charSet = CharSet.Ansi;  					break;  				case TypeAttributes.AutoClass:  					charSet = CharSet.Auto;  					break;  				case TypeAttributes.UnicodeClass:  					charSet = CharSet.Unicode;  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,InitTypeModifiers,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.VisibilityMask) {  				case TypeAttributes.NotPublic:  				case TypeAttributes.NestedAssembly:  					td.Accessibility = Accessibility.Internal;  					break;  				case TypeAttributes.Public:  				case TypeAttributes.NestedPublic:  					td.Accessibility = Accessibility.Public;  					break;  				case TypeAttributes.NestedPrivate:  					td.Accessibility = Accessibility.Private;  					break;  				case TypeAttributes.NestedFamily:  					td.Accessibility = Accessibility.Protected;  					break;  				case TypeAttributes.NestedFamANDAssem:  					td.Accessibility = Accessibility.ProtectedAndInternal;  					break;  				case TypeAttributes.NestedFamORAssem:  					td.Accessibility = Accessibility.ProtectedOrInternal;  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,CecilLoader,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\CecilLoader.cs,AddConstraints,The following switch statement is missing a default case: switch (g.Attributes & GenericParameterAttributes.VarianceMask) {  				case GenericParameterAttributes.Contravariant:  					tp.Variance = VarianceModifier.Contravariant;  					break;  				case GenericParameterAttributes.Covariant:  					tp.Variance = VarianceModifier.Covariant;  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,ReflectionHelper,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs,SkipAheadAndReadAssemblyName,The following switch statement is missing a default case: switch (reflectionTypeName[pos++]) {  					case '[':  						nestingLevel++;  						break;  					case ']':  						if (nestingLevel == 0)  							return null;  						nestingLevel--;  						break;  					case ''':  						if (nestingLevel == 0) {  							// first skip the whitespace  							while (pos < reflectionTypeName.Length && reflectionTypeName[pos] == ' ')  								pos++;  							// everything up to the end/next ']' is the assembly name  							int endPos = pos;  							while (endPos < reflectionTypeName.Length && reflectionTypeName[endPos] != ']')  								endPos++;  							return reflectionTypeName.Substring(pos' endPos - pos);  						}  						break;  				}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following switch statement is missing a default case: switch (type.Kind) {  				case TypeKind.Pointer:  				case TypeKind.ByReference:  				case TypeKind.Class:  					return NativeIntSize;  				case TypeKind.Enum:  					type = type.GetEnumUnderlyingType();  					break;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetSize,The following switch statement is missing a default case: switch (typeDef.KnownTypeCode) {  				case KnownTypeCode.Boolean:  				case KnownTypeCode.SByte:  				case KnownTypeCode.Byte:  					return 1;  				case KnownTypeCode.Char:  				case KnownTypeCode.Int16:  				case KnownTypeCode.UInt16:  					return 2;  				case KnownTypeCode.Int32:  				case KnownTypeCode.UInt32:  				case KnownTypeCode.Single:  					return 4;  				case KnownTypeCode.IntPtr:  				case KnownTypeCode.UIntPtr:  					return NativeIntSize;  				case KnownTypeCode.Int64:  				case KnownTypeCode.UInt64:  				case KnownTypeCode.Double:  					return 8;  			}
Missing Default,ICSharpCode.Decompiler.TypeSystem,TypeUtils,C:\repos\icsharpcode_ILSpy\ICSharpCode.Decompiler\TypeSystem\TypeUtils.cs,GetStackType,The following switch statement is missing a default case: switch (type.Kind) {  				case TypeKind.Unknown:  					return StackType.Unknown;  				case TypeKind.ByReference:  					return StackType.Ref;  				case TypeKind.Pointer:  					return StackType.I;  			}
