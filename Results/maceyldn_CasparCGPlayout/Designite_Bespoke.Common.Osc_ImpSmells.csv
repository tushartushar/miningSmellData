Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Bespoke.Common.Osc,OscMessage,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscMessage.cs,FromByteArray,Cyclomatic complexity of the method is 25
Complex Method,Bespoke.Common.Osc,OscMessage,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscMessage.cs,Append,Cyclomatic complexity of the method is 20
Complex Method,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,Cyclomatic complexity of the method is 27
Complex Method,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueToByteArray,Cyclomatic complexity of the method is 32
Complex Method,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,OscServer,Cyclomatic complexity of the method is 12
Complex Method,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,Start,Cyclomatic complexity of the method is 10
Complex Method,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,Stop,Cyclomatic complexity of the method is 11
Complex Method,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,DataReceived,Cyclomatic complexity of the method is 10
Long Parameter List,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,OscServer,The method has 5 parameters.
Long Parameter List,Bespoke.Common.Osc,OscServer,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscServer.cs,OscServer,The method has 6 parameters.
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String") {  	int count = 0;  	for (int index = start; index < data.Length && data [index] != 0; index++) {  		count++;  	}  	value = Encoding.ASCII.GetString (data' start' count);  	start += count + 1;  	start = ((start + 3) / 4) * 4;  	Assert.IsTrue (((String)value).Length > 0);  }  else if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "Byte[]") {  	int length = ValueFromByteArray<int> (data' ref start);  	byte[] buffer = new byte[length];  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length + 1;  	start = ((start + 3) / 4) * 4;  	value = buffer;  }  else {  	byte[] buffer;  	switch (type.Name) {  	case "Int32":  	case "Single":  		buffer = new byte[4];  		break;  	case "Int64":  	case "Double":  		buffer = new byte[8];  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  	Array.Copy (data' start' buffer' 0' buffer.Length);  	start += buffer.Length;  	if (BitConverter.IsLittleEndian != sLittleEndianByteOrder) {  		buffer = Library.SwapEndian (buffer);  	}  	switch (type.Name) {  	case "Int32":  		value = BitConverter.ToInt32 (buffer' 0);  		break;  	case "Int64":  		value = BitConverter.ToInt64 (buffer' 0);  		break;  	case "Single":  		value = BitConverter.ToSingle (buffer' 0);  		break;  	case "Double":  		value = BitConverter.ToDouble (buffer' 0);  		break;  	default:  		throw new Exception ("Unsupported data type.");  	}  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: start = ((start + 3) / 4) * 4;  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: switch (type.Name) {  case "Int32":  case "Single":  	buffer = new byte[4];  	break;  case "Int64":  case "Double":  	buffer = new byte[8];  	break;  default:  	throw new Exception ("Unsupported data type.");  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: switch (type.Name) {  case "Int32":  case "Single":  	buffer = new byte[4];  	break;  case "Int64":  case "Double":  	buffer = new byte[8];  	break;  default:  	throw new Exception ("Unsupported data type.");  }  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: buffer = new byte[4];  
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\maceyldn_CasparCGPlayout\Dependencies\OSCFramework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: buffer = new byte[8];  
