Implementation smell,Namespace,Class,File,Method,Description
Long Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Call,The method has 65 lines of code.
Long Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The method has 188 lines of code.
Complex Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Wrap,Cyclomatic complexity of the method is 11
Complex Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,Cyclomatic complexity of the method is 62
Complex Method,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,AsLuaValue,Cyclomatic complexity of the method is 7
Complex Method,Eluant,LuaValueExtensions,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaValueExtensions.cs,CreateEnumerateArrayEnumerable,Cyclomatic complexity of the method is 7
Complex Method,Eluant,MemoryConstrainedLuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\MemoryConstrainedLuaRuntime.cs,Allocate,Cyclomatic complexity of the method is 7
Long Parameter List,Eluant,LuaApi,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaApi.cs,lua_pcall,The method has 4 parameters.
Long Parameter List,Eluant,MemoryConstrainedLuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\MemoryConstrainedLuaRuntime.cs,Allocate,The method has 4 parameters.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__add"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaAdditionBinding> (state' (i' a' b) => i.Add (this' a' b))); " is 150.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__sub"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaSubtractionBinding> (state' (i' a' b) => i.Subtract (this' a' b))); " is 158.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__mul"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaMultiplicationBinding> (state' (i' a' b) => i.Multiply (this' a' b))); " is 161.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__div"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaDivisionBinding> (state' (i' a' b) => i.Divide (this' a' b))); " is 153.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__mod"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaModuloBinding> (state' (i' a' b) => i.Modulo (this' a' b))); " is 151.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__pow"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaExponentiationBinding> (state' (i' a' b) => i.Power (this' a' b))); " is 158.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__unm"] = CreateCallbackWrapper (state => UnaryOperatorCallback<ILuaUnaryMinusBinding> (state' i => i.Minus (this))); " is 139.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__concat"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaConcatenationBinding> (state' (i' a' b) => i.Concatenate (this' a' b))); " is 166.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__len"] = CreateCallbackWrapper (state => UnaryOperatorCallback<ILuaLengthBinding> (state' i => i.GetLength (this))); " is 139.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__eq"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaEqualityBinding> (state' (i' a' b) => i.Equals (this' a' b))); " is 152.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__lt"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaLessThanBinding> (state' (i' a' b) => i.LessThan (this' a' b))); " is 154.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The length of the statement  "	metamethodCallbacks ["__le"] = CreateCallbackWrapper (state => BinaryOperatorCallback<ILuaLessThanOrEqualToBinding> (state' (i' a' b) => i.LessThanOrEqualTo (this' a' b))); " is 172.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,GetClrObject,The length of the statement  "		throw new InvalidOperationException ("Attempt to obtain CLR object from a Lua object that does not represent a CLR object."); " is 125.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,GetClrObject,The length of the statement  "		throw new InvalidOperationException (string.Format ("CLR object of type {0} was found' but CLR object of incompatible type {1} was expected."' obj.GetType ().FullName' typeof(T).FullName)); " is 189.
Long Statement,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The length of the statement  "		var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ()); " is 184.
Long Statement,Eluant,Scripts,D:\newReposJune17\cdhowie_Eluant\Eluant\Scripts.cs,GetResource,The length of the statement  "	using (var s = new StreamReader (Assembly.GetExecutingAssembly ().GetManifestResourceStream ("Eluant." + file)' Encoding.UTF8)) { " is 129.
Long Statement,Eluant.ObjectBinding,BasicLuaBinder,D:\newReposJune17\cdhowie_Eluant\Eluant\ObjectBinding\BasicLuaBinder.cs,GetMembersByName,The length of the statement  "		foreach (var memberNameAttr in member.GetCustomAttributes (typeof(LuaMemberAttribute)' true).Cast<LuaMemberAttribute> ()) { " is 123.
Long Statement,Eluant.ObjectBinding,BasicLuaBinder,D:\newReposJune17\cdhowie_Eluant\Eluant\ObjectBinding\BasicLuaBinder.cs,ObjectToLuaValue,The length of the statement  "	return runtime.AsLuaValue (obj) ?? new LuaTransparentClrObject (obj' bindingContext.Binder' bindingContext.BindingSecurityPolicy); " is 130.
Virtual Method Call from Constructor,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,LuaRuntime,The constructor "LuaRuntime" calls a virtual method "CreateAllocatorDelegate".
Empty Catch Block,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,ClrObjectGcCallback,The method has an empty catch block.
Empty Catch Block,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,AsLuaValue,The method has an empty catch block.
Empty Catch Block,Eluant,LuaNumber,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaNumber.cs,ToClrType,The method has an empty catch block.
Empty Catch Block,Eluant,LuaClrObjectReference,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaClrObjectReference.cs,ToClrType,The method has an empty catch block.
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Initialize,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: while (LuaApi.lua_next (LuaState' -3) != 0) {  	// Stack: reftable newtable key value  	// Goal:  reftable newtable key key value  	// reftable newtable key value key  	LuaApi.lua_pushvalue (LuaState' -2);  	// reftable newtable key key value  	LuaApi.lua_insert (LuaState' LuaApi.abs_index (LuaState' -2));  	// reftable newtable key  	LuaApi.lua_settable (LuaState' -4);  	// All set for next iteration.  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: while (LuaApi.lua_next (LuaState' -3) != 0) {  	// Stack: reftable newtable key value  	// Goal:  reftable newtable key key value  	// reftable newtable key value key  	LuaApi.lua_pushvalue (LuaState' -2);  	// reftable newtable key key value  	LuaApi.lua_insert (LuaState' LuaApi.abs_index (LuaState' -2));  	// reftable newtable key  	LuaApi.lua_settable (LuaState' -4);  	// All set for next iteration.  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: while (LuaApi.lua_next (LuaState' -3) != 0) {  	// Stack: reftable newtable key value  	// Goal:  reftable newtable key key value  	// reftable newtable key value key  	LuaApi.lua_pushvalue (LuaState' -2);  	// reftable newtable key key value  	LuaApi.lua_insert (LuaState' LuaApi.abs_index (LuaState' -2));  	// reftable newtable key  	LuaApi.lua_settable (LuaState' -4);  	// All set for next iteration.  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: while (LuaApi.lua_next (LuaState' -3) != 0) {  	// Stack: reftable newtable key value  	// Goal:  reftable newtable key key value  	// reftable newtable key value key  	LuaApi.lua_pushvalue (LuaState' -2);  	// reftable newtable key key value  	LuaApi.lua_insert (LuaState' LuaApi.abs_index (LuaState' -2));  	// reftable newtable key  	LuaApi.lua_settable (LuaState' -4);  	// All set for next iteration.  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: LuaApi.lua_pushvalue (LuaState' -2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: LuaApi.lua_insert (LuaState' LuaApi.abs_index (LuaState' -2));  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,RewriteReferenceTable,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -4);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,GetNextReference,The following statement contains a magic number: if (++referenceSeq == 100) {  	// Every hundred references taken' reset lastReference so that we try to reuse slots in the reference  	// table.  Otherwise the table is going to grow very large.  	referenceSeq = 0;  	lastReference = 0;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateReference,The following statement contains a magic number: LuaApi.lua_rawseti (LuaState' -2' reference);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,DestroyReference,The following statement contains a magic number: LuaApi.lua_rawseti (LuaState' -2' reference);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,DestroyReference,The following statement contains a magic number: if (++destroySeq == 1000) {  	destroySeq = 0;  	RewriteReferenceTable ();  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushReference,The following statement contains a magic number: LuaApi.lua_remove (LuaState' LuaApi.abs_index (LuaState' -2));  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,HasMetatable,The following statement contains a magic number: try {  	if (LuaApi.lua_getmetatable (LuaState' index) == 0) {  		return false;  	}  	LuaApi.luaL_getmetatable (LuaState' tableName);  	return LuaApi.lua_rawequal (LuaState' -1' -2) != 0;  } finally {  	LuaApi.lua_settop (LuaState' top);  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,HasMetatable,The following statement contains a magic number: return LuaApi.lua_rawequal (LuaState' -1' -2) != 0;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,IsClrObject,The following statement contains a magic number: LuaApi.lua_gettable (LuaState' -2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,IsClrObject,The following statement contains a magic number: LuaApi.lua_pop (LuaState' 2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCFunction,The following statement contains a magic number: LuaApi.lua_pushcclosure (LuaState' cFunctionCallback' 2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CFunctionCallback,The following statement contains a magic number: try {  	var runtime = GetSelf (state' LuaApi.lua_upvalueindex (1));  	fn = (LuaApi.lua_CFunction)runtime.TryGetClrObject<LuaOpaqueClrObject> (LuaApi.lua_upvalueindex (2)).ClrObject;  } catch {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Unexpected error processing callback.");  	return 2;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CFunctionCallback,The following statement contains a magic number: try {  	var runtime = GetSelf (state' LuaApi.lua_upvalueindex (1));  	fn = (LuaApi.lua_CFunction)runtime.TryGetClrObject<LuaOpaqueClrObject> (LuaApi.lua_upvalueindex (2)).ClrObject;  } catch {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Unexpected error processing callback.");  	return 2;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CFunctionCallback,The following statement contains a magic number: fn = (LuaApi.lua_CFunction)runtime.TryGetClrObject<LuaOpaqueClrObject> (LuaApi.lua_upvalueindex (2)).ClrObject;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CFunctionCallback,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushOpaqueClrObject,The following statement contains a magic number: LuaApi.lua_setmetatable (LuaState' -2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: try {  	PushNewReferenceValue (reference);  	// We will build up a unique metatable for this object based on the bindings it has implemented.  	LuaApi.lua_newtable (LuaState);  	// Set flag so that TryGetReference knows that this is a CLR object.  	LuaApi.lua_pushstring (LuaState' "is_clr_object");  	LuaApi.lua_pushboolean (LuaState' 1);  	LuaApi.lua_settable (LuaState' -3);  	// Protect the metatable.  	LuaApi.lua_pushstring (LuaState' "__metatable");  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_settable (LuaState' -3);  	// __gc is required to clean up the reference.  The callback will determine if it implements the  	// interface.  	LuaApi.lua_pushstring (LuaState' "__gc");  	PushSelf ();  	LuaApi.lua_pushcclosure (LuaState' clrObjectGcCallbackWrapper' 1);  	LuaApi.lua_settable (LuaState' -3);  	// For all others' we use MetamethodAttribute on the interface to make this code less repetitive.  	var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ());  	foreach (var metamethod in metamethods) {  		LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  		Push (metamethodCallbacks [metamethod.MethodName]);  		LuaApi.lua_settable (LuaState' -3);  	}  	LuaApi.lua_setmetatable (LuaState' -2);  } catch {  	objectReferenceManager.DestroyReference (reference);  	throw;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: try {  	PushNewReferenceValue (reference);  	// We will build up a unique metatable for this object based on the bindings it has implemented.  	LuaApi.lua_newtable (LuaState);  	// Set flag so that TryGetReference knows that this is a CLR object.  	LuaApi.lua_pushstring (LuaState' "is_clr_object");  	LuaApi.lua_pushboolean (LuaState' 1);  	LuaApi.lua_settable (LuaState' -3);  	// Protect the metatable.  	LuaApi.lua_pushstring (LuaState' "__metatable");  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_settable (LuaState' -3);  	// __gc is required to clean up the reference.  The callback will determine if it implements the  	// interface.  	LuaApi.lua_pushstring (LuaState' "__gc");  	PushSelf ();  	LuaApi.lua_pushcclosure (LuaState' clrObjectGcCallbackWrapper' 1);  	LuaApi.lua_settable (LuaState' -3);  	// For all others' we use MetamethodAttribute on the interface to make this code less repetitive.  	var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ());  	foreach (var metamethod in metamethods) {  		LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  		Push (metamethodCallbacks [metamethod.MethodName]);  		LuaApi.lua_settable (LuaState' -3);  	}  	LuaApi.lua_setmetatable (LuaState' -2);  } catch {  	objectReferenceManager.DestroyReference (reference);  	throw;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: try {  	PushNewReferenceValue (reference);  	// We will build up a unique metatable for this object based on the bindings it has implemented.  	LuaApi.lua_newtable (LuaState);  	// Set flag so that TryGetReference knows that this is a CLR object.  	LuaApi.lua_pushstring (LuaState' "is_clr_object");  	LuaApi.lua_pushboolean (LuaState' 1);  	LuaApi.lua_settable (LuaState' -3);  	// Protect the metatable.  	LuaApi.lua_pushstring (LuaState' "__metatable");  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_settable (LuaState' -3);  	// __gc is required to clean up the reference.  The callback will determine if it implements the  	// interface.  	LuaApi.lua_pushstring (LuaState' "__gc");  	PushSelf ();  	LuaApi.lua_pushcclosure (LuaState' clrObjectGcCallbackWrapper' 1);  	LuaApi.lua_settable (LuaState' -3);  	// For all others' we use MetamethodAttribute on the interface to make this code less repetitive.  	var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ());  	foreach (var metamethod in metamethods) {  		LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  		Push (metamethodCallbacks [metamethod.MethodName]);  		LuaApi.lua_settable (LuaState' -3);  	}  	LuaApi.lua_setmetatable (LuaState' -2);  } catch {  	objectReferenceManager.DestroyReference (reference);  	throw;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: try {  	PushNewReferenceValue (reference);  	// We will build up a unique metatable for this object based on the bindings it has implemented.  	LuaApi.lua_newtable (LuaState);  	// Set flag so that TryGetReference knows that this is a CLR object.  	LuaApi.lua_pushstring (LuaState' "is_clr_object");  	LuaApi.lua_pushboolean (LuaState' 1);  	LuaApi.lua_settable (LuaState' -3);  	// Protect the metatable.  	LuaApi.lua_pushstring (LuaState' "__metatable");  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_settable (LuaState' -3);  	// __gc is required to clean up the reference.  The callback will determine if it implements the  	// interface.  	LuaApi.lua_pushstring (LuaState' "__gc");  	PushSelf ();  	LuaApi.lua_pushcclosure (LuaState' clrObjectGcCallbackWrapper' 1);  	LuaApi.lua_settable (LuaState' -3);  	// For all others' we use MetamethodAttribute on the interface to make this code less repetitive.  	var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ());  	foreach (var metamethod in metamethods) {  		LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  		Push (metamethodCallbacks [metamethod.MethodName]);  		LuaApi.lua_settable (LuaState' -3);  	}  	LuaApi.lua_setmetatable (LuaState' -2);  } catch {  	objectReferenceManager.DestroyReference (reference);  	throw;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: try {  	PushNewReferenceValue (reference);  	// We will build up a unique metatable for this object based on the bindings it has implemented.  	LuaApi.lua_newtable (LuaState);  	// Set flag so that TryGetReference knows that this is a CLR object.  	LuaApi.lua_pushstring (LuaState' "is_clr_object");  	LuaApi.lua_pushboolean (LuaState' 1);  	LuaApi.lua_settable (LuaState' -3);  	// Protect the metatable.  	LuaApi.lua_pushstring (LuaState' "__metatable");  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_settable (LuaState' -3);  	// __gc is required to clean up the reference.  The callback will determine if it implements the  	// interface.  	LuaApi.lua_pushstring (LuaState' "__gc");  	PushSelf ();  	LuaApi.lua_pushcclosure (LuaState' clrObjectGcCallbackWrapper' 1);  	LuaApi.lua_settable (LuaState' -3);  	// For all others' we use MetamethodAttribute on the interface to make this code less repetitive.  	var metamethods = obj.BackingCustomObject.GetType ().GetInterfaces ().SelectMany (iface => iface.GetCustomAttributes (typeof(MetamethodAttribute)' false).Cast<MetamethodAttribute> ());  	foreach (var metamethod in metamethods) {  		LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  		Push (metamethodCallbacks [metamethod.MethodName]);  		LuaApi.lua_settable (LuaState' -3);  	}  	LuaApi.lua_setmetatable (LuaState' -2);  } catch {  	objectReferenceManager.DestroyReference (reference);  	throw;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: foreach (var metamethod in metamethods) {  	LuaApi.lua_pushstring (LuaState' metamethod.MethodName);  	Push (metamethodCallbacks [metamethod.MethodName]);  	LuaApi.lua_settable (LuaState' -3);  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: LuaApi.lua_settable (LuaState' -3);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,PushCustomClrObject,The following statement contains a magic number: LuaApi.lua_setmetatable (LuaState' -2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,NewindexCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	// Arguments: Userdata (CLR object)' key (property)' value  	var obj = GetClrObject<LuaClrObjectValue> (1).BackingCustomObject as ILuaTableBinding;  	if (obj == null) {  		throw new LuaException ("CLR object does not support indexing.");  	}  	var key = Wrap (2);  	toDispose.Add (key);  	var value = Wrap (3);  	toDispose.Add (value);  	obj [this' key] = value;  	return 0;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,NewindexCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	// Arguments: Userdata (CLR object)' key (property)' value  	var obj = GetClrObject<LuaClrObjectValue> (1).BackingCustomObject as ILuaTableBinding;  	if (obj == null) {  		throw new LuaException ("CLR object does not support indexing.");  	}  	var key = Wrap (2);  	toDispose.Add (key);  	var value = Wrap (3);  	toDispose.Add (value);  	obj [this' key] = value;  	return 0;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,IndexCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	// Arguments: Userdata (CLR object)' key (property)  	var obj = GetClrObject<LuaClrObjectValue> (1).BackingCustomObject as ILuaTableBinding;  	if (obj == null) {  		throw new LuaException ("CLR object does not support indexing.");  	}  	var key = Wrap (2);  	toDispose.Add (key);  	var value = obj [this' key];  	toDispose.Add (value);  	Push (value);  	return 1;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CallCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	var obj = GetClrObject<LuaClrObjectValue> (1).BackingCustomObject as ILuaCallBinding;  	if (obj == null) {  		throw new LuaException ("CLR object is not callable.");  	}  	var nargs = LuaApi.lua_gettop (LuaState) - 1;  	var args = new LuaValue[nargs];  	for (int i = 0; i < nargs; ++i) {  		args [i] = Wrap (i + 2);  		toDispose.Add (args [i]);  	}  	var vararg = new LuaVararg (args' true);  	var results = obj.Call (this' vararg);  	toDispose.Add (results);  	if (LuaApi.lua_checkstack (LuaState' 1 + results.Count) == 0) {  		throw new LuaException ("Cannot grow stack for results.");  	}  	foreach (var v in results) {  		Push (v);  	}  	return results.Count;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CallCallback,The following statement contains a magic number: for (int i = 0; i < nargs; ++i) {  	args [i] = Wrap (i + 2);  	toDispose.Add (args [i]);  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CallCallback,The following statement contains a magic number: args [i] = Wrap (i + 2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,BinaryOperatorCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	// For binary operators' the right argument could be a CLR object while the left argument might not' and  	// only one is guaranteed to support the given interface.  So we need to do some tests.  	LuaClrObjectValue obj;  	T binding = null;  	if ((obj = TryGetClrObject<LuaClrObjectValue> (1)) != null) {  		binding = obj.BackingCustomObject as T;  	}  	if (binding == null && (obj = TryGetClrObject<LuaClrObjectValue> (2)) != null) {  		binding = obj.BackingCustomObject as T;  	}  	if (binding == null) {  		throw new LuaException ("Binary operator not found for CLR object.");  	}  	var left = Wrap (1);  	toDispose.Add (left);  	var right = Wrap (2);  	toDispose.Add (right);  	var result = oper (binding' left' right);  	toDispose.Add (result);  	Push (result);  	return 1;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,BinaryOperatorCallback,The following statement contains a magic number: return LuaToClrBoundary (state' toDispose => {  	// For binary operators' the right argument could be a CLR object while the left argument might not' and  	// only one is guaranteed to support the given interface.  So we need to do some tests.  	LuaClrObjectValue obj;  	T binding = null;  	if ((obj = TryGetClrObject<LuaClrObjectValue> (1)) != null) {  		binding = obj.BackingCustomObject as T;  	}  	if (binding == null && (obj = TryGetClrObject<LuaClrObjectValue> (2)) != null) {  		binding = obj.BackingCustomObject as T;  	}  	if (binding == null) {  		throw new LuaException ("Binary operator not found for CLR object.");  	}  	var left = Wrap (1);  	toDispose.Add (left);  	var right = Wrap (2);  	toDispose.Add (right);  	var result = oper (binding' left' right);  	toDispose.Add (result);  	Push (result);  	return 1;  });  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,BinaryOperatorCallback,The following statement contains a magic number: if (binding == null && (obj = TryGetClrObject<LuaClrObjectValue> (2)) != null) {  	binding = obj.BackingCustomObject as T;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateTable,The following statement contains a magic number: foreach (var v in values) {  	Push (v);  	LuaApi.lua_rawseti (LuaState' -2' i);  	++i;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateTable,The following statement contains a magic number: LuaApi.lua_rawseti (LuaState' -2' i);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CheckOnMainThread,The following statement contains a magic number: if (state != GetMainThread (state)) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Cannot enter the CLR from inside of a Lua coroutine.");  	return 2;  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CheckOnMainThread,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MethodWrapperCallCallback,The following statement contains a magic number: try {  	var wrapper = (MethodWrapper)(GetClrObject<LuaClrObjectValue> (LuaApi.lua_upvalueindex (2)).ClrObject);  	return MakeManagedCall (state' wrapper);  } finally {  	OnEnterLua ();  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateFunctionFromMethodWrapper,The following statement contains a magic number: try {  	Push (createManagedCallWrapper);  	PushSelf ();  	Push (new LuaOpaqueClrObject (wrapper));  	LuaApi.lua_pushcclosure (LuaState' methodWrapperCallCallbackWrapper' 2);  	if (LuaApi.lua_pcall (LuaState' 1' 1' 0) != 0) {  		throw new InvalidOperationException ("Unable to create wrapper function.");  	}  	return (LuaFunction)Wrap (-1);  } finally {  	LuaApi.lua_settop (LuaState' top);  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateFunctionFromMethodWrapper,The following statement contains a magic number: LuaApi.lua_pushcclosure (LuaState' methodWrapperCallCallbackWrapper' 2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,LuaToClrBoundary,The following statement contains a magic number: try {  	// Pre-push the success flag.  	LuaApi.lua_pushboolean (LuaState' 1);  	return callback (toDispose) + 1;  } catch (LuaException ex) {  	// If something bad happens' we can't be sure how much space is left on the stack.  Lua guarantees 20  	// free slots from the top' so restore the top back to the initial value to make sure we have enough  	// space to report the error.  	//  	// The same thing goes for the other exception handler.  	LuaApi.lua_settop (state' oldTop);  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_pushstring (LuaState' ex.Message);  	return 2;  } catch (Exception ex) {  	LuaApi.lua_settop (state' oldTop);  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Uncaught CLR exception at Lua->CLR boundary: " + ex.ToString ());  	return 2;  } finally {  	try {  		foreach (var i in toDispose) {  			if (i != null) {  				i.Dispose ();  			}  		}  	} finally {  		// If something bad happens while disposing stuff that's okay... but we CAN'T skip this' or Lua code  		// running under a MemoryConstrainedLuaRuntime would be able to allocate more memory than the limit.  		OnEnterLua ();  	}  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,LuaToClrBoundary,The following statement contains a magic number: try {  	// Pre-push the success flag.  	LuaApi.lua_pushboolean (LuaState' 1);  	return callback (toDispose) + 1;  } catch (LuaException ex) {  	// If something bad happens' we can't be sure how much space is left on the stack.  Lua guarantees 20  	// free slots from the top' so restore the top back to the initial value to make sure we have enough  	// space to report the error.  	//  	// The same thing goes for the other exception handler.  	LuaApi.lua_settop (state' oldTop);  	LuaApi.lua_pushboolean (LuaState' 0);  	LuaApi.lua_pushstring (LuaState' ex.Message);  	return 2;  } catch (Exception ex) {  	LuaApi.lua_settop (state' oldTop);  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Uncaught CLR exception at Lua->CLR boundary: " + ex.ToString ());  	return 2;  } finally {  	try {  		foreach (var i in toDispose) {  			if (i != null) {  				i.Dispose ();  			}  		}  	} finally {  		// If something bad happens while disposing stuff that's okay... but we CAN'T skip this' or Lua code  		// running under a MemoryConstrainedLuaRuntime would be able to allocate more memory than the limit.  		OnEnterLua ();  	}  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,LuaToClrBoundary,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,LuaToClrBoundary,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: try {  	// As with Call()' we are crossing a Lua<->CLR boundary' so release any references that have been   	// queued to be released.  	ProcessReleasedReferences ();  	var nargs = LuaApi.lua_gettop (state);  	// By Lua convention' extra arguments are ignored.  For omitted/nil arguments' we will first see if the  	// managed argument declaration specifies a default value.  Otherwise' for reference/nullable arguments'  	// we will pass null (by Lua convention).  Otherwise' we will raise an error.  	//  	// For numeric types will try to be smart and convert the argument' if possible.  	var parms = wrapper.Method.GetParameters ();  	object[] args;  	LuaValue wrapped;  	if (parms.Length == 1 && parms [0].ParameterType == typeof(LuaVararg)) {  		// Special case: wrap all arguments into a vararg.  		//  		// We still use toDispose instead of disposing the vararg later' because any exception thrown from  		// Wrap() could leak some objects.  It's safer to add the wrapped objects to toDisposed as we  		// create them to prevent this possibility.  		var varargs = new LuaValue[nargs];  		for (int i = 0; i < nargs; ++i) {  			varargs [i] = wrapped = Wrap (i + 1);  			toDispose.Add (wrapped);  		}  		// "Retain ownership" is true here because we don't want references copied.  Since we don't call  		// Dispose() on the vararg' they won't be disposed anyway.  This is what we want.  (The finally  		// block will take care of that.)  		args = new object[] {  			new LuaVararg (varargs' true)  		};  	} else {  		args = new object[parms.Length];  		for (int i = 0; i < parms.Length; ++i) {  			var ptype = parms [i].ParameterType;  			var luaType = i >= nargs ? LuaApi.LuaType.None : LuaApi.lua_type (state' i + 1);  			switch (luaType) {  			case LuaApi.LuaType.None:  			case LuaApi.LuaType.Nil:  				// Omitted/nil argument.  				if (parms [i].IsOptional) {  					args [i] = parms [i].DefaultValue;  				} else if (!ptype.IsValueType || (ptype.IsGenericType && ptype.GetGenericTypeDefinition () == typeof(Nullable<>))) {  					args [i] = null;  				} else {  					throw new LuaException (string.Format ("Argument {0} is not optional."' i + 1));  				}  				break;  			case LuaApi.LuaType.Boolean:  				// Bool means bool.  				if (!ptype.IsAssignableFrom (typeof(bool))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be bool."' i + 1));  				}  				args [i] = LuaApi.lua_toboolean (state' i + 1) != 0;  				break;  			case LuaApi.LuaType.Function:  				if (!ptype.IsAssignableFrom (typeof(LuaFunction))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a function."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.LightUserdata:  				if (ptype.IsAssignableFrom (typeof(LuaLightUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be light userdata."' i + 1));  				}  				break;  			case LuaApi.LuaType.Number:  				try {  					args [i] = Convert.ChangeType (LuaApi.lua_tonumber (state' i + 1)' ptype);  				} catch {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a number."' i + 1));  				}  				break;  			case LuaApi.LuaType.String:  				if (!ptype.IsAssignableFrom (typeof(string))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a string."' i + 1));  				}  				args [i] = LuaApi.lua_tostring (state' i + 1);  				break;  			case LuaApi.LuaType.Table:  				if (!ptype.IsAssignableFrom (typeof(LuaTable))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a table."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Thread:  				if (!ptype.IsAssignableFrom (typeof(LuaThread))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a thread."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Userdata:  				// With CLR objects' we have ambiguity.  We could test if the parameter type is  				// compatible with LuaUserdata first' and if so wrap the Lua object.  But' perhaps the  				// opaque object IS a LuaUserdata instance?  There's really no way to be smart in that  				// situation.  Therefore' we will just unwrap any CLR object and pray that was the  				// right thing to do.  (Especially since it's kind of silly to hand Lua code userdata  				// wrapped in userdata.  Further' we are trying to map to CLR types; if code wants Eluant  				// objects then it should take a LuaVararg instead.)  				LuaClrObjectValue clrObject;  				if ((clrObject = TryGetClrObject<LuaClrObjectValue> (i + 1)) != null) {  					args [i] = clrObject.ClrObject;  				} else if (ptype.IsAssignableFrom (typeof(LuaUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be userdata."' i + 1));  				}  				break;  			default:  				throw new LuaException (string.Format ("Argument {0}: Cannot proxy Lua type {1}."' i + 1' luaType));  			}  		}  	}  	object ret;  	try {  		ret = wrapper.Invoke (args);  	} catch (MemberAccessException) {  		throw new LuaException ("Invalid argument(s).");  	} catch (TargetInvocationException ex) {  		if (ex.InnerException is LuaException) {  			throw ex.InnerException;  		}  		throw;  	}  	// Process any released references again.  	ProcessReleasedReferences ();  	// If the method was declared to return void we can just stop now.  	if (wrapper.Method.ReturnType == typeof(void)) {  		LuaApi.lua_pushboolean (state' 1);  		return 1;  	}  	// If a vararg is returned' unpack the results.  	var retVararg = ret as LuaVararg;  	if (retVararg != null) {  		// We do need to dispose the vararg.  If the calling code wants to retain references then it can  		// pass takeOwnership:false to the LuaVararg constructor.  If we didn't dispose of it then the  		// called method would have no way to dispose of references that it didn't need anymore.  		toDispose.Add (retVararg);  		LuaApi.lua_pushboolean (state' 1);  		if (LuaApi.lua_checkstack (LuaState' 1 + retVararg.Count) == 0) {  			throw new LuaException ("Cannot grow stack for results.");  		}  		foreach (var a in retVararg) {  			Push (a);  		}  		return retVararg.Count + 1;  	}  	var retValue = AsLuaValue (ret);  	if (retValue == null) {  		throw new LuaException (string.Format ("Unable to convert object of type {0} to Lua value."' ret.GetType ().FullName));  	}  	// Similar to the vararg case' we always dispose the returned value object.  	//  	// 1. If we created it ourselves' we need to dispose of it anyway.  	//  	// 2. If the callee created an object with the sole purpose of being returned (tables are probably a  	//    common case of that) they would have no way to dispose of the CLR reference to the object.  So we  	//    do that here.  (If they didn't want the reference disposed they could return value.CopyHandle().)  	toDispose.Add (retValue);  	LuaApi.lua_pushboolean (state' 1);  	Push (retValue);  	return 2;  } catch (LuaException ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' ex.Message);  	return 2;  } catch (Exception ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Uncaught CLR exception at Lua->CLR boundary: " + ex.ToString ());  	return 2;  } finally {  	// Dispose whatever we need to.  It's okay to dispose result objects' as that will only release the CLR  	// reference to them; they will still be alive on the Lua stack.  	foreach (var o in toDispose) {  		if (o != null) {  			o.Dispose ();  		}  	}  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: try {  	// As with Call()' we are crossing a Lua<->CLR boundary' so release any references that have been   	// queued to be released.  	ProcessReleasedReferences ();  	var nargs = LuaApi.lua_gettop (state);  	// By Lua convention' extra arguments are ignored.  For omitted/nil arguments' we will first see if the  	// managed argument declaration specifies a default value.  Otherwise' for reference/nullable arguments'  	// we will pass null (by Lua convention).  Otherwise' we will raise an error.  	//  	// For numeric types will try to be smart and convert the argument' if possible.  	var parms = wrapper.Method.GetParameters ();  	object[] args;  	LuaValue wrapped;  	if (parms.Length == 1 && parms [0].ParameterType == typeof(LuaVararg)) {  		// Special case: wrap all arguments into a vararg.  		//  		// We still use toDispose instead of disposing the vararg later' because any exception thrown from  		// Wrap() could leak some objects.  It's safer to add the wrapped objects to toDisposed as we  		// create them to prevent this possibility.  		var varargs = new LuaValue[nargs];  		for (int i = 0; i < nargs; ++i) {  			varargs [i] = wrapped = Wrap (i + 1);  			toDispose.Add (wrapped);  		}  		// "Retain ownership" is true here because we don't want references copied.  Since we don't call  		// Dispose() on the vararg' they won't be disposed anyway.  This is what we want.  (The finally  		// block will take care of that.)  		args = new object[] {  			new LuaVararg (varargs' true)  		};  	} else {  		args = new object[parms.Length];  		for (int i = 0; i < parms.Length; ++i) {  			var ptype = parms [i].ParameterType;  			var luaType = i >= nargs ? LuaApi.LuaType.None : LuaApi.lua_type (state' i + 1);  			switch (luaType) {  			case LuaApi.LuaType.None:  			case LuaApi.LuaType.Nil:  				// Omitted/nil argument.  				if (parms [i].IsOptional) {  					args [i] = parms [i].DefaultValue;  				} else if (!ptype.IsValueType || (ptype.IsGenericType && ptype.GetGenericTypeDefinition () == typeof(Nullable<>))) {  					args [i] = null;  				} else {  					throw new LuaException (string.Format ("Argument {0} is not optional."' i + 1));  				}  				break;  			case LuaApi.LuaType.Boolean:  				// Bool means bool.  				if (!ptype.IsAssignableFrom (typeof(bool))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be bool."' i + 1));  				}  				args [i] = LuaApi.lua_toboolean (state' i + 1) != 0;  				break;  			case LuaApi.LuaType.Function:  				if (!ptype.IsAssignableFrom (typeof(LuaFunction))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a function."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.LightUserdata:  				if (ptype.IsAssignableFrom (typeof(LuaLightUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be light userdata."' i + 1));  				}  				break;  			case LuaApi.LuaType.Number:  				try {  					args [i] = Convert.ChangeType (LuaApi.lua_tonumber (state' i + 1)' ptype);  				} catch {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a number."' i + 1));  				}  				break;  			case LuaApi.LuaType.String:  				if (!ptype.IsAssignableFrom (typeof(string))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a string."' i + 1));  				}  				args [i] = LuaApi.lua_tostring (state' i + 1);  				break;  			case LuaApi.LuaType.Table:  				if (!ptype.IsAssignableFrom (typeof(LuaTable))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a table."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Thread:  				if (!ptype.IsAssignableFrom (typeof(LuaThread))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a thread."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Userdata:  				// With CLR objects' we have ambiguity.  We could test if the parameter type is  				// compatible with LuaUserdata first' and if so wrap the Lua object.  But' perhaps the  				// opaque object IS a LuaUserdata instance?  There's really no way to be smart in that  				// situation.  Therefore' we will just unwrap any CLR object and pray that was the  				// right thing to do.  (Especially since it's kind of silly to hand Lua code userdata  				// wrapped in userdata.  Further' we are trying to map to CLR types; if code wants Eluant  				// objects then it should take a LuaVararg instead.)  				LuaClrObjectValue clrObject;  				if ((clrObject = TryGetClrObject<LuaClrObjectValue> (i + 1)) != null) {  					args [i] = clrObject.ClrObject;  				} else if (ptype.IsAssignableFrom (typeof(LuaUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be userdata."' i + 1));  				}  				break;  			default:  				throw new LuaException (string.Format ("Argument {0}: Cannot proxy Lua type {1}."' i + 1' luaType));  			}  		}  	}  	object ret;  	try {  		ret = wrapper.Invoke (args);  	} catch (MemberAccessException) {  		throw new LuaException ("Invalid argument(s).");  	} catch (TargetInvocationException ex) {  		if (ex.InnerException is LuaException) {  			throw ex.InnerException;  		}  		throw;  	}  	// Process any released references again.  	ProcessReleasedReferences ();  	// If the method was declared to return void we can just stop now.  	if (wrapper.Method.ReturnType == typeof(void)) {  		LuaApi.lua_pushboolean (state' 1);  		return 1;  	}  	// If a vararg is returned' unpack the results.  	var retVararg = ret as LuaVararg;  	if (retVararg != null) {  		// We do need to dispose the vararg.  If the calling code wants to retain references then it can  		// pass takeOwnership:false to the LuaVararg constructor.  If we didn't dispose of it then the  		// called method would have no way to dispose of references that it didn't need anymore.  		toDispose.Add (retVararg);  		LuaApi.lua_pushboolean (state' 1);  		if (LuaApi.lua_checkstack (LuaState' 1 + retVararg.Count) == 0) {  			throw new LuaException ("Cannot grow stack for results.");  		}  		foreach (var a in retVararg) {  			Push (a);  		}  		return retVararg.Count + 1;  	}  	var retValue = AsLuaValue (ret);  	if (retValue == null) {  		throw new LuaException (string.Format ("Unable to convert object of type {0} to Lua value."' ret.GetType ().FullName));  	}  	// Similar to the vararg case' we always dispose the returned value object.  	//  	// 1. If we created it ourselves' we need to dispose of it anyway.  	//  	// 2. If the callee created an object with the sole purpose of being returned (tables are probably a  	//    common case of that) they would have no way to dispose of the CLR reference to the object.  So we  	//    do that here.  (If they didn't want the reference disposed they could return value.CopyHandle().)  	toDispose.Add (retValue);  	LuaApi.lua_pushboolean (state' 1);  	Push (retValue);  	return 2;  } catch (LuaException ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' ex.Message);  	return 2;  } catch (Exception ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Uncaught CLR exception at Lua->CLR boundary: " + ex.ToString ());  	return 2;  } finally {  	// Dispose whatever we need to.  It's okay to dispose result objects' as that will only release the CLR  	// reference to them; they will still be alive on the Lua stack.  	foreach (var o in toDispose) {  		if (o != null) {  			o.Dispose ();  		}  	}  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: try {  	// As with Call()' we are crossing a Lua<->CLR boundary' so release any references that have been   	// queued to be released.  	ProcessReleasedReferences ();  	var nargs = LuaApi.lua_gettop (state);  	// By Lua convention' extra arguments are ignored.  For omitted/nil arguments' we will first see if the  	// managed argument declaration specifies a default value.  Otherwise' for reference/nullable arguments'  	// we will pass null (by Lua convention).  Otherwise' we will raise an error.  	//  	// For numeric types will try to be smart and convert the argument' if possible.  	var parms = wrapper.Method.GetParameters ();  	object[] args;  	LuaValue wrapped;  	if (parms.Length == 1 && parms [0].ParameterType == typeof(LuaVararg)) {  		// Special case: wrap all arguments into a vararg.  		//  		// We still use toDispose instead of disposing the vararg later' because any exception thrown from  		// Wrap() could leak some objects.  It's safer to add the wrapped objects to toDisposed as we  		// create them to prevent this possibility.  		var varargs = new LuaValue[nargs];  		for (int i = 0; i < nargs; ++i) {  			varargs [i] = wrapped = Wrap (i + 1);  			toDispose.Add (wrapped);  		}  		// "Retain ownership" is true here because we don't want references copied.  Since we don't call  		// Dispose() on the vararg' they won't be disposed anyway.  This is what we want.  (The finally  		// block will take care of that.)  		args = new object[] {  			new LuaVararg (varargs' true)  		};  	} else {  		args = new object[parms.Length];  		for (int i = 0; i < parms.Length; ++i) {  			var ptype = parms [i].ParameterType;  			var luaType = i >= nargs ? LuaApi.LuaType.None : LuaApi.lua_type (state' i + 1);  			switch (luaType) {  			case LuaApi.LuaType.None:  			case LuaApi.LuaType.Nil:  				// Omitted/nil argument.  				if (parms [i].IsOptional) {  					args [i] = parms [i].DefaultValue;  				} else if (!ptype.IsValueType || (ptype.IsGenericType && ptype.GetGenericTypeDefinition () == typeof(Nullable<>))) {  					args [i] = null;  				} else {  					throw new LuaException (string.Format ("Argument {0} is not optional."' i + 1));  				}  				break;  			case LuaApi.LuaType.Boolean:  				// Bool means bool.  				if (!ptype.IsAssignableFrom (typeof(bool))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be bool."' i + 1));  				}  				args [i] = LuaApi.lua_toboolean (state' i + 1) != 0;  				break;  			case LuaApi.LuaType.Function:  				if (!ptype.IsAssignableFrom (typeof(LuaFunction))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a function."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.LightUserdata:  				if (ptype.IsAssignableFrom (typeof(LuaLightUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be light userdata."' i + 1));  				}  				break;  			case LuaApi.LuaType.Number:  				try {  					args [i] = Convert.ChangeType (LuaApi.lua_tonumber (state' i + 1)' ptype);  				} catch {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a number."' i + 1));  				}  				break;  			case LuaApi.LuaType.String:  				if (!ptype.IsAssignableFrom (typeof(string))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a string."' i + 1));  				}  				args [i] = LuaApi.lua_tostring (state' i + 1);  				break;  			case LuaApi.LuaType.Table:  				if (!ptype.IsAssignableFrom (typeof(LuaTable))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a table."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Thread:  				if (!ptype.IsAssignableFrom (typeof(LuaThread))) {  					throw new LuaException (string.Format ("Argument {0}: Cannot be a thread."' i + 1));  				}  				args [i] = wrapped = Wrap (i + 1);  				toDispose.Add (wrapped);  				break;  			case LuaApi.LuaType.Userdata:  				// With CLR objects' we have ambiguity.  We could test if the parameter type is  				// compatible with LuaUserdata first' and if so wrap the Lua object.  But' perhaps the  				// opaque object IS a LuaUserdata instance?  There's really no way to be smart in that  				// situation.  Therefore' we will just unwrap any CLR object and pray that was the  				// right thing to do.  (Especially since it's kind of silly to hand Lua code userdata  				// wrapped in userdata.  Further' we are trying to map to CLR types; if code wants Eluant  				// objects then it should take a LuaVararg instead.)  				LuaClrObjectValue clrObject;  				if ((clrObject = TryGetClrObject<LuaClrObjectValue> (i + 1)) != null) {  					args [i] = clrObject.ClrObject;  				} else if (ptype.IsAssignableFrom (typeof(LuaUserdata))) {  					args [i] = wrapped = Wrap (i + 1);  					toDispose.Add (wrapped);  				} else {  					throw new LuaException (string.Format ("Argument {0}: Cannot be userdata."' i + 1));  				}  				break;  			default:  				throw new LuaException (string.Format ("Argument {0}: Cannot proxy Lua type {1}."' i + 1' luaType));  			}  		}  	}  	object ret;  	try {  		ret = wrapper.Invoke (args);  	} catch (MemberAccessException) {  		throw new LuaException ("Invalid argument(s).");  	} catch (TargetInvocationException ex) {  		if (ex.InnerException is LuaException) {  			throw ex.InnerException;  		}  		throw;  	}  	// Process any released references again.  	ProcessReleasedReferences ();  	// If the method was declared to return void we can just stop now.  	if (wrapper.Method.ReturnType == typeof(void)) {  		LuaApi.lua_pushboolean (state' 1);  		return 1;  	}  	// If a vararg is returned' unpack the results.  	var retVararg = ret as LuaVararg;  	if (retVararg != null) {  		// We do need to dispose the vararg.  If the calling code wants to retain references then it can  		// pass takeOwnership:false to the LuaVararg constructor.  If we didn't dispose of it then the  		// called method would have no way to dispose of references that it didn't need anymore.  		toDispose.Add (retVararg);  		LuaApi.lua_pushboolean (state' 1);  		if (LuaApi.lua_checkstack (LuaState' 1 + retVararg.Count) == 0) {  			throw new LuaException ("Cannot grow stack for results.");  		}  		foreach (var a in retVararg) {  			Push (a);  		}  		return retVararg.Count + 1;  	}  	var retValue = AsLuaValue (ret);  	if (retValue == null) {  		throw new LuaException (string.Format ("Unable to convert object of type {0} to Lua value."' ret.GetType ().FullName));  	}  	// Similar to the vararg case' we always dispose the returned value object.  	//  	// 1. If we created it ourselves' we need to dispose of it anyway.  	//  	// 2. If the callee created an object with the sole purpose of being returned (tables are probably a  	//    common case of that) they would have no way to dispose of the CLR reference to the object.  So we  	//    do that here.  (If they didn't want the reference disposed they could return value.CopyHandle().)  	toDispose.Add (retValue);  	LuaApi.lua_pushboolean (state' 1);  	Push (retValue);  	return 2;  } catch (LuaException ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' ex.Message);  	return 2;  } catch (Exception ex) {  	LuaApi.lua_pushboolean (state' 0);  	LuaApi.lua_pushstring (state' "Uncaught CLR exception at Lua->CLR boundary: " + ex.ToString ());  	return 2;  } finally {  	// Dispose whatever we need to.  It's okay to dispose result objects' as that will only release the CLR  	// reference to them; they will still be alive on the Lua stack.  	foreach (var o in toDispose) {  		if (o != null) {  			o.Dispose ();  		}  	}  }  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,MakeManagedCall,The following statement contains a magic number: return 2;  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateWeakReference,The following statement contains a magic number: LuaApi.lua_setmetatable (LuaState' -2);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,CreateWeakReference,The following statement contains a magic number: LuaApi.lua_rawseti (LuaState' -2' 1);  
Magic Number,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,GetWeakReference,The following statement contains a magic number: LuaApi.lua_pop (LuaState' 2);  
Magic Number,Eluant,LuaBoolean,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaBoolean.cs,LuaBoolean,The following statement contains a magic number: hashCode = typeof(LuaBoolean).GetHashCode () ^ (value ? 1 : 2);  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Clear,The following statement contains a magic number: for (; ;) {  	LuaApi.lua_pushnil (Runtime.LuaState);  	if (LuaApi.lua_next (Runtime.LuaState' -2) == 0) {  		// Table is empty.  		LuaApi.lua_pop (Runtime.LuaState' 1);  		break;  	}  	// Replace the value with nil and set the key.  	LuaApi.lua_pop (Runtime.LuaState' 1);  	LuaApi.lua_pushnil (Runtime.LuaState);  	LuaApi.lua_settable (Runtime.LuaState' -3);  	// Next iteration will start from the next key by using a nil key again.  }  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Clear,The following statement contains a magic number: for (; ;) {  	LuaApi.lua_pushnil (Runtime.LuaState);  	if (LuaApi.lua_next (Runtime.LuaState' -2) == 0) {  		// Table is empty.  		LuaApi.lua_pop (Runtime.LuaState' 1);  		break;  	}  	// Replace the value with nil and set the key.  	LuaApi.lua_pop (Runtime.LuaState' 1);  	LuaApi.lua_pushnil (Runtime.LuaState);  	LuaApi.lua_settable (Runtime.LuaState' -3);  	// Next iteration will start from the next key by using a nil key again.  }  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Clear,The following statement contains a magic number: if (LuaApi.lua_next (Runtime.LuaState' -2) == 0) {  	// Table is empty.  	LuaApi.lua_pop (Runtime.LuaState' 1);  	break;  }  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Clear,The following statement contains a magic number: LuaApi.lua_settable (Runtime.LuaState' -3);  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Add,The following statement contains a magic number: LuaApi.lua_gettable (Runtime.LuaState' -2);  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Add,The following statement contains a magic number: if (LuaApi.lua_type (Runtime.LuaState' -1) != LuaApi.LuaType.Nil) {  	// Slot is occupied.  	LuaApi.lua_pop (Runtime.LuaState' 2);  	throw new ArgumentException ("Table already contains given key."' "key");  }  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Add,The following statement contains a magic number: LuaApi.lua_pop (Runtime.LuaState' 2);  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Add,The following statement contains a magic number: LuaApi.lua_settable (Runtime.LuaState' -4);  
Magic Number,Eluant,LuaTable,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaTable.cs,Add,The following statement contains a magic number: LuaApi.lua_pop (Runtime.LuaState' 2);  
Missing Default,Eluant,LuaRuntime,D:\newReposJune17\cdhowie_Eluant\Eluant\LuaRuntime.cs,Wrap,The following switch statement is missing a default case: switch (type) {  case LuaApi.LuaType.Nil:  	return LuaNil.Instance;  case LuaApi.LuaType.Boolean:  	return (LuaBoolean)(LuaApi.lua_toboolean (LuaState' index) != 0);  case LuaApi.LuaType.Number:  	return (LuaNumber)LuaApi.lua_tonumber (LuaState' index);  case LuaApi.LuaType.String:  	return (LuaString)LuaApi.lua_tostring (LuaState' index);  case LuaApi.LuaType.Table:  	return new LuaTable (this' CreateReference (index));  case LuaApi.LuaType.Function:  	return new LuaFunction (this' CreateReference (index));  case LuaApi.LuaType.LightUserdata:  	return new LuaLightUserdata (this' CreateReference (index));  case LuaApi.LuaType.Userdata:  	if (IsClrObject (index)) {  		return new LuaClrObjectReference (this' CreateReference (index));  	}  	return new LuaUserdata (this' CreateReference (index));  case LuaApi.LuaType.Thread:  	return new LuaThread (this' CreateReference (index));  }  
