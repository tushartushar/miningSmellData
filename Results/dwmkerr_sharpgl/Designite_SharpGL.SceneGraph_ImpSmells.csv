Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,The method has 265 lines of code.
Long Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SolveLinear,The method has 107 lines of code.
Long Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The method has 102 lines of code.
Complex Method,SharpGL.SceneGraph.Core,VertexGrid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\VertexGrid.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Det,Cyclomatic complexity of the method is 9
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Inverse,Cyclomatic complexity of the method is 15
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,Cyclomatic complexity of the method is 63
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,LU,Cyclomatic complexity of the method is 26
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SolveLinear,Cyclomatic complexity of the method is 28
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,PINV,Cyclomatic complexity of the method is 13
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,Cyclomatic complexity of the method is 14
Complex Method,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,PrintMat,Cyclomatic complexity of the method is 11
Complex Method,SharpGL.SceneGraph,GLColor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\GLColor.cs,Clamp,Cyclomatic complexity of the method is 9
Complex Method,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,RenderElement,Cyclomatic complexity of the method is 14
Complex Method,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,RenderElementForHitTest,Cyclomatic complexity of the method is 10
Complex Method,SharpGL.OpenGLAttributes,EnableAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\EnableAttributes.cs,SetAttributes,Cyclomatic complexity of the method is 24
Complex Method,SharpGL.OpenGLAttributes,PixelModeAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\PixelModeAttributes.cs,SetAttributes,Cyclomatic complexity of the method is 15
Complex Method,SharpGL.OpenGLAttributes,PolygonAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\PolygonAttributes.cs,SetAttributes,Cyclomatic complexity of the method is 10
Complex Method,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,Cyclomatic complexity of the method is 10
Complex Method,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Raytrace,Cyclomatic complexity of the method is 8
Complex Method,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,SetConnectivity,Cyclomatic complexity of the method is 13
Complex Method,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,Cyclomatic complexity of the method is 11
Long Parameter List,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,VertexPointer,The method has 5 parameters. Parameters: gl' size' type' stride' pointer
Long Parameter List,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,ROT,The method has 9 parameters. Parameters: g' h' s' tau' a' i' j' k' l
Long Statement,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,MouseMove,The length of the statement  "            Matrix4fSetRotationFromMatrix3f(ref transformMatrix' thisRotationMatrix);          // Set Our Final Transform's Rotation From This One " is 134.
Long Statement,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,MouseUp,The length of the statement  "            //Matrix4fSetRotationFromMatrix3f(ref transformMatrix' thisRotationMatrix);          // Set Our Final Transform's Rotation From This One " is 136.
Long Statement,SharpGL.SceneGraph,CameraCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Cameras.FrustumCamera)' typeof(Cameras.OrthographicCamera)' typeof(Cameras.PerspectiveCamera)};  " is 121.
Long Statement,SharpGL.SceneGraph,EvaluatorCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Evaluators.Evaluator1D)' typeof(Evaluators.Evaluator2D)' typeof(Evaluators.NurbsCurve)' typeof(Evaluators.NurbsSurface)};  " is 147.
Long Statement,Designers,CameraCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Cameras.FrustumCamera)' typeof(Cameras.OrthographicCamera)' typeof(Cameras.PerspectiveCamera)};  " is 121.
Long Statement,Designers,EvaluatorCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Evaluators.Evaluator1D)' typeof(Evaluators.Evaluator2D)' typeof(Evaluators.NurbsCurve)' typeof(Evaluators.NurbsSurface)};  " is 147.
Long Statement,NETDesignSurface,CameraCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Cameras.FrustumCamera)' typeof(Cameras.OrthographicCamera)' typeof(Cameras.PerspectiveCamera)};  " is 121.
Long Statement,NETDesignSurface,EvaluatorCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Evaluators.Evaluator1D)' typeof(Evaluators.Evaluator2D)' typeof(Evaluators.NurbsCurve)' typeof(Evaluators.NurbsSurface)};  " is 147.
Long Statement,Converters,CameraCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Cameras.FrustumCamera)' typeof(Cameras.OrthographicCamera)' typeof(Cameras.PerspectiveCamera)};  " is 121.
Long Statement,Converters,EvaluatorCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Evaluators.Evaluator1D)' typeof(Evaluators.Evaluator2D)' typeof(Evaluators.NurbsCurve)' typeof(Evaluators.NurbsSurface)};  " is 147.
Long Statement,Editors,CameraCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Cameras.FrustumCamera)' typeof(Cameras.OrthographicCamera)' typeof(Cameras.PerspectiveCamera)};  " is 121.
Long Statement,Editors,EvaluatorCollectionEditor,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,CreateNewItemTypes,The length of the statement  "					return new Type[] {typeof(Evaluators.Evaluator1D)' typeof(Evaluators.Evaluator2D)' typeof(Evaluators.NurbsCurve)' typeof(Evaluators.NurbsSurface)};  " is 147.
Long Statement,SharpGL.OpenGLAttributes,ColorBufferAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\ColorBufferAttributes.cs,SetAttributes,The length of the statement  "            if(colorModeClearColor != null) gl.ClearColor(colorModeClearColor.R' colorModeClearColor.G' colorModeClearColor.B' colorModeClearColor.A); " is 138.
Long Statement,SharpGL.OpenGLAttributes,CurrentAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\CurrentAttributes.cs,SetAttributes,The length of the statement  "            if (currentNormalVector != null) gl.Normal(currentNormalVector.Value.X' currentNormalVector.Value.Y' currentNormalVector.Value.Z); " is 130.
Long Statement,SharpGL.SceneGraph.Effects,OpenGLAttributesEffect,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Effects\OpenGLAttributesEffect.cs,Push,The length of the statement  "            attributeFlags |= accumBufferAttributes.AreAnyAttributesSet() ? accumBufferAttributes.AttributeFlags : AttributeMask.None; " is 122.
Long Statement,SharpGL.SceneGraph.Effects,OpenGLAttributesEffect,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Effects\OpenGLAttributesEffect.cs,Push,The length of the statement  "            attributeFlags |= colorBufferAttributes.AreAnyAttributesSet() ? colorBufferAttributes.AttributeFlags : AttributeMask.None; " is 122.
Long Statement,SharpGL.SceneGraph.Effects,OpenGLAttributesEffect,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Effects\OpenGLAttributesEffect.cs,Push,The length of the statement  "            attributeFlags |= depthBufferAttributes.AreAnyAttributesSet() ? depthBufferAttributes.AttributeFlags : AttributeMask.None; " is 122.
Long Statement,SharpGL.SceneGraph.Effects,OpenGLAttributesEffect,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Effects\OpenGLAttributesEffect.cs,Push,The length of the statement  "            attributeFlags |= polygonStippleAttributes.AreAnyAttributesSet() ? polygonStippleAttributes.AttributeFlags : AttributeMask.None; " is 128.
Long Statement,SharpGL.SceneGraph.Effects,OpenGLAttributesEffect,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Effects\OpenGLAttributesEffect.cs,Push,The length of the statement  "            attributeFlags |= stencilBufferAttributes.AreAnyAttributesSet() ? stencilBufferAttributes.AttributeFlags : AttributeMask.None; " is 126.
Long Statement,SharpGL.SceneGraph.Feedback,Feedback,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Feedback.cs,End,The length of the statement  "                System.Windows.Forms.MessageBox.Show("The scene contained too much data! The data buffer has been doubled in size now' please try again."); " is 139.
Complex Conditional,SharpGL.SceneGraph,VertexSearch,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Collections.cs,Search,The conditional expression  "(vertices[i].X > (vertex.X - accuracy) && vertices[i].X < (vertex.X + accuracy))                          && (vertices[i].Y > (vertex.Y - accuracy) && vertices[i].Y < (vertex.Y + accuracy))                          && (vertices[i].Z > (vertex.Z - accuracy) && vertices[i].Z < (vertex.Z + accuracy))"  is complex.
Complex Conditional,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,FromOtherMatrix,The conditional expression  "rows > Rows || rows > rhs.Rows || cols > Columns || cols > rhs.Columns"  is complex.
Complex Conditional,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Multiply,The conditional expression  "(Mat1.Rows == 3) && (Mat2.Rows == 3) &&                  (Mat1.Columns == 1) && (Mat1.Columns == 1)"  is complex.
Complex Conditional,SharpGL.OpenGLAttributes,ScissorAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\ScissorAttributes.cs,SetAttributes,The conditional expression  "scissorX.HasValue && scissorY.HasValue && scissorWidth.HasValue && scissorHeight.HasValue"  is complex.
Complex Conditional,SharpGL.OpenGLAttributes,ViewportAttributes,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLAttributes\ViewportAttributes.cs,SetAttributes,The conditional expression  "viewportX.HasValue && viewportY.HasValue && viewportWidth.HasValue && viewportHeight.HasValue"  is complex.
Complex Conditional,Collections,VertexSearch,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Collections.cs,Search,The conditional expression  "(vertices[i].X > (vertex.X - accuracy) && vertices[i].X < (vertex.X + accuracy))                          && (vertices[i].Y > (vertex.Y - accuracy) && vertices[i].Y < (vertex.Y + accuracy))                          && (vertices[i].Z > (vertex.Z - accuracy) && vertices[i].Z < (vertex.Z + accuracy))"  is complex.
Complex Conditional,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,SetConnectivity,The conditional expression  "(vA1 == vB1 && vA2 == vB2) || (vA1 == vB2 && vA2 == vB1)"  is complex.
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Evaluator1D,The constructor "Evaluator1D" calls a virtual method "CreateGrid".
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Evaluator1D,The constructor "Evaluator1D" calls a virtual method "CreateGrid".
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The constructor "Evaluator2D" calls a virtual method "CreateGrid".
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The constructor "Evaluator2D" calls a virtual method "CreateGrid".
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,NurbsCurve,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsCurve.cs,NurbsCurve,The constructor "NurbsCurve" calls a virtual method "CreateGrid".
Virtual Method Call from Constructor,SharpGL.SceneGraph.Evaluators,NurbsSurface,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsSurface.cs,NurbsSurface,The constructor "NurbsSurface" calls a virtual method "CreateGrid".
Empty Catch Block,SharpGL.SceneGraph,VertexConverter,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,ConvertFrom,The method has an empty catch block.
Empty Catch Block,Designers,VertexConverter,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,ConvertFrom,The method has an empty catch block.
Empty Catch Block,NETDesignSurface,VertexConverter,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,ConvertFrom,The method has an empty catch block.
Empty Catch Block,Converters,VertexConverter,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,ConvertFrom,The method has an empty catch block.
Empty Catch Block,Editors,VertexConverter,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\NETDesignSurface.cs,ConvertFrom,The method has an empty catch block.
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,MouseUp,The following statement contains a magic number: lastRotationMatrix.FromOtherMatrix(thisRotationMatrix' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,MouseUp,The following statement contains a magic number: lastRotationMatrix.FromOtherMatrix(thisRotationMatrix' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: n = (q1[0] * q1[0]) + (q1[1] * q1[1]) + (q1[2] * q1[2]) + (q1[3] * q1[3]);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: n = (q1[0] * q1[0]) + (q1[1] * q1[1]) + (q1[2] * q1[2]) + (q1[3] * q1[3]);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: n = (q1[0] * q1[0]) + (q1[1] * q1[1]) + (q1[2] * q1[2]) + (q1[3] * q1[3]);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: n = (q1[0] * q1[0]) + (q1[1] * q1[1]) + (q1[2] * q1[2]) + (q1[3] * q1[3]);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: zs = q1[2] * s;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: wx = q1[3] * xs;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: wy = q1[3] * ys;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: wz = q1[3] * zs;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: zz = q1[2] * zs;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: Matrix matrix = new Matrix(3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: Matrix matrix = new Matrix(3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[2' 0] = xz + wy;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[2' 1] = yz - wx;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[0' 2] = xz - wy;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[1' 2] = yz + wx;
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[2' 2] = 1.0f - (xx + yy);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix3fSetRotationFromQuat4f,The following statement contains a magic number: matrix[2' 2] = 1.0f - (xx + yy);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix4fSetRotationFromMatrix3f,The following statement contains a magic number: transform.FromOtherMatrix(matrix' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix4fSetRotationFromMatrix3f,The following statement contains a magic number: transform.FromOtherMatrix(matrix' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix4fSetRotationFromMatrix3f,The following statement contains a magic number: transform.Multiply(scale' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,Matrix4fSetRotationFromMatrix3f,The following statement contains a magic number: transform.Multiply(scale' 3' 3);
Magic Number,SharpGL.SceneGraph.Core,ArcBall,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\ArcBall.cs,CalculateQuaternion,The following statement contains a magic number: if (cross.Magnitude() > 1.0e-5)              {                  //  The quaternion is the transform.                  return new float[] { cross.X' cross.Y' cross.Z' startVector.ScalarProduct(currentVector) };              }              else              {                  //  Begin and end coincide' return identity.                  return new float[] { 0' 0' 0' 0 };              }
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromVertices,The following statement contains a magic number: if (vertexList.Count < 2)                  return;
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromCylindricalVolume,The following statement contains a magic number: Vertex[] set = new Vertex[6];
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromCylindricalVolume,The following statement contains a magic number: set[2] = baseline + new Vertex(baseRadius' baseRadius ' 0);
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromCylindricalVolume,The following statement contains a magic number: set[3] = baseline + new Vertex(-baseRadius' -baseRadius' 0);
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromCylindricalVolume,The following statement contains a magic number: set[4] = set[1] + new Vertex(topRadius' topRadius' 0);
Magic Number,SharpGL.SceneGraph.Core,BoundingVolume,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\BoundingVolume.cs,FromCylindricalVolume,The following statement contains a magic number: set[5] = set[1] + new Vertex(-topRadius' -topRadius' 0);
Magic Number,SharpGL.SceneGraph.Core,VertexGrid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\VertexGrid.cs,Draw,The following statement contains a magic number: if(points)  			{                  int name = 0;    				gl.PointSize(5);    				//	Add a new name (the vertex name).  				gl.PushName(0);    				foreach(Vertex v in vertices)  				{  					//	Set the name' draw the vertex.  					gl.LoadName((uint)name++);  					//todo draw vertex                      //((IInteractable)v).DrawPick(gl);  				}    				//	Pop the name.  				gl.PopName();  			}
Magic Number,SharpGL.SceneGraph.Core,VertexGrid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Core\VertexGrid.cs,ToFloatArray,The following statement contains a magic number: float[] floats = new float[Vertices.Count * 3];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,Project,The following statement contains a magic number: double[] modelview = new double[16];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,Project,The following statement contains a magic number: double[] projection = new double[16];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,Project,The following statement contains a magic number: int[] viewport = new int[4];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetModelViewMatrix,The following statement contains a magic number: double[] matrix = new double[16];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetModelViewMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetModelViewMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetProjectionMatrix,The following statement contains a magic number: double[] matrix = new double[16];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetProjectionMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetProjectionMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetTextureMatrix,The following statement contains a magic number: double[] matrix = new double[16];
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetTextureMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,OpenGLSceneGraphExtensions,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\OpenGLSceneGraphExtensions.cs,GetTextureMatrix,The following statement contains a magic number: return Matrix.FromColumnMajorArray(matrix' 4' 4);
Magic Number,SharpGL.SceneGraph,Face,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Face.cs,GetPlaneEquation,The following statement contains a magic number: Vertex v3 = parent.Vertices[indices[2].Vertex];
Magic Number,SharpGL.SceneGraph,Face,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Face.cs,GetSurfaceNormal,The following statement contains a magic number: if (indices.Count < 3)                  return new Vertex(0' 0' 0);
Magic Number,SharpGL.SceneGraph,Face,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Face.cs,GetSurfaceNormal,The following statement contains a magic number: Vertex v3 = parent.Vertices[indices[2].Vertex];
Magic Number,SharpGL.SceneGraph,Face,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Face.cs,GenerateNormals,The following statement contains a magic number: if (Indices.Count >= 3)              {                  foreach (Index index in Indices)                  {                      //	Do we have enough vertices for a normal?                      if (Indices.Count >= 3)                      {                          //	Create a normal.                          Vertex vNormal = GetSurfaceNormal(parent);                          vNormal.UnitLength();                            //	Add it to the normals' setting the index for next time.                          if (index.Normal != -1)                              parent.Normals.RemoveAt(index.Normal);                          index.Normal = parent.Normals.Count;                          parent.Normals.Add(vNormal);                      }                  }              }
Magic Number,SharpGL.SceneGraph,Face,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Face.cs,GenerateNormals,The following statement contains a magic number: if (Indices.Count >= 3)              {                  foreach (Index index in Indices)                  {                      //	Do we have enough vertices for a normal?                      if (Indices.Count >= 3)                      {                          //	Create a normal.                          Vertex vNormal = GetSurfaceNormal(parent);                          vNormal.UnitLength();                            //	Add it to the normals' setting the index for next time.                          if (index.Normal != -1)                              parent.Normals.RemoveAt(index.Normal);                          index.Normal = parent.Normals.Count;                          parent.Normals.Add(vNormal);                      }                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,TempSVD,The following statement contains a magic number: return (float)Math.Sqrt(                  (float)((this[0'0] * this[0'0]) + (this[0'1] * this[0'1]) + (this[0'2] * this[0'2]) +                   (this[1'0] * this[1'0]) + (this[1'1] * this[1'1]) + (this[1'2] * this[1'2]) +                  (this[2'0] * this[2'0]) + (this[2'1] * this[2'1]) + (this[2'2] * this[2'2]) ) / 3.0f );
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Multiply,The following statement contains a magic number: if ((Mat1.Rows == 3) && (Mat2.Rows == 3) &&                  (Mat1.Columns == 1) && (Mat1.Columns == 1))              { return new Matrix(CrossProduct(Mat1.in_Mat' Mat2.in_Mat)); }              else              { return new Matrix(Multiply(Mat1.in_Mat' Mat2.in_Mat)); }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Multiply,The following statement contains a magic number: if ((Mat1.Rows == 3) && (Mat2.Rows == 3) &&                  (Mat1.Columns == 1) && (Mat1.Columns == 1))              { return new Matrix(CrossProduct(Mat1.in_Mat' Mat2.in_Mat)); }              else              { return new Matrix(Multiply(Mat1.in_Mat' Mat2.in_Mat)); }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Inverse,The following statement contains a magic number: for (LC = 0; LC <= LL; LC++)              {                  if (Math.Abs(Mat1[LC' LC]) < 0.0000000001)                  {                      for (LCA = LC + 1; LCA <= LL; LCA++)                      {                          if (LCA == LC) continue;                          if (Math.Abs(Mat1[LC' LCA]) > 0.0000000001)                          {                              for (LCB = 0; LCB <= LL; LCB++)                              {                                  Mat1[LCB' LC] = Mat1[LCB' LC] + Mat1[LCB' LCA];                                  AI[LCB' LC] = AI[LCB' LC] + AI[LCB' LCA];                              }                              break;                          }                      }                  }                  AIN = 1 / Mat1[LC' LC];                  for (LCA = 0; LCA <= LL; LCA++)                  {                      Mat1[LCA' LC] = AIN * Mat1[LCA' LC];                      AI[LCA' LC] = AIN * AI[LCA' LC];                  }                    for (LCA = 0; LCA <= LL; LCA++)                  {                      if (LCA == LC) continue;                      AF = Mat1[LC' LCA];                      for (LCB = 0; LCB <= LL; LCB++)                      {                          Mat1[LCB' LCA] = Mat1[LCB' LCA] - AF * Mat1[LCB' LC];                          AI[LCB' LCA] = AI[LCB' LCA] - AF * AI[LCB' LC];                      }                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Inverse,The following statement contains a magic number: for (LC = 0; LC <= LL; LC++)              {                  if (Math.Abs(Mat1[LC' LC]) < 0.0000000001)                  {                      for (LCA = LC + 1; LCA <= LL; LCA++)                      {                          if (LCA == LC) continue;                          if (Math.Abs(Mat1[LC' LCA]) > 0.0000000001)                          {                              for (LCB = 0; LCB <= LL; LCB++)                              {                                  Mat1[LCB' LC] = Mat1[LCB' LC] + Mat1[LCB' LCA];                                  AI[LCB' LC] = AI[LCB' LC] + AI[LCB' LCA];                              }                              break;                          }                      }                  }                  AIN = 1 / Mat1[LC' LC];                  for (LCA = 0; LCA <= LL; LCA++)                  {                      Mat1[LCA' LC] = AIN * Mat1[LCA' LC];                      AI[LCA' LC] = AIN * AI[LCA' LC];                  }                    for (LCA = 0; LCA <= LL; LCA++)                  {                      if (LCA == LC) continue;                      AF = Mat1[LC' LCA];                      for (LCB = 0; LCB <= LL; LCB++)                      {                          Mat1[LCB' LCA] = Mat1[LCB' LCA] - AF * Mat1[LCB' LC];                          AI[LCB' LCA] = AI[LCB' LCA] - AF * AI[LCB' LC];                      }                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,The following statement contains a magic number: const int NMAX = 100;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,The following statement contains a magic number: for (k = n; k >= 1; k--)              {                  for (its = 1; its <= 30; its++)                  {                      flag = 1;                      for (l = k; l >= 1; l--)                      {                          nm = l - 1;                          if (Math.Abs(rv1[l]) + anorm == anorm)                          {                              flag = 0;                              break;                          }                          if (Math.Abs(w[nm]) + anorm == anorm) break;                      }                      if (flag != 0)                      {                          c = 0.0;                          s = 1.0;                          for (i = l; i <= k; i++)                          {                              f = s * rv1[i];                              if (Math.Abs(f) + anorm != anorm)                              {                                  g = w[i];                                  h = PYTHAG(f' g);                                  w[i] = h;                                  h = 1.0 / h;                                  c = g * h;                                  s = (-f * h);                                  for (j = 1; j <= m; j++)                                  {                                      y = A[j' nm];                                      z = A[j' i];                                      A[j' nm] = y * c + z * s;                                      A[j' i] = z * c - y * s;                                  }                              }                          }                      }                      z = w[k];                      if (l == k)                      {                          if (z < 0.0)                          {                              w[k] = -z;                              for (j = 1; j <= n; j++) v[j' k] = (-v[j' k]);                          }                          break;                      }                      if (its == 30) Console.WriteLine("No convergence in 30 SVDCMP iterations");                      x = w[l];                      nm = k - 1;                      y = w[nm];                      g = rv1[nm];                      h = rv1[k];                      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);                      g = PYTHAG(f' 1.0);                      f = ((x - z) * (x + z) + h * ((y / (f + Sign(g' f))) - h)) / x;                      c = s = 1.0;                      for (j = l; j <= nm; j++)                      {                          i = j + 1;                          g = rv1[i];                          y = w[i];                          h = s * g;                          g = c * g;                          z = PYTHAG(f' h);                          rv1[j] = z;                          c = f / z;                          s = h / z;                          f = x * c + g * s;                          g = g * c - x * s;                          h = y * s;                          y = y * c;                          for (jj = 1; jj <= n; jj++)                          {                              x = v[jj' j];                              z = v[jj' i];                              v[jj' j] = x * c + z * s;                              v[jj' i] = z * c - x * s;                          }                          z = PYTHAG(f' h);                          w[j] = z;                          if (z != 0)                          {                              z = 1.0 / z;                              c = f * z;                              s = h * z;                          }                          f = (c * g) + (s * y);                          x = (c * y) - (s * g);                          for (jj = 1; jj <= m; jj++)                          {                              y = A[jj' j];                              z = A[jj' i];                              A[jj' j] = y * c + z * s;                              A[jj' i] = z * c - y * s;                          }                      }                      rv1[l] = 0.0;                      rv1[k] = f;                      w[k] = x;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,The following statement contains a magic number: for (k = n; k >= 1; k--)              {                  for (its = 1; its <= 30; its++)                  {                      flag = 1;                      for (l = k; l >= 1; l--)                      {                          nm = l - 1;                          if (Math.Abs(rv1[l]) + anorm == anorm)                          {                              flag = 0;                              break;                          }                          if (Math.Abs(w[nm]) + anorm == anorm) break;                      }                      if (flag != 0)                      {                          c = 0.0;                          s = 1.0;                          for (i = l; i <= k; i++)                          {                              f = s * rv1[i];                              if (Math.Abs(f) + anorm != anorm)                              {                                  g = w[i];                                  h = PYTHAG(f' g);                                  w[i] = h;                                  h = 1.0 / h;                                  c = g * h;                                  s = (-f * h);                                  for (j = 1; j <= m; j++)                                  {                                      y = A[j' nm];                                      z = A[j' i];                                      A[j' nm] = y * c + z * s;                                      A[j' i] = z * c - y * s;                                  }                              }                          }                      }                      z = w[k];                      if (l == k)                      {                          if (z < 0.0)                          {                              w[k] = -z;                              for (j = 1; j <= n; j++) v[j' k] = (-v[j' k]);                          }                          break;                      }                      if (its == 30) Console.WriteLine("No convergence in 30 SVDCMP iterations");                      x = w[l];                      nm = k - 1;                      y = w[nm];                      g = rv1[nm];                      h = rv1[k];                      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);                      g = PYTHAG(f' 1.0);                      f = ((x - z) * (x + z) + h * ((y / (f + Sign(g' f))) - h)) / x;                      c = s = 1.0;                      for (j = l; j <= nm; j++)                      {                          i = j + 1;                          g = rv1[i];                          y = w[i];                          h = s * g;                          g = c * g;                          z = PYTHAG(f' h);                          rv1[j] = z;                          c = f / z;                          s = h / z;                          f = x * c + g * s;                          g = g * c - x * s;                          h = y * s;                          y = y * c;                          for (jj = 1; jj <= n; jj++)                          {                              x = v[jj' j];                              z = v[jj' i];                              v[jj' j] = x * c + z * s;                              v[jj' i] = z * c - x * s;                          }                          z = PYTHAG(f' h);                          w[j] = z;                          if (z != 0)                          {                              z = 1.0 / z;                              c = f * z;                              s = h * z;                          }                          f = (c * g) + (s * y);                          x = (c * y) - (s * g);                          for (jj = 1; jj <= m; jj++)                          {                              y = A[jj' j];                              z = A[jj' i];                              A[jj' j] = y * c + z * s;                              A[jj' i] = z * c - y * s;                          }                      }                      rv1[l] = 0.0;                      rv1[k] = f;                      w[k] = x;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SVD,The following statement contains a magic number: for (k = n; k >= 1; k--)              {                  for (its = 1; its <= 30; its++)                  {                      flag = 1;                      for (l = k; l >= 1; l--)                      {                          nm = l - 1;                          if (Math.Abs(rv1[l]) + anorm == anorm)                          {                              flag = 0;                              break;                          }                          if (Math.Abs(w[nm]) + anorm == anorm) break;                      }                      if (flag != 0)                      {                          c = 0.0;                          s = 1.0;                          for (i = l; i <= k; i++)                          {                              f = s * rv1[i];                              if (Math.Abs(f) + anorm != anorm)                              {                                  g = w[i];                                  h = PYTHAG(f' g);                                  w[i] = h;                                  h = 1.0 / h;                                  c = g * h;                                  s = (-f * h);                                  for (j = 1; j <= m; j++)                                  {                                      y = A[j' nm];                                      z = A[j' i];                                      A[j' nm] = y * c + z * s;                                      A[j' i] = z * c - y * s;                                  }                              }                          }                      }                      z = w[k];                      if (l == k)                      {                          if (z < 0.0)                          {                              w[k] = -z;                              for (j = 1; j <= n; j++) v[j' k] = (-v[j' k]);                          }                          break;                      }                      if (its == 30) Console.WriteLine("No convergence in 30 SVDCMP iterations");                      x = w[l];                      nm = k - 1;                      y = w[nm];                      g = rv1[nm];                      h = rv1[k];                      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);                      g = PYTHAG(f' 1.0);                      f = ((x - z) * (x + z) + h * ((y / (f + Sign(g' f))) - h)) / x;                      c = s = 1.0;                      for (j = l; j <= nm; j++)                      {                          i = j + 1;                          g = rv1[i];                          y = w[i];                          h = s * g;                          g = c * g;                          z = PYTHAG(f' h);                          rv1[j] = z;                          c = f / z;                          s = h / z;                          f = x * c + g * s;                          g = g * c - x * s;                          h = y * s;                          y = y * c;                          for (jj = 1; jj <= n; jj++)                          {                              x = v[jj' j];                              z = v[jj' i];                              v[jj' j] = x * c + z * s;                              v[jj' i] = z * c - x * s;                          }                          z = PYTHAG(f' h);                          w[j] = z;                          if (z != 0)                          {                              z = 1.0 / z;                              c = f * z;                              s = h * z;                          }                          f = (c * g) + (s * y);                          x = (c * y) - (s * g);                          for (jj = 1; jj <= m; jj++)                          {                              y = A[jj' j];                              z = A[jj' i];                              A[jj' j] = y * c + z * s;                              A[jj' i] = z * c - y * s;                          }                      }                      rv1[l] = 0.0;                      rv1[k] = f;                      w[k] = x;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,LU,The following statement contains a magic number: double AAMAX' Sum' Dum' TINY = 1E-20;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,LU,The following statement contains a magic number: double[] VV = new double[N * 10];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SolveLinear,The following statement contains a magic number: double AAMAX' Sum' Dum' TINY = 1E-20;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,SolveLinear,The following statement contains a magic number: double[] VV = new double[N * 10];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Rank,The following statement contains a magic number: double EPS = 2.2204E-16;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,PINV,The following statement contains a magic number: EPS = 2.2204E-16;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,Eigen,The following statement contains a magic number: for (i = 0; i <= 50; i++)              {                  sm = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                          sm += Math.Abs(a[ip' iq]);                  }                  if (sm == 0.0)                  {                      return;                  }                  if (i < 4)                      tresh = 0.2 * sm / (n * n);                  else                      tresh = 0.0;                  for (ip = 0; ip <= n - 1; ip++)                  {                      for (iq = ip + 1; iq <= n; iq++)                      {                          g = 100.0 * Math.Abs(a[ip' iq]);                          if (i > 4 && (double)(Math.Abs(d[ip' 0]) + g) == (double)Math.Abs(d[ip' 0])                              && (double)(Math.Abs(d[iq' 0]) + g) == (double)Math.Abs(d[iq' 0]))                              a[ip' iq] = 0.0;                          else if (Math.Abs(a[ip' iq]) > tresh)                          {                              h = d[iq' 0] - d[ip' 0];                              if ((double)(Math.Abs(h) + g) == (double)Math.Abs(h))                                  t = (a[ip' iq]) / h;                              else                              {                                  theta = 0.5 * h / (a[ip' iq]);                                  t = 1.0 / (Math.Abs(theta) + Math.Sqrt(1.0 + theta * theta));                                  if (theta < 0.0) t = -t;                              }                              c = 1.0 / Math.Sqrt(1 + t * t);                              s = t * c;                              tau = s / (1.0 + c);                              h = t * a[ip' iq];                              z[ip] -= h;                              z[iq] += h;                              d[ip' 0] -= h;                              d[iq' 0] += h;                              a[ip' iq] = 0.0;                              for (j = 0; j <= ip - 1; j++)                              {                                  ROT(g' h' s' tau' a' j' ip' j' iq);                              }                              for (j = ip + 1; j <= iq - 1; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' j' iq);                              }                              for (j = iq + 1; j <= n; j++)                              {                                  ROT(g' h' s' tau' a' ip' j' iq' j);                              }                              for (j = 0; j <= n; j++)                              {                                  ROT(g' h' s' tau' v' j' ip' j' iq);                              }                              ++(nrot);                          }                      }                  }                  for (ip = 0; ip <= n; ip++)                  {                      b[ip] += z[ip];                      d[ip' 0] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: double[] sol = new double[2];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: if (Rows1 != 2) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: if (Rows2 != 2) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: i = V1[1] * V2[2] - V1[2] * V2[1];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: i = V1[1] * V2[2] - V1[2] * V2[1];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: j = V1[2] * V2[0] - V1[0] * V2[2];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: j = V1[2] * V2[0] - V1[0] * V2[2];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: sol[2] = k;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: double['] sol = new double[3' 1];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: if (Rows1 != 2 || Cols1 != 0) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: if (Rows2 != 2 || Cols2 != 0) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: i = V1[1' 0] * V2[2' 0] - V1[2' 0] * V2[1' 0];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: i = V1[1' 0] * V2[2' 0] - V1[2' 0] * V2[1' 0];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: j = V1[2' 0] * V2[0' 0] - V1[0' 0] * V2[2' 0];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: j = V1[2' 0] * V2[0' 0] - V1[0' 0] * V2[2' 0];
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,CrossProduct,The following statement contains a magic number: sol[2' 0] = k;
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: if (Rows1 != 2) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: if (Rows2 != 2) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: return (V1[0] * V2[0] + V1[1] * V2[1] + V1[2] * V2[2]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: return (V1[0] * V2[0] + V1[1] * V2[1] + V1[2] * V2[2]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: if (Rows1 != 2 || Cols1 != 0) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: if (Rows2 != 2 || Cols2 != 0) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: return (V1[0' 0] * V2[0' 0] + V1[1' 0] * V2[1' 0] + V1[2' 0] * V2[2' 0]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,DotProduct,The following statement contains a magic number: return (V1[0' 0] * V2[0' 0] + V1[1' 0] * V2[1' 0] + V1[2' 0] * V2[2' 0]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: if (Rows != 2) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: return Math.Sqrt(V[0] * V[0] + V[1] * V[1] + V[2] * V[2]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: return Math.Sqrt(V[0] * V[0] + V[1] * V[1] + V[2] * V[2]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: if (Rows != 2 || Cols != 0) throw new VectorDimensionException();
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: return Math.Sqrt(V[0' 0] * V[0' 0] + V[1' 0] * V[1' 0] + V[2' 0] * V[2' 0]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,VectorMagnitude,The following statement contains a magic number: return Math.Sqrt(V[0' 0] * V[0' 0] + V[1' 0] * V[1' 0] + V[2' 0] * V[2' 0]);
Magic Number,SharpGL.SceneGraph,Matrix,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Matrix.cs,IsEqual,The following statement contains a magic number: double eps = 1E-14;
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: int[] viewport = new int[4];
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: y = viewport[3] - y;
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: uint[] selectBuffer = new uint[512];
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: gl.SelectBuffer(512' selectBuffer);
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: gl.PickMatrix(x' y' 4' 4' viewport);
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,DoHitTest,The following statement contains a magic number: gl.PickMatrix(x' y' 4' 4' viewport);
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,Draw,The following statement contains a magic number: gl.ClearColor(clear[0]' clear[1]' clear[2]' clear[3]);
Magic Number,SharpGL.SceneGraph,Scene,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Scene.cs,Draw,The following statement contains a magic number: gl.ClearColor(clear[0]' clear[1]' clear[2]' clear[3]);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Intialise,The following statement contains a magic number: color.R = rand.Next(256) / 256.0f;
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Intialise,The following statement contains a magic number: life = (rand.Next(100) / 1000.0f) + 0.03f;
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Intialise,The following statement contains a magic number: direction.X += rand.Next(10) / 100.0f;
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Intialise,The following statement contains a magic number: direction.Y += rand.Next(10) / 100.0f;
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Intialise,The following statement contains a magic number: direction.Z += rand.Next(10) / 100.0f;
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: direction.X = directionRandomise.X - (2 * (float)rand.NextDouble() * directionRandomise.X);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: direction.Y = directionRandomise.Y - (2 * (float)rand.NextDouble() * directionRandomise.Y);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: direction.Z = directionRandomise.Z - (2 * (float)rand.NextDouble() * directionRandomise.Z);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: color.R += colorRandomise.R - (2 * (float)rand.NextDouble() * colorRandomise.R);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: color.G += colorRandomise.G - (2 * (float)rand.NextDouble() * colorRandomise.G);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: color.B += colorRandomise.B - (2 * (float)rand.NextDouble() * colorRandomise.B);
Magic Number,SharpGL.SceneGraph.ParticleSystems,BasicParticle,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\ParticleSystem\Particle.cs,Tick,The following statement contains a magic number: color.A += colorRandomise.A - (2 * (float)rand.NextDouble() * colorRandomise.A);
Magic Number,SharpGL.SceneGraph.Assets,Material,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Material.cs,CalculateLighting,The following statement contains a magic number: double angleRadians = angle * 3.14159 / 360.0;
Magic Number,SharpGL.SceneGraph.Assets,Material,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Material.cs,CalculateLighting,The following statement contains a magic number: double angleRadians = angle * 3.14159 / 360.0;
Magic Number,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,Create,The following statement contains a magic number: for (int size = 1; size <= textureMaxSize[0]; size *= 2)              {                  if (image.Width < size)                  {                      targetWidth = size / 2;                      break;                  }                  if (image.Width == size)                      targetWidth = size;                }
Magic Number,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,Create,The following statement contains a magic number: for (int size = 1; size <= textureMaxSize[0]; size *= 2)              {                  if (image.Width < size)                  {                      targetWidth = size / 2;                      break;                  }                  if (image.Width == size)                      targetWidth = size;                }
Magic Number,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,Create,The following statement contains a magic number: for (int size = 1; size <= textureMaxSize[0]; size *= 2)              {                  if (image.Height < size)                  {                      targetHeight = size / 2;                      break;                  }                  if (image.Height == size)                      targetHeight = size;              }
Magic Number,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,Create,The following statement contains a magic number: for (int size = 1; size <= textureMaxSize[0]; size *= 2)              {                  if (image.Height < size)                  {                      targetHeight = size / 2;                      break;                  }                  if (image.Height == size)                      targetHeight = size;              }
Magic Number,SharpGL.SceneGraph.Assets,Texture,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Assets\Texture.cs,ToBitmap,The following statement contains a magic number: Bitmap bitmap = new Bitmap(width' height' width * 4'                      PixelFormat.Format32bppRgb' handle.AddrOfPinnedObject());
Magic Number,SharpGL.SceneGraph.Cameras,ArcBallCamera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\ArcBallCamera.cs,TransformProjectionMatrix,The following statement contains a magic number: int[] viewport = new int[4];
Magic Number,SharpGL.SceneGraph.Cameras,ArcBallCamera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\ArcBallCamera.cs,TransformProjectionMatrix,The following statement contains a magic number: arcBall.SetBounds(viewport[2]' viewport[3]);
Magic Number,SharpGL.SceneGraph.Cameras,ArcBallCamera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\ArcBallCamera.cs,TransformProjectionMatrix,The following statement contains a magic number: arcBall.SetBounds(viewport[2]' viewport[3]);
Magic Number,SharpGL.SceneGraph.Cameras,Camera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\Camera.cs,Project,The following statement contains a magic number: float[] matrix = new float[16];
Magic Number,SharpGL.SceneGraph.Cameras,Camera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\Camera.cs,Project,The following statement contains a magic number: for(int i=0; i<4; i++)  				for(int j=0; j<4; j++)  					projectionMatrix[i'j] = matrix[(i*4) + j];
Magic Number,SharpGL.SceneGraph.Cameras,Camera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\Camera.cs,Project,The following statement contains a magic number: for(int i=0; i<4; i++)  				for(int j=0; j<4; j++)  					projectionMatrix[i'j] = matrix[(i*4) + j];
Magic Number,SharpGL.SceneGraph.Cameras,Camera,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Cameras\Camera.cs,Project,The following statement contains a magic number: for(int i=0; i<4; i++)  				for(int j=0; j<4; j++)  					projectionMatrix[i'j] = matrix[(i*4) + j];
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Evaluator1D,The following statement contains a magic number: ControlPoints.CreateGrid(4' 1);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Evaluator1D,The following statement contains a magic number: Transformation.RotateX = 180;
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Evaluator1D,The following statement contains a magic number: Transformation.RotateX = 180;
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator1D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator1D.cs,Render,The following statement contains a magic number: gl.Map1(OpenGL.GL_MAP1_VERTEX_3'//	Use and produce 3D points.                  0'								//	Low order value of 'u'.                  1'								//	High order value of 'u'.                  3'								//	Size (bytes) of a control point.                  ControlPoints.Width'			//	Order (i.e degree plus one).                  ControlPoints.ToFloatArray());
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The following statement contains a magic number: ControlPoints.CreateGrid(4' 4);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The following statement contains a magic number: ControlPoints.CreateGrid(4' 4);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The following statement contains a magic number: Transformation.RotateX = 180;
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Evaluator2D,The following statement contains a magic number: Transformation.RotateX = 180;
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.Map2(OpenGL.GL_MAP2_VERTEX_3'//	Use and produce 3D points.  				0'								//	Low order value of 'u'.  				1'								//	High order value of 'u'.  				3'								//	Size (bytes) of a control point.  				ControlPoints.Width'			//	Order (i.e degree plus one).  				0'								//	Low order value of 'v'.  				1'								//	High order value of 'v'  				ControlPoints.Width * 3'		//	Size in bytes of a 'row' of points.  				ControlPoints.Height'			//	Order (i.e degree plus one).  				ControlPoints.ToFloatArray());
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.Map2(OpenGL.GL_MAP2_VERTEX_3'//	Use and produce 3D points.  				0'								//	Low order value of 'u'.  				1'								//	High order value of 'u'.  				3'								//	Size (bytes) of a control point.  				ControlPoints.Width'			//	Order (i.e degree plus one).  				0'								//	Low order value of 'v'.  				1'								//	High order value of 'v'  				ControlPoints.Width * 3'		//	Size in bytes of a 'row' of points.  				ControlPoints.Height'			//	Order (i.e degree plus one).  				ControlPoints.ToFloatArray());
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.MapGrid2(20' 0' 1' 20' 0' 1);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.MapGrid2(20' 0' 1' 20' 0' 1);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.EvalMesh2(OpenGL.GL_FILL' 0' 20' 0' 20);
Magic Number,SharpGL.SceneGraph.Evaluators,Evaluator2D,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\Evaluator2D.cs,Render,The following statement contains a magic number: gl.EvalMesh2(OpenGL.GL_FILL' 0' 20' 0' 20);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsCurve,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsCurve.cs,NurbsCurve,The following statement contains a magic number: ControlPoints.CreateGrid(4' 1);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsCurve,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsCurve.cs,Render,The following statement contains a magic number: gl.NurbsCurve(nurbsRenderer'		//	The internal nurbs object.  				knots.Length'					//	Number of knots.  				knots'							//	The knots themselves.  				3'								//	The size of a vertex.  				ControlPoints.ToFloatArray()'	//	The control points.  				ControlPoints.Width'			//	The order' i.e degree + 1.  				OpenGL.GL_MAP1_VERTEX_3);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsSurface,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsSurface.cs,NurbsSurface,The following statement contains a magic number: ControlPoints.CreateGrid(4' 4);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsSurface,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsSurface.cs,NurbsSurface,The following statement contains a magic number: ControlPoints.CreateGrid(4' 4);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsSurface,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsSurface.cs,Render,The following statement contains a magic number: gl.NurbsSurface(nurbsRenderer'		//	The internal nurbs object.                  sKnots.Length'					//	Number of s-knots.                  sKnots'							//	The s-knots themselves.                  tKnots.Length'					//	The number of t-knots.                  tKnots'							//	The t-knots themselves.                  ControlPoints.Width * 3'		//	The size of a row of control points.                  3'								//	The size of a control points.                  ControlPoints.ToFloatArray()'	//	The control points.                  ControlPoints.Width'			//	The order' i.e degree + 1.                  ControlPoints.Height'			//	The order' i.e degree + 1.                  OpenGL.GL_MAP2_VERTEX_3);
Magic Number,SharpGL.SceneGraph.Evaluators,NurbsSurface,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Evaluators\NurbsSurface.cs,Render,The following statement contains a magic number: gl.NurbsSurface(nurbsRenderer'		//	The internal nurbs object.                  sKnots.Length'					//	Number of s-knots.                  sKnots'							//	The s-knots themselves.                  tKnots.Length'					//	The number of t-knots.                  tKnots'							//	The t-knots themselves.                  ControlPoints.Width * 3'		//	The size of a row of control points.                  3'								//	The size of a control points.                  ControlPoints.ToFloatArray()'	//	The control points.                  ControlPoints.Width'			//	The order' i.e degree + 1.                  ControlPoints.Height'			//	The order' i.e degree + 1.                  OpenGL.GL_MAP2_VERTEX_3);
Magic Number,SharpGL.SceneGraph.Feedback,Feedback,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Feedback.cs,End,The following statement contains a magic number: if (values == -1)              {                  System.Windows.Forms.MessageBox.Show("The scene contained too much data! The data buffer has been doubled in size now' please try again.");                  feedbackBuffer = new float[feedbackBuffer.Length * 2];                  return new float[] { -1 };              }
Magic Number,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following statement contains a magic number: while (count != 0)              {                  //	Get the token.                  float token = feedbackBuffer[values - count];                    //	Decrement count (move to the next token).                  count--;                    //	Check the type of the token.                  switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }              }
Magic Number,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following statement contains a magic number: while (count != 0)              {                  //	Get the token.                  float token = feedbackBuffer[values - count];                    //	Decrement count (move to the next token).                  count--;                    //	Check the type of the token.                  switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }              }
Magic Number,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following statement contains a magic number: while (count != 0)              {                  //	Get the token.                  float token = feedbackBuffer[values - count];                    //	Decrement count (move to the next token).                  count--;                    //	Check the type of the token.                  switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }              }
Magic Number,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following statement contains a magic number: while (count != 0)              {                  //	Get the token.                  float token = feedbackBuffer[values - count];                    //	Decrement count (move to the next token).                  count--;                    //	Check the type of the token.                  switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }              }
Magic Number,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following statement contains a magic number: while (count != 0)              {                  //	Get the token.                  float token = feedbackBuffer[values - count];                    //	Decrement count (move to the next token).                  count--;                    //	Check the type of the token.                  switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }              }
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light1 = new Light()              {                  Name="Light 1"'                  On = true'                  Position = new Vertex(-9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT0              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light1 = new Light()              {                  Name="Light 1"'                  On = true'                  Position = new Vertex(-9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT0              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light1 = new Light()              {                  Name="Light 1"'                  On = true'                  Position = new Vertex(-9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT0              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light2 = new Light()              {                  Name = "Light 2"'                  On = true'                  Position = new Vertex(9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT1              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light2 = new Light()              {                  Name = "Light 2"'                  On = true'                  Position = new Vertex(9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT1              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light2 = new Light()              {                  Name = "Light 2"'                  On = true'                  Position = new Vertex(9' -9' 11)'                  GLCode = OpenGL.GL_LIGHT1              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light3 = new Light()              {                  Name = "Light 3"'                  On = true'                  Position = new Vertex(0' 15' 15)'                  GLCode = OpenGL.GL_LIGHT2              };
Magic Number,SharpGL.SceneGraph.Helpers,SceneHelper,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Helpers\SceneHelper.cs,InitialiseModelingScene,The following statement contains a magic number: Light light3 = new Light()              {                  Name = "Light 3"'                  On = true'                  Position = new Vertex(0' 15' 15)'                  GLCode = OpenGL.GL_LIGHT2              };
Magic Number,SharpGL.SceneGraph.Lighting,Light,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Lighting\Light.cs,Light,The following statement contains a magic number: Position = new Vertex(0' 3' 0);
Magic Number,SharpGL.SceneGraph.Lighting,Spotlight,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Lighting\Spotlight.cs,Spotlight,The following statement contains a magic number: Position = new Vertex(0' 3' 0);
Magic Number,SharpGL.SceneGraph.Primitives,Axies,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Axies.cs,CreateDisplayList,The following statement contains a magic number: gl.Vertex(3' 0' 0);
Magic Number,SharpGL.SceneGraph.Primitives,Axies,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Axies.cs,CreateDisplayList,The following statement contains a magic number: gl.Vertex(0' 3' 0);
Magic Number,SharpGL.SceneGraph.Primitives,Axies,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Axies.cs,CreateDisplayList,The following statement contains a magic number: gl.Vertex(0' 0' 3);
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(2' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(0' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(7' 0));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(6' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(5' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(5' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(4' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(4' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(5' 0));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(6' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(2' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(2' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(1' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(7' 0));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(4' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(0' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(4' 0));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(5' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(1' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(0' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(6' 0));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(7' 1));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(3' 2));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(2' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Cube,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Cube.cs,CreateCubeGeometry,The following statement contains a magic number: face.Indices.Add(new Index(2' 3));
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Grid,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Grid.cs,CreateDisplayList,The following statement contains a magic number: for (int i = -10; i <= 10; i++)              {                  float fcol = ((i % 10) == 0) ? 0.3f : 0.15f;                  gl.Color(fcol' fcol' fcol);                  gl.Vertex(i' -10' 0);                  gl.Vertex(i' 10' 0);                  gl.Vertex(-10' i' 0);                  gl.Vertex(10' i' 0);              }
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Triangulate,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Number of triangles = vertices - 2.  				int triangles = face.Indices.Count - 2;    				//	Is it a triangle already?...  				if(triangles == 1)  				{  					newFaces.Add(face);  					continue;  				}    				//	Add a set of triangles.  				for(int i=0; i<triangles; i++)  				{  					Face triangle = new Face();  					triangle.Indices.Add(new Index(face.Indices[0]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					newFaces.Add(triangle);  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Triangulate,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Number of triangles = vertices - 2.  				int triangles = face.Indices.Count - 2;    				//	Is it a triangle already?...  				if(triangles == 1)  				{  					newFaces.Add(face);  					continue;  				}    				//	Add a set of triangles.  				for(int i=0; i<triangles; i++)  				{  					Face triangle = new Face();  					triangle.Indices.Add(new Index(face.Indices[0]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					newFaces.Add(triangle);  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Triangulate,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Number of triangles = vertices - 2.  				int triangles = face.Indices.Count - 2;    				//	Is it a triangle already?...  				if(triangles == 1)  				{  					newFaces.Add(face);  					continue;  				}    				//	Add a set of triangles.  				for(int i=0; i<triangles; i++)  				{  					Face triangle = new Face();  					triangle.Indices.Add(new Index(face.Indices[0]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+2]));  					triangle.Indices.Add(new Index(face.Indices[i+1]));  					newFaces.Add(triangle);  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Render,The following statement contains a magic number: foreach (Face face in faces)              {                  //  If the face has its own material' push it.                  if (face.Material != null)                      face.Material.Push(gl);                    //	Begin drawing a polygon.                  if (face.Indices.Count == 2)                      gl.Begin(OpenGL.GL_LINES);                  else                      gl.Begin(OpenGL.GL_POLYGON);                    foreach (Index index in face.Indices)                  {                      //	Set a texture coord (if any).                      if (index.UV != -1)                          gl.TexCoord(uvs[index.UV]);                        //	Set a normal' or generate one.                      if (index.Normal != -1)                          gl.Normal(normals[index.Normal]);                      else                      {                          //	Do we have enough vertices for a normal?                          if (face.Indices.Count >= 3)                          {                              //	Create a normal.                              Vertex vNormal = face.GetSurfaceNormal(this);                              vNormal.UnitLength();                                // todo use auto smoothing instead                              //	Add it to the normals' setting the index for next time.                              normals.Add(vNormal);                              index.Normal = normals.Count - 1;                                gl.Normal(vNormal);                          }                      }                        //	Set the vertex.                      gl.Vertex(vertices[index.Vertex]);                  }                    gl.End();                    //  If the face has its own material' pop it.                  if (face.Material != null)                      face.Material.Pop(gl);              }
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Render,The following statement contains a magic number: foreach (Face face in faces)              {                  //  If the face has its own material' push it.                  if (face.Material != null)                      face.Material.Push(gl);                    //	Begin drawing a polygon.                  if (face.Indices.Count == 2)                      gl.Begin(OpenGL.GL_LINES);                  else                      gl.Begin(OpenGL.GL_POLYGON);                    foreach (Index index in face.Indices)                  {                      //	Set a texture coord (if any).                      if (index.UV != -1)                          gl.TexCoord(uvs[index.UV]);                        //	Set a normal' or generate one.                      if (index.Normal != -1)                          gl.Normal(normals[index.Normal]);                      else                      {                          //	Do we have enough vertices for a normal?                          if (face.Indices.Count >= 3)                          {                              //	Create a normal.                              Vertex vNormal = face.GetSurfaceNormal(this);                              vNormal.UnitLength();                                // todo use auto smoothing instead                              //	Add it to the normals' setting the index for next time.                              normals.Add(vNormal);                              index.Normal = normals.Count - 1;                                gl.Normal(vNormal);                          }                      }                        //	Set the vertex.                      gl.Vertex(vertices[index.Vertex]);                  }                    gl.End();                    //  If the face has its own material' pop it.                  if (face.Material != null)                      face.Material.Pop(gl);              }
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,OptimisePolygon,The following statement contains a magic number: return (facesAfter / facesBefore) * 100;
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Assert that it's a triangle.  				if(face.Count != 3)  					continue;  			  				//	Find the point of intersection upon the plane' as a point 't' along  				//	the ray.  				Vertex point1OnPlane = vertices[face.Indices[0].Vertex];  				Vertex point2OnPlane = vertices[face.Indices[1].Vertex];  				Vertex point3OnPlane = vertices[face.Indices[2].Vertex];  				Vertex midpointOpp1 = (point2OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp2 = (point1OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp3 = (point1OnPlane + point2OnPlane) / 2;  				  				Vertex planeNormal = face.GetSurfaceNormal(this);      				Vertex diff = point1OnPlane - ray.origin;  				float s1 = diff.ScalarProduct(planeNormal);  				float s2 =  ray.direction.ScalarProduct(planeNormal);    				if(s2 == 0)  					continue;  				float t = s1 / s2;  				if(t < 0)  					continue;  	  				float denomintor = planeNormal.ScalarProduct(ray.direction);  				if(denomintor < 0.00001f && denomintor > -0.00001f)  					continue;	//	doesn't intersect the plane.    			//	Vertex v = point1OnPlane - ray.origin;  			//	float t = (v.ScalarProduct(planeNormal)) / denomintor;    				//	Now we can get the point of intersection.  				Vertex vIntersect = ray.origin + (ray.direction * t);    				//	Do my cool test.  				Vertex vectorTo1 = vIntersect - point1OnPlane;  				Vertex vectorTo2 = vIntersect - point2OnPlane;  				Vertex vectorTo3 = vIntersect - point3OnPlane;  				Vertex vectorMidTo1 = midpointOpp1 - point1OnPlane;  				Vertex vectorMidTo2 = midpointOpp2 - point2OnPlane;  				Vertex vectorMidTo3 = midpointOpp3 - point3OnPlane;  				  				if(vectorTo1.Magnitude() > vectorMidTo1.Magnitude())  					continue;  				if(vectorTo2.Magnitude() > vectorMidTo2.Magnitude())  					continue;  				if(vectorTo3.Magnitude() > vectorMidTo3.Magnitude())  					continue;    				if(intersect.closeness == -1 || t < intersect.closeness)   				{  					//	It's fucking intersection city man  					intersect.point = vIntersect;  					intersect.intersected = true;  					intersect.normal = planeNormal;  					intersect.closeness = t;  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Assert that it's a triangle.  				if(face.Count != 3)  					continue;  			  				//	Find the point of intersection upon the plane' as a point 't' along  				//	the ray.  				Vertex point1OnPlane = vertices[face.Indices[0].Vertex];  				Vertex point2OnPlane = vertices[face.Indices[1].Vertex];  				Vertex point3OnPlane = vertices[face.Indices[2].Vertex];  				Vertex midpointOpp1 = (point2OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp2 = (point1OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp3 = (point1OnPlane + point2OnPlane) / 2;  				  				Vertex planeNormal = face.GetSurfaceNormal(this);      				Vertex diff = point1OnPlane - ray.origin;  				float s1 = diff.ScalarProduct(planeNormal);  				float s2 =  ray.direction.ScalarProduct(planeNormal);    				if(s2 == 0)  					continue;  				float t = s1 / s2;  				if(t < 0)  					continue;  	  				float denomintor = planeNormal.ScalarProduct(ray.direction);  				if(denomintor < 0.00001f && denomintor > -0.00001f)  					continue;	//	doesn't intersect the plane.    			//	Vertex v = point1OnPlane - ray.origin;  			//	float t = (v.ScalarProduct(planeNormal)) / denomintor;    				//	Now we can get the point of intersection.  				Vertex vIntersect = ray.origin + (ray.direction * t);    				//	Do my cool test.  				Vertex vectorTo1 = vIntersect - point1OnPlane;  				Vertex vectorTo2 = vIntersect - point2OnPlane;  				Vertex vectorTo3 = vIntersect - point3OnPlane;  				Vertex vectorMidTo1 = midpointOpp1 - point1OnPlane;  				Vertex vectorMidTo2 = midpointOpp2 - point2OnPlane;  				Vertex vectorMidTo3 = midpointOpp3 - point3OnPlane;  				  				if(vectorTo1.Magnitude() > vectorMidTo1.Magnitude())  					continue;  				if(vectorTo2.Magnitude() > vectorMidTo2.Magnitude())  					continue;  				if(vectorTo3.Magnitude() > vectorMidTo3.Magnitude())  					continue;    				if(intersect.closeness == -1 || t < intersect.closeness)   				{  					//	It's fucking intersection city man  					intersect.point = vIntersect;  					intersect.intersected = true;  					intersect.normal = planeNormal;  					intersect.closeness = t;  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Assert that it's a triangle.  				if(face.Count != 3)  					continue;  			  				//	Find the point of intersection upon the plane' as a point 't' along  				//	the ray.  				Vertex point1OnPlane = vertices[face.Indices[0].Vertex];  				Vertex point2OnPlane = vertices[face.Indices[1].Vertex];  				Vertex point3OnPlane = vertices[face.Indices[2].Vertex];  				Vertex midpointOpp1 = (point2OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp2 = (point1OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp3 = (point1OnPlane + point2OnPlane) / 2;  				  				Vertex planeNormal = face.GetSurfaceNormal(this);      				Vertex diff = point1OnPlane - ray.origin;  				float s1 = diff.ScalarProduct(planeNormal);  				float s2 =  ray.direction.ScalarProduct(planeNormal);    				if(s2 == 0)  					continue;  				float t = s1 / s2;  				if(t < 0)  					continue;  	  				float denomintor = planeNormal.ScalarProduct(ray.direction);  				if(denomintor < 0.00001f && denomintor > -0.00001f)  					continue;	//	doesn't intersect the plane.    			//	Vertex v = point1OnPlane - ray.origin;  			//	float t = (v.ScalarProduct(planeNormal)) / denomintor;    				//	Now we can get the point of intersection.  				Vertex vIntersect = ray.origin + (ray.direction * t);    				//	Do my cool test.  				Vertex vectorTo1 = vIntersect - point1OnPlane;  				Vertex vectorTo2 = vIntersect - point2OnPlane;  				Vertex vectorTo3 = vIntersect - point3OnPlane;  				Vertex vectorMidTo1 = midpointOpp1 - point1OnPlane;  				Vertex vectorMidTo2 = midpointOpp2 - point2OnPlane;  				Vertex vectorMidTo3 = midpointOpp3 - point3OnPlane;  				  				if(vectorTo1.Magnitude() > vectorMidTo1.Magnitude())  					continue;  				if(vectorTo2.Magnitude() > vectorMidTo2.Magnitude())  					continue;  				if(vectorTo3.Magnitude() > vectorMidTo3.Magnitude())  					continue;    				if(intersect.closeness == -1 || t < intersect.closeness)   				{  					//	It's fucking intersection city man  					intersect.point = vIntersect;  					intersect.intersected = true;  					intersect.normal = planeNormal;  					intersect.closeness = t;  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Assert that it's a triangle.  				if(face.Count != 3)  					continue;  			  				//	Find the point of intersection upon the plane' as a point 't' along  				//	the ray.  				Vertex point1OnPlane = vertices[face.Indices[0].Vertex];  				Vertex point2OnPlane = vertices[face.Indices[1].Vertex];  				Vertex point3OnPlane = vertices[face.Indices[2].Vertex];  				Vertex midpointOpp1 = (point2OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp2 = (point1OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp3 = (point1OnPlane + point2OnPlane) / 2;  				  				Vertex planeNormal = face.GetSurfaceNormal(this);      				Vertex diff = point1OnPlane - ray.origin;  				float s1 = diff.ScalarProduct(planeNormal);  				float s2 =  ray.direction.ScalarProduct(planeNormal);    				if(s2 == 0)  					continue;  				float t = s1 / s2;  				if(t < 0)  					continue;  	  				float denomintor = planeNormal.ScalarProduct(ray.direction);  				if(denomintor < 0.00001f && denomintor > -0.00001f)  					continue;	//	doesn't intersect the plane.    			//	Vertex v = point1OnPlane - ray.origin;  			//	float t = (v.ScalarProduct(planeNormal)) / denomintor;    				//	Now we can get the point of intersection.  				Vertex vIntersect = ray.origin + (ray.direction * t);    				//	Do my cool test.  				Vertex vectorTo1 = vIntersect - point1OnPlane;  				Vertex vectorTo2 = vIntersect - point2OnPlane;  				Vertex vectorTo3 = vIntersect - point3OnPlane;  				Vertex vectorMidTo1 = midpointOpp1 - point1OnPlane;  				Vertex vectorMidTo2 = midpointOpp2 - point2OnPlane;  				Vertex vectorMidTo3 = midpointOpp3 - point3OnPlane;  				  				if(vectorTo1.Magnitude() > vectorMidTo1.Magnitude())  					continue;  				if(vectorTo2.Magnitude() > vectorMidTo2.Magnitude())  					continue;  				if(vectorTo3.Magnitude() > vectorMidTo3.Magnitude())  					continue;    				if(intersect.closeness == -1 || t < intersect.closeness)   				{  					//	It's fucking intersection city man  					intersect.point = vIntersect;  					intersect.intersected = true;  					intersect.normal = planeNormal;  					intersect.closeness = t;  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,TestIntersection,The following statement contains a magic number: foreach(Face face in faces)  			{  				//	Assert that it's a triangle.  				if(face.Count != 3)  					continue;  			  				//	Find the point of intersection upon the plane' as a point 't' along  				//	the ray.  				Vertex point1OnPlane = vertices[face.Indices[0].Vertex];  				Vertex point2OnPlane = vertices[face.Indices[1].Vertex];  				Vertex point3OnPlane = vertices[face.Indices[2].Vertex];  				Vertex midpointOpp1 = (point2OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp2 = (point1OnPlane + point3OnPlane) / 2;  				Vertex midpointOpp3 = (point1OnPlane + point2OnPlane) / 2;  				  				Vertex planeNormal = face.GetSurfaceNormal(this);      				Vertex diff = point1OnPlane - ray.origin;  				float s1 = diff.ScalarProduct(planeNormal);  				float s2 =  ray.direction.ScalarProduct(planeNormal);    				if(s2 == 0)  					continue;  				float t = s1 / s2;  				if(t < 0)  					continue;  	  				float denomintor = planeNormal.ScalarProduct(ray.direction);  				if(denomintor < 0.00001f && denomintor > -0.00001f)  					continue;	//	doesn't intersect the plane.    			//	Vertex v = point1OnPlane - ray.origin;  			//	float t = (v.ScalarProduct(planeNormal)) / denomintor;    				//	Now we can get the point of intersection.  				Vertex vIntersect = ray.origin + (ray.direction * t);    				//	Do my cool test.  				Vertex vectorTo1 = vIntersect - point1OnPlane;  				Vertex vectorTo2 = vIntersect - point2OnPlane;  				Vertex vectorTo3 = vIntersect - point3OnPlane;  				Vertex vectorMidTo1 = midpointOpp1 - point1OnPlane;  				Vertex vectorMidTo2 = midpointOpp2 - point2OnPlane;  				Vertex vectorMidTo3 = midpointOpp3 - point3OnPlane;  				  				if(vectorTo1.Magnitude() > vectorMidTo1.Magnitude())  					continue;  				if(vectorTo2.Magnitude() > vectorMidTo2.Magnitude())  					continue;  				if(vectorTo3.Magnitude() > vectorMidTo3.Magnitude())  					continue;    				if(intersect.closeness == -1 || t < intersect.closeness)   				{  					//	It's fucking intersection city man  					intersect.point = vIntersect;  					intersect.intersected = true;  					intersect.normal = planeNormal;  					intersect.closeness = t;  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Subdivide,The following statement contains a magic number: foreach(Face face in Faces)  			{  				//	Make sure the face is a triangle.  				if(face.Count != 3)  					continue;    				//	Now get the vertices of the face.  				Vertex v1 = Vertices[face.Indices[0].Vertex];  				Vertex v2 = Vertices[face.Indices[1].Vertex];  				Vertex v3 = Vertices[face.Indices[2].Vertex];    				//	Add the vertices to get a the midpoint of the edge formed by those  				//	vectors.  				Vertex vMidpoint = (v1 + v2 + v3) / 3;  				Index iMidpoint = new Index(Vertices.Count);                  Vertices.Add(vMidpoint);    				//	Now make three new faces from the old vertices and the midpoint.  				Face newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Subdivide,The following statement contains a magic number: foreach(Face face in Faces)  			{  				//	Make sure the face is a triangle.  				if(face.Count != 3)  					continue;    				//	Now get the vertices of the face.  				Vertex v1 = Vertices[face.Indices[0].Vertex];  				Vertex v2 = Vertices[face.Indices[1].Vertex];  				Vertex v3 = Vertices[face.Indices[2].Vertex];    				//	Add the vertices to get a the midpoint of the edge formed by those  				//	vectors.  				Vertex vMidpoint = (v1 + v2 + v3) / 3;  				Index iMidpoint = new Index(Vertices.Count);                  Vertices.Add(vMidpoint);    				//	Now make three new faces from the old vertices and the midpoint.  				Face newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Subdivide,The following statement contains a magic number: foreach(Face face in Faces)  			{  				//	Make sure the face is a triangle.  				if(face.Count != 3)  					continue;    				//	Now get the vertices of the face.  				Vertex v1 = Vertices[face.Indices[0].Vertex];  				Vertex v2 = Vertices[face.Indices[1].Vertex];  				Vertex v3 = Vertices[face.Indices[2].Vertex];    				//	Add the vertices to get a the midpoint of the edge formed by those  				//	vectors.  				Vertex vMidpoint = (v1 + v2 + v3) / 3;  				Index iMidpoint = new Index(Vertices.Count);                  Vertices.Add(vMidpoint);    				//	Now make three new faces from the old vertices and the midpoint.  				Face newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Subdivide,The following statement contains a magic number: foreach(Face face in Faces)  			{  				//	Make sure the face is a triangle.  				if(face.Count != 3)  					continue;    				//	Now get the vertices of the face.  				Vertex v1 = Vertices[face.Indices[0].Vertex];  				Vertex v2 = Vertices[face.Indices[1].Vertex];  				Vertex v3 = Vertices[face.Indices[2].Vertex];    				//	Add the vertices to get a the midpoint of the edge formed by those  				//	vectors.  				Vertex vMidpoint = (v1 + v2 + v3) / 3;  				Index iMidpoint = new Index(Vertices.Count);                  Vertices.Add(vMidpoint);    				//	Now make three new faces from the old vertices and the midpoint.  				Face newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);  			}
Magic Number,SharpGL.SceneGraph.Primitives,Polygon,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Polygon.cs,Subdivide,The following statement contains a magic number: foreach(Face face in Faces)  			{  				//	Make sure the face is a triangle.  				if(face.Count != 3)  					continue;    				//	Now get the vertices of the face.  				Vertex v1 = Vertices[face.Indices[0].Vertex];  				Vertex v2 = Vertices[face.Indices[1].Vertex];  				Vertex v3 = Vertices[face.Indices[2].Vertex];    				//	Add the vertices to get a the midpoint of the edge formed by those  				//	vectors.  				Vertex vMidpoint = (v1 + v2 + v3) / 3;  				Index iMidpoint = new Index(Vertices.Count);                  Vertices.Add(vMidpoint);    				//	Now make three new faces from the old vertices and the midpoint.  				Face newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[1]));  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);    				newFace = new Face();  				newFace.Indices.Add(new Index(face.Indices[2]));  				newFace.Indices.Add(new Index(face.Indices[0]));  				newFace.Indices.Add(iMidpoint);  				newFaces.Add(newFace);  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,SetConnectivity,The following statement contains a magic number: foreach(Face face in faces)  			{  				face.NeighbourIndices = new int[face.Indices.Count];                  for (int i = 0; i < face.NeighbourIndices.Length; i++)                      face.NeighbourIndices[i] = -2;		//	-2 = no neighbour calculated.  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,SetConnectivity,The following statement contains a magic number: for(int faceAindex = 0; faceAindex < faces.Count; faceAindex++)  			{  				Face faceA = faces[faceAindex];                    for (int edgeA = 0; edgeA < faceA.NeighbourIndices.Length; edgeA++)  				{                      if (faceA.NeighbourIndices[edgeA] == -2)  					{  						//	We don't yet know the neighbor.  						bool found = false;  						for(int faceBindex = 0; faceBindex < faces.Count; faceBindex++)  						{  							if(faceBindex == faceAindex) continue;    							Face faceB = faces[faceBindex];                                  for (int edgeB = 0; edgeB < faceB.NeighbourIndices.Length; edgeB++)  							{  								int vA1 = faceA.Indices[edgeA].Vertex;  								int vA2 = faceA.Indices[(edgeA+1)%faceA.Indices.Count].Vertex;  								int vB1 = faceB.Indices[edgeB].Vertex;  								int vB2 = faceB.Indices[(edgeB+1)%faceB.Indices.Count].Vertex;    								//	Check if they're neighbours...  								if((vA1 == vB1 && vA2 == vB2) || (vA1 == vB2 && vA2 == vB1))  								{                                      faceA.NeighbourIndices[edgeA] = faceBindex;                                      faceB.NeighbourIndices[edgeB] = faceAindex;  									found = true;  									break;  								}  							}  							if(found)  								break;  						}  						if(found == false)                              faceA.NeighbourIndices[edgeA] = -1;  					}  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,CastShadow,The following statement contains a magic number: foreach(var light in lights)  			{  				//	Every face will have a visibility setting.  				bool[] facesVisible = new bool[faces.Count];    				//	Get the light position relative to the polygon.  				Vertex lightPos = light.Position;  				lightPos = lightPos - ParentPolygon.Transformation.TranslationVertex;    				//	Go through every face' finding out whether it's visible to the light.  				for(int nFace = 0; nFace < faces.Count; nFace++)  				{  					//	Get a reference to the face.  					Face face = faces[nFace];    					//	Is this face facing the light?  					float[] planeEquation = face.GetPlaneEquation(ParentPolygon);  					float side = planeEquation[0] * lightPos.X +   						planeEquation[1] * lightPos.Y +   						planeEquation[2] * lightPos.Z + planeEquation[3];  					facesVisible[nFace] = (side > 0) ? true : false;  				}    				//	Save all the attributes.                  gl.PushAttrib(OpenGL.GL_ALL_ATTRIB_BITS);  			  				//	Turn off lighting.                  gl.Disable(OpenGL.GL_LIGHTING);    				//	Turn off writing to the depth mask.  				gl.DepthMask(0);                  gl.DepthFunc(OpenGL.GL_LEQUAL);    				//	Turn on stencil buffer testing.                  gl.Enable(OpenGL.GL_STENCIL_TEST);    				//	Translate our shadow volumes.  				ParentPolygon.PushObjectSpace(gl);    				//	Don't draw to the color buffer.  				gl.ColorMask(0' 0' 0' 0);                  gl.StencilFunc(OpenGL.GL_ALWAYS' 1' 0xFFFFFFFF);                    gl.Enable(OpenGL.GL_CULL_FACE);  			  				//	First Pass. Increase Stencil Value In The Shadow                  gl.FrontFace(OpenGL.GL_CCW);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_INCR);  				DoShadowPass(gl' lightPos' facesVisible);    				//	Second Pass. Decrease Stencil Value In The Shadow                  gl.FrontFace(OpenGL.GL_CW);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_DECR);  				DoShadowPass(gl' lightPos' facesVisible);                    gl.FrontFace(OpenGL.GL_CCW);    				ParentPolygon.PopObjectSpace(gl);  			  				//	Enable writing to the color buffer.  				gl.ColorMask(1' 1' 1' 1);                 				// Draw A Shadowing Rectangle Covering The Entire Screen  				gl.Color(light.ShadowColor);                  gl.Enable(OpenGL.GL_BLEND);                  gl.BlendFunc(OpenGL.GL_SRC_ALPHA' OpenGL.GL_ONE_MINUS_SRC_ALPHA);                  gl.StencilFunc(OpenGL.GL_NOTEQUAL' 0' 0xFFFFFFF);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_KEEP);  				  				Quadrics.Sphere shadow = new Quadrics.Sphere();                  shadow.Transformation.ScaleX = shadowSize;                  shadow.Transformation.ScaleY = shadowSize;                  shadow.Transformation.ScaleZ = shadowSize;  				shadow.Render(gl' RenderMode.Design);  	  				gl.PopAttrib();  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,CastShadow,The following statement contains a magic number: foreach(var light in lights)  			{  				//	Every face will have a visibility setting.  				bool[] facesVisible = new bool[faces.Count];    				//	Get the light position relative to the polygon.  				Vertex lightPos = light.Position;  				lightPos = lightPos - ParentPolygon.Transformation.TranslationVertex;    				//	Go through every face' finding out whether it's visible to the light.  				for(int nFace = 0; nFace < faces.Count; nFace++)  				{  					//	Get a reference to the face.  					Face face = faces[nFace];    					//	Is this face facing the light?  					float[] planeEquation = face.GetPlaneEquation(ParentPolygon);  					float side = planeEquation[0] * lightPos.X +   						planeEquation[1] * lightPos.Y +   						planeEquation[2] * lightPos.Z + planeEquation[3];  					facesVisible[nFace] = (side > 0) ? true : false;  				}    				//	Save all the attributes.                  gl.PushAttrib(OpenGL.GL_ALL_ATTRIB_BITS);  			  				//	Turn off lighting.                  gl.Disable(OpenGL.GL_LIGHTING);    				//	Turn off writing to the depth mask.  				gl.DepthMask(0);                  gl.DepthFunc(OpenGL.GL_LEQUAL);    				//	Turn on stencil buffer testing.                  gl.Enable(OpenGL.GL_STENCIL_TEST);    				//	Translate our shadow volumes.  				ParentPolygon.PushObjectSpace(gl);    				//	Don't draw to the color buffer.  				gl.ColorMask(0' 0' 0' 0);                  gl.StencilFunc(OpenGL.GL_ALWAYS' 1' 0xFFFFFFFF);                    gl.Enable(OpenGL.GL_CULL_FACE);  			  				//	First Pass. Increase Stencil Value In The Shadow                  gl.FrontFace(OpenGL.GL_CCW);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_INCR);  				DoShadowPass(gl' lightPos' facesVisible);    				//	Second Pass. Decrease Stencil Value In The Shadow                  gl.FrontFace(OpenGL.GL_CW);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_DECR);  				DoShadowPass(gl' lightPos' facesVisible);                    gl.FrontFace(OpenGL.GL_CCW);    				ParentPolygon.PopObjectSpace(gl);  			  				//	Enable writing to the color buffer.  				gl.ColorMask(1' 1' 1' 1);                 				// Draw A Shadowing Rectangle Covering The Entire Screen  				gl.Color(light.ShadowColor);                  gl.Enable(OpenGL.GL_BLEND);                  gl.BlendFunc(OpenGL.GL_SRC_ALPHA' OpenGL.GL_ONE_MINUS_SRC_ALPHA);                  gl.StencilFunc(OpenGL.GL_NOTEQUAL' 0' 0xFFFFFFF);                  gl.StencilOp(OpenGL.GL_KEEP' OpenGL.GL_KEEP' OpenGL.GL_KEEP);  				  				Quadrics.Sphere shadow = new Quadrics.Sphere();                  shadow.Transformation.ScaleX = shadowSize;                  shadow.Transformation.ScaleY = shadowSize;                  shadow.Transformation.ScaleZ = shadowSize;  				shadow.Render(gl' RenderMode.Design);  	  				gl.PopAttrib();  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,DoShadowPass,The following statement contains a magic number: for(int i = 0; i < faces.Count; i++)  			{  				//	Get a reference to the face.  				Face face = faces[i];  				  				//	Is the face visible...  				if(visibleArray[i])  				{  					//	Go through each edge...  					for(int j = 0; j < face.Indices.Count; j++)  					{  						//	Get the neighbour of this edge.                          int neighbourIndex = face.NeighbourIndices[j];    						//	If there's no neighbour' or the neighbour ain't visible' it's  						//	an edge...  						if(neighbourIndex == -1 || visibleArray[neighbourIndex] == false )  						{  							//	Get the edge vertices.  							Vertex v1 = vertices[face.Indices[j].Vertex];  							Vertex v2 = vertices[face.Indices[(j+1)%face.Indices.Count].Vertex];  						  							//	Create the two distant vertices.  							Vertex v3 = (v1 - lightPos) * 100;  							Vertex v4 = (v2 - lightPos) * 100;  							  							//	Draw the shadow volume.                              gl.Begin(OpenGL.GL_TRIANGLE_STRIP);  							gl.Vertex(v1);  							gl.Vertex(v1 + v3);  							gl.Vertex(v2);  							gl.Vertex(v2 + v4);  							gl.End();  						}  					}  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Shadow,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Shadow.cs,DoShadowPass,The following statement contains a magic number: for(int i = 0; i < faces.Count; i++)  			{  				//	Get a reference to the face.  				Face face = faces[i];  				  				//	Is the face visible...  				if(visibleArray[i])  				{  					//	Go through each edge...  					for(int j = 0; j < face.Indices.Count; j++)  					{  						//	Get the neighbour of this edge.                          int neighbourIndex = face.NeighbourIndices[j];    						//	If there's no neighbour' or the neighbour ain't visible' it's  						//	an edge...  						if(neighbourIndex == -1 || visibleArray[neighbourIndex] == false )  						{  							//	Get the edge vertices.  							Vertex v1 = vertices[face.Indices[j].Vertex];  							Vertex v2 = vertices[face.Indices[(j+1)%face.Indices.Count].Vertex];  						  							//	Create the two distant vertices.  							Vertex v3 = (v1 - lightPos) * 100;  							Vertex v4 = (v2 - lightPos) * 100;  							  							//	Draw the shadow volume.                              gl.Begin(OpenGL.GL_TRIANGLE_STRIP);  							gl.Vertex(v1);  							gl.Vertex(v1 + v3);  							gl.Vertex(v2);  							gl.Vertex(v2 + v4);  							gl.End();  						}  					}  				}  			}
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Teapot,The following statement contains a magic number: Grid = 14;
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] p = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] p = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] p = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] q = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] q = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] q = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] r = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] r = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] r = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] s = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] s = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: float[' '] s = new float[4' 4' 3];
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: gl.Translate(0.0' 0.0' -1.5);
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Primitives,Teapot,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Primitives\Teapot.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++)              {                  for (int j = 0; j < 4; j++)                  {                      for (int k = 0; k < 4; k++)                      {                          for (int l = 0; l < 3; l++)                          {                              p[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                              q[j'k'l] = cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                              if (l == 1)                                  q[j'k'l] *= -1.0f;                              if (i < 6)                              {                                  r[j'k'l] =                                    cpdata[patchdata[i'(j * 4 + (3 - k))]'l];                                  if (l == 0)                                      r[j'k'l] *= -1.0f;                                  s[j'k'l] = cpdata[patchdata[i'(j * 4 + k)]'l];                                  if (l == 0)                                      s[j'k'l] *= -1.0f;                                  if (l == 1)                                      s[j'k'l] *= -1.0f;                              }                          }                      }                  }                  gl.Map2(OpenGL.GL_MAP2_TEXTURE_COORD_2' 0.0f' 1.0f' 2' 2' 0.0f' 1.0f' 4' 2'                    tex.Flatten());                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    p.Flatten());                  gl.MapGrid2(grid' 0.0' 1.0' grid' 0.0' 1.0);                  gl.EvalMesh2(type' 0' grid' 0' grid);                  gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                    q.Flatten());                  gl.EvalMesh2(type' 0' grid' 0' grid);                  if (i < 6)                  {                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        r.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                      gl.Map2(OpenGL.GL_MAP2_VERTEX_3' 0' 1' 3' 4' 0' 1' 12' 4'                        s.Flatten());                      gl.EvalMesh2(type' 0' grid' 0' grid);                  }              }
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: double[] modelview = new double[16];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: double[] projection = new double[16];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: int[] viewport = new int[4];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: int screenwidth = viewport[2];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: int screenheight = viewport[3];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: Vertex vScreenOrigin = new Vertex(0' 0' 5);
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: ScreenPixel[] pixels = new ScreenPixel[viewport[2] * viewport[3]];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: ScreenPixel[] pixels = new ScreenPixel[viewport[2] * viewport[3]];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: for (int y = 0; y < screenheight; y++)              {                  for (int x = 0; x < screenwidth; x++)                  {                      //	Get plane coordinates first of all.                      int planeX = x - (screenwidth / 2);                      int planeY = y - (screenwidth / 2);                        float worldX = vScreenOrigin.X + (planeX * t.X) + (planeY * s.X);                      float worldY = vScreenOrigin.Y + (planeX * t.Y) + (planeY * s.Y);                      float worldZ = vScreenOrigin.Z + (planeX * t.Z) + (planeY * s.Z);                        //	Finally' pack all that data into a ScreenPixel.                      ScreenPixel pixel = new ScreenPixel();                      pixel.x = x;                      pixel.y = y;                      pixel.worldpos = new Vertex(worldX' worldY' worldZ);                      pixel.ray.origin = camera.Position;                      pixel.ray.direction = pixel.worldpos - camera.Position;                        pixels[(y * viewport[2]) + x] = pixel;                  }              }
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: for (int y = 0; y < screenheight; y++)              {                  for (int x = 0; x < screenwidth; x++)                  {                      //	Get plane coordinates first of all.                      int planeX = x - (screenwidth / 2);                      int planeY = y - (screenwidth / 2);                        float worldX = vScreenOrigin.X + (planeX * t.X) + (planeY * s.X);                      float worldY = vScreenOrigin.Y + (planeX * t.Y) + (planeY * s.Y);                      float worldZ = vScreenOrigin.Z + (planeX * t.Z) + (planeY * s.Z);                        //	Finally' pack all that data into a ScreenPixel.                      ScreenPixel pixel = new ScreenPixel();                      pixel.x = x;                      pixel.y = y;                      pixel.worldpos = new Vertex(worldX' worldY' worldZ);                      pixel.ray.origin = camera.Position;                      pixel.ray.direction = pixel.worldpos - camera.Position;                        pixels[(y * viewport[2]) + x] = pixel;                  }              }
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: for (int y = 0; y < screenheight; y++)              {                  for (int x = 0; x < screenwidth; x++)                  {                      //	Get plane coordinates first of all.                      int planeX = x - (screenwidth / 2);                      int planeY = y - (screenwidth / 2);                        float worldX = vScreenOrigin.X + (planeX * t.X) + (planeY * s.X);                      float worldY = vScreenOrigin.Y + (planeX * t.Y) + (planeY * s.Y);                      float worldZ = vScreenOrigin.Z + (planeX * t.Z) + (planeY * s.Z);                        //	Finally' pack all that data into a ScreenPixel.                      ScreenPixel pixel = new ScreenPixel();                      pixel.x = x;                      pixel.y = y;                      pixel.worldpos = new Vertex(worldX' worldY' worldZ);                      pixel.ray.origin = camera.Position;                      pixel.ray.direction = pixel.worldpos - camera.Position;                        pixels[(y * viewport[2]) + x] = pixel;                  }              }
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: System.Drawing.Bitmap bmp = new System.Drawing.Bitmap(viewport[2]' viewport[3]);
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: System.Drawing.Bitmap bmp = new System.Drawing.Bitmap(viewport[2]' viewport[3]);
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: int pixelcount = viewport[2] * viewport[3];
Magic Number,SharpGL.SceneGraph.Raytracing,RayTracer,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Raytracing\RayTracer.cs,Render,The following statement contains a magic number: int pixelcount = viewport[2] * viewport[3];
Magic Number,SharpGL.SceneGraph.Shaders,ShaderProgram,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Shaders\ShaderProgram.cs,SetFullShaderSource,The following statement contains a magic number: foreach (var line in lines)              {                  //  If the line is a vertex shader' switch to vertex mode.                  if (line.StartsWith("--") && line.Contains("Vertex"))                  {                      code = 1;                  }                  else if (line.StartsWith("--") && line.Contains("Fragment"))                  {                      code = 2;                  }                  else                  {                      //  Add the line to the appropriate shader.                      switch (code)                      {                          case 1:                              vertexShader += line + Environment.NewLine;                              break;                          case 2:                              fragmentShader += line + Environment.NewLine;                              break;                      }                  }              }
Magic Number,SharpGL.SceneGraph.Shaders,ShaderProgram,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Shaders\ShaderProgram.cs,SetFullShaderSource,The following statement contains a magic number: foreach (var line in lines)              {                  //  If the line is a vertex shader' switch to vertex mode.                  if (line.StartsWith("--") && line.Contains("Vertex"))                  {                      code = 1;                  }                  else if (line.StartsWith("--") && line.Contains("Fragment"))                  {                      code = 2;                  }                  else                  {                      //  Add the line to the appropriate shader.                      switch (code)                      {                          case 1:                              vertexShader += line + Environment.NewLine;                              break;                          case 2:                              fragmentShader += line + Environment.NewLine;                              break;                      }                  }              }
Missing Default,SharpGL.SceneGraph.Feedback,Triangulator,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Feedback\Triangulator.cs,ParseData,The following switch statement is missing a default case: switch ((int)token)                  {                      case (int)OpenGL.GL_PASS_THROUGH_TOKEN:                          count--;                          break;                      case (int)OpenGL.GL_POINT_TOKEN:                          //	We use only polygons' skip this single vertex (11 floats).                          count -= 11;                          break;                      case (int)OpenGL.GL_LINE_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_LINE_RESET_TOKEN:                          //	We use only polygons' skip this vertex pair (22 floats).                          count -= 22;                          break;                      case (int)OpenGL.GL_POLYGON_TOKEN:                            //	Get the number of vertices.                          int vertexCount = (int)feedbackBuffer[values - count--];                            //	Create an array of vertices.                          Vertex[] vertices = new Vertex[vertexCount];                            //	Parse them.                          for (int i = 0; i < vertexCount; i++)                          {                              vertices[i] = new Vertex();                              double x = (double)feedbackBuffer[values - count--];                              double y = (double)feedbackBuffer[values - count--];                              double z = (double)feedbackBuffer[values - count--];                              double[] coords = gl.UnProject(x' y' z);                              vertices[i].X = (float)coords[0];                              vertices[i].Y = (float)coords[1];                              vertices[i].Z = (float)coords[2];                                //	Ignore the four r'g'b'a values and four material coords.                              count -= 8;                          }                            //	Add a new face to the current polygon.                          triangle.AddFaceFromVertexData(vertices);                            break;                  }
Missing Default,SharpGL.SceneGraph.Shaders,ShaderProgram,C:\repos\dwmkerr_sharpgl\source\SharpGL\Core\SharpGL.SceneGraph\Shaders\ShaderProgram.cs,SetFullShaderSource,The following switch statement is missing a default case: switch (code)                      {                          case 1:                              vertexShader += line + Environment.NewLine;                              break;                          case 2:                              fragmentShader += line + Environment.NewLine;                              break;                      }
