Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The method has 67 lines of code.
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: using (REngine engine = REngine.GetInstance ()) {  	var e = engine.Evaluate ("x <- 3");  	// You can now access x defined in the R environment.  	NumericVector x = engine.GetSymbol ("x").AsNumeric ();  	engine.Evaluate ("y <- 1:10");  	NumericVector y = engine.GetSymbol ("y").AsNumeric ();  	// Invoking functions; Previously you may have needed custom function definitions  	var myFunc = engine.Evaluate ("function(x' y) { expand.grid(x=x' y=y) }").AsFunction ();  	var v1 = engine.CreateIntegerVector (new[] {  		1'  		2'  		3  	});  	var v2 = engine.CreateCharacterVector (new[] {  		"a"'  		"b"'  		"c"  	});  	var df = myFunc.Invoke (new SymbolicExpression[] {  		v1'  		v2  	}).AsDataFrame ();  	// As of R.NET 1.6' more function call syntaxes are supported.  	var expandGrid = engine.Evaluate ("expand.grid").AsFunction ();  	var d = new Dictionary<string' SymbolicExpression> ();  	d ["x"] = v1;  	d ["y"] = v2;  	df = expandGrid.Invoke (d).AsDataFrame ();  	// querying data frames  	engine.SetSymbol ("cases"' df);  	// As of R.NET 1.6' factor to character expressions work consistently with R  	engine.Evaluate ("head(cases)");  	/*   x y 1 1 a 2 2 a 3 3 a 4 1 b 5 2 b 6 3 b                 */var letterCases = engine.Evaluate ("cases[''y']").AsCharacter ().ToArray ();  	// "a"'"a"'"a"'"b"'"b"'"b"' etc. Same as as.character(cases[''y']) in R  	// This used to return  "1"' "1"' "1"' "2"' "2"' etc. with R.NET 1.5.5  	// Equivalent:  	letterCases = df [1].AsCharacter ().ToArray ();  	letterCases = df ["y"].AsCharacter ().ToArray ();  	// Accessing items by two dimensional indexing  	string s = (string)df [1' 1];  	// "a"  	s = (string)df [3' 1];  	// "a"  	s = (string)df [3' "y"];  	// "b"  	// s = (string)df["4"' "y"]; // fails because there are no row names  	df [3' "y"] = "a";  	s = (string)df [3' "y"];  	// "a"  	df [3' "y"] = "d";  	s = (string)df [3' "y"];  	// null' because we have an <NA> string in R  	// invoking a whole script  	// engine.Evaluate("source('c:/src/path/to/myscript.r')");  	// TODO  	// Date-time objects  }  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: s = (string)df [3' 1];  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: s = (string)df [3' "y"];  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: df [3' "y"] = "a";  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: s = (string)df [3' "y"];  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: df [3' "y"] = "d";  
Magic Number,Sample2,Program,D:\newReposJune17\jmp75_rdotnet-onboarding\Sample2\Program.cs,Main,The following statement contains a magic number: s = (string)df [3' "y"];  
