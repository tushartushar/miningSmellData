Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MemBus.Subscribing,MessageEndpointsBuilder,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Subscribing\Adapter\MessageEndpointsBuilder.cs,BuildSubscriptions,Cyclomatic complexity of the method is 12
Long Statement,MemBus,Subscriber,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Subscriber.cs,Subscribe,The length of the statement  "                    "No subscription adapter rules were formulated. Apply the FlexibleSubscribeAdapter to state rules how some instance may be wired up into MemBus."); " is 147.
Long Statement,MemBus,SubscriptionPipeline,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Subscribing\SubscriptionPipeline.cs,GetIntroductionShape,The length of the statement  "            return _introductionShape != null ? _introductionShape.Clone() : new SubscriptionShaperAggregate(new [] {new ShapeToPassthrough()}); " is 132.
Long Statement,MemBus.Publishing,ParallelNonBlockingPublisher,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Publishing\ParallelNonBlockingPublisher.cs,LookAt,The length of the statement  "                                                  throw new MemBusException("Possible infinite messaging cycle since handling ExceptionOccurred has produced unhandled exceptions!"); " is 131.
Long Statement,MemBus.Subscribing,SubscriptionCustomizer<M>,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Subscribing\SubscriptionCustomizer.cs,DispatchOnUiThread,The length of the statement  "              throw new InvalidOperationException("No knowledge of a UI thread is available. This method cannot be called. Please setup your bus for a UI scenario with RichClientFrontend"); " is 175.
Long Statement,MemBus.Support,AbstractServices<TARGET>,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Support\AbstractServices.cs,AddExtension,The length of the statement  "        throw new ArgumentException(string.Format("An object of Type {0} is already attached to this context"' typeof(T).Name)); " is 120.
Missing Default,MemBus.Subscribing,MessageEndpointsBuilder,D:\research\architectureSmells\repos\flq_MemBus\MemBus\Subscribing\Adapter\MessageEndpointsBuilder.cs,BuildSubscriptions,The following switch statement is missing a default case: switch (group.Key)                  {                      case MethodInfoClassifier.Unusable:                          continue;                      case MethodInfoClassifier.MessageSink:                          foreach (var mi in group)                              yield return ConstructSubscription(mi.MethodInfo' targetToAdapt);                          break;                      case MethodInfoClassifier.MessageMap:                          foreach (var mi in group)                              yield return ConstructPublishingSubscription(mi.MethodInfo' targetToAdapt' _bus);                          break;                      case MethodInfoClassifier.ObservableSink:                          foreach (var mi in group)                          {                              // Could also construct a cached method looked up by message type.                              // However' typical usage would be a wire-once thing.                              var msgObsInstance = ConstructMessageObservable(mi);                              mi.MethodInfo.Invoke(targetToAdapt' new []{ msgObsInstance });                          }                          break;                      case MethodInfoClassifier.ObservableSource:                          foreach (var mi in group)                          {                              var observable = mi.MethodInfo.Invoke(targetToAdapt' null);                              var busPublish = ConstructBusPublishMethod(mi);                              busPublish.Invoke(_bus' new[] {observable});                          }                          break;                      case MethodInfoClassifier.ObservableMap:                          foreach (var mi in group)                          {                              var msgObsInstance = ConstructMessageObservable(mi);                              var observable = mi.MethodInfo.Invoke(targetToAdapt' new[] { msgObsInstance });                              var busPublish = ConstructBusPublishMethod(mi);                              busPublish.Invoke(_bus' new[] { observable });                          }                          break;                  }
