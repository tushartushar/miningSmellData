Implementation smell,Namespace,Class,File,Method,Description
Long Identifier,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,RemoveOtherTransportAssemblies,The length of the parameter currentDirectoryOfSelectedTransport is 35.
Long Identifier,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_critical_error_is_triggered,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_critical_error_is_triggered.cs,,The length of the parameter allTypesExcludingBuiltInCustomChecks is 36.
Long Identifier,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the parameter allTypesExcludingBuiltInCustomChecks is 36.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeRetriedAsPartOfGroupRetry is 36.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeArchivedUnresolvedResult is 35.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeRetriedAsPartOfGroupUnresolvedRetryResult is 52.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeRetriedAsPartOfGroupResolvedRetryResult is 50.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeArchivedArchivedResult is 33.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the parameter originalExceptionAndStackTraceFailureGroupIds is 45.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the parameter retriedExceptionAndStackTraceFailureGroupIds is 44.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the parameter exceptionTypeAndStackTraceGroups is 32.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The length of the parameter exceptionTypeAndStackTraceGroups is 32.
Long Identifier,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the parameter messageToBeRetriedAsPartOfRetryAll is 34.
Long Identifier,ServiceControl.AcceptanceTests.TestSupport.EndpointTemplates,DefaultServer,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\EndpointTemplates\DefaultServer.cs,GetConfiguration,The length of the parameter configurationBuilderCustomization is 33.
Long Identifier,ServiceControl.AcceptanceTests.TestSupport.SelfVerification,EndpointNameEnforcementTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\SelfVerification\EndpointNameEnforcementTests.cs,,The length of the parameter endpointConfigurationBuilderType is 32.
Long Statement,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,Setup,The length of the statement  "            var logFile = Path.Combine(logfilesPath' $"{TestContext.CurrentContext.Test.ID}-{TestContext.CurrentContext.Test.Name}.txt"); " is 125.
Long Statement,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,Setup,The length of the statement  "                Assert.Inconclusive($"Not flagged with [RunOnAllTransports] therefore skipping this test with '{TransportIntegration.Name}'"); " is 126.
Long Statement,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,Setup,The length of the statement  "            serviceControlRunnerBehavior = new ServiceControlComponentBehavior(TransportIntegration' s => SetSettings(s)' s => CustomConfiguration(s)); " is 139.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_a_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_a_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.EventType == typeof(CustomCheckFailed).Name); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_a_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_a_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item.StartsWith($"/endpoint/{Conventions.EndpointNamingConvention(typeof(EndpointWithFailingCustomCheck))}"))); " is 153.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_a_periodic_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_a_periodic_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.EventType == typeof(CustomCheckFailed).Name); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_a_periodic_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_a_periodic_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item.StartsWith($"/endpoint/{Conventions.EndpointNamingConvention(typeof(WithCustomCheck))}"))); " is 138.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_custom_check_events_are_triggered,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_custom_check_events_are_triggered.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.EventType == typeof(CustomCheckFailed).Name); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_critical_error_is_triggered,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_critical_error_is_triggered.cs,Service_control_is_not_killed_and_error_is_reported_via_custom_check,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.EventType == typeof(CustomCheckFailed).Name); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_critical_error_is_triggered,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_critical_error_is_triggered.cs,Service_control_is_not_killed_and_error_is_reported_via_custom_check,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item == "/customcheck/ServiceControl Primary Instance")' "Event log entry should be related to the Primary instance health Custom Check"); " is 180.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_critical_error_is_triggered,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_critical_error_is_triggered.cs,Service_control_is_not_killed_and_error_is_reported_via_custom_check,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item.StartsWith("/endpoint/Particular.ServiceControl"))' "Event log entry should be related to the ServiceControl endpoint"); " is 167.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "            var allTypesExcludingBuiltInCustomChecks = allServiceControlTypes.Where(t => !t.GetInterfaces().Contains(typeof(ICustomCheck))); " is 128.
Long Statement,ServiceControl.AcceptanceTests.Monitoring.InternalCustomChecks,When_a_custom_check_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\InternalCustomChecks\When_a_custom_check_fails.cs,Should_result_in_a_custom_check_failed_event,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.EventType == typeof(CustomCheckFailed).Name); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring,When_an_endpoint_starts_up,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\When_an_endpoint_starts_up.cs,Should_result_in_a_startup_event,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.RelatedTo.Any(r => r.Contains(typeof(StartingEndpoint).Name)) && e.EventType == typeof(EndpointStarted).Name); " is 191.
Long Statement,ServiceControl.AcceptanceTests.Monitoring,When_an_endpoint_with_heartbeat_plugin_starts_up,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\When_an_endpoint_with_heartbeat_plugin_starts_up.cs,Should_be_monitored_and_active,The length of the statement  "                    var result = await this.TryGetSingle<EndpointsView>("/api/endpoints/"' e => e.Name == EndpointName && e.Monitored && e.MonitorHeartbeat && e.IsSendingHeartbeats); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Monitoring,When_an_unmonitored_endpoint_is_marked_as_monitored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\When_an_unmonitored_endpoint_is_marked_as_monitored.cs,It_is_shown_as_inactive_if_it_does_not_send_heartbeats,The length of the statement  "                        var intermediateResult = await this.TryGetMany<EndpointsView>("/api/endpoints/"' e => e.Name == EndpointName && !e.Monitored); " is 126.
Long Statement,ServiceControl.AcceptanceTests.Monitoring,When_an_unmonitored_endpoint_is_marked_as_monitored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\When_an_unmonitored_endpoint_is_marked_as_monitored.cs,It_is_shown_as_inactive_if_it_does_not_send_heartbeats,The length of the statement  "                    var result = await this.TryGetMany<EndpointsView>("/api/endpoints/"' e => e.Name == EndpointName && e.MonitorHeartbeat && e.Monitored && !e.IsSendingHeartbeats); " is 161.
Long Statement,ServiceControl.AcceptanceTests.Monitoring,When_unmonitored_endpoint_starts_to_sends_heartbeats,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\When_unmonitored_endpoint_starts_to_sends_heartbeats.cs,Should_be_marked_as_monitored,The length of the statement  "                    var result = await this.TryGetSingle<EndpointsView>("/api/endpoints"' e => e.Name == EndpointName && e.IsSendingHeartbeats); " is 124.
Long Statement,ServiceControl.AcceptanceTests.Recoverability,EditMessageHelper,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\EditMessageHelper.cs,TryRestoreOriginalHeaderKeys,The length of the statement  "            // brings up the normal header key for most of the message headers. Unfortunately this approach can't fix all headers as during serialization some of the necessary information is lost. " is 184.
Long Statement,ServiceControl.AcceptanceTests.Recoverability,EditMessageHelper,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\EditMessageHelper.cs,TryRestoreOriginalHeaderKeys,The length of the statement  "                var newKey = Regex.Replace(headerKey' @"([0-9a-z])\.([a-z])"' m => $"{m.Groups[1].Value}.{m.Groups[2].Value.ToUpper()}"); " is 121.
Long Statement,ServiceControl.AcceptanceTests.Recoverability,When_a_native_integration_message_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\When_a_native_integration_message_is_retried.cs,Should_not_corrupt_headers,The length of the statement  "            if (TransportIntegration.Name == TransportNames.RabbitMQConventionalRoutingTopology || TransportIntegration.Name == TransportNames.RabbitMQDirectRoutingTopology) " is 161.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_a_message_has_failed_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_a_message_has_failed_detected.cs,Should_publish_notification,The length of the statement  "                .WithEndpoint<FailingReceiver>(b => b.When(c => c.ExternalProcessorSubscribed' bus => bus.SendLocal(new MyMessage {Body = "Faulty message"})).DoNotFailOnErrorMessages()) " is 169.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_archived,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_archived.cs,All_messages_in_group_should_get_archived,The length of the statement  "                    var failedMessages = await this.TryGetMany<FailedMessage>($"/api/recoverability/groups/{ctx.GroupId}/errors").ConfigureAwait(false); " is 132.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                        var messageToBeArchivedUnresolvedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Unresolved); " is 166.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                        var messageToBeRetriedAsPartOfGroupUnresolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Unresolved); " is 189.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                        await this.Post<object>($"/api/recoverability/groups/{messageToBeRetriedAsPartOfGroupRetry.FailureGroups[0].Id}/errors/retry"); " is 127.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                    var messageToBeRetriedAsPartOfGroupResolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Resolved); " is 185.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                    var messageToBeArchivedArchivedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Archived); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "            Assert.AreEqual(FailedMessageStatus.Resolved' messageToBeRetriedAsPartOfGroupRetry.Status' "Retried Message should not be set to Archived when group is retried"); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the statement  "                        var retriedMessageResult = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"' err => err.ProcessingAttempts.Count == 2); " is 140.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the statement  "            var originalExceptionAndStackTraceFailureGroupIds = originalMessage.FailureGroups.Where(x => x.Type == ExceptionTypeAndStackTraceFailureClassifier.Id).Select(x => x.Id).ToArray(); " is 179.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the statement  "            var retriedExceptionAndStackTraceFailureGroupIds = retriedMessage.FailureGroups.Where(x => x.Type == ExceptionTypeAndStackTraceFailureClassifier.Id).Select(x => x.Id).ToArray(); " is 177.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the statement  "            Assert.AreEqual(originalMessage.FailureGroups.Single(x => x.Type == MessageTypeFailureClassifier.Id).Id' retriedMessage.FailureGroups.Single(x => x.Type == MessageTypeFailureClassifier.Id).Id' $"{MessageTypeFailureClassifier.Id} FailureGroup Ids changed"); " is 256.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The length of the statement  "                Assert.False(retriedExceptionAndStackTraceFailureGroupIds.Contains(failureId)' "Failure Group {0} is still set on retried message"' failureId); " is 143.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "                    exceptionTypeAndStackTraceGroups = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/Exception%20Type%20and%20Stack%20Trace"); " is 144.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "                    var failedMessageAResult = await this.TryGet<FailedMessage>($"/api/errors/{c.UniqueMessageIdA}"' msg => msg.FailureGroups.Any()); " is 129.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "                    var failedMessageBResult = await this.TryGet<FailedMessage>($"/api/errors/{c.UniqueMessageIdB}"' msg => msg.FailureGroups.Any()); " is 129.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.IsEmpty(exceptionTypeAndStackTraceGroups.Select(g => g.Id).Except(defaultGroups.Select(g => g.Id))' "/api/recoverability/groups did not retrieve Exception Type and Stack Trace Group"); " is 191.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.Contains(DeterministicGuid.MakeId(MessageTypeFailureClassifier.Id' typeof(MyMessageA).FullName).ToString()' messageTypeGroups.Select(g => g.Id).ToArray()); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.Contains(DeterministicGuid.MakeId(MessageTypeFailureClassifier.Id' typeof(MyMessageB).FullName).ToString()' messageTypeGroups.Select(g => g.Id).ToArray()); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.AreEqual(1' failedMessageA.FailureGroups.Count(g => g.Type == ExceptionTypeAndStackTraceFailureClassifier.Id)' $"{ExceptionTypeAndStackTraceFailureClassifier.Id} FailureGroup was not created"); " is 200.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.AreEqual(1' failedMessageA.FailureGroups.Count(g => g.Type == MessageTypeFailureClassifier.Id)' $"{MessageTypeFailureClassifier.Id} FailureGroup was not created"); " is 170.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.AreEqual(1' failedMessageB.FailureGroups.Count(g => g.Type == ExceptionTypeAndStackTraceFailureClassifier.Id)' $"{ExceptionTypeAndStackTraceFailureClassifier.Id} FailureGroup was not created"); " is 200.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The length of the statement  "            Assert.AreEqual(1' failedMessageB.FailureGroups.Count(g => g.Type == MessageTypeFailureClassifier.Id)' $"{MessageTypeFailureClassifier.Id} FailureGroup was not created"); " is 170.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_message_groups_are_sorted_by_a_web_api_call,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,SortTest,The length of the statement  "                    var errorResult = await this.TryGetMany<FailedMessageView>($"/api/recoverability/groups/{groups[0].Id}/errors?page=1&direction=asc&sort={sortProperty}"); " is 153.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_ServiceControl_has_started,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_ServiceControl_has_started.cs,All_classifiers_should_be_retrievable,The length of the statement  "            Assert.Contains(ExceptionTypeAndStackTraceFailureClassifier.Id' classifiers' "ExceptionTypeAndStackTraceFailureClassifier was not found"); " is 138.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_ServiceControl_has_started,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_ServiceControl_has_started.cs,All_classifiers_should_be_retrievable,The length of the statement  "            Assert.Contains(AddressOfFailingEndpointClassifier.Id' classifiers' "AddressOfFailingEndpointClassifier was not found"); " is 120.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The length of the statement  "            Assert.AreEqual(1' exceptionTypeAndStackTraceGroups.Count' "There should only be one Exception Type And Stack Trace Group"); " is 124.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The length of the statement  "            Assert.AreEqual(failureTimes.Min()' failureGroup.First' "Failure Group should start when the earliest failure occurred"); " is 121.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,ErrorImportPerformanceTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\ErrorImportPerformanceTests.cs,Should_import_all_messages,The length of the statement  "                .WithEndpoint<Receiver>(b => b.When(bus => Task.WhenAll(Enumerable.Repeat(0' 100).Select(i => bus.SendLocal(new MyMessage())))).DoNotFailOnErrorMessages()) " is 155.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Is_System_Message_Tests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,Should_set_the_IsSystemMessage_when_message_type_is_not_a_scheduled_task,The length of the statement  "                    ctx.EnclosedMessageType = "SendOnlyError.SendSomeCommand' TestSendOnlyError' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null"; " is 132.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Foo,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Foo,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,CreateMessage,The length of the statement  "                        headers[Headers.ControlMessageHeader] = context.ControlMessageHeaderValue != null && (bool)context.ControlMessageHeaderValue ? context.ControlMessageHeaderValue.ToString() : null; " is 179.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Foo,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,CreateMessage,The length of the statement  "                    return new TransportOperations(new TransportOperation(new OutgoingMessage(context.MessageId' headers' new byte[0])' new UnicastAddressTag("error"))); " is 149.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Foo,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,Foo,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\Is_System_Message_Tests.cs,CreateMessage,The length of the statement  "                        [Headers.EnclosedMessageTypes] = "SendOnlyError.SendSomeCommand' TestSendOnlyError' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null" " is 138.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                        var result = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Unresolved); " is 137.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                        var unresolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Unresolved); " is 162.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                    var resolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Resolved); " is 158.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "                    var archivedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Archived); " is 143.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The length of the statement  "            Assert.AreEqual(FailedMessageStatus.Resolved' messageToBeRetriedAsPartOfRetryAll.Status' "Retried Message should not be set to Archived when group is retried"); " is 160.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_invalid_id_is_sent_to_retry,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_invalid_id_is_sent_to_retry.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "                    .When(async ctx => ctx.IssueRetry && await this.TryGet<object>("/api/errors/" + ctx.UniqueMessageId)' (bus' ctx) => this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry")).DoNotFailOnErrorMessages()) " is 206.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,MessageThatWillFailHandler,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_invalid_id_is_sent_to_retry.cs,Handle,The length of the statement  "                    Context.MessageThatWillFailUniqueMessageId = DeterministicGuid.MakeId(context.MessageId' Settings.EndpointName()).ToString(); " is 125.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,MessageThatWillFailHandler,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_invalid_id_is_sent_to_retry.cs,Handle,The length of the statement  "                    if (!Context.RetryForMessageThatWillFailAndThenBeResolvedIssued) //simulate that the exception will be resolved with the retry " is 126.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_be_listed_in_the_error_list,The length of the statement  "            Assert.AreEqual(context.MessageId' failure.MessageId.Replace(@"\"' "-")' "The returned message should match the processed one"); " is 128.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_add_an_event_log_item,The length of the statement  "                    var result = await this.TryGetSingle<EventLogItem>("/api/eventlogitems/"' e => e.RelatedTo.Any(r => r.Contains(c.UniqueMessageId)) && e.EventType == typeof(MessageFailed).Name); " is 177.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_add_an_event_log_item,The length of the statement  "            Assert.IsTrue(entry.Description.Contains("exception")' "For failed messages' the description should contain the exception information"); " is 136.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_add_an_event_log_item,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item == "/message/" + context.UniqueMessageId)' "Should contain the api url to retrieve additional details about the failed message"); " is 176.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_add_an_event_log_item,The length of the statement  "            Assert.IsTrue(entry.RelatedTo.Any(item => item == "/endpoint/" + context.EndpointNameOfReceivingEndpoint)' "Should contain the api url to retrieve additional details about the endpoint where the message failed"); " is 212.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_only_return_queueaddresses_that_startswith_search,The length of the statement  "                    b.CustomConfig(configuration => configuration.GetSettings().Set("NServiceBus.Routing.EndpointName"' searchEndpointName)); " is 121.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_only_return_queueaddresses_that_startswith_search,The length of the statement  "                    b.CustomConfig(configuration => configuration.GetSettings().Set("NServiceBus.Routing.EndpointName"' "YetAnotherEndpoint")); " is 123.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_only_return_queueaddresses_that_startswith_search,The length of the statement  "            Assert.IsTrue(searchResults[0].PhysicalAddress.StartsWith(searchEndpointName' StringComparison.InvariantCultureIgnoreCase)); " is 124.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed_from_send_only_endpoint,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed_from_send_only_endpoint.cs,Should_be_listed_in_the_error_list_when_processing_endpoint_header_is_not_present,The length of the statement  "            Assert.IsTrue(failure.ReceivingEndpoint.Name.Contains("SomeEndpoint")' $"The sending endpoint should be SomeEndpoint and not {failure.ReceivingEndpoint.Name}"); " is 160.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed_from_send_only_endpoint,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed_from_send_only_endpoint.cs,Should_be_listed_in_the_error_list_when_processing_endpoint_header_is_present,The length of the statement  "            Assert.IsTrue(failure.ReceivingEndpoint.Name.Contains("SomeEndpoint")' $"The sending endpoint should be SomeEndpoint and not {failure.ReceivingEndpoint.Name}"); " is 160.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_pending_retry_is_resolved_by_selection,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_pending_retry_is_resolved_by_selection.cs,Should_succeed,The length of the statement  "                .Do("WaitForRetryIssued"' async ctx => { return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"' msg => msg.Status == FailedMessageStatus.RetryIssued); }) " is 176.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "            CustomConfiguration = config => config.RegisterComponents(components => components.ConfigureComponent<ReturnToSender>(b => new FakeReturnToSender(b.Build<IBodyStorage>()' b.Build<MyContext>())' DependencyLifecycle.SingleInstance)); " is 231.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "                    .When(async ctx => { return !ctx.RetryForInvalidAddressIssued && await this.TryGetSingle<FailedMessageView>("/api/errors/"' m => m.Id == ctx.DecommissionedEndpointUniqueMessageId); }' " is 183.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "                    .When(async ctx => { return !ctx.RetryForMessageThatWillFailAndThenBeResolvedIssued && await this.TryGetSingle<FailedMessageView>("/api/errors/"' m => m.Id == ctx.MessageThatWillFailUniqueMessageId); }' " is 202.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "                    var decomissionedFailureResult = await this.TryGetSingle<FailedMessage>("/api/errors/"' m => m.Id == ctx.DecommissionedEndpointUniqueMessageId && m.Status == FailedMessageStatus.Unresolved); " is 190.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The length of the statement  "                    var successfullyRetriedResult = await this.TryGetSingle<FailedMessage>("/api/errors/"' m => m.Id == ctx.MessageThatWillFailUniqueMessageId && m.Status == FailedMessageStatus.Resolved); " is 184.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                    context.DecommissionedEndpointUniqueMessageId = DeterministicGuid.MakeId(context.DecommissionedEndpointMessageId' context.DecommissionedEndpointName).ToString(); " is 161.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                    context.UniqueMessageId = DeterministicGuid.MakeId(context.MessageId' context.EndpointNameOfReceivingEndpoint).ToString(); " is 122.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                    context.UniqueMessageId = DeterministicGuid.MakeId(context.MessageId' context.EndpointNameOfReceivingEndpoint).ToString(); " is 122.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendFailedMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendControlMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_empty_body_message_is_successful.cs,CreateMessage,The length of the statement  "                    context.UniqueMessageId = DeterministicGuid.MakeId(context.MessageId' context.EndpointNameOfReceivingEndpoint).ToString(); " is 122.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendControlMessage,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_empty_body_message_is_successful.cs,CreateMessage,The length of the statement  "                        ["NServiceBus.ExceptionInfo.Message"] = "An error occurred while attempting to extract logical messages from transport message NServiceBus.TransportMessage"' " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_in_the_eventlog,The length of the statement  "                        var eventLogItemsResult = await this.TryGetMany<EventLogItem>("/api/eventlogitems"' item => item.Description.StartsWith("Failed message resolved by retry")); " is 157.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_in_the_eventlog,The length of the statement  "            Assert.IsTrue(eventLogItems.Any(item => item.Description.Equals("Failed message resolved by retry") && item.RelatedTo.Contains("/message/" + failure.UniqueMessageId))); " is 168.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Acknowledging_the_retry_should_be_successful,The length of the statement  "                    await IssueRetry(c' () => this.Post<object>($"/api/recoverability/groups/{failure.FailureGroups.First().Id}/errors/retry")); " is 124.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Acknowledging_the_retry_should_be_successful,The length of the statement  "            //await this.Delete($"/api/recoverability/unacknowledgedgroups/{failure.FailureGroups.First().Id}"); // Exception will throw if 404 " is 131.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,When_a_message_fails_a_retry_with_a_redirect,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_message_fails_a_retry_with_a_redirect.cs,The_original_failed_message_record_is_updated,The length of the statement  "                    var result = await this.TryGetMany<FailedMessageView>("/api/errors"' msg => msg.Exception.Message.Contains("Message Failed In New Endpoint Too")); " is 146.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,MessageToRetryHandler,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_message_fails_a_retry_with_a_redirect.cs,Handle,The length of the statement  "                    Context.UniqueMessageId = DeterministicGuid.MakeId(context.MessageId.Replace(@"\"' "-")' Settings.EndpointName()).ToString(); " is 125.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,MessageToRetryHandler,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_message_fails_a_retry_with_a_redirect.cs,Handle,The length of the statement  "                    Context.UniqueMessageId = DeterministicGuid.MakeId(context.MessageId.Replace(@"\"' "-")' Settings.EndpointName()).ToString(); " is 125.
Long Statement,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,When_a_redirect_is_created,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_redirect_is_created.cs,Should_be_added_and_accessible_via_the_api,The length of the statement  "            Assert.AreEqual(DeterministicGuid.MakeId(redirect.fromphysicaladdress)' response[0].message_redirect_id' "Message Redirect Id mismatch"); " is 137.
Long Statement,ServiceControl.AcceptanceTests.SagaAudit,When_multiple_messages_are_emitted_by_a_saga,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\SagaAudit\When_multiple_messages_are_emitted_by_a_saga.cs,Should_capture_all_outgoing_message_intents,The length of the statement  "            Assert.AreEqual("Reply"' outgoingIntents[typeof(MessageReplyToOriginatorBySaga).FullName]' "MessageReplyToOriginatorBySaga was not present"); " is 141.
Long Statement,ServiceControl.AcceptanceTests.SagaAudit,When_multiple_messages_are_emitted_by_a_saga,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\SagaAudit\When_multiple_messages_are_emitted_by_a_saga.cs,Should_capture_all_outgoing_message_intents,The length of the statement  "            Assert.AreEqual("Publish"' outgoingIntents[typeof(MessagePublishedBySaga).FullName]' "MessagePublishedBySaga was not present"); " is 127.
Long Statement,ServiceControl.AcceptanceTests.SagaAudit,When_requesting_timeout_from_a_saga,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\SagaAudit\When_requesting_timeout_from_a_saga.cs,Saga_audit_trail_should_contain_the_state_change,The length of the statement  "                    var result = await this.TryGet<SagaHistory>($"/api/sagas/{c.SagaId}"' sh => sh.Changes.Any(change => change.Status == SagaStateChangeStatus.Updated)); " is 150.
Long Statement,ServiceControl.AcceptanceTests.TestSupport,EndpointConfigurationExtensions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\EndpointConfigurationExtensions.cs,ReportSuccessfulRetriesToServiceControl,The length of the statement  "            configuration.Pipeline.Register(typeof(ReportSuccessfulRetryToServiceControl)' "Simulate that the audit instance detects and reports successfull retries"); " is 155.
Long Statement,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The length of the statement  "                        log.Debug($"Discarding message '{id}'({originalMessageId ?? string.Empty}) because it's session id is '{session}' instead of '{currentSession}'."); " is 147.
Long Statement,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The length of the statement  "            // This is a hack to ensure ServiceControl picks the correct type for the messages that come from plugins otherwise we pick the type from the plugins assembly and that is not the type we want' we need to pick the type from ServiceControl assembly. " is 247.
Long Statement,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The length of the statement  "                    builder.RegisterType<FailedErrorsController>().FindConstructorsWith(t => t.GetTypeInfo().DeclaredConstructors.ToArray()); " is 121.
Long Statement,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The length of the statement  "                    builder.RegisterType<CriticalErrorTriggerController>().FindConstructorsWith(t => t.GetTypeInfo().DeclaredConstructors.ToArray()); " is 129.
Empty Catch Block,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_invalid_id_is_sent_to_retry,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_invalid_id_is_sent_to_retry.cs,SubsequentBatchesShouldBeProcessed,The method has an empty catch block.
Magic Number,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,AcceptanceTest,The following statement contains a magic number: ServicePointManager.SetTcpKeepAlive(true' 5000' 1000);
Magic Number,ServiceControl.AcceptanceTests,AcceptanceTest,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\AcceptanceTest.cs,AcceptanceTest,The following statement contains a magic number: ServicePointManager.SetTcpKeepAlive(true' 5000' 1000);
Magic Number,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,EventuallyFailingCustomCheck,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_custom_check_events_are_triggered.cs,PerformCheck,The following statement contains a magic number: Interlocked.Increment(ref counter) / 10 % 2 == 0
Magic Number,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,EventuallyFailingCustomCheck,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_custom_check_events_are_triggered.cs,PerformCheck,The following statement contains a magic number: Interlocked.Increment(ref counter) / 10 % 2 == 0
Magic Number,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,EventuallyFailingCustomCheck,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_custom_check_events_are_triggered.cs,PerformCheck,The following statement contains a magic number: Interlocked.Increment(ref counter) / 5 % 2 == 1
Magic Number,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,EventuallyFailingCustomCheck,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_custom_check_events_are_triggered.cs,PerformCheck,The following statement contains a magic number: Interlocked.Increment(ref counter) / 5 % 2 == 1
Magic Number,ServiceControl.AcceptanceTests.Monitoring.CustomChecks,When_reporting_custom_check_with_signalr,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\CustomChecks\When_reporting_custom_check_with_signalr.cs,Should_result_in_a_custom_check_failed_event,The following statement contains a magic number: var context = await Define<MyContext>(ctx => { ctx.Handler = () => Handler; })                  .WithEndpoint<EndpointWithCustomCheck>()                  .WithEndpoint<EndpointThatUsesSignalR>()                  .Done(c => c.SignalrEventReceived)                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_is_restored,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_is_restored.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointHeartbeatRestored              {                  RestoredAt = new DateTime(2013' 09' 13' 13' 15' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "LuckyHost"'                      HostId = Guid.NewGuid()'                      Name = "LuckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Monitoring.ExternalIntegration,When_heartbeat_loss_is_detected,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Monitoring\ExternalIntegration\When_heartbeat_loss_is_detected.cs,Should_publish_notification,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability,EditMessageHelper,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\EditMessageHelper.cs,TryRestoreOriginalHeaderKeys,The following statement contains a magic number: var newKey = Regex.Replace(headerKey' @"([0-9a-z])\.([a-z])"' m => $"{m.Groups[1].Value}.{m.Groups[2].Value.ToUpper()}");
Magic Number,ServiceControl.AcceptanceTests.Recoverability,EditMessageHelper,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\EditMessageHelper.cs,TryRestoreOriginalHeaderKeys,The following statement contains a magic number: newKey = Regex.Replace(newKey' "([0-9a-z])_([a-z])"' m => $"{m.Groups[1].Value}{m.Groups[2].Value.ToUpper()}");
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,FailingReceiver,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_a_message_has_failed_detected.cs,FailingReceiver,The following statement contains a magic number: EndpointSetup<DefaultServer>(c => { c.Recoverability().Immediate(s => s.NumberOfRetries(2)).Delayed(s => s.NumberOfRetries(0)); });
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.ExternalIntegration,When_encountered_an_error,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\ExternalIntegration\When_encountered_an_error.cs,Should_restart_dispatch_thread,The following statement contains a magic number: ExecuteWhen(() => externalProcessorSubscribed' domainEvents => domainEvents.Raise(new EndpointFailedToHeartbeat              {                  DetectedAt = new DateTime(2013' 09' 13' 13' 14' 13)'                  LastReceivedAt = new DateTime(2013' 09' 13' 13' 13' 13)'                  Endpoint = new EndpointDetails                  {                      Host = "UnluckyHost"'                      HostId = Guid.NewGuid()'                      Name = "UnluckyEndpoint"                  }              }));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_archived,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_archived.cs,All_messages_in_group_should_get_archived,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Do("WaitUntilGrouped"' async ctx =>                  {                      if (ctx.FirstMessageId == null || ctx.SecondMessageId == null)                      {                          return false;                      }                        // Don't retry until the message has been added to a group                      var groups = await this.TryGetMany<FailedMessage.FailureGroup>("/api/recoverability/groups/");                      if (!groups)                      {                          return false;                      }                        ctx.GroupId = groups.Items[0].Id;                      return true;                  })                  .Do("WaitUntilGroupContainsBothMessages"' async ctx =>                  {                      var failedMessages = await this.TryGetMany<FailedMessage>($"/api/recoverability/groups/{ctx.GroupId}/errors").ConfigureAwait(false);                      return failedMessages && failedMessages.Items.Count == 2;                  })                  .Do("Archive"' async ctx => { await this.Post<object>($"/api/recoverability/groups/{ctx.GroupId}/errors/archive"); })                  .Do("EnsureFirstArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Do("EnsureSecondArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Done(ctx => true) //Done when sequence is finished                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_archived,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_archived.cs,All_messages_in_group_should_get_archived,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Do("WaitUntilGrouped"' async ctx =>                  {                      if (ctx.FirstMessageId == null || ctx.SecondMessageId == null)                      {                          return false;                      }                        // Don't retry until the message has been added to a group                      var groups = await this.TryGetMany<FailedMessage.FailureGroup>("/api/recoverability/groups/");                      if (!groups)                      {                          return false;                      }                        ctx.GroupId = groups.Items[0].Id;                      return true;                  })                  .Do("WaitUntilGroupContainsBothMessages"' async ctx =>                  {                      var failedMessages = await this.TryGetMany<FailedMessage>($"/api/recoverability/groups/{ctx.GroupId}/errors").ConfigureAwait(false);                      return failedMessages && failedMessages.Items.Count == 2;                  })                  .Do("Archive"' async ctx => { await this.Post<object>($"/api/recoverability/groups/{ctx.GroupId}/errors/archive"); })                  .Do("EnsureFirstArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Do("EnsureSecondArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Done(ctx => true) //Done when sequence is finished                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_archived,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_archived.cs,Only_unresolved_issues_should_be_archived,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Do("WaitUntilGrouped"' async ctx =>                  {                      if (ctx.FirstMessageId == null || ctx.SecondMessageId == null)                      {                          return false;                      }                        // Don't retry until the message has been added to a group                      var groups = await this.TryGetMany<FailedMessage.FailureGroup>("/api/recoverability/groups/");                      if (!groups)                      {                          return false;                      }                        ctx.GroupId = groups.Items[0].Id;                      return true;                  })                  .Do("DetectFirstFailure"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Unresolved);                  })                  .Do("DetectSecondFailure"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Unresolved);                  })                  .Do("RetrySecond"' async ctx =>                  {                      ctx.FailProcessing = false;                      await this.Post<object>($"/api/errors/{ctx.SecondMessageId}/retry");                  })                  .Do("DetectSecondResolved"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Resolved);                  })                  .Do("Archive"' async ctx => { await this.Post<object>($"/api/recoverability/groups/{ctx.GroupId}/errors/archive"); })                  .Do("EnsureFirstArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Do("EnsureSecondResolved"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Resolved);                  })                  .Done(ctx => true) //Done when sequence is finished                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_archived,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_archived.cs,Only_unresolved_issues_should_be_archived,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Do("WaitUntilGrouped"' async ctx =>                  {                      if (ctx.FirstMessageId == null || ctx.SecondMessageId == null)                      {                          return false;                      }                        // Don't retry until the message has been added to a group                      var groups = await this.TryGetMany<FailedMessage.FailureGroup>("/api/recoverability/groups/");                      if (!groups)                      {                          return false;                      }                        ctx.GroupId = groups.Items[0].Id;                      return true;                  })                  .Do("DetectFirstFailure"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Unresolved);                  })                  .Do("DetectSecondFailure"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Unresolved);                  })                  .Do("RetrySecond"' async ctx =>                  {                      ctx.FailProcessing = false;                      await this.Post<object>($"/api/errors/{ctx.SecondMessageId}/retry");                  })                  .Do("DetectSecondResolved"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Resolved);                  })                  .Do("Archive"' async ctx => { await this.Post<object>($"/api/recoverability/groups/{ctx.GroupId}/errors/archive"); })                  .Do("EnsureFirstArchived"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.FirstMessageId}"'                          e => e.Status == FailedMessageStatus.Archived);                  })                  .Do("EnsureSecondResolved"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.SecondMessageId}"'                          e => e.Status == FailedMessageStatus.Resolved);                  })                  .Done(ctx => true) //Done when sequence is finished                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (c.MessageToBeRetriedByGroupId == null || c.MessageToBeArchivedId == null)                      {                          return false;                      }                        //First we are going to issue an archive to one of the messages                      if (!c.ArchiveIssued)                      {                          var messageToBeArchivedUnresolvedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeArchived = messageToBeArchivedUnresolvedResult;                          if (!messageToBeArchivedUnresolvedResult)                          {                              return false;                          }                            await this.Patch<object>($"/api/errors/{messageToBeArchived.UniqueMessageId}/archive");                            c.ArchiveIssued = true;                            return false;                      }                        //We are now going to issue a retry group                      if (!c.RetryIssued)                      {                          // Ensure message is being retried                          var messageToBeRetriedAsPartOfGroupUnresolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeRetriedAsPartOfGroupRetry = messageToBeRetriedAsPartOfGroupUnresolvedRetryResult;                          if (!messageToBeRetriedAsPartOfGroupUnresolvedRetryResult)                          {                              return false;                          }                            c.RetryIssued = true;                            await this.Post<object>($"/api/recoverability/groups/{messageToBeRetriedAsPartOfGroupRetry.FailureGroups[0].Id}/errors/retry");                            return false;                      }                        var messageToBeRetriedAsPartOfGroupResolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Resolved);                      messageToBeRetriedAsPartOfGroupRetry = messageToBeRetriedAsPartOfGroupResolvedRetryResult;                      if (!messageToBeRetriedAsPartOfGroupResolvedRetryResult)                      {                          return false;                      }                        var messageToBeArchivedArchivedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Archived);                      messageToBeArchived = messageToBeArchivedArchivedResult;                      return messageToBeArchivedArchivedResult;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_group_is_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_group_is_retried.cs,Only_unresolved_issues_should_be_retried,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1)                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (c.MessageToBeRetriedByGroupId == null || c.MessageToBeArchivedId == null)                      {                          return false;                      }                        //First we are going to issue an archive to one of the messages                      if (!c.ArchiveIssued)                      {                          var messageToBeArchivedUnresolvedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeArchived = messageToBeArchivedUnresolvedResult;                          if (!messageToBeArchivedUnresolvedResult)                          {                              return false;                          }                            await this.Patch<object>($"/api/errors/{messageToBeArchived.UniqueMessageId}/archive");                            c.ArchiveIssued = true;                            return false;                      }                        //We are now going to issue a retry group                      if (!c.RetryIssued)                      {                          // Ensure message is being retried                          var messageToBeRetriedAsPartOfGroupUnresolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeRetriedAsPartOfGroupRetry = messageToBeRetriedAsPartOfGroupUnresolvedRetryResult;                          if (!messageToBeRetriedAsPartOfGroupUnresolvedRetryResult)                          {                              return false;                          }                            c.RetryIssued = true;                            await this.Post<object>($"/api/recoverability/groups/{messageToBeRetriedAsPartOfGroupRetry.FailureGroups[0].Id}/errors/retry");                            return false;                      }                        var messageToBeRetriedAsPartOfGroupResolvedRetryResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeRetriedByGroupId}"' e => e.Status == FailedMessageStatus.Resolved);                      messageToBeRetriedAsPartOfGroupRetry = messageToBeRetriedAsPartOfGroupResolvedRetryResult;                      if (!messageToBeRetriedAsPartOfGroupResolvedRetryResult)                      {                          return false;                      }                        var messageToBeArchivedArchivedResult = await this.TryGet<FailedMessage>($"/api/errors/{c.MessageToBeArchivedId}"' e => e.Status == FailedMessageStatus.Archived);                      messageToBeArchived = messageToBeArchivedArchivedResult;                      return messageToBeArchivedArchivedResult;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The following statement contains a magic number: await Define<MeowContext>()                  .WithEndpoint<MeowReceiver>(b => b.When(bus => bus.SendLocal(new Meow()))                      .DoNotFailOnErrorMessages())                  .Done(async ctx =>                  {                      if (String.IsNullOrWhiteSpace(ctx.UniqueMessageId))                      {                          return false;                      }                        if (!ctx.Retrying)                      {                          var result = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                          FailedMessage originalMessageTemp = result;                          if (result)                          {                              originalMessage = originalMessageTemp;                              ctx.Retrying = true;                              await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                          }                      }                      else                      {                          var retriedMessageResult = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"' err => err.ProcessingAttempts.Count == 2);                          retriedMessage = retriedMessageResult;                          return retriedMessageResult;                      }                        return false;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_a_message_fails_twice_with_different_exceptions,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_a_message_fails_twice_with_different_exceptions.cs,Only_the_second_groups_should_apply,The following statement contains a magic number: await Define<MeowContext>()                  .WithEndpoint<MeowReceiver>(b => b.When(bus => bus.SendLocal(new Meow()))                      .DoNotFailOnErrorMessages())                  .Done(async ctx =>                  {                      if (String.IsNullOrWhiteSpace(ctx.UniqueMessageId))                      {                          return false;                      }                        if (!ctx.Retrying)                      {                          var result = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                          FailedMessage originalMessageTemp = result;                          if (result)                          {                              originalMessage = originalMessageTemp;                              ctx.Retrying = true;                              await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                          }                      }                      else                      {                          var retriedMessageResult = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"' err => err.ProcessingAttempts.Count == 2);                          retriedMessage = retriedMessageResult;                          return retriedMessageResult;                      }                        return false;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The following statement contains a magic number: var context = await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal(new MyMessageA())                          .ConfigureAwait(false);                      await bus.SendLocal(new MyMessageB())                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (c.MessageIdA == null || c.MessageIdB == null)                      {                          return false;                      }                        var defaultGroupsResult = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/");                      defaultGroups = defaultGroupsResult;                      if (!defaultGroupsResult)                      {                          return false;                      }                        if (defaultGroups.Count != 2)                      {                          return false;                      }                        messageTypeGroups = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/Message%20Type");                      exceptionTypeAndStackTraceGroups = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/Exception%20Type%20and%20Stack%20Trace");                        var failedMessageAResult = await this.TryGet<FailedMessage>($"/api/errors/{c.UniqueMessageIdA}"' msg => msg.FailureGroups.Any());                      failedMessageA = failedMessageAResult;                      var failedMessageBResult = await this.TryGet<FailedMessage>($"/api/errors/{c.UniqueMessageIdB}"' msg => msg.FailureGroups.Any());                      failedMessageB = failedMessageBResult;                      if (!failedMessageAResult || !failedMessageBResult)                      {                          return false;                      }                        return true;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The following statement contains a magic number: Assert.AreEqual(2' exceptionTypeAndStackTraceGroups.Count' "There should be 2 Exception Type and Stack Trace Groups");
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_messages_have_failed.cs,Should_be_grouped,The following statement contains a magic number: Assert.AreEqual(2' messageTypeGroups.Count' "There should be 2 Message Type Groups");
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_message_groups_are_sorted_by_a_web_api_call,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,All_messages_in_group_should_be_sorted_by_time_sent,The following statement contains a magic number: Assert.IsTrue(errors[2].MessageId.StartsWith("3"));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_message_groups_are_sorted_by_a_web_api_call,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,All_messages_in_group_should_be_sorted_by_message_type,The following statement contains a magic number: Assert.IsTrue(errors[2].MessageId.StartsWith("3"));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_message_groups_are_sorted_by_a_web_api_call,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,SortTest,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>()                  .Done(async c =>                  {                      var result = await this.TryGetMany<FailedMessage.FailureGroup>("/api/recoverability/groups");                      List<FailedMessage.FailureGroup> groups = result;                      if (!result)                      {                          return false;                      }                        if (groups.Count != 1)                      {                          return false;                      }                        var errorResult = await this.TryGetMany<FailedMessageView>($"/api/recoverability/groups/{groups[0].Id}/errors?page=1&direction=asc&sort={sortProperty}");                      localErrors = errorResult;                      if (!errorResult)                      {                          return false;                      }                        if (localErrors.Count != 3)                      {                          return false;                      }                        return true;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,SendFailedMessages,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,CreateMessage,The following statement contains a magic number: return new TransportOperations(                          new TransportOperation(CreateTransportMessage(1)' errorAddress)'                          new TransportOperation(CreateTransportMessage(2)' errorAddress)'                          new TransportOperation(CreateTransportMessage(3)' errorAddress)                      );
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,SendFailedMessages,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,CreateMessage,The following statement contains a magic number: return new TransportOperations(                          new TransportOperation(CreateTransportMessage(1)' errorAddress)'                          new TransportOperation(CreateTransportMessage(2)' errorAddress)'                          new TransportOperation(CreateTransportMessage(3)' errorAddress)                      );
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,SendFailedMessages,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,CreateTransportMessage,The following statement contains a magic number: var date = new DateTime(2015' 9 + i' 20 + i' 0' 0' 0);
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,SendFailedMessages,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,CreateTransportMessage,The following statement contains a magic number: var date = new DateTime(2015' 9 + i' 20 + i' 0' 0' 0);
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,SendFailedMessages,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_message_groups_are_sorted_by_a_web_api_call.cs,CreateTransportMessage,The following statement contains a magic number: var date = new DateTime(2015' 9 + i' 20 + i' 0' 0' 0);
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.IsFirst = true)                          .ConfigureAwait(false);                      await Task.Delay(TimeSpan.FromSeconds(1))                          .ConfigureAwait(false);                      await bus.SendLocal<MyMessage>(m => m.IsFirst = false)                          .ConfigureAwait(false);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (!c.FirstDone || !c.SecondDone)                      {                          return false;                      }                        var result = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/");                      exceptionTypeAndStackTraceGroups = result;                      if (!result)                      {                          return false;                      }                        if (exceptionTypeAndStackTraceGroups.Any(x => x.Count != 2))                      {                          return false;                      }                        messageTypeGroups = await this.TryGetMany<FailureGroupView>("/api/recoverability/groups/Message%20Type");                        var firstFailureResult = await this.TryGet<FailedMessage>($"/api/errors/{c.FirstMessageId}");                      firstFailure = firstFailureResult;                      if (!firstFailureResult)                      {                          return false;                      }                        var secondFailureResult = await this.TryGet<FailedMessage>($"/api/errors/{c.SecondMessageId}");                      secondFailure = secondFailureResult;                        return secondFailureResult;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The following statement contains a magic number: Assert.AreEqual(2' failureGroup.Count' "Exception Type And Stack Trace Group should have both messages in it");
Magic Number,ServiceControl.AcceptanceTests.Recoverability.Groups,When_two_similar_messages_have_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\Groups\When_two_similar_messages_have_failed.cs,They_should_be_grouped_together,The following statement contains a magic number: Assert.AreEqual(2' messageTypeGroups.First().Count' "Message Type Group should have both messages in it");
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,ErrorImportPerformanceTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\ErrorImportPerformanceTests.cs,Should_import_all_messages,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(bus => Task.WhenAll(Enumerable.Repeat(0' 100).Select(i => bus.SendLocal(new MyMessage())))).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var result = await this.TryGetMany<MessagesView>("/api/messages?per_page=150");                      if (!result)                      {                          return false;                      }                        List<MessagesView> messages = result;                      if (messages.Count < 100)                      {                          Console.Out.WriteLine("Messages found: " + messages.Count);                      }                        return messages.Count >= 100;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,ErrorImportPerformanceTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\ErrorImportPerformanceTests.cs,Should_import_all_messages,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(bus => Task.WhenAll(Enumerable.Repeat(0' 100).Select(i => bus.SendLocal(new MyMessage())))).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var result = await this.TryGetMany<MessagesView>("/api/messages?per_page=150");                      if (!result)                      {                          return false;                      }                        List<MessagesView> messages = result;                      if (messages.Count < 100)                      {                          Console.Out.WriteLine("Messages found: " + messages.Count);                      }                        return messages.Count >= 100;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,ErrorImportPerformanceTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\ErrorImportPerformanceTests.cs,Should_import_all_messages,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(bus => Task.WhenAll(Enumerable.Repeat(0' 100).Select(i => bus.SendLocal(new MyMessage())))).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var result = await this.TryGetMany<MessagesView>("/api/messages?per_page=150");                      if (!result)                      {                          return false;                      }                        List<MessagesView> messages = result;                      if (messages.Count < 100)                      {                          Console.Out.WriteLine("Messages found: " + messages.Count);                      }                        return messages.Count >= 100;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,ErrorImportPerformanceTests,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\ErrorImportPerformanceTests.cs,Should_import_all_messages,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(bus => Task.WhenAll(Enumerable.Repeat(0' 100).Select(i => bus.SendLocal(new MyMessage())))).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var result = await this.TryGetMany<MessagesView>("/api/messages?per_page=150");                      if (!result)                      {                          return false;                      }                        List<MessagesView> messages = result;                      if (messages.Count < 100)                      {                          Console.Out.WriteLine("Messages found: " + messages.Count);                      }                        return messages.Count >= 100;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (c.MessageToBeRetriedAsPartOfRetryAllId == null || c.MessageToBeArchivedId == null)                      {                          return false;                      }                        //First we are going to issue an archive to one of the messages                      if (!c.ArchiveIssued)                      {                          var result = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeArchived = result;                          if (!result)                          {                              return false;                          }                            await this.Patch<object>($"/api/errors/{messageToBeArchived.UniqueMessageId}/archive");                            c.ArchiveIssued = true;                            return false;                      }                        //We are now going to issue a retry group                      if (!c.RetryAllIssued)                      {                          // Ensure message is being retried                          var unresolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeRetriedAsPartOfRetryAll = unresolvedResult;                          if (!unresolvedResult)                          {                              return false;                          }                            c.RetryAllIssued = true;                            await this.Post<object>("/api/errors/retry/all");                            return false;                      }                        var resolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Resolved);                      messageToBeRetriedAsPartOfRetryAll = resolvedResult;                      if (!resolvedResult)                      {                          return false;                      }                        var archivedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Archived);                      messageToBeArchived = archivedResult;                      return archivedResult;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_all_messages_are_retried,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_all_messages_are_retried.cs,Only_unresolved_issues_should_be_retried,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(async bus =>                  {                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 1);                      await bus.SendLocal<MyMessage>(m => m.MessageNumber = 2);                  }).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      if (c.MessageToBeRetriedAsPartOfRetryAllId == null || c.MessageToBeArchivedId == null)                      {                          return false;                      }                        //First we are going to issue an archive to one of the messages                      if (!c.ArchiveIssued)                      {                          var result = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeArchived = result;                          if (!result)                          {                              return false;                          }                            await this.Patch<object>($"/api/errors/{messageToBeArchived.UniqueMessageId}/archive");                            c.ArchiveIssued = true;                            return false;                      }                        //We are now going to issue a retry group                      if (!c.RetryAllIssued)                      {                          // Ensure message is being retried                          var unresolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Unresolved);                          messageToBeRetriedAsPartOfRetryAll = unresolvedResult;                          if (!unresolvedResult)                          {                              return false;                          }                            c.RetryAllIssued = true;                            await this.Post<object>("/api/errors/retry/all");                            return false;                      }                        var resolvedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeRetriedAsPartOfRetryAllId' e => e.Status == FailedMessageStatus.Resolved);                      messageToBeRetriedAsPartOfRetryAll = resolvedResult;                      if (!resolvedResult)                      {                          return false;                      }                        var archivedResult = await this.TryGet<FailedMessage>("/api/errors/" + c.MessageToBeArchivedId' e => e.Status == FailedMessageStatus.Archived);                      messageToBeArchived = archivedResult;                      return archivedResult;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_an_event_with_multiple_subscribers_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_an_event_with_multiple_subscribers_fails.cs,There_should_be_a_FailedMessage_for_each_subscriber,The following statement contains a magic number: await Define<FailingEventContext>()                  .WithEndpoint<FakeFailedSubscribers>()                  .Done(async ctx =>                  {                      var result = await this.TryGetMany<FailedMessageView>("/api/errors");                      failedMessages = result;                      return result && failedMessages.Sum(x => x.NumberOfProcessingAttempts) >= 2;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_invalid_id_is_sent_to_retry,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_invalid_id_is_sent_to_retry.cs,SubsequentBatchesShouldBeProcessed,The following statement contains a magic number: var context = await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(cfg => cfg                      .When(async bus =>                      {                          while (true)                          {                              try                              {                                  await this.Post<object>("/api/errors/1785201b-5ccd-4705-b14e-f9dd7ef1386e/retry");                                  break;                              }                              catch (InvalidOperationException)                              {                                  // api not up yet                              }                          }                            await bus.SendLocal(new MessageThatWillFail());                      }).DoNotFailOnErrorMessages()                      .When(async ctx => ctx.IssueRetry && await this.TryGet<object>("/api/errors/" + ctx.UniqueMessageId)' (bus' ctx) => this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry")).DoNotFailOnErrorMessages())                  .Done(ctx => ctx.Done)                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_be_listed_in_the_messages_list,The following statement contains a magic number: var context = await Define<MyContext>()                  .WithEndpoint<Receiver>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var result = await this.TryGetSingle<MessagesView>("/api/messages"' m => m.MessageId == c.MessageId);                      failure = result;                      return result;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_message_has_failed,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_message_has_failed.cs,Should_only_return_queueaddresses_that_startswith_search,The following statement contains a magic number: await Define<QueueSearchContext>()                  .WithEndpoint<FailingEndpoint>(b =>                  {                      b.DoNotFailOnErrorMessages();                      b.When(bus => bus.SendLocal(new MyMessage()));                  })                  .WithEndpoint<FailingEndpoint>(b =>                  {                      b.DoNotFailOnErrorMessages();                      b.CustomConfig(configuration => configuration.GetSettings().Set("NServiceBus.Routing.EndpointName"' searchEndpointName));                      b.When(bus => bus.SendLocal(new MyMessage()));                  })                  .WithEndpoint<FailingEndpoint>(b =>                  {                      b.DoNotFailOnErrorMessages();                      b.CustomConfig(configuration => configuration.GetSettings().Set("NServiceBus.Routing.EndpointName"' "YetAnotherEndpoint"));                      b.When(bus => bus.SendLocal(new MyMessage()));                  }).Done(async c =>                  {                      if (c.FailedMessageCount < 3)                      {                          return false;                      }                        var result = await this.TryGetMany<QueueAddress>($"/api/errors/queues/addresses/search/{searchTerm}");                      searchResults = result;                      return result;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_pending_retry_is_retried_again,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_pending_retry_is_retried_again.cs,Should_succeed,The following statement contains a magic number: await Define<Context>()                  .WithEndpoint<FailingEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Do("DetectFailure"' async ctx =>                  {                      if (ctx.UniqueMessageId == null)                      {                          return false;                      }                        return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                  })                  .Do("Retry"' async ctx => { await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry"); })                  .Do("WaitForRetryIssued"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"'                          msg => msg.Status == FailedMessageStatus.RetryIssued);                  })                  .Do("RetryPending"' async ctx =>                  {                      await this.Post<object>("/api/pendingretries/retry"' new List<string>                      {                          ctx.UniqueMessageId                      });                  })                  .Done(ctx => ctx.RetryCount == 2)                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_pending_retry_is_retried_by_queue_and_timeframe,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_pending_retry_is_retried_by_queue_and_timeframe.cs,Should_succeed,The following statement contains a magic number: await Define<Context>()                  .WithEndpoint<Failing>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Do("DetectFailure"' async ctx =>                  {                      return ctx.UniqueMessageId != null                             && await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                  })                  .Do("Retry"' async ctx => { await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry"); })                  .Do("WaitForRetryIssued"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"'                          msg => msg.Status == FailedMessageStatus.RetryIssued);                  })                  .Do("WaitForIndex"' async ctx =>                  {                      return await this.TryGet<FailedMessage[]>("/api/errors"'                          allErrors => allErrors.Any(fm => fm.Id == ctx.UniqueMessageId));                  })                  .Do("RetryPending"' async ctx =>                  {                      await this.Post<object>("/api/pendingretries/queues/retry"' new                      {                          queueaddress = ctx.FromAddress'                          from = DateTime.UtcNow.AddHours(-1).ToString("o")'                          to = DateTime.UtcNow.AddSeconds(10).ToString("o")                      });                  })                  .Done(ctx => ctx.RetryCount == 2)                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_pending_retry_is_retried_by_queue_and_timeframe,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_pending_retry_is_retried_by_queue_and_timeframe.cs,Should_succeed,The following statement contains a magic number: await Define<Context>()                  .WithEndpoint<Failing>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Do("DetectFailure"' async ctx =>                  {                      return ctx.UniqueMessageId != null                             && await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                  })                  .Do("Retry"' async ctx => { await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry"); })                  .Do("WaitForRetryIssued"' async ctx =>                  {                      return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}"'                          msg => msg.Status == FailedMessageStatus.RetryIssued);                  })                  .Do("WaitForIndex"' async ctx =>                  {                      return await this.TryGet<FailedMessage[]>("/api/errors"'                          allErrors => allErrors.Any(fm => fm.Id == ctx.UniqueMessageId));                  })                  .Do("RetryPending"' async ctx =>                  {                      await this.Post<object>("/api/pendingretries/queues/retry"' new                      {                          queueaddress = ctx.FromAddress'                          from = DateTime.UtcNow.AddHours(-1).ToString("o")'                          to = DateTime.UtcNow.AddSeconds(10).ToString("o")                      });                  })                  .Done(ctx => ctx.RetryCount == 2)                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_fails_to_be_sent,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_fails_to_be_sent.cs,SubsequentBatchesShouldBeProcessed,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.DoNotFailOnErrorMessages()                      .When(async ctx => { return !ctx.RetryForInvalidAddressIssued && await this.TryGetSingle<FailedMessageView>("/api/errors/"' m => m.Id == ctx.DecommissionedEndpointUniqueMessageId); }'                          async (bus' ctx) =>                          {                              await this.Post<object>($"/api/errors/{ctx.DecommissionedEndpointUniqueMessageId}/retry");                              await bus.SendLocal(new MessageThatWillFail());                              ctx.RetryForInvalidAddressIssued = true;                          }).DoNotFailOnErrorMessages()                      .When(async ctx => { return !ctx.RetryForMessageThatWillFailAndThenBeResolvedIssued && await this.TryGetSingle<FailedMessageView>("/api/errors/"' m => m.Id == ctx.MessageThatWillFailUniqueMessageId); }'                          async (bus' ctx) =>                          {                              await this.Post<object>($"/api/errors/{ctx.MessageThatWillFailUniqueMessageId}/retry");                              ctx.RetryForMessageThatWillFailAndThenBeResolvedIssued = true;                          }).DoNotFailOnErrorMessages())                  .Done(async ctx =>                  {                      if (!ctx.Done)                      {                          return false;                      }                        var decomissionedFailureResult = await this.TryGetSingle<FailedMessage>("/api/errors/"' m => m.Id == ctx.DecommissionedEndpointUniqueMessageId && m.Status == FailedMessageStatus.Unresolved);                      decomissionedFailure = decomissionedFailureResult;                      var successfullyRetriedResult = await this.TryGetSingle<FailedMessage>("/api/errors/"' m => m.Id == ctx.MessageThatWillFailUniqueMessageId && m.Status == FailedMessageStatus.Resolved);                      successfullyRetried = successfullyRetriedResult;                      return decomissionedFailureResult && successfullyRetriedResult;                  })                  .Run(TimeSpan.FromMinutes(3));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_empty_body_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_empty_body_message_is_successful.cs,Should_show_up_as_resolved_when_doing_a_single_retry,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>()                  .Done(async c =>                  {                      var result = await GetFailedMessage(c);                      failure = result;                      if (!c.RetryIssued && result)                      {                          await IssueRetry(c' () => this.Post<object>($"/api/errors/{c.UniqueMessageId}/retry"));                            return false;                      }                        var afterRetryResult = await GetFailedMessage(c' x => x.Status == FailedMessageStatus.Resolved);                      failure = afterRetryResult;                      return c.Done && afterRetryResult;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_marked_as_unresolved,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx =>                  {                      ctx.Result = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                      return ctx.Result.ProcessingAttempts.Count == 3;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_marked_as_unresolved,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx =>                  {                      ctx.Result = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                      return ctx.Result.ProcessingAttempts.Count == 3;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_marked_as_unresolved,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx =>                  {                      ctx.Result = await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                      return ctx.Result.ProcessingAttempts.Count == 3;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_able_to_be_retried_successfully,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetryThirdTime"' async ctx =>                  {                      ctx.Succeed = true;                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSuccess"' async ctx =>                  {                      ctx.Result = await GetFailedMessage(ctx' f => f.Status == FailedMessageStatus.Resolved);                      return ctx.Result != null;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_able_to_be_retried_successfully,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetryThirdTime"' async ctx =>                  {                      ctx.Succeed = true;                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSuccess"' async ctx =>                  {                      ctx.Result = await GetFailedMessage(ctx' f => f.Status == FailedMessageStatus.Resolved);                      return ctx.Result != null;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_fails,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_fails.cs,It_should_be_able_to_be_retried_successfully,The following statement contains a magic number: var result = await Define<MyContext>(ctx => { ctx.Succeed = false; })                  .WithEndpoint<FailureEndpoint>(b =>                      b.When(bus => bus.SendLocal(new MyMessage()))                          .DoNotFailOnErrorMessages()                  )                  .Do("DetectFirstFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 1))                  .Do("RetryFirstTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSecondFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetrySecondTime"' async ctx =>                  {                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectThirdFailure"' async ctx => await CheckProcessingAttemptsIs(ctx' 2))                  .Do("RetryThirdTime"' async ctx =>                  {                      ctx.Succeed = true;                      await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      return true;                  })                  .Do("DetectSuccess"' async ctx =>                  {                      ctx.Result = await GetFailedMessage(ctx' f => f.Status == FailedMessageStatus.Resolved);                      return ctx.Result != null;                  })                  .Done()                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_in_the_eventlog,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var failedMessageResult = await GetFailedMessage(c);                      failure = failedMessageResult;                      if (!failedMessageResult)                      {                          return false;                      }                        if (failure.Status == FailedMessageStatus.Resolved)                      {                          var eventLogItemsResult = await this.TryGetMany<EventLogItem>("/api/eventlogitems"' item => item.Description.StartsWith("Failed message resolved by retry"));                          eventLogItems = eventLogItemsResult;                          return eventLogItemsResult;                      }                        await IssueRetry(c' () => this.Post<object>($"/api/errors/{c.UniqueMessageId}/retry"));                        return false;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_when_doing_a_multi_retry,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var failedMessageResult = await GetFailedMessage(c);                      failure = failedMessageResult;                      if (!failedMessageResult)                      {                          return false;                      }                        if (failure.Status == FailedMessageStatus.Resolved)                      {                          return true;                      }                        await IssueRetry(c' () => this.Post("/api/errors/retry"' new List<string> {c.UniqueMessageId}));                        return false;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_when_doing_a_retry_all,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var failedMessageResult = await GetFailedMessage(c);                      failure = failedMessageResult;                      if (!failedMessageResult)                      {                          return false;                      }                        if (failure.Status == FailedMessageStatus.Resolved)                      {                          return true;                      }                        await IssueRetry(c' () => this.Post<object>("/api/errors/retry/all"));                        return false;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Acknowledging_the_retry_should_be_successful,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var failedMessageResult = await GetFailedMessage(c);                      failure = failedMessageResult;                      if (!failedMessageResult)                      {                          return false;                      }                        if (failure.Status == FailedMessageStatus.Resolved)                      {                          return true;                      }                        await IssueRetry(c' () => this.Post<object>($"/api/recoverability/groups/{failure.FailureGroups.First().Id}/errors/retry"));                        return false;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_a_retry_for_a_failed_message_is_successful,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_a_retry_for_a_failed_message_is_successful.cs,Should_show_up_as_resolved_when_doing_a_retry_all_for_the_given_endpoint,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<FailureEndpoint>(b => b.When(bus => bus.SendLocal(new MyMessage())).DoNotFailOnErrorMessages())                  .Done(async c =>                  {                      var failedMessageResult = await GetFailedMessage(c);                      failure = failedMessageResult;                      if (!failedMessageResult)                      {                          return false;                      }                        if (failure.Status == FailedMessageStatus.Resolved)                      {                          return true;                      }                        await IssueRetry(c' () => this.Post<object>($"/api/errors/{c.EndpointNameOfReceivingEndpoint}/retry/all"));                        return false;                  })                  .Run(TimeSpan.FromMinutes(2));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_errors_with_same_uniqueid_are_imported,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_errors_with_same_uniqueid_are_imported.cs,The_import_should_support_it,The following statement contains a magic number: SetSettings = settings => { settings.MaximumConcurrencyLevel = 10; };
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_errors_with_same_uniqueid_are_imported,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_errors_with_same_uniqueid_are_imported.cs,The_import_should_support_it,The following statement contains a magic number: await Define<MyContext>()                  .WithEndpoint<SourceEndpoint>()                  .Done(async c =>                  {                      if (c.UniqueId == null)                      {                          return false;                      }                        var result = await this.TryGet<FailedMessage>($"/api/errors/{c.UniqueId}"' m =>                      {                          Console.WriteLine("Processing attempts: " + m.ProcessingAttempts.Count);                          return m.ProcessingAttempts.Count == 10;                      });                      failure = result;                      return criticalErrorExecuted || result;                  })                  .Run();
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,When_errors_with_same_uniqueid_are_imported,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_errors_with_same_uniqueid_are_imported.cs,The_import_should_support_it,The following statement contains a magic number: Assert.AreEqual(10' failure.ProcessingAttempts.Count);
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageFailures,SendMultipleFailedMessagesWithSameUniqueId,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageFailures\When_errors_with_same_uniqueid_are_imported.cs,GetMessages,The following statement contains a magic number: i < 10
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,When_a_message_fails_a_retry_with_a_redirect,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_message_fails_a_retry_with_a_redirect.cs,The_original_failed_message_record_is_updated,The following statement contains a magic number: Assert.AreEqual(2' failedMessageView.NumberOfProcessingAttempts);
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,When_a_message_is_retried_with_a_redirect,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_message_is_retried.cs,It_should_be_sent_to_the_correct_endpoint,The following statement contains a magic number: var context = await Define<Context>()                  .WithEndpoint<FromEndpoint>(b => b.When(bus => bus.SendLocal(new MessageToRetry()))                      .When(async ctx =>                      {                          if (ctx.UniqueMessageId == null)                          {                              return false;                          }                            return await this.TryGet<FailedMessage>($"/api/errors/{ctx.UniqueMessageId}");                      }' async (bus' ctx) =>                      {                          await this.Post("/api/redirects"' new RedirectRequest                          {                              fromphysicaladdress = ctx.FromAddress'                              tophysicaladdress = ctx.ToAddress                          }' status => status != HttpStatusCode.Created);                            await this.Post<object>($"/api/errors/{ctx.UniqueMessageId}/retry");                      }).DoNotFailOnErrorMessages())                  .WithEndpoint<ToNewEndpoint>(c =>                      c.When((session' ctx) =>                      {                          ctx.ToAddress = Conventions.EndpointNamingConvention(typeof(ToNewEndpoint));                          return Task.FromResult(0);                      }))                  .Done(ctx => ctx.Received)                  .Run(TimeSpan.FromSeconds(120));
Magic Number,ServiceControl.AcceptanceTests.Recoverability.MessageRedirects,When_a_redirect_is_created,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\Recoverability\MessageRedirects\When_a_redirect_is_created.cs,Should_fail_validation_with_dependent_redirects,The following statement contains a magic number: var dependentCount = 3;
Magic Number,ServiceControl.AcceptanceTests.SagaAudit,MySaga,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\SagaAudit\When_a_saga_instance_is_being_created.cs,Handle,The following statement contains a magic number: return RequestTimeout<TimeoutMessage>(context' TimeSpan.FromMilliseconds(10));
Magic Number,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,FindAvailablePort,The following statement contains a magic number: port < startPort + 1024
Magic Number,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The following statement contains a magic number: var instancePort = FindAvailablePort(33333);
Magic Number,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The following statement contains a magic number: var settings = new Settings(instanceName)              {                  Port = instancePort'                  DatabaseMaintenancePort = maintenancePort'                  DbPath = Path.Combine(Path.GetTempPath()' Path.GetRandomFileName())'                  ForwardErrorMessages = false'                  TransportCustomizationType = transportToUse.TypeName'                  TransportConnectionString = transportToUse.ConnectionString'                  ProcessRetryBatchesFrequency = TimeSpan.FromSeconds(2)'                  TimeToRestartErrorIngestionAfterFailure = TimeSpan.FromSeconds(2)'                  MaximumConcurrencyLevel = 2'                  HttpDefaultConnectionLimit = int.MaxValue'                  RunInMemory = true'                  OnMessage = (id' headers' body' @continue) =>                  {                      var log = LogManager.GetLogger<ServiceControlComponentRunner>();                      headers.TryGetValue(Headers.MessageId' out var originalMessageId);                      log.Debug($"OnMessage for message '{id}'({originalMessageId ?? string.Empty}).");                        //Do not filter out CC' SA and HB messages as they can't be stamped                      if (headers.TryGetValue(Headers.EnclosedMessageTypes' out var messageTypes)                          && messageTypes.StartsWith("ServiceControl."))                      {                          return @continue();                      }                        //Do not filter out subscribe messages as they can't be stamped                      if (headers.TryGetValue(Headers.MessageIntent' out var intent)                          && intent == MessageIntentEnum.Subscribe.ToString())                      {                          return @continue();                      }                        var currentSession = context.TestRunId.ToString();                      if (!headers.TryGetValue("SC.SessionID"' out var session) || session != currentSession)                      {                          log.Debug($"Discarding message '{id}'({originalMessageId ?? string.Empty}) because it's session id is '{session}' instead of '{currentSession}'.");                          return Task.FromResult(0);                      }                        return @continue();                  }              };
Magic Number,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The following statement contains a magic number: var settings = new Settings(instanceName)              {                  Port = instancePort'                  DatabaseMaintenancePort = maintenancePort'                  DbPath = Path.Combine(Path.GetTempPath()' Path.GetRandomFileName())'                  ForwardErrorMessages = false'                  TransportCustomizationType = transportToUse.TypeName'                  TransportConnectionString = transportToUse.ConnectionString'                  ProcessRetryBatchesFrequency = TimeSpan.FromSeconds(2)'                  TimeToRestartErrorIngestionAfterFailure = TimeSpan.FromSeconds(2)'                  MaximumConcurrencyLevel = 2'                  HttpDefaultConnectionLimit = int.MaxValue'                  RunInMemory = true'                  OnMessage = (id' headers' body' @continue) =>                  {                      var log = LogManager.GetLogger<ServiceControlComponentRunner>();                      headers.TryGetValue(Headers.MessageId' out var originalMessageId);                      log.Debug($"OnMessage for message '{id}'({originalMessageId ?? string.Empty}).");                        //Do not filter out CC' SA and HB messages as they can't be stamped                      if (headers.TryGetValue(Headers.EnclosedMessageTypes' out var messageTypes)                          && messageTypes.StartsWith("ServiceControl."))                      {                          return @continue();                      }                        //Do not filter out subscribe messages as they can't be stamped                      if (headers.TryGetValue(Headers.MessageIntent' out var intent)                          && intent == MessageIntentEnum.Subscribe.ToString())                      {                          return @continue();                      }                        var currentSession = context.TestRunId.ToString();                      if (!headers.TryGetValue("SC.SessionID"' out var session) || session != currentSession)                      {                          log.Debug($"Discarding message '{id}'({originalMessageId ?? string.Empty}) because it's session id is '{session}' instead of '{currentSession}'.");                          return Task.FromResult(0);                      }                        return @continue();                  }              };
Magic Number,ServiceControl.AcceptanceTests.TestSupport,ServiceControlComponentRunner,C:\research\architectureSmells\repos\Particular_ServiceControl\src\ServiceControl.AcceptanceTests\TestSupport\ServiceControlComponentRunner.cs,InitializeServiceControl,The following statement contains a magic number: var settings = new Settings(instanceName)              {                  Port = instancePort'                  DatabaseMaintenancePort = maintenancePort'                  DbPath = Path.Combine(Path.GetTempPath()' Path.GetRandomFileName())'                  ForwardErrorMessages = false'                  TransportCustomizationType = transportToUse.TypeName'                  TransportConnectionString = transportToUse.ConnectionString'                  ProcessRetryBatchesFrequency = TimeSpan.FromSeconds(2)'                  TimeToRestartErrorIngestionAfterFailure = TimeSpan.FromSeconds(2)'                  MaximumConcurrencyLevel = 2'                  HttpDefaultConnectionLimit = int.MaxValue'                  RunInMemory = true'                  OnMessage = (id' headers' body' @continue) =>                  {                      var log = LogManager.GetLogger<ServiceControlComponentRunner>();                      headers.TryGetValue(Headers.MessageId' out var originalMessageId);                      log.Debug($"OnMessage for message '{id}'({originalMessageId ?? string.Empty}).");                        //Do not filter out CC' SA and HB messages as they can't be stamped                      if (headers.TryGetValue(Headers.EnclosedMessageTypes' out var messageTypes)                          && messageTypes.StartsWith("ServiceControl."))                      {                          return @continue();                      }                        //Do not filter out subscribe messages as they can't be stamped                      if (headers.TryGetValue(Headers.MessageIntent' out var intent)                          && intent == MessageIntentEnum.Subscribe.ToString())                      {                          return @continue();                      }                        var currentSession = context.TestRunId.ToString();                      if (!headers.TryGetValue("SC.SessionID"' out var session) || session != currentSession)                      {                          log.Debug($"Discarding message '{id}'({originalMessageId ?? string.Empty}) because it's session id is '{session}' instead of '{currentSession}'.");                          return Task.FromResult(0);                      }                        return @continue();                  }              };
