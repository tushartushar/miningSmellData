Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The method has 231 lines of code.
Complex Method,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,Cyclomatic complexity of the method is 10
Complex Method,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,Dispose,Cyclomatic complexity of the method is 8
Long Parameter List,OpenGL,FBO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\FBO.cs,FBO,The method has 5 parameters. Parameters: width' height' attachment' format' mipmaps
Long Parameter List,OpenGL,FBO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\FBO.cs,FBO,The method has 6 parameters. Parameters: size' attachments' format' mipmaps' filterType' pixelType
Long Parameter List,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,ProgramParam,The method has 5 parameters. Parameters: Type' ParamType' Name' Program' Location
Long Parameter List,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The method has 5 parameters. Parameters: program' location' size' uvloc' uvsize
Long Parameter List,OpenGL,VAO<T1;T2>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 5 parameters. Parameters: program' vbo1' vbo2' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 6 parameters. Parameters: program' vbo1' vbo2' vbo3' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 7 parameters. Parameters: program' vbo1' vbo2' vbo3' vbo4' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 8 parameters. Parameters: program' vbo1' vbo2' vbo3' vbo4' vbo5' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 9 parameters. Parameters: program' vbo1' vbo2' vbo3' vbo4' vbo5' vbo6' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 10 parameters. Parameters: program' vbo1' vbo2' vbo3' vbo4' vbo5' vbo6' vbo7' attribNames' elementArray
Long Parameter List,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 11 parameters. Parameters: program' vbo1' vbo2' vbo3' vbo4' vbo5' vbo6' vbo7' vbo8' attribNames' elementArray
Long Parameter List,OpenGL,GenericVBO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,GenericVBO,The method has 6 parameters. Parameters: id' name' length' size' pointerType' bufferTarget
Long Parameter List,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 5 parameters. Parameters: program' vertex' normal' uv' element
Long Parameter List,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The method has 6 parameters. Parameters: program' vertex' normal' tangent' uv' element
Long Parameter List,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The method has 5 parameters. Parameters: program' vertexAttributeLocation' normalAttributeLocation' uvAttributeLocation' tangentAttributeLocation
Long Parameter List,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The method has 5 parameters. Parameters: Data' Position' Length' Target' Hint
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BindBufferRange,The method has 5 parameters. Parameters: target' index' buffer' offset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BindBuffersRange,The method has 6 parameters. Parameters: target' first' count' buffers' offsets' sizes
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BindImageTexture,The method has 7 parameters. Parameters: unit' texture' level' layered' layer' access' format
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexArrayVertexBuffer,The method has 5 parameters. Parameters: vaobj' bindingindex' buffer' offset' stride
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BindVertexBuffers,The method has 5 parameters. Parameters: first' count' buffers' offsets' strides
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexArrayVertexBuffers,The method has 6 parameters. Parameters: vaobj' first' count' buffers' offsets' strides
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BlendFuncSeparatei,The method has 5 parameters. Parameters: buf' srcRGB' dstRGB' srcAlpha' dstAlpha
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BlitFramebuffer,The method has 10 parameters. Parameters: srcX0' srcY0' srcX1' srcY1' dstX0' dstY0' dstX1' dstY1' mask' filter
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BlitNamedFramebuffer,The method has 12 parameters. Parameters: readFramebuffer' drawFramebuffer' srcX0' srcY0' srcX1' srcY1' dstX0' dstY0' dstX1' dstY1' mask' filter
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearNamedFramebufferfi,The method has 5 parameters. Parameters: framebuffer' buffer' drawbuffer' depth' stencil
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearBufferData,The method has 5 parameters. Parameters: target' internalFormat' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearNamedBufferData,The method has 5 parameters. Parameters: buffer' internalFormat' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearBufferSubData,The method has 7 parameters. Parameters: target' internalFormat' offset' size' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearNamedBufferSubData,The method has 7 parameters. Parameters: buffer' internalFormat' offset' size' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearTexImage,The method has 5 parameters. Parameters: texture' level' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ClearTexSubImage,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ColorMaski,The method has 5 parameters. Parameters: buf' red' green' blue' alpha
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexImage1D,The method has 7 parameters. Parameters: target' level' internalFormat' width' border' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexImage2D,The method has 8 parameters. Parameters: target' level' internalFormat' width' height' border' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexImage3D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' depth' border' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexSubImage1D,The method has 7 parameters. Parameters: target' level' xoffset' width' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTextureSubImage1D,The method has 7 parameters. Parameters: texture' level' xoffset' width' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexSubImage2D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' width' height' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTextureSubImage2D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' width' height' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexSubImage3D,The method has 11 parameters. Parameters: target' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTextureSubImage3D,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyBufferSubData,The method has 5 parameters. Parameters: readTarget' writeTarget' readOffset' writeOffset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyNamedBufferSubData,The method has 5 parameters. Parameters: readBuffer' writeBuffer' readOffset' writeOffset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyImageSubData,The method has 15 parameters. Parameters: srcName' srcTarget' srcLevel' srcX' srcY' srcZ' dstName' dstTarget' dstLevel' dstX' dstY' dstZ' srcWidth' srcHeight' srcDepth
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTexImage1D,The method has 7 parameters. Parameters: target' level' internalFormat' x' y' width' border
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTexImage2D,The method has 8 parameters. Parameters: target' level' internalFormat' x' y' width' height' border
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTexSubImage1D,The method has 6 parameters. Parameters: target' level' xoffset' x' y' width
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTextureSubImage1D,The method has 6 parameters. Parameters: texture' level' xoffset' x' y' width
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTexSubImage2D,The method has 8 parameters. Parameters: target' level' xoffset' yoffset' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTextureSubImage2D,The method has 8 parameters. Parameters: texture' level' xoffset' yoffset' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTexSubImage3D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' zoffset' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyTextureSubImage3D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawArraysInstancedBaseInstance,The method has 5 parameters. Parameters: mode' first' count' primcount' baseinstance
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsBaseVertex,The method has 5 parameters. Parameters: mode' count' type' indices' basevertex
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsInstanced,The method has 5 parameters. Parameters: mode' count' type' indices' primcount
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsInstancedBaseInstance,The method has 6 parameters. Parameters: mode' count' type' indices' primcount' baseinstance
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsInstancedBaseVertex,The method has 6 parameters. Parameters: mode' count' type' indices' primcount' basevertex
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsInstancedBaseVertexBaseInstance,The method has 7 parameters. Parameters: mode' count' type' indices' primcount' basevertex' baseinstance
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawRangeElementsBaseVertex,The method has 7 parameters. Parameters: mode' start' end' count' type' indices' basevertex
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,FramebufferTexture1D,The method has 5 parameters. Parameters: target' attachment' textarget' texture' level
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,FramebufferTexture2D,The method has 5 parameters. Parameters: target' attachment' textarget' texture' level
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,FramebufferTexture3D,The method has 6 parameters. Parameters: target' attachment' textarget' texture' level' layer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,FramebufferTextureLayer,The method has 5 parameters. Parameters: target' attachment' texture' level' layer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,NamedFramebufferTextureLayer,The method has 5 parameters. Parameters: framebuffer' attachment' texture' level' layer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveAttrib,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveAttrib,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveSubroutineName,The method has 6 parameters. Parameters: program' shadertype' index' bufsize' length' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveSubroutineUniformiv,The method has 5 parameters. Parameters: program' shadertype' index' pname' values
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveSubroutineUniformiv,The method has 5 parameters. Parameters: program' shadertype' index' pname' values
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveSubroutineUniformName,The method has 6 parameters. Parameters: program' shadertype' index' bufsize' length' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveSubroutineUniformName,The method has 6 parameters. Parameters: program' shadertype' index' bufsize' length' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveUniform,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveUniform,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveUniformBlockName,The method has 5 parameters. Parameters: program' uniformBlockIndex' bufSize' length' uniformBlockName
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveUniformName,The method has 5 parameters. Parameters: program' uniformIndex' bufSize' length' uniformName
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetActiveUniformsiv,The method has 5 parameters. Parameters: program' uniformCount' uniformIndices' pname' params
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetCompressedTextureSubImage,The method has 10 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' bufSize' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetInternalformativ,The method has 5 parameters. Parameters: target' internalFormat' pname' bufSize' params
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetInternalformati64v,The method has 5 parameters. Parameters: target' internalFormat' pname' bufSize' params
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetObjectLabel,The method has 5 parameters. Parameters: identifier' name' bufSize' length' label
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetProgramBinary,The method has 5 parameters. Parameters: program' bufsize' length' binaryFormat' binary
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetProgramResourceiv,The method has 8 parameters. Parameters: program' programInterface' index' propCount' props' bufSize' length' params
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetProgramResourceName,The method has 6 parameters. Parameters: program' programInterface' index' bufSize' length' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetSynciv,The method has 5 parameters. Parameters: sync' pname' bufSize' length' values
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetTexImage,The method has 5 parameters. Parameters: target' level' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetnTexImage,The method has 6 parameters. Parameters: target' level' format' type' bufSize' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetTextureImage,The method has 6 parameters. Parameters: texture' level' format' type' bufSize' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetTextureSubImage,The method has 12 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' bufSize' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetTransformFeedbackVarying,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,InvalidateSubFramebuffer,The method has 7 parameters. Parameters: target' numAttachments' attachments' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,InvalidateNamedFramebufferSubData,The method has 7 parameters. Parameters: framebuffer' numAttachments' attachments' x' y' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,InvalidateTexSubImage,The method has 8 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,MultiDrawElements,The method has 5 parameters. Parameters: mode' count' type' indices' drawcount
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,MultiDrawElementsBaseVertex,The method has 6 parameters. Parameters: mode' count' type' indices' drawcount' basevertex
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,MultiDrawElementsIndirect,The method has 5 parameters. Parameters: mode' type' indirect' drawcount' stride
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform3f,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform4f,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform3i,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform4i,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform3ui,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniform4ui,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix2x3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix3x2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix2x4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix4x2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix3x4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ProgramUniformMatrix4x3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ReadPixels,The method has 7 parameters. Parameters: x' y' width' height' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ReadnPixels,The method has 8 parameters. Parameters: x' y' width' height' format' type' bufSize' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,RenderbufferStorageMultisample,The method has 5 parameters. Parameters: target' samples' internalFormat' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,NamedRenderbufferStorageMultisample,The method has 5 parameters. Parameters: renderbuffer' samples' internalFormat' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ScissorIndexed,The method has 5 parameters. Parameters: index' left' bottom' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ShaderBinary,The method has 5 parameters. Parameters: count' shaders' binaryFormat' binary' length
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexBufferRange,The method has 5 parameters. Parameters: target' internalFormat' buffer' offset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureBufferRange,The method has 5 parameters. Parameters: texture' internalFormat' buffer' offset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexImage1D,The method has 8 parameters. Parameters: target' level' internalFormat' width' border' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexImage2DMultisample,The method has 6 parameters. Parameters: target' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexImage3D,The method has 10 parameters. Parameters: target' level' internalFormat' width' height' depth' border' format' type' data
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexImage3DMultisample,The method has 7 parameters. Parameters: target' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexStorage2D,The method has 5 parameters. Parameters: target' levels' internalFormat' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureStorage2D,The method has 5 parameters. Parameters: texture' levels' internalFormat' width' height
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexStorage2DMultisample,The method has 6 parameters. Parameters: target' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureStorage2DMultisample,The method has 6 parameters. Parameters: texture' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexStorage3D,The method has 6 parameters. Parameters: target' levels' internalFormat' width' height' depth
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureStorage3D,The method has 6 parameters. Parameters: texture' levels' internalFormat' width' height' depth
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexStorage3DMultisample,The method has 7 parameters. Parameters: target' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureStorage3DMultisample,The method has 7 parameters. Parameters: texture' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexSubImage1D,The method has 7 parameters. Parameters: target' level' xoffset' width' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureSubImage1D,The method has 7 parameters. Parameters: texture' level' xoffset' width' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexSubImage2D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' width' height' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureSubImage2D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' width' height' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TexSubImage3D,The method has 11 parameters. Parameters: target' level' xoffset' yoffset' zoffset' width' height' depth' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureSubImage3D,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' pixels
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TextureView,The method has 8 parameters. Parameters: texture' target' origtexture' internalFormat' minlevel' numlevels' minlayer' numlayers
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,TransformFeedbackBufferRange,The method has 5 parameters. Parameters: xfb' index' buffer' offset' size
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,Uniform4f,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,Uniform4i,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,Uniform4ui,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4f,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4f,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4s,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4s,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4Nub,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttrib4Nub,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribI4i,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribI4i,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribI4ui,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribI4ui,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribL4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribL4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribFormat,The method has 5 parameters. Parameters: attribindex' size' type' normalized' relativeoffset
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexArrayAttribFormat,The method has 6 parameters. Parameters: vaobj' attribindex' size' type' normalized' relativeoffset
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexArrayAttribIFormat,The method has 5 parameters. Parameters: vaobj' attribindex' size' type' relativeoffset
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexArrayAttribLFormat,The method has 5 parameters. Parameters: vaobj' attribindex' size' type' relativeoffset
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribPointer,The method has 6 parameters. Parameters: index' size' type' normalized' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribPointer,The method has 6 parameters. Parameters: index' size' type' normalized' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribIPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribIPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribLPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,VertexAttribLPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ViewportIndexedf,The method has 5 parameters. Parameters: index' x' y' w' h
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BufferData,The method has 5 parameters. Parameters: target' position' size' data' usage
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateVBO,The method has 5 parameters. Parameters: target' data' hint' position' length
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The method has 5 parameters. Parameters: target' data1' data2' data3' hint
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The method has 5 parameters. Parameters: target' data1' data2' data3' hint
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The method has 6 parameters. Parameters: target' data1' data2' data3' data4' hint
Long Parameter List,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateVAO,The method has 8 parameters. Parameters: program' vbo' sizes' types' targets' names' stride' eboHandle
Long Parameter List,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographicOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreatePerspectiveOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,Squad,The method has 5 parameters. Parameters: q1' q2' ta' tb' t
Long Parameter List,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,SimpleSquad,The method has 5 parameters. Parameters: prev' q1' q2' post' t
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BindBufferRange,The method has 5 parameters. Parameters: target' index' buffer' offset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BindBuffersRange,The method has 6 parameters. Parameters: target' first' count' buffers' offsets' sizes
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BindImageTexture,The method has 7 parameters. Parameters: unit' texture' level' layered' layer' access' format
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexArrayVertexBuffer,The method has 5 parameters. Parameters: vaobj' bindingindex' buffer' offset' stride
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BindVertexBuffers,The method has 5 parameters. Parameters: first' count' buffers' offsets' strides
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexArrayVertexBuffers,The method has 6 parameters. Parameters: vaobj' first' count' buffers' offsets' strides
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BlendFuncSeparatei,The method has 5 parameters. Parameters: buf' srcRGB' dstRGB' srcAlpha' dstAlpha
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BlitFramebuffer,The method has 10 parameters. Parameters: srcX0' srcY0' srcX1' srcY1' dstX0' dstY0' dstX1' dstY1' mask' filter
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,BlitNamedFramebuffer,The method has 12 parameters. Parameters: readFramebuffer' drawFramebuffer' srcX0' srcY0' srcX1' srcY1' dstX0' dstY0' dstX1' dstY1' mask' filter
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearNamedFramebufferfi,The method has 5 parameters. Parameters: framebuffer' buffer' drawbuffer' depth' stencil
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearBufferData,The method has 5 parameters. Parameters: target' internalFormat' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearNamedBufferData,The method has 5 parameters. Parameters: buffer' internalFormat' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearBufferSubData,The method has 7 parameters. Parameters: target' internalFormat' offset' size' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearNamedBufferSubData,The method has 7 parameters. Parameters: buffer' internalFormat' offset' size' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearTexImage,The method has 5 parameters. Parameters: texture' level' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ClearTexSubImage,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ColorMaski,The method has 5 parameters. Parameters: buf' red' green' blue' alpha
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexImage1D,The method has 7 parameters. Parameters: target' level' internalFormat' width' border' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexImage2D,The method has 8 parameters. Parameters: target' level' internalFormat' width' height' border' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexImage3D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' depth' border' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexSubImage1D,The method has 7 parameters. Parameters: target' level' xoffset' width' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTextureSubImage1D,The method has 7 parameters. Parameters: texture' level' xoffset' width' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexSubImage2D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' width' height' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTextureSubImage2D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' width' height' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTexSubImage3D,The method has 11 parameters. Parameters: target' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CompressedTextureSubImage3D,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyBufferSubData,The method has 5 parameters. Parameters: readTarget' writeTarget' readOffset' writeOffset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyNamedBufferSubData,The method has 5 parameters. Parameters: readBuffer' writeBuffer' readOffset' writeOffset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyImageSubData,The method has 15 parameters. Parameters: srcName' srcTarget' srcLevel' srcX' srcY' srcZ' dstName' dstTarget' dstLevel' dstX' dstY' dstZ' srcWidth' srcHeight' srcDepth
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTexImage1D,The method has 7 parameters. Parameters: target' level' internalFormat' x' y' width' border
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTexImage2D,The method has 8 parameters. Parameters: target' level' internalFormat' x' y' width' height' border
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTexSubImage1D,The method has 6 parameters. Parameters: target' level' xoffset' x' y' width
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTextureSubImage1D,The method has 6 parameters. Parameters: texture' level' xoffset' x' y' width
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTexSubImage2D,The method has 8 parameters. Parameters: target' level' xoffset' yoffset' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTextureSubImage2D,The method has 8 parameters. Parameters: texture' level' xoffset' yoffset' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTexSubImage3D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' zoffset' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,CopyTextureSubImage3D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawArraysInstancedBaseInstance,The method has 5 parameters. Parameters: mode' first' count' primcount' baseinstance
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawElementsBaseVertex,The method has 5 parameters. Parameters: mode' count' type' indices' basevertex
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawElementsInstanced,The method has 5 parameters. Parameters: mode' count' type' indices' primcount
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawElementsInstancedBaseInstance,The method has 6 parameters. Parameters: mode' count' type' indices' primcount' baseinstance
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawElementsInstancedBaseVertex,The method has 6 parameters. Parameters: mode' count' type' indices' primcount' basevertex
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawElementsInstancedBaseVertexBaseInstance,The method has 7 parameters. Parameters: mode' count' type' indices' primcount' basevertex' baseinstance
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,DrawRangeElementsBaseVertex,The method has 7 parameters. Parameters: mode' start' end' count' type' indices' basevertex
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,FramebufferTexture1D,The method has 5 parameters. Parameters: target' attachment' textarget' texture' level
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,FramebufferTexture2D,The method has 5 parameters. Parameters: target' attachment' textarget' texture' level
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,FramebufferTexture3D,The method has 6 parameters. Parameters: target' attachment' textarget' texture' level' layer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,FramebufferTextureLayer,The method has 5 parameters. Parameters: target' attachment' texture' level' layer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,NamedFramebufferTextureLayer,The method has 5 parameters. Parameters: framebuffer' attachment' texture' level' layer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveAttrib,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveSubroutineName,The method has 6 parameters. Parameters: program' shadertype' index' bufsize' length' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveSubroutineUniformiv,The method has 5 parameters. Parameters: program' shadertype' index' pname' values
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveSubroutineUniformName,The method has 6 parameters. Parameters: program' shadertype' index' bufsize' length' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveUniform,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveUniformBlockName,The method has 5 parameters. Parameters: program' uniformBlockIndex' bufSize' length' uniformBlockName
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveUniformName,The method has 5 parameters. Parameters: program' uniformIndex' bufSize' length' uniformName
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetActiveUniformsiv,The method has 5 parameters. Parameters: program' uniformCount' uniformIndices' pname' params
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetCompressedTextureSubImage,The method has 10 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' bufSize' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetInternalformativ,The method has 5 parameters. Parameters: target' internalFormat' pname' bufSize' params
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetInternalformati64v,The method has 5 parameters. Parameters: target' internalFormat' pname' bufSize' params
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetObjectLabel,The method has 5 parameters. Parameters: identifier' name' bufSize' length' label
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetProgramBinary,The method has 5 parameters. Parameters: program' bufsize' length' binaryFormat' binary
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetProgramResourceiv,The method has 8 parameters. Parameters: program' programInterface' index' propCount' props' bufSize' length' params
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetProgramResourceName,The method has 6 parameters. Parameters: program' programInterface' index' bufSize' length' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetSynciv,The method has 5 parameters. Parameters: sync' pname' bufSize' length' values
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetTexImage,The method has 5 parameters. Parameters: target' level' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetnTexImage,The method has 6 parameters. Parameters: target' level' format' type' bufSize' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetTextureImage,The method has 6 parameters. Parameters: texture' level' format' type' bufSize' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetTextureSubImage,The method has 12 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' bufSize' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,GetTransformFeedbackVarying,The method has 7 parameters. Parameters: program' index' bufSize' length' size' type' name
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,InvalidateSubFramebuffer,The method has 7 parameters. Parameters: target' numAttachments' attachments' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,InvalidateNamedFramebufferSubData,The method has 7 parameters. Parameters: framebuffer' numAttachments' attachments' x' y' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,InvalidateTexSubImage,The method has 8 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,MultiDrawElements,The method has 5 parameters. Parameters: mode' count' type' indices' drawcount
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,MultiDrawElementsBaseVertex,The method has 6 parameters. Parameters: mode' count' type' indices' drawcount' basevertex
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,MultiDrawElementsIndirect,The method has 5 parameters. Parameters: mode' type' indirect' drawcount' stride
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform3f,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform4f,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform3i,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform4i,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform3ui,The method has 5 parameters. Parameters: program' location' v0' v1' v2
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniform4ui,The method has 6 parameters. Parameters: program' location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix2x3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix3x2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix2x4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix4x2fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix3x4fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ProgramUniformMatrix4x3fv,The method has 5 parameters. Parameters: program' location' count' transpose' value
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ReadPixels,The method has 7 parameters. Parameters: x' y' width' height' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ReadnPixels,The method has 8 parameters. Parameters: x' y' width' height' format' type' bufSize' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,RenderbufferStorageMultisample,The method has 5 parameters. Parameters: target' samples' internalFormat' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,NamedRenderbufferStorageMultisample,The method has 5 parameters. Parameters: renderbuffer' samples' internalFormat' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ScissorIndexed,The method has 5 parameters. Parameters: index' left' bottom' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ShaderBinary,The method has 5 parameters. Parameters: count' shaders' binaryFormat' binary' length
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexBufferRange,The method has 5 parameters. Parameters: target' internalFormat' buffer' offset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureBufferRange,The method has 5 parameters. Parameters: texture' internalFormat' buffer' offset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexImage1D,The method has 8 parameters. Parameters: target' level' internalFormat' width' border' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexImage2DMultisample,The method has 6 parameters. Parameters: target' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexImage3D,The method has 10 parameters. Parameters: target' level' internalFormat' width' height' depth' border' format' type' data
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexImage3DMultisample,The method has 7 parameters. Parameters: target' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexStorage2D,The method has 5 parameters. Parameters: target' levels' internalFormat' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureStorage2D,The method has 5 parameters. Parameters: texture' levels' internalFormat' width' height
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexStorage2DMultisample,The method has 6 parameters. Parameters: target' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureStorage2DMultisample,The method has 6 parameters. Parameters: texture' samples' internalFormat' width' height' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexStorage3D,The method has 6 parameters. Parameters: target' levels' internalFormat' width' height' depth
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureStorage3D,The method has 6 parameters. Parameters: texture' levels' internalFormat' width' height' depth
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexStorage3DMultisample,The method has 7 parameters. Parameters: target' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureStorage3DMultisample,The method has 7 parameters. Parameters: texture' samples' internalFormat' width' height' depth' fixedsamplelocations
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexSubImage1D,The method has 7 parameters. Parameters: target' level' xoffset' width' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureSubImage1D,The method has 7 parameters. Parameters: texture' level' xoffset' width' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexSubImage2D,The method has 9 parameters. Parameters: target' level' xoffset' yoffset' width' height' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureSubImage2D,The method has 9 parameters. Parameters: texture' level' xoffset' yoffset' width' height' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TexSubImage3D,The method has 11 parameters. Parameters: target' level' xoffset' yoffset' zoffset' width' height' depth' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureSubImage3D,The method has 11 parameters. Parameters: texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' pixels
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TextureView,The method has 8 parameters. Parameters: texture' target' origtexture' internalFormat' minlevel' numlevels' minlayer' numlayers
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,TransformFeedbackBufferRange,The method has 5 parameters. Parameters: xfb' index' buffer' offset' size
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,Uniform4f,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,Uniform4i,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,Uniform4ui,The method has 5 parameters. Parameters: location' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttrib4f,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttrib4s,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttrib4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttrib4Nub,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribI4i,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribI4ui,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribL4d,The method has 5 parameters. Parameters: index' v0' v1' v2' v3
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribFormat,The method has 5 parameters. Parameters: attribindex' size' type' normalized' relativeoffset
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexArrayAttribFormat,The method has 6 parameters. Parameters: vaobj' attribindex' size' type' normalized' relativeoffset
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexArrayAttribIFormat,The method has 5 parameters. Parameters: vaobj' attribindex' size' type' relativeoffset
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexArrayAttribLFormat,The method has 5 parameters. Parameters: vaobj' attribindex' size' type' relativeoffset
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribPointer,The method has 6 parameters. Parameters: index' size' type' normalized' stride' pointer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribIPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,VertexAttribLPointer,The method has 5 parameters. Parameters: index' size' type' stride' pointer
Long Parameter List,OpenGL,NativeMethods,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlCore.cs,ViewportIndexedf,The method has 5 parameters. Parameters: index' x' y' w' h
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawArraysInstancedBaseInstance is 33.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawElementsInstancedBaseInstance is 35.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawElementsInstancedBaseVertex is 33.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawElementsInstancedBaseVertexBaseInstance is 45.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawTransformFeedbackInstanced is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glDrawTransformFeedbackStreamInstanced is 38.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glNamedFramebufferRenderbuffer is 30.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glNamedFramebufferTextureLayer is 30.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetActiveAtomicCounterBufferiv is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetActiveSubroutineUniformiv is 30.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetActiveSubroutineUniformName is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetCompressedTextureSubImage is 30.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetFramebufferAttachmentParameteriv is 37.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetNamedFramebufferAttachmentParameteriv is 42.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetNamedFramebufferParameteriv is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetProgramResourceLocationIndex is 33.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetNamedRenderbufferParameteriv is 33.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glGetSubroutineUniformLocation is 30.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glInvalidateNamedFramebufferData is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glInvalidateNamedFramebufferSubData is 35.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glRenderbufferStorageMultisample is 32.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glNamedRenderbufferStorageMultisample is 37.
Long Identifier,OpenGL,Delegates,C:\repos\giawa_opengl4csharp\OpenGL\Core\GlDelegates.cs,,The length of the parameter glTransformFeedbackBufferRange is 30.
Long Statement,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The length of the statement  "            if (Type != typeof(int) && Type != typeof(Texture)) throw new Exception(string.Format("SetValue({0}) was given a int."' Type)); " is 127.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                Gl.GetProgramInterfaceiv(ProgramID' ProgramInterface.ProgramInput' ProgramInterfaceParameterName.ActiveResources' resources); " is 125.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                    Gl.GetProgramResourceiv(ProgramID' ProgramInterface.ProgramInput' (uint)i' 2' new ProgramResourceParameterName[] { ProgramResourceParameterName.NameLength' ProgramResourceParameterName.Type }' 256' null' values); " is 212.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                        ProgramParam param = new ProgramParam(TypeFromAttributeType((ActiveAttribType)values[1])' ParamType.Attribute' sb.ToString()); " is 126.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                Gl.GetProgramInterfaceiv(ProgramID' ProgramInterface.Uniform' ProgramInterfaceParameterName.ActiveResources' resources); " is 120.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                    Gl.GetProgramResourceiv(ProgramID' ProgramInterface.Uniform' (uint)i' 2' new ProgramResourceParameterName[] { ProgramResourceParameterName.NameLength' ProgramResourceParameterName.Type }' 256' null' values); " is 207.
Long Statement,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The length of the statement  "                        ProgramParam param = new ProgramParam(TypeFromUniformType((ActiveUniformType)values[1])' ParamType.Uniform' sb.ToString()); " is 123.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The length of the statement  "            Vector3[] vertices = new Vector3[] { new Vector3(location.X' location.Y' 0)' new Vector3(location.X + size.X' location.Y' 0)'  " is 125.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The length of the statement  "            return new VAO(program' new VBO<Vector3>(vertices)' new VBO<Vector2>(uvs)' new VBO<int>(indices' BufferTarget.ElementArrayBuffer' BufferUsageHint.StaticRead)); " is 159.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The length of the statement  "            Vector3[] vertices = new Vector3[] { new Vector3(location.X' location.Y' 0)' new Vector3(location.X + size.X' location.Y' 0)'  " is 125.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The length of the statement  "            Vector2[] uvs = new Vector2[] { uvloc' new Vector2(uvloc.X + uvsize.X' uvloc.Y)' new Vector2(uvloc.X + uvsize.X' uvloc.Y + uvsize.Y)' new Vector2(uvloc.X' uvloc.Y + uvsize.Y) }; " is 177.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The length of the statement  "            return new VAO(program' new VBO<Vector3>(vertices)' new VBO<Vector2>(uvs)' new VBO<int>(indices' BufferTarget.ElementArrayBuffer' BufferUsageHint.StaticRead)); " is 159.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuadWithNormals,The length of the statement  "            Vector3[] vertex = new Vector3[] { new Vector3(location.X' location.Y' 0)' new Vector3(location.X + size.X' location.Y' 0)'  " is 123.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuadWithNormals,The length of the statement  "            return new VAO(program' new VBO<Vector3>(vertex)' new VBO<Vector3>(normal)' new VBO<int>(element' BufferTarget.ElementArrayBuffer' BufferUsageHint.StaticRead)); " is 160.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The length of the statement  "            return new VAO(program' new VBO<Vector3>(vertex)' new VBO<int>(element' BufferTarget.ElementArrayBuffer' BufferUsageHint.StaticRead)); " is 134.
Long Statement,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The length of the statement  "            return new VAO(program' new VBO<Vector3>(vertex)' new VBO<Vector3>(normal)' new VBO<int>(element' BufferTarget.ElementArrayBuffer' BufferUsageHint.StaticRead)); " is 160.
Long Statement,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The length of the statement  "                Gl.VertexAttribPointer((uint)loc' vbos[i].Size' vbos[i].PointerType' true' vbos[i].Size * SizeOfType(vbos[i].PointerType)' IntPtr.Zero); " is 136.
Long Statement,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The length of the statement  "            if (element == null || element.ID == 0) throw new Exception("Error binding attributes.  No element array was supplied."); " is 121.
Long Statement,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The length of the statement  "            if (element == null || element.ID == 0) throw new Exception("Error binding attributes.  No element array was supplied."); " is 121.
Long Statement,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,BufferSubData,The length of the statement  "                throw new InvalidOperationException(string.Format("BufferSubData cannot be called with a BufferTarget of type {0}"' BufferTarget.ToString())); " is 142.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,BlitNamedFramebuffer,The length of the statement  "            Delegates.glBlitNamedFramebuffer(readFramebuffer' drawFramebuffer' srcX0' srcY0' srcX1' srcY1' dstX0' dstY0' dstX1' dstY1' mask' filter); " is 137.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTexSubImage3D,The length of the statement  "            Delegates.glCompressedTexSubImage3D(target' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data); " is 125.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CompressedTextureSubImage3D,The length of the statement  "            Delegates.glCompressedTextureSubImage3D(texture' level' xoffset' yoffset' zoffset' width' height' depth' format' imageSize' data); " is 130.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CopyImageSubData,The length of the statement  "            Delegates.glCopyImageSubData(srcName' srcTarget' srcLevel' srcX' srcY' srcZ' dstName' dstTarget' dstLevel' dstX' dstY' dstZ' srcWidth' srcHeight' srcDepth); " is 156.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,DrawElementsInstancedBaseVertexBaseInstance,The length of the statement  "            Delegates.glDrawElementsInstancedBaseVertexBaseInstance(mode' count' type' indices' primcount' basevertex' baseinstance); " is 121.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetCompressedTextureSubImage,The length of the statement  "            Delegates.glGetCompressedTextureSubImage(texture' level' xoffset' yoffset' zoffset' width' height' depth' bufSize' pixels); " is 123.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetTextureSubImage,The length of the statement  "            Delegates.glGetTextureSubImage(texture' level' xoffset' yoffset' zoffset' width' height' depth' format' type' bufSize' pixels); " is 127.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ReloadExtensions,The length of the statement  "                // Older versions of OpenGL have to use the normal GetString method' which returns a space delimited list of supported extensions " is 129.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The length of the statement  "            if (data2.Length != data1.Length) throw new Exception("Data lengths must be identical to construct an interleaved VBO."); " is 121.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The length of the statement  "            if (data2.Length != data1.Length || data3.Length != data1.Length) throw new Exception("Data lengths must be identical to construct an interleaved VBO."); " is 153.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The length of the statement  "            if (data2.Length != data1.Length || data3.Length != data1.Length) throw new Exception("Data lengths must be identical to construct an interleaved VBO."); " is 153.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The length of the statement  "            matrix4Float[8] = param[2].X; matrix4Float[9] = param[2].Y; matrix4Float[10] = param[2].Z; matrix4Float[11] = param[2].W; " is 121.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The length of the statement  "            matrix4Float[12] = param[3].X; matrix4Float[13] = param[3].Y; matrix4Float[14] = param[3].Z; matrix4Float[15] = param[3].W; " is 123.
Long Statement,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetAddress,The length of the statement  "                                DetectUnixKernel() + ": Unknown Unix platform - cannot load extensions. Please report a bug at http://taoframework.com"); " is 121.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[0].Set(clipMatrix[3].W - clipMatrix[3].X' new Vector3(clipMatrix[0].W - clipMatrix[0].X' clipMatrix[1].W - clipMatrix[1].X' clipMatrix[2].W - clipMatrix[2].X)); " is 167.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[1].Set(clipMatrix[3].W + clipMatrix[3].X' new Vector3(clipMatrix[0].W + clipMatrix[0].X' clipMatrix[1].W + clipMatrix[1].X' clipMatrix[2].W + clipMatrix[2].X)); " is 167.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y)); " is 167.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y)); " is 167.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z)); " is 167.
Long Statement,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The length of the statement  "            planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z)); " is 167.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToString,The length of the statement  "            return "[ " + row1.ToString() + " ] [ " + row2.ToString() + " ] [ " + row3.ToString() + " ] [ " + row4.ToString() + " ]"; " is 121.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateRotationX,The length of the statement  "            return new Matrix4(Vector4.UnitX' new Vector4(0.0f' cos' sin' 0.0f)' new Vector4(0.0f' -sin' cos' 0.0f)' Vector4.UnitW); " is 120.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateRotationY,The length of the statement  "            return new Matrix4(new Vector4(cos' 0.0f' -sin' 0.0f)' Vector4.UnitY' new Vector4(sin' 0.0f' cos' 0.0f)' Vector4.UnitW); " is 120.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateRotationZ,The length of the statement  "            return new Matrix4(new Vector4(cos' sin' 0.0f' 0.0f)' new Vector4(-sin' cos' 0.0f' 0.0f)' Vector4.UnitZ' Vector4.UnitW); " is 120.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateFromAxisAngle,The length of the statement  "            return new Matrix4(new Vector4(t * axis.X * axis.X + cos' t * axis.X * axis.Y - sin * axis.Z' t * axis.X * axis.Z + sin * axis.Y' 0.0f)' " is 136.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateScaling,The length of the statement  "            return new Matrix4(new Vector4(scale.X' 0.0f' 0.0f' 0.0f)' new Vector4(0.0f' scale.Y' 0.0f' 0.0f)' new Vector4(0.0f' 0.0f' scale.Z' 0.0f)' new Vector4(0.0f' 0.0f' 0.0f' 1.0f)); " is 176.
Long Statement,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreatePerspectiveOffCenter,The length of the statement  "            return new Matrix4(new Vector4(x' 0' 0' 0)' new Vector4(0' y' 0' 0)' new Vector4(a' b' c' -1)' new Vector4(0' 0' d' 0)); " is 120.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadBitmap,The length of the statement  "            BitmapData bitmapData = BitmapImage.LockBits(new Rectangle(0' 0' BitmapImage.Width' BitmapImage.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 181.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadBitmap,The length of the statement  "            Gl.TexImage2D(TextureTarget' 0' PixelInternalFormat.Rgba8' BitmapImage.Width' BitmapImage.Height' 0' PixelFormat.Bgra' PixelType.UnsignedByte' bitmapData.Scan0); " is 161.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor " is 151.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                        else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 && " is 121.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize); " is 134.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                            Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset)); " is 136.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                            PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed; " is 136.
Long Statement,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The length of the statement  "                            Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset)); " is 148.
Complex Conditional,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,BufferSubData,The conditional expression  "BufferTarget != OpenGL.BufferTarget.ArrayBuffer && BufferTarget != OpenGL.BufferTarget.ElementArrayBuffer &&                  BufferTarget != OpenGL.BufferTarget.PixelPackBuffer && BufferTarget != OpenGL.BufferTarget.PixelUnpackBuffer"  is complex.
Complex Conditional,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetAddress,The conditional expression  "Environment.OSVersion.Platform == PlatformID.Win32NT ||                      Environment.OSVersion.Platform == PlatformID.Win32S ||                      Environment.OSVersion.Platform == PlatformID.Win32Windows ||                      Environment.OSVersion.Platform == PlatformID.WinCE"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X > b.Max.X) || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X > b.Max.X) || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X > b.Max.X) || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X > b.Max.X) || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.Z < b.Min.Z)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.Z > b.Max.Z)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X > b.Max.X) || (origin.Z < b.Min.Z)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X > b.Max.X) || (origin.Z > b.Max.Z)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.Y < b.Min.Y)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.Y > b.Max.Y)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X > b.Max.X) || (origin.Y < b.Min.Y)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X > b.Max.X) || (origin.Y > b.Max.Y)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X < b.Min.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y < b.Min.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The conditional expression  "(origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)"  is complex.
Complex Conditional,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The conditional expression  "imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16"  is complex.
Complex Conditional,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The conditional expression  "imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32"  is complex.
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: Vector3[] vertices = new Vector3[Text.Length * 4];
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: Vector2[] uvs = new Vector2[Text.Length * 4];
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: int[] indices = new int[Text.Length * 6];
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,BitmapFont,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\BitmapFont.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < Text.Length; i++)              {                  // Note: These are fixed width fonts so just use 2x2 quads (-1..1)                  vertices[i * 4 + 0] = new Vector3(-1 + i * 2' 1' 0);                  vertices[i * 4 + 1] = new Vector3(-1 + i * 2' -1' 0);                  vertices[i * 4 + 2] = new Vector3(1 + i * 2' 1' 0);                  vertices[i * 4 + 3] = new Vector3(1 + i * 2' -1' 0);                    UVPair ch = Character[Text[i] > 256 ? ' ' : Text[i]];                  uvs[i * 4 + 0] = new Vector2(ch.Topleft.X' ch.BottomRight.Y);                  uvs[i * 4 + 1] = ch.Topleft;                  uvs[i * 4 + 2] = ch.BottomRight;                  uvs[i * 4 + 3] = new Vector2(ch.BottomRight.X' ch.Topleft.Y);                    indices[i * 6 + 0] = i * 4 + 1;                  indices[i * 6 + 1] = i * 4 + 0;                  indices[i * 6 + 2] = i * 4 + 2;                  indices[i * 6 + 3] = i * 4 + 1;                  indices[i * 6 + 4] = i * 4 + 2;                  indices[i * 6 + 5] = i * 4 + 3;              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ProgramParam,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,SetValue,The following statement contains a magic number: if (param.Length == 16)              {                  if (Type != typeof(Matrix4)) throw new Exception(string.Format("SetValue({0}) was given a Matrix4."' Type));                  Gl.UniformMatrix4fv(location' 1' false' param);              }              else if (param.Length == 9)              {                  if (Type != typeof(Matrix3)) throw new Exception(string.Format("SetValue({0}) was given a Matrix3."' Type));                  Gl.UniformMatrix3fv(location' 1' false' param);              }              else if (param.Length == 4)              {                  if (Type != typeof(Vector4)) throw new Exception(string.Format("SetValue({0}) was given a Vector4."' Type));                  Gl.Uniform4f(location' param[0]' param[1]' param[2]' param[3]);              }              else if (param.Length == 3)              {                  if (Type != typeof(Vector3)) throw new Exception(string.Format("SetValue({0}) was given a Vector3."' Type));                  Gl.Uniform3f(location' param[0]' param[1]' param[2]);              }              else if (param.Length == 2)              {                  if (Type != typeof(Vector2)) throw new Exception(string.Format("SetValue({0}) was given a Vector2."' Type));                  Gl.Uniform2f(location' param[0]' param[1]);              }              else if (param.Length == 1)              {                  if (Type != typeof(float)) throw new Exception(string.Format("SetValue({0}) was given a float."' Type));                  Gl.Uniform1f(location' param[0]);              }              else              {                  throw new ArgumentException("param was an unexpected length."' "param");              }
Magic Number,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The following statement contains a magic number: for (int i = 0; i < resources[0]; i++)                  {                      ActiveAttribType[] type = new ActiveAttribType[1];                      System.Text.StringBuilder sb = new System.Text.StringBuilder(256);                      Gl.GetActiveAttrib(ProgramID' i' 256' actualLength' arraySize' type' sb);                        if (!shaderParams.ContainsKey(sb.ToString()))                      {                          ProgramParam param = new ProgramParam(TypeFromAttributeType(type[0])' ParamType.Attribute' sb.ToString());                          shaderParams.Add(param.Name' param);                          param.GetLocation(this);                      }                  }
Magic Number,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The following statement contains a magic number: for (int i = 0; i < resources[0]; i++)                  {                      ActiveAttribType[] type = new ActiveAttribType[1];                      System.Text.StringBuilder sb = new System.Text.StringBuilder(256);                      Gl.GetActiveAttrib(ProgramID' i' 256' actualLength' arraySize' type' sb);                        if (!shaderParams.ContainsKey(sb.ToString()))                      {                          ProgramParam param = new ProgramParam(TypeFromAttributeType(type[0])' ParamType.Attribute' sb.ToString());                          shaderParams.Add(param.Name' param);                          param.GetLocation(this);                      }                  }
Magic Number,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The following statement contains a magic number: for (int i = 0; i < resources[0]; i++)                  {                      ActiveUniformType[] type = new ActiveUniformType[1];                      System.Text.StringBuilder sb = new System.Text.StringBuilder(256);                      Gl.GetActiveUniform(ProgramID' (uint)i' 256' actualLength' arraySize' type' sb);                        if (!shaderParams.ContainsKey(sb.ToString()))                      {                          ProgramParam param = new ProgramParam(TypeFromUniformType(type[0])' ParamType.Uniform' sb.ToString());                          shaderParams.Add(param.Name' param);                          param.GetLocation(this);                      }                  }
Magic Number,OpenGL,ShaderProgram,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Shader.cs,GetParams,The following statement contains a magic number: for (int i = 0; i < resources[0]; i++)                  {                      ActiveUniformType[] type = new ActiveUniformType[1];                      System.Text.StringBuilder sb = new System.Text.StringBuilder(256);                      Gl.GetActiveUniform(ProgramID' (uint)i' 256' actualLength' arraySize' type' sb);                        if (!shaderParams.ContainsKey(sb.ToString()))                      {                          ProgramParam param = new ProgramParam(TypeFromUniformType(type[0])' ParamType.Uniform' sb.ToString());                          shaderParams.Add(param.Name' param);                          param.GetLocation(this);                      }                  }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++)              {                  int cornerA = elementData[i * 3];                  int cornerB = elementData[i * 3 + 1];                  int cornerC = elementData[i * 3 + 2];                    b1 = vertexData[cornerB] - vertexData[cornerA];                  b2 = vertexData[cornerC] - vertexData[cornerA];                    normal = Vector3.Cross(b1' b2).Normalize();                    normalData[cornerA] += normal;                  normalData[cornerB] += normal;                  normalData[cornerC] += normal;              }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++)              {                  int cornerA = elementData[i * 3];                  int cornerB = elementData[i * 3 + 1];                  int cornerC = elementData[i * 3 + 2];                    b1 = vertexData[cornerB] - vertexData[cornerA];                  b2 = vertexData[cornerC] - vertexData[cornerA];                    normal = Vector3.Cross(b1' b2).Normalize();                    normalData[cornerA] += normal;                  normalData[cornerB] += normal;                  normalData[cornerC] += normal;              }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++)              {                  int cornerA = elementData[i * 3];                  int cornerB = elementData[i * 3 + 1];                  int cornerC = elementData[i * 3 + 2];                    b1 = vertexData[cornerB] - vertexData[cornerA];                  b2 = vertexData[cornerC] - vertexData[cornerA];                    normal = Vector3.Cross(b1' b2).Normalize();                    normalData[cornerA] += normal;                  normalData[cornerB] += normal;                  normalData[cornerC] += normal;              }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++)              {                  int cornerA = elementData[i * 3];                  int cornerB = elementData[i * 3 + 1];                  int cornerC = elementData[i * 3 + 2];                    b1 = vertexData[cornerB] - vertexData[cornerA];                  b2 = vertexData[cornerC] - vertexData[cornerA];                    normal = Vector3.Cross(b1' b2).Normalize();                    normalData[cornerA] += normal;                  normalData[cornerB] += normal;                  normalData[cornerC] += normal;              }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++)              {                  int cornerA = elementData[i * 3];                  int cornerB = elementData[i * 3 + 1];                  int cornerC = elementData[i * 3 + 2];                    b1 = vertexData[cornerB] - vertexData[cornerA];                  b2 = vertexData[cornerC] - vertexData[cornerA];                    normal = Vector3.Cross(b1' b2).Normalize();                    normalData[cornerA] += normal;                  normalData[cornerB] += normal;                  normalData[cornerC] += normal;              }
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuad,The following statement contains a magic number: int[] indices = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuadWithNormals,The following statement contains a magic number: int[] element = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuadWithNormals,The following statement contains a magic number: int[] element = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateQuadWithNormals,The following statement contains a magic number: int[] element = new int[] { 0' 1' 2' 2' 3' 0 };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCube,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,Geometry,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Geometry.cs,CreateCubeWithNormals,The following statement contains a magic number: int[] element = new int[] {                  0' 1' 2' 1' 3' 2'                  1' 4' 3' 4' 5' 3'                  4' 7' 5' 7' 6' 5'                  7' 0' 6' 0' 2' 6'                  7' 4' 0' 4' 1' 0'                  2' 3' 6' 3' 5' 6              };
Magic Number,OpenGL,VAO<T1>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[2];
Magic Number,OpenGL,VAO<T1>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[2];
Magic Number,OpenGL,VAO<T1;T2>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 2) throw new Exception(string.Format("Expected an array of 2 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[3];
Magic Number,OpenGL,VAO<T1;T2>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 3) throw new Exception(string.Format("Expected an array of 3 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[4];
Magic Number,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 4) throw new Exception(string.Format("Expected an array of 4 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[5];
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 5) throw new Exception(string.Format("Expected an array of 5 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[6];
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 6) throw new Exception(string.Format("Expected an array of 6 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[7];
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[6] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 7) throw new Exception(string.Format("Expected an array of 7 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[8];
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[6] = new GenericVBO(vbo7.ID' attribNames[6]' vbo7.Count' vbo7.Size' vbo7.PointerType' vbo7.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[6] = new GenericVBO(vbo7.ID' attribNames[6]' vbo7.Count' vbo7.Size' vbo7.PointerType' vbo7.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[7] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (attribNames.Length != 8) throw new Exception(string.Format("Expected an array of 8 names' but instead got {0}."' attribNames.Length));
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: GenericVAO.GenericVBO[] vbos = new GenericVBO[8];
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[2] = new GenericVBO(vbo3.ID' attribNames[2]' vbo3.Count' vbo3.Size' vbo3.PointerType' vbo3.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[3] = new GenericVBO(vbo4.ID' attribNames[3]' vbo4.Count' vbo4.Size' vbo4.PointerType' vbo4.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[4] = new GenericVBO(vbo5.ID' attribNames[4]' vbo5.Count' vbo5.Size' vbo5.PointerType' vbo5.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[5] = new GenericVBO(vbo6.ID' attribNames[5]' vbo6.Count' vbo6.Size' vbo6.PointerType' vbo6.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[6] = new GenericVBO(vbo7.ID' attribNames[6]' vbo7.Count' vbo7.Size' vbo7.PointerType' vbo7.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[6] = new GenericVBO(vbo7.ID' attribNames[6]' vbo7.Count' vbo7.Size' vbo7.PointerType' vbo7.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[7] = new GenericVBO(vbo8.ID' attribNames[7]' vbo8.Count' vbo8.Size' vbo8.PointerType' vbo8.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[7] = new GenericVBO(vbo8.ID' attribNames[7]' vbo8.Count' vbo8.Size' vbo8.PointerType' vbo8.BufferTarget);
Magic Number,OpenGL,VAO<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: vbos[8] = new GenericVBO(elementArray.ID' ""' elementArray.Count' elementArray.Size' elementArray.PointerType' elementArray.BufferTarget);
Magic Number,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,Init,The following statement contains a magic number: if (Gl.Version() >= 3)              {                  ID = Gl.GenVertexArray();                  if (ID != 0)                  {                      Gl.BindVertexArray(ID);                      BindAttributes(Program);                  }                  Gl.BindVertexArray(0);                    Draw = DrawOGL3;              }              else              {                  Draw = DrawOGL2;              }
Magic Number,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,SizeOfType,The following statement contains a magic number: switch (type)              {                  case VertexAttribPointerType.Byte:                   case VertexAttribPointerType.UnsignedByte: return 1;                  case VertexAttribPointerType.Short:                  case VertexAttribPointerType.UnsignedShort:                   case VertexAttribPointerType.HalfFloat: return 2;                  case VertexAttribPointerType.Int:                  case VertexAttribPointerType.Float: return 4;                  case VertexAttribPointerType.Double: return 8;              }
Magic Number,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,SizeOfType,The following statement contains a magic number: switch (type)              {                  case VertexAttribPointerType.Byte:                   case VertexAttribPointerType.UnsignedByte: return 1;                  case VertexAttribPointerType.Short:                  case VertexAttribPointerType.UnsignedShort:                   case VertexAttribPointerType.HalfFloat: return 2;                  case VertexAttribPointerType.Int:                  case VertexAttribPointerType.Float: return 4;                  case VertexAttribPointerType.Double: return 8;              }
Magic Number,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,SizeOfType,The following statement contains a magic number: switch (type)              {                  case VertexAttribPointerType.Byte:                   case VertexAttribPointerType.UnsignedByte: return 1;                  case VertexAttribPointerType.Short:                  case VertexAttribPointerType.UnsignedShort:                   case VertexAttribPointerType.HalfFloat: return 2;                  case VertexAttribPointerType.Int:                  case VertexAttribPointerType.Float: return 4;                  case VertexAttribPointerType.Double: return 8;              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,VAO,The following statement contains a magic number: if (Gl.Version() >= 3)              {                  ID = Gl.GenVertexArray();                  if (ID != 0)                  {                      Gl.BindVertexArray(ID);                      BindAttributes(Program);                  }                  Gl.BindVertexArray(0);                    Draw = DrawOGL3;              }              else              {                  Draw = DrawOGL2;              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The following statement contains a magic number: if (normalAttributeLocation != -1 && normal.ID != 0)              {                  Gl.EnableVertexAttribArray((uint)normalAttributeLocation);                  Gl.BindBuffer(normal.BufferTarget' normal.ID);                  Gl.VertexAttribPointer((uint)normalAttributeLocation' normal.Size' normal.PointerType' true' 12' IntPtr.Zero);              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The following statement contains a magic number: if (uvAttributeLocation != -1 && uv.ID != 0)              {                  Gl.EnableVertexAttribArray((uint)uvAttributeLocation);                  Gl.BindBuffer(uv.BufferTarget' uv.ID);                  Gl.VertexAttribPointer((uint)uvAttributeLocation' uv.Size' uv.PointerType' true' 8' IntPtr.Zero);              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The following statement contains a magic number: if (tangentAttributeLocation != -1 && tangent.ID != 0)              {                  Gl.EnableVertexAttribArray((uint)tangentAttributeLocation);                  Gl.BindBuffer(tangent.BufferTarget' tangent.ID);                  Gl.VertexAttribPointer((uint)tangentAttributeLocation' tangent.Size' tangent.PointerType' true' 12' IntPtr.Zero);              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindCachedAttributes,The following statement contains a magic number: Gl.VertexAttribPointer((uint)vertexAttributeLocation' vertex.Size' vertex.PointerType' true' 12' IntPtr.Zero);
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The following statement contains a magic number: Gl.VertexAttribPointer((uint)loc' vertex.Size' vertex.PointerType' true' 12' IntPtr.Zero);
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The following statement contains a magic number: if (normal != null && normal.ID != 0)              {                  loc = Gl.GetAttribLocation(program.ProgramID' "in_normal");                  if (loc != -1)                  {                      Gl.EnableVertexAttribArray((uint)loc);                      Gl.BindBuffer(normal.BufferTarget' normal.ID);                      Gl.VertexAttribPointer((uint)loc' normal.Size' normal.PointerType' true' 12' IntPtr.Zero);                  }              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The following statement contains a magic number: if (uv != null && uv.ID != 0)              {                  loc = Gl.GetAttribLocation(program.ProgramID' "in_uv");                  if (loc != -1)                  {                      Gl.EnableVertexAttribArray((uint)loc);                      Gl.BindBuffer(uv.BufferTarget' uv.ID);                      Gl.VertexAttribPointer((uint)loc' uv.Size' uv.PointerType' true' 8' IntPtr.Zero);                  }              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,BindAttributes,The following statement contains a magic number: if (tangent != null && tangent.ID != 0)              {                  loc = Gl.GetAttribLocation(program.ProgramID' "in_tangent");                  if (loc != -1)                  {                      Gl.EnableVertexAttribArray((uint)loc);                      Gl.BindBuffer(tangent.BufferTarget' tangent.ID);                      Gl.VertexAttribPointer((uint)loc' tangent.Size' tangent.PointerType' true' 12' IntPtr.Zero);                  }              }
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,DrawOGL3,The following statement contains a magic number: IntPtr offset = (IntPtr)(Offset * 4);
Magic Number,OpenGL,VAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,DrawOGL2,The following statement contains a magic number: IntPtr offset = (IntPtr)(Offset * 4);
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: this.Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,VBO<T>,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VBO.cs,VBO,The following statement contains a magic number: Size = (Data is int[] ? 1 : (Data is Vector2[] ? 2 : (Data is Vector3[] ? 3 : (Data is Vector4[] ? 4 : 0))));
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,ReloadExtensions,The following statement contains a magic number: if (Version() >= 3)              {                  // OpenGL version >= 3 supports indexed extensions' and actually deprecated the legacy GetString method                  int extensionCount = GetInteger(GetPName.NumExtensions);                    for (int i = 0; i < extensionCount; i++)                  {                      string extension = GetStringi(StringName.Extensions' (uint)i);                      if (!stringExtensions.Contains(extension)) stringExtensions.Add(extension.ToLower());                  }              }              else              {                  // Older versions of OpenGL have to use the normal GetString method' which returns a space delimited list of supported extensions                  var extensions = GetString(StringName.Extensions).Split(new char[] { '\0'' ' ' });                    for (int i = 0; i < extensions.Length; i++)                  {                      if (extensions[i].Length == 0) continue;                      else if (!stringExtensions.Contains(extensions[i])) stringExtensions.Add(extensions[i].ToLower());                  }              }
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The following statement contains a magic number: float[] interleaved = new float[data1.Length * 6];
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The following statement contains a magic number: float[] interleaved = new float[data1.Length * 8];
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The following statement contains a magic number: float[] interleaved = new float[data1.Length * 9];
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,CreateInterleavedVBO,The following statement contains a magic number: float[] interleaved = new float[data1.Length * 11];
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[2] = param[0].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[3] = param[0].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[4] = param[1].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[5] = param[1].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[6] = param[1].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[7] = param[1].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[8] = param[2].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[8] = param[2].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[9] = param[2].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[9] = param[2].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[10] = param[2].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[10] = param[2].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[11] = param[2].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[11] = param[2].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[12] = param[3].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[12] = param[3].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[13] = param[3].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[13] = param[3].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[14] = param[3].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[14] = param[3].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[15] = param[3].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix4fv,The following statement contains a magic number: matrix4Float[15] = param[3].W;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[2] = param[0].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[3] = param[1].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[4] = param[1].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[5] = param[1].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[6] = param[2].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[6] = param[2].X;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[7] = param[2].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[7] = param[2].Y;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[8] = param[2].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,UniformMatrix3fv,The following statement contains a magic number: matrix3Float[8] = param[2].Z;
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetDelegate,The following statement contains a magic number: return GetExtensionDelegate(name' signature) ??                    (Core.FunctionMap.TryGetValue((name.Substring(2))' out m) ?                     Delegate.CreateDelegate(signature' m) : null);
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetExtensionDelegate,The following statement contains a magic number: if (address == IntPtr.Zero ||                  address == new IntPtr(1) ||     // Workaround for buggy nvidia drivers which return                  address == new IntPtr(2))       // 1 or 2 instead of IntPtr.Zero for some extensions.              {                  return null;              }              else              {                  return Marshal.GetDelegateForFunctionPointer(address' signature);              }
Magic Number,OpenGL,Gl,C:\repos\giawa_opengl4csharp\OpenGL\Core\Gl.cs,GetAddress,The following statement contains a magic number: if (getProcAddress == null)              {                  if (Environment.OSVersion.Platform == PlatformID.Win32NT ||                      Environment.OSVersion.Platform == PlatformID.Win32S ||                      Environment.OSVersion.Platform == PlatformID.Win32Windows ||                      Environment.OSVersion.Platform == PlatformID.WinCE)                  {                      getProcAddress = new GetProcAddressWindows();                  }                  else if (Environment.OSVersion.Platform == PlatformID.Unix ||                           Environment.OSVersion.Platform == (PlatformID)4)                  {                      // Distinguish between Unix and Mac OS X kernels.                      switch (DetectUnixKernel())                      {                          case "Unix":                          case "Linux":                              getProcAddress = new GetProcAddressX11();                              break;                            case "Darwin":                              getProcAddress = new GetProcAddressOSX();                              break;                            default:                              throw new PlatformNotSupportedException(                                  DetectUnixKernel() + ": Unknown Unix platform - cannot load extensions. Please report a bug at http://taoframework.com");                      }                  }                  else                  {                      throw new PlatformNotSupportedException(                          "Extension loading is only supported under Mac OS X' Unix/X11 and Windows. We are sorry for the inconvience.");                  }              }
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,Frustum,The following statement contains a magic number: planes = new Plane[6];
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,Frustum,The following statement contains a magic number: for (int i = 0; i < 6; i++) planes[i] = new Plane(0' 0' 0' 0);
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[0].Set(clipMatrix[3].W - clipMatrix[3].X' new Vector3(clipMatrix[0].W - clipMatrix[0].X' clipMatrix[1].W - clipMatrix[1].X' clipMatrix[2].W - clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[0].Set(clipMatrix[3].W - clipMatrix[3].X' new Vector3(clipMatrix[0].W - clipMatrix[0].X' clipMatrix[1].W - clipMatrix[1].X' clipMatrix[2].W - clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[0].Set(clipMatrix[3].W - clipMatrix[3].X' new Vector3(clipMatrix[0].W - clipMatrix[0].X' clipMatrix[1].W - clipMatrix[1].X' clipMatrix[2].W - clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[0].Set(clipMatrix[3].W - clipMatrix[3].X' new Vector3(clipMatrix[0].W - clipMatrix[0].X' clipMatrix[1].W - clipMatrix[1].X' clipMatrix[2].W - clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[1].Set(clipMatrix[3].W + clipMatrix[3].X' new Vector3(clipMatrix[0].W + clipMatrix[0].X' clipMatrix[1].W + clipMatrix[1].X' clipMatrix[2].W + clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[1].Set(clipMatrix[3].W + clipMatrix[3].X' new Vector3(clipMatrix[0].W + clipMatrix[0].X' clipMatrix[1].W + clipMatrix[1].X' clipMatrix[2].W + clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[1].Set(clipMatrix[3].W + clipMatrix[3].X' new Vector3(clipMatrix[0].W + clipMatrix[0].X' clipMatrix[1].W + clipMatrix[1].X' clipMatrix[2].W + clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[1].Set(clipMatrix[3].W + clipMatrix[3].X' new Vector3(clipMatrix[0].W + clipMatrix[0].X' clipMatrix[1].W + clipMatrix[1].X' clipMatrix[2].W + clipMatrix[2].X));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[2].Set(clipMatrix[3].W + clipMatrix[3].Y' new Vector3(clipMatrix[0].W + clipMatrix[0].Y' clipMatrix[1].W + clipMatrix[1].Y' clipMatrix[2].W + clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[3].Set(clipMatrix[3].W - clipMatrix[3].Y' new Vector3(clipMatrix[0].W - clipMatrix[0].Y' clipMatrix[1].W - clipMatrix[1].Y' clipMatrix[2].W - clipMatrix[2].Y));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[4].Set(clipMatrix[3].W - clipMatrix[3].Z' new Vector3(clipMatrix[0].W - clipMatrix[0].Z' clipMatrix[1].W - clipMatrix[1].Z' clipMatrix[2].W - clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: planes[5].Set(clipMatrix[3].W + clipMatrix[3].Z' new Vector3(clipMatrix[0].W + clipMatrix[0].Z' clipMatrix[1].W + clipMatrix[1].Z' clipMatrix[2].W + clipMatrix[2].Z));
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,UpdateFrustum,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {  #if USE_NUMERICS                  float length = planes[i].Normal.Length();  #else                  float length = planes[i].Normal.Length;  #endif                  planes[i].D /= length;                  planes[i].Normal /= length;              }
Magic Number,OpenGL,Frustum,C:\repos\giawa_opengl4csharp\OpenGL\Math\Frustum.cs,Intersects,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  Plane p = planes[i];                    float d = box.Center.Dot(p.Normal);                  float r = box.Size.X * Math.Abs(p.Normal.X) + box.Size.Y * Math.Abs(p.Normal.Y) + box.Size.Z * Math.Abs(p.Normal.Z);                  float dpr = d + r;                  //float dmr = d - r;                    if (dpr < -p.D) return false;              }
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = existingMatrix[2];
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row1 = new Vector3(array[0]' array[1]' array[2]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3(array[3]' array[4]' array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3(array[3]' array[4]' array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3(array[3]' array[4]' array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3(array[6]' array[7]' array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3(array[6]' array[7]' array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3(array[6]' array[7]' array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row1 = new Vector3((float)array[0]' (float)array[1]' (float)array[2]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3((float)array[3]' (float)array[4]' (float)array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3((float)array[3]' (float)array[4]' (float)array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row2 = new Vector3((float)array[3]' (float)array[4]' (float)array[5]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3((float)array[6]' (float)array[7]' (float)array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3((float)array[6]' (float)array[7]' (float)array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Matrix3,The following statement contains a magic number: row3 = new Vector3((float)array[6]' (float)array[7]' (float)array[8]);
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Transpose,The following statement contains a magic number: return new Matrix3(new Vector3(this[0].X' this[1].X' this[2].X)'                  new Vector3(this[0].Y' this[1].Y' this[2].Y)'                  new Vector3(this[0].Z' this[1].Z' this[2].Z));
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Transpose,The following statement contains a magic number: return new Matrix3(new Vector3(this[0].X' this[1].X' this[2].X)'                  new Vector3(this[0].Y' this[1].Y' this[2].Y)'                  new Vector3(this[0].Z' this[1].Z' this[2].Z));
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Transpose,The following statement contains a magic number: return new Matrix3(new Vector3(this[0].X' this[1].X' this[2].X)'                  new Vector3(this[0].Y' this[1].Y' this[2].Y)'                  new Vector3(this[0].Z' this[1].Z' this[2].Z));
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 3; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 3; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix3 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 3; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 3; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 3; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix3 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 3; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 3; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 3; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix3 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 3; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[1].X' this[1].Y' this[1].Z'                  this[2].X' this[2].Y' this[2].Z };
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[1].X' this[1].Y' this[1].Z'                  this[2].X' this[2].Y' this[2].Z };
Magic Number,OpenGL,Matrix3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix3.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[1].X' this[1].Y' this[1].Z'                  this[2].X' this[2].Y' this[2].Z };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = existingMatrix[2];
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = existingMatrix[3];
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row1 = new Vector4(array[0]' array[1]' array[2]' array[3]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row1 = new Vector4(array[0]' array[1]' array[2]' array[3]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4(array[4]' array[5]' array[6]' array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4(array[4]' array[5]' array[6]' array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4(array[4]' array[5]' array[6]' array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4(array[4]' array[5]' array[6]' array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4(array[8]' array[9]' array[10]' array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4(array[8]' array[9]' array[10]' array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4(array[8]' array[9]' array[10]' array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4(array[8]' array[9]' array[10]' array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4(array[12]' array[13]' array[14]' array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4(array[12]' array[13]' array[14]' array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4(array[12]' array[13]' array[14]' array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4(array[12]' array[13]' array[14]' array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row1 = new Vector4((float)array[0]' (float)array[1]' (float)array[2]' (float)array[3]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row1 = new Vector4((float)array[0]' (float)array[1]' (float)array[2]' (float)array[3]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4((float)array[4]' (float)array[5]' (float)array[6]' (float)array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4((float)array[4]' (float)array[5]' (float)array[6]' (float)array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4((float)array[4]' (float)array[5]' (float)array[6]' (float)array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row2 = new Vector4((float)array[4]' (float)array[5]' (float)array[6]' (float)array[7]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4((float)array[8]' (float)array[9]' (float)array[10]' (float)array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4((float)array[8]' (float)array[9]' (float)array[10]' (float)array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4((float)array[8]' (float)array[9]' (float)array[10]' (float)array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row3 = new Vector4((float)array[8]' (float)array[9]' (float)array[10]' (float)array[11]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4((float)array[12]' (float)array[13]' (float)array[14]' (float)array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4((float)array[12]' (float)array[13]' (float)array[14]' (float)array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4((float)array[12]' (float)array[13]' (float)array[14]' (float)array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Matrix4,The following statement contains a magic number: row4 = new Vector4((float)array[12]' (float)array[13]' (float)array[14]' (float)array[15]);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateTranslation,The following statement contains a magic number: result[3] = new Vector4(translation' 1.0f);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographic,The following statement contains a magic number: return CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographic,The following statement contains a magic number: return CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographic,The following statement contains a magic number: return CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographic,The following statement contains a magic number: return CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar);
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4(new Vector4(2 * invRL' 0' 0' 0)' new Vector4(0' 2 * invTB' 0' 0)' new Vector4(0' 0' -2 * invFN' 0)'                  new Vector4(-(right + left) * invRL' -(top + bottom) * invTB' -(zFar + zNear) * invFN' 1));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4(new Vector4(2 * invRL' 0' 0' 0)' new Vector4(0' 2 * invTB' 0' 0)' new Vector4(0' 0' -2 * invFN' 0)'                  new Vector4(-(right + left) * invRL' -(top + bottom) * invTB' -(zFar + zNear) * invFN' 1));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4(new Vector4(2 * invRL' 0' 0' 0)' new Vector4(0' 2 * invTB' 0' 0)' new Vector4(0' 0' -2 * invFN' 0)'                  new Vector4(-(right + left) * invRL' -(top + bottom) * invTB' -(zFar + zNear) * invFN' 1));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Transpose,The following statement contains a magic number: return new Matrix4(new Vector4(this[0].X' this[1].X' this[2].X' this[3].X)'                  new Vector4(this[0].Y' this[1].Y' this[2].Y' this[3].Y)'                  new Vector4(this[0].Z' this[1].Z' this[2].Z' this[3].Z)'                  new Vector4(this[0].W' this[1].W' this[2].W' this[3].W));
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 4; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 4; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix4 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 4; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 4; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 4; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix4 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 4; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,Inverse,The following statement contains a magic number: for (int j = 0; j < 4; j++)              {                  k = j;    // row with largest pivot cadence                  for (int i = j + 1; i < 4; i++)                      if (Math.Abs(original[i].Get(j)) > Math.Abs(original[k].Get(j))) k = i;                    original.SwapRows(k' j);                  identity.SwapRows(k' j);                    if (original[j].Get(j) == 0.0f)                       throw new Exception("Matrix4 was a singular matrix and cannot be inverted.");                    identity[j] /= original[j].Get(j);                  original[j] /= original[j].Get(j);                    for (int i = 0; i < 4; i++)                  {                      if (i != j)                      {                          identity[i] -= original[i].Get(j) * identity[j];                          original[i] -= original[i].Get(j) * original[j];                      }                  }              }
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Matrix4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Matrix4.cs,ToFloat,The following statement contains a magic number: return new float[] { this[0].X' this[0].Y' this[0].Z' this[0].W' this[1].X' this[1].Y' this[1].Z' this[1].W'                  this[2].X' this[2].Y' this[2].Z' this[2].W' this[3].X' this[3].Y' this[3].Z' this[3].W };
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,Parse,The following statement contains a magic number: if (split.Length != 4) return Quaternion.Identity;
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,Parse,The following statement contains a magic number: return new Quaternion(float.Parse(split[0])' float.Parse(split[1])' float.Parse(split[2])' float.Parse(split[3]));
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,Parse,The following statement contains a magic number: return new Quaternion(float.Parse(split[0])' float.Parse(split[1])' float.Parse(split[2])' float.Parse(split[3]));
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,ToAxis,The following statement contains a magic number: return new Vector3[] { new Vector3(rotationMatrix[0].X' rotationMatrix[1].X' rotationMatrix[2].X)'                  new Vector3(rotationMatrix[0].Y' rotationMatrix[1].Y' rotationMatrix[2].Y)'                  new Vector3(rotationMatrix[0].Z' rotationMatrix[1].Z' rotationMatrix[2].Z) };
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,ToAxis,The following statement contains a magic number: return new Vector3[] { new Vector3(rotationMatrix[0].X' rotationMatrix[1].X' rotationMatrix[2].X)'                  new Vector3(rotationMatrix[0].Y' rotationMatrix[1].Y' rotationMatrix[2].Y)'                  new Vector3(rotationMatrix[0].Z' rotationMatrix[1].Z' rotationMatrix[2].Z) };
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,ToAxis,The following statement contains a magic number: return new Vector3[] { new Vector3(rotationMatrix[0].X' rotationMatrix[1].X' rotationMatrix[2].X)'                  new Vector3(rotationMatrix[0].Y' rotationMatrix[1].Y' rotationMatrix[2].Y)'                  new Vector3(rotationMatrix[0].Z' rotationMatrix[1].Z' rotationMatrix[2].Z) };
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,FromRotationMatrix,The following statement contains a magic number: float t_trace = Rotation[0].X + Rotation[1].Y + Rotation[2].Z;
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,FromRotationMatrix,The following statement contains a magic number: if (t_trace > 0.0)              {   // |w| > 1/2                  Quaternion t_return = Quaternion.Zero;                  t_root = (float)Math.Sqrt(t_trace + 1.0);                  t_return.W = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.X = (Rotation[2].Y - Rotation[1].Z) * t_root;                  t_return.Y = (Rotation[0].Z - Rotation[2].X) * t_root;                  t_return.Z = (Rotation[1].X - Rotation[0].Y) * t_root;                  return t_return;              }              else              {   // |w| <= 1/2                  Quaternion t_return = Quaternion.Zero;                    int i = 0;                  if (Rotation[1].Y > Rotation[0].X) i = 1;                  if (Rotation[2].Z > Rotation[i].Get(i)) i = 2;                  int j = rotationLookup[i];                  int k = rotationLookup[j];                    t_root = (float)Math.Sqrt(Rotation[i].Get(i) - Rotation[j].Get(j) - Rotation[k].Get(k) + 1.0f);                  t_return[i] = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.W = (Rotation[k].Get(j) - Rotation[j].Get(k)) * t_root;                  t_return[j] = (Rotation[j].Get(i) + Rotation[i].Get(j)) * t_root;                  t_return[k] = (Rotation[k].Get(i) + Rotation[i].Get(k)) * t_root;                  return t_return;              }
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,FromRotationMatrix,The following statement contains a magic number: if (t_trace > 0.0)              {   // |w| > 1/2                  Quaternion t_return = Quaternion.Zero;                  t_root = (float)Math.Sqrt(t_trace + 1.0);                  t_return.W = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.X = (Rotation[2].Y - Rotation[1].Z) * t_root;                  t_return.Y = (Rotation[0].Z - Rotation[2].X) * t_root;                  t_return.Z = (Rotation[1].X - Rotation[0].Y) * t_root;                  return t_return;              }              else              {   // |w| <= 1/2                  Quaternion t_return = Quaternion.Zero;                    int i = 0;                  if (Rotation[1].Y > Rotation[0].X) i = 1;                  if (Rotation[2].Z > Rotation[i].Get(i)) i = 2;                  int j = rotationLookup[i];                  int k = rotationLookup[j];                    t_root = (float)Math.Sqrt(Rotation[i].Get(i) - Rotation[j].Get(j) - Rotation[k].Get(k) + 1.0f);                  t_return[i] = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.W = (Rotation[k].Get(j) - Rotation[j].Get(k)) * t_root;                  t_return[j] = (Rotation[j].Get(i) + Rotation[i].Get(j)) * t_root;                  t_return[k] = (Rotation[k].Get(i) + Rotation[i].Get(k)) * t_root;                  return t_return;              }
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,FromRotationMatrix,The following statement contains a magic number: if (t_trace > 0.0)              {   // |w| > 1/2                  Quaternion t_return = Quaternion.Zero;                  t_root = (float)Math.Sqrt(t_trace + 1.0);                  t_return.W = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.X = (Rotation[2].Y - Rotation[1].Z) * t_root;                  t_return.Y = (Rotation[0].Z - Rotation[2].X) * t_root;                  t_return.Z = (Rotation[1].X - Rotation[0].Y) * t_root;                  return t_return;              }              else              {   // |w| <= 1/2                  Quaternion t_return = Quaternion.Zero;                    int i = 0;                  if (Rotation[1].Y > Rotation[0].X) i = 1;                  if (Rotation[2].Z > Rotation[i].Get(i)) i = 2;                  int j = rotationLookup[i];                  int k = rotationLookup[j];                    t_root = (float)Math.Sqrt(Rotation[i].Get(i) - Rotation[j].Get(j) - Rotation[k].Get(k) + 1.0f);                  t_return[i] = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.W = (Rotation[k].Get(j) - Rotation[j].Get(k)) * t_root;                  t_return[j] = (Rotation[j].Get(i) + Rotation[i].Get(j)) * t_root;                  t_return[k] = (Rotation[k].Get(i) + Rotation[i].Get(k)) * t_root;                  return t_return;              }
Magic Number,OpenGL,Quaternion,C:\repos\giawa_opengl4csharp\OpenGL\Math\Quaternion.cs,FromRotationMatrix,The following statement contains a magic number: if (t_trace > 0.0)              {   // |w| > 1/2                  Quaternion t_return = Quaternion.Zero;                  t_root = (float)Math.Sqrt(t_trace + 1.0);                  t_return.W = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.X = (Rotation[2].Y - Rotation[1].Z) * t_root;                  t_return.Y = (Rotation[0].Z - Rotation[2].X) * t_root;                  t_return.Z = (Rotation[1].X - Rotation[0].Y) * t_root;                  return t_return;              }              else              {   // |w| <= 1/2                  Quaternion t_return = Quaternion.Zero;                    int i = 0;                  if (Rotation[1].Y > Rotation[0].X) i = 1;                  if (Rotation[2].Z > Rotation[i].Get(i)) i = 2;                  int j = rotationLookup[i];                  int k = rotationLookup[j];                    t_root = (float)Math.Sqrt(Rotation[i].Get(i) - Rotation[j].Get(j) - Rotation[k].Get(k) + 1.0f);                  t_return[i] = 0.5f * t_root;                  t_root = 0.5f / t_root;                  t_return.W = (Rotation[k].Get(j) - Rotation[j].Get(k)) * t_root;                  t_return[j] = (Rotation[j].Get(i) + Rotation[i].Get(j)) * t_root;                  t_return[k] = (Rotation[k].Get(i) + Rotation[i].Get(k)) * t_root;                  return t_return;              }
Magic Number,OpenGL,Vector2,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector2.cs,Parse,The following statement contains a magic number: if (split.Length != 2) return Vector2.Zero;
Magic Number,OpenGL,Vector2,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector2.cs,Truncate,The following statement contains a magic number: float _x = (Math.Abs(X) - 0.0001 < 0) ? 0 : X;
Magic Number,OpenGL,Vector2,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector2.cs,Truncate,The following statement contains a magic number: float _y = (Math.Abs(Y) - 0.0001 < 0) ? 0 : Y;
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Vector3,The following statement contains a magic number: if (vector.Length != 3) throw new Exception(string.Format("float[] vector was of length {0}.  Was expecting a length of 3."' vector.Length));
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Vector3,The following statement contains a magic number: Z = vector[2];
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Parse,The following statement contains a magic number: if (split.Length != 3) return Vector3.Zero;
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Parse,The following statement contains a magic number: return new Vector3(float.Parse(split[0])' float.Parse(split[1])' float.Parse(split[2]));
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Truncate,The following statement contains a magic number: float _x = (Math.Abs(X) - 0.0001 < 0) ? 0 : X;
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Truncate,The following statement contains a magic number: float _y = (Math.Abs(Y) - 0.0001 < 0) ? 0 : Y;
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,Truncate,The following statement contains a magic number: float _z = (Math.Abs(Z) - 0.0001 < 0) ? 0 : Z;
Magic Number,OpenGL,Vector3,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector3.cs,GetRotationTo,The following statement contains a magic number: if (d >= 1.0f) return Quaternion.Identity;              else if (d < (1e-6f - 1.0f))              {                  Vector3 t_axis = Vector3.UnitX.Cross(this);                  if (t_axis.LengthSquared() < (1e-12)) // pick another if colinear                      t_axis = Vector3.UnitY.Cross(this);                  t_axis.Normalize();                  return Quaternion.FromAngleAxis((float)Math.PI' t_axis);              }              else              {                  float t_sqrt = (float)Math.Sqrt((1 + d) * 2.0f);                  float t_invs = 1.0f / t_sqrt;                    Vector3 t_cross = t_source.Cross(t_dest);                  return new Quaternion(t_cross.X * t_invs' t_cross.Y * t_invs' t_cross.Z * t_invs' t_sqrt * 0.5f).Normalize();              }
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: if (RGBByte.Length < 3) throw new Exception("Color data was not 24bit as expected.");
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: X = (float)(RGBByte[0] / 256.0);
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: Y = (float)(RGBByte[1] / 256.0);
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: Z = (float)(RGBByte[2] / 256.0);
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: Z = (float)(RGBByte[2] / 256.0);
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: if (vector.Length != 4) throw new Exception(string.Format("float[] vector was of length {0}.  Was expecting a length of 4."' vector.Length));
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: Z = vector[2];
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Vector4,The following statement contains a magic number: W = vector[3];
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Parse,The following statement contains a magic number: if (split.Length != 4) return Vector4.Zero;
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Parse,The following statement contains a magic number: return new Vector4(float.Parse(split[0])' float.Parse(split[1])' float.Parse(split[2])' float.Parse(split[3]));
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Parse,The following statement contains a magic number: return new Vector4(float.Parse(split[0])' float.Parse(split[1])' float.Parse(split[2])' float.Parse(split[3]));
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Get,The following statement contains a magic number: switch (index)              {                  case 0: return X;                  case 1: return Y;                  case 2: return Z;                  case 3: return W;                  default: return 0;  // error case              }
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Get,The following statement contains a magic number: switch (index)              {                  case 0: return X;                  case 1: return Y;                  case 2: return Z;                  case 3: return W;                  default: return 0;  // error case              }
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Truncate,The following statement contains a magic number: float _x = (Math.Abs(X) - 0.0001 < 0) ? 0 : X;
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Truncate,The following statement contains a magic number: float _y = (Math.Abs(Y) - 0.0001 < 0) ? 0 : Y;
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Truncate,The following statement contains a magic number: float _z = (Math.Abs(Z) - 0.0001 < 0) ? 0 : Z;
Magic Number,OpenGL,Vector4,C:\repos\giawa_opengl4csharp\OpenGL\Math\Vector4.cs,Truncate,The following statement contains a magic number: float _w = (Math.Abs(W) - 0.0001 < 0) ? 0 : W;
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,Texture,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,LoadDDS,The following statement contains a magic number: using (BinaryReader stream = new BinaryReader(new FileStream(ResourceFile' FileMode.Open)))              {                  string filecode = new string(stream.ReadChars(4));                  if (filecode != "DDS ")                                 // first 4 chars should be "DDS "                      throw new Exception("File was not a DDS file format.");                    DDS.DDSURFACEDESC2 imageData = DDS.DDSURFACEDESC2.FromBinaryReader(stream);//new DDS.DDSURFACEDESC2(stream);  // read the DirectDraw surface descriptor                  this.Size = new Size((int)imageData.Width' (int)imageData.Height);                    if (imageData.LinearSize == 0)                      throw new Exception("The linear scan line size was zero.");                    bool compressed = true;                  int factor = 0' buffersize = 0' blocksize = 0;                  PixelInternalFormat format;                  switch (imageData.PixelFormat.FourCC)       // check the compression type                  {                      case "DXT1":    // DXT1 compression ratio is 8:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          factor = 2;                          blocksize = 8;                          break;                      case "DXT3":    // DXT3 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          factor = 4;                          blocksize = 16;                          break;                      case "DXT5":    // DXT5 compression ratio is 4:1                          format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          factor = 4;                          blocksize = 16;                          break;                      default:                          compressed = false;                          if (imageData.PixelFormat.ABitMask == 0xf000 && imageData.PixelFormat.RBitMask == 0x0f00 &&                              imageData.PixelFormat.GBitMask == 0x00f0 && imageData.PixelFormat.BBitMask == 0x000f &&                              imageData.PixelFormat.RGBBitCount == 16) format = PixelInternalFormat.Rgba;                          else if (imageData.PixelFormat.ABitMask == unchecked((int) 0xff000000) && imageData.PixelFormat.RBitMask == 0x00ff0000 &&                              imageData.PixelFormat.GBitMask == 0x0000ff00 && imageData.PixelFormat.BBitMask == 0x000000ff &&                              imageData.PixelFormat.RGBBitCount == 32) format = PixelInternalFormat.Rgba;                          else throw new Exception(string.Format("File compression \"{0}\" is not supported."' imageData.PixelFormat.FourCC));                          break;                  }                    if (imageData.LinearSize != 0) buffersize = (int)((imageData.MipmapCount > 1) ? imageData.LinearSize * factor : imageData.LinearSize);                  else buffersize = (int)(stream.BaseStream.Length - stream.BaseStream.Position);                    // read the pixel data and then pin it to memory so that the garbage collector                  // doesn't shuffle the data around while OpenGL is decompressing it                  byte[] pixels = stream.ReadBytes(buffersize);                  GCHandle pinned = GCHandle.Alloc(pixels' GCHandleType.Pinned);                    try                  {                      TextureTarget = (imageData.Height == 1 || imageData.Width == 1) ? TextureTarget.Texture1D : TextureTarget.Texture2D;                      TextureID = Gl.GenTexture();                        Gl.BindTexture(TextureTarget' TextureID);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMinFilter' TextureParameter.Linear);                      Gl.TexParameteri(TextureTarget' TextureParameterName.TextureMagFilter' TextureParameter.Linear);                        int nOffset = 0' nWidth = (int)imageData.Width' nHeight = (int)imageData.Height;                        for (int i = 0; i < (imageData.MipmapCount == 0 ? 1 : imageData.MipmapCount); ++i)                      {                          if (nWidth == 0) nWidth = 1;        // smallest mipmap is 1x1 pixels                          if (nHeight == 0) nHeight = 1;                          int nSize = 0;                            if (compressed)                          {                              nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * blocksize;                              Gl.CompressedTexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' nSize' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                          else                          {                              PixelType pixelType = imageData.PixelFormat.RGBBitCount == 16 ? PixelType.UnsignedShort4444Reversed : PixelType.UnsignedInt8888Reversed;                                nSize = nWidth * nHeight * imageData.PixelFormat.RGBBitCount / 8;                              Gl.TexImage2D(TextureTarget' i' format' nWidth' nHeight' 0' PixelFormat.Bgra' pixelType' (IntPtr)(pinned.AddrOfPinnedObject().ToInt64() + nOffset));                          }                            nOffset += nSize;                          nWidth /= 2;                          nHeight /= 2;                      }    #if MEMORY_LOGGER                      MemoryLogger.AllocateTexture(TextureID' Size);  #endif                  }                  catch (Exception)                  {   // There was some sort of Dll related error' or the target GPU does not support glCompressedTexImage2DARB                      throw;                  }                  finally                  {                      pinned.Free();                  }              }
Magic Number,OpenGL,DDSURFACEDESC2,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\Texture.cs,FromBinaryReader,The following statement contains a magic number: byte[] data = stream.ReadBytes(124);
Missing Default,OpenGL,GenericVAO,C:\repos\giawa_opengl4csharp\OpenGL\Constructs\VAO.cs,SizeOfType,The following switch statement is missing a default case: switch (type)              {                  case VertexAttribPointerType.Byte:                   case VertexAttribPointerType.UnsignedByte: return 1;                  case VertexAttribPointerType.Short:                  case VertexAttribPointerType.UnsignedShort:                   case VertexAttribPointerType.HalfFloat: return 2;                  case VertexAttribPointerType.Int:                  case VertexAttribPointerType.Float: return 4;                  case VertexAttribPointerType.Double: return 8;              }
Missing Default,OpenGL,Ray,C:\repos\giawa_opengl4csharp\OpenGL\Math\Ray.cs,Intersects,The following switch statement is missing a default case: switch (classification)              {                  case RayType.MMM:                      if ((origin.X < b.Min.X) || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.MMP:                      if ((origin.X < b.Min.X) || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.MPM:                      if ((origin.X < b.Min.X) || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.MPP:                      if ((origin.X < b.Min.X) || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.PMM:                      if ((origin.X > b.Max.X) || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.PMP:                      if ((origin.X > b.Max.X) || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.PPM:                      if ((origin.X > b.Max.X) || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.PPP:                      if ((origin.X > b.Max.X) || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.OMM:                      if ((origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Z < b.Min.Z)                          || (jbyk * b.Min.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Max.Z + c_yz > 0))                          return false;                      return true;                  case RayType.OMP:                      if ((origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Z > b.Max.Z)                          || (jbyk * b.Max.Z - b.Max.Y + c_zy > 0)                          || (kbyj * b.Min.Y - b.Min.Z + c_yz < 0))                          return false;                      return true;                  case RayType.OPM:                      if ((origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y > b.Max.Y) || (origin.Z < b.Min.Z)                          || (jbyk * b.Min.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Max.Z + c_yz > 0))                          return false;                      return true;                  case RayType.OPP:                      if ((origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y > b.Max.Y) || (origin.Z > b.Max.Z)                          || (jbyk * b.Max.Z - b.Min.Y + c_zy < 0)                          || (kbyj * b.Max.Y - b.Min.Z + c_yz < 0))                          return false;                      return true;                  case RayType.MOM:                      if ((origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.Z < b.Min.Z)                          || (kbyi * b.Min.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.MOP:                      if ((origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.Z > b.Max.Z)                          || (kbyi * b.Min.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Max.X + c_zx > 0))                          return false;                      return true;                  case RayType.POM:                      if ((origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X > b.Max.X) || (origin.Z < b.Min.Z)                          || (kbyi * b.Max.X - b.Max.Z + c_xz > 0)                          || (ibyk * b.Min.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.POP:                      if ((origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.X > b.Max.X) || (origin.Z > b.Max.Z)                          || (kbyi * b.Max.X - b.Min.Z + c_xz < 0)                          || (ibyk * b.Max.Z - b.Min.X + c_zx < 0))                          return false;                      return true;                  case RayType.MMO:                      if ((origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.Y < b.Min.Y)                          || (jbyi * b.Min.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Max.X + c_yx > 0))                          return false;                      return true;                  case RayType.MPO:                      if ((origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.Y > b.Max.Y)                          || (jbyi * b.Min.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Max.X + c_yx > 0))                          return false;                      return true;                  case RayType.PMO:                      if ((origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X > b.Max.X) || (origin.Y < b.Min.Y)                          || (jbyi * b.Max.X - b.Max.Y + c_xy > 0)                          || (ibyj * b.Min.Y - b.Min.X + c_yx < 0))                          return false;                      return true;                  case RayType.PPO:                      if ((origin.Z < b.Min.Z) || (origin.Z > b.Max.Z)                          || (origin.X > b.Max.X) || (origin.Y > b.Max.Y)                          || (jbyi * b.Max.X - b.Min.Y + c_xy < 0)                          || (ibyj * b.Max.Y - b.Min.X + c_yx < 0))                          return false;                      return true;                  case RayType.MOO:                      if ((origin.X < b.Min.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z))                          return false;                      return true;                  case RayType.POO:                      if ((origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z))                          return false;                      return true;                  case RayType.OMO:                      if ((origin.Y < b.Min.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z))                          return false;                      if ((origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z))                          return false;                      if ((origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      if ((origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      return true;                  case RayType.OPO:                      if ((origin.Y > b.Max.Y)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Z < b.Min.Z) || (origin.Z > b.Max.Z))                          return false;                      if ((origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      if ((origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      return true;                  case RayType.OOM:                      if ((origin.Z < b.Min.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      if ((origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      return true;                  case RayType.OOP:                      if ((origin.Z > b.Max.Z)                          || (origin.X < b.Min.X) || (origin.X > b.Max.X)                          || (origin.Y < b.Min.Y) || (origin.Y > b.Max.Y))                          return false;                      return true;              }
