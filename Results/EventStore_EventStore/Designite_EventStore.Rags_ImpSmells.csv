Implementation smell,Namespace,Class,File,Method,Description
Long Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,The method has 121 lines of code.
Long Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The method has 132 lines of code.
Long Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The method has 103 lines of code.
Long Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The method has 133 lines of code.
Complex Method,EventStore.Rags,ArgUsage,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ArgUsage.cs,GetOptionsUsage,Cyclomatic complexity of the method is 9
Complex Method,EventStore.Rags,ArgUsage,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ArgUsage.cs,FormatAsTable,Cyclomatic complexity of the method is 11
Complex Method,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,Cyclomatic complexity of the method is 10
Complex Method,EventStore.Rags,Yaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Yaml.cs,FromFile,Cyclomatic complexity of the method is 10
Complex Method,EventStore.Rags.YamlDotNet.Dynamic,DynamicYaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet.Dynamic\DynamicYaml.cs,TryConvertToBasicType,Cyclomatic complexity of the method is 14
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,Cyclomatic complexity of the method is 23
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,Cyclomatic complexity of the method is 31
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,StateMachine,Cyclomatic complexity of the method is 55
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitDocumentStart,Cyclomatic complexity of the method is 14
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitNode,Cyclomatic complexity of the method is 14
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,SelectScalarStyle,Cyclomatic complexity of the method is 13
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,ProcessScalar,Cyclomatic complexity of the method is 17
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WritePlainScalar,Cyclomatic complexity of the method is 9
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteSingleQuotedScalar,Cyclomatic complexity of the method is 8
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteDoubleQuotedScalar,Cyclomatic complexity of the method is 55
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteFoldedScalar,Cyclomatic complexity of the method is 8
Complex Method,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckSimpleKey,Cyclomatic complexity of the method is 20
Complex Method,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,StateMachine,Cyclomatic complexity of the method is 26
Complex Method,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ProcessDirectives,Cyclomatic complexity of the method is 9
Complex Method,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseNode,Cyclomatic complexity of the method is 19
Complex Method,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseFlowMappingKey,Cyclomatic complexity of the method is 8
Complex Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,Cyclomatic complexity of the method is 22
Complex Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanDirective,Cyclomatic complexity of the method is 13
Complex Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,Cyclomatic complexity of the method is 19
Complex Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,Cyclomatic complexity of the method is 35
Complex Method,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,Cyclomatic complexity of the method is 19
Complex Method,EventStore.Rags.YamlDotNet.RepresentationModel,YamlMappingNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlMappingNode.cs,ResolveAliases,Cyclomatic complexity of the method is 10
Complex Method,EventStore.Rags.YamlDotNet.Serialization,Deserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Deserializer.cs,Deserialize,Cyclomatic complexity of the method is 8
Complex Method,EventStore.Rags.YamlDotNet.Serialization.EventEmitters,JsonEventEmitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\EventEmitters\JsonEventEmitter.cs,Emit,Cyclomatic complexity of the method is 31
Complex Method,EventStore.Rags.YamlDotNet.Serialization.EventEmitters,TypeAssigningEventEmitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\EventEmitters\TypeAssigningEventEmitter.cs,Emit,Cyclomatic complexity of the method is 39
Complex Method,EventStore.Rags.YamlDotNet.Serialization.NodeDeserializers,ScalarNodeDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\NodeDeserializers\ScalarNodeDeserializer.cs,Deserialize,Cyclomatic complexity of the method is 51
Complex Method,EventStore.Rags.YamlDotNet.Serialization.ObjectGraphTraversalStrategies,FullObjectGraphTraversalStrategy,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\FullObjectGraphTraversalStrategy.cs,Traverse,Cyclomatic complexity of the method is 31
Complex Method,EventStore.Rags.YamlDotNet.Serialization.Utilities,TypeConverter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\TypeConverter.cs,ChangeType,Cyclomatic complexity of the method is 19
Complex Method,EventStore.Rags.YamlDotNet.Serialization.Utilities,TypeConverter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\TypeConverter.cs,TryParse,Cyclomatic complexity of the method is 15
Long Parameter List,EventStore.Rags.YamlDotNet.Core.Events,DocumentStart,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\DocumentStart.cs,DocumentStart,The method has 5 parameters.
Long Parameter List,EventStore.Rags.YamlDotNet.Core.Events,MappingStart,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\MappingStart.cs,MappingStart,The method has 6 parameters.
Long Parameter List,EventStore.Rags.YamlDotNet.Core.Events,Scalar,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\Scalar.cs,Scalar,The method has 8 parameters.
Long Parameter List,EventStore.Rags.YamlDotNet.Core.Events,Scalar,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\Scalar.cs,Scalar,The method has 6 parameters.
Long Parameter List,EventStore.Rags.YamlDotNet.Core.Events,SequenceStart,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\SequenceStart.cs,SequenceStart,The method has 6 parameters.
Long Statement,EventStore.Rags,ArgUsage,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ArgUsage.cs,GetStyledUsage,The length of the statement  "			throw new InvalidOperationException ("EventStore.Rags could not determine the name of your executable automatically.  This may happen if you run GetUsage<T>() from within unit tests.  Use GetUsageT>(string exeName) in unit tests to avoid this exception."); " is 256.
Long Statement,EventStore.Rags,ArgUsage,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ArgUsage.cs,GetOptionsUsage,The length of the statement  "			var proposedInlineAliases = inlineAliasInfo == string.Empty ? aliases [aliasIndex] : inlineAliasInfo + "' " + aliases [aliasIndex]; " is 131.
Long Statement,EventStore.Rags,ConsoleCharacter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ConsoleString.cs,Equals,The length of the statement  "	return this.Value == other.Value && this.ForegroundColor == other.ForegroundColor && this.BackgroundColor == other.BackgroundColor; " is 131.
Long Statement,EventStore.Rags,TypeMap,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\TypeMap.cs,CanMap,The length of the statement  "	if (Translators.ContainsKey (t) || t.IsEnum || (t.GetInterfaces ().Contains (typeof(IList)) && t.IsGenericType && CanMap (t.GetGenericArguments () [0])) || (t.IsArray && CanMap (t.GetElementType ()))) " is 200.
Long Statement,EventStore.Rags,TypeMap,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\TypeMap.cs,CanMap,The length of the statement  "	return System.ComponentModel.TypeDescriptor.GetConverter (t).CanConvertFrom (typeof(string)) || Translators.ContainsKey (t); " is 124.
Long Statement,EventStore.Rags,TypeMap,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\TypeMap.cs,Translate,The length of the statement  "	throw new ArgumentException ("Cannot revive type " + t.FullName + ". Callers should be calling CanRevive before calling Revive()"); " is 131.
Long Statement,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,IsBool,The length of the statement  "	var possibleBooleanProperty = typeof(T).GetProperties ().FirstOrDefault (x => x.Name.Equals (propertyName' StringComparison.OrdinalIgnoreCase)); " is 144.
Long Statement,EventStore.Rags,MemberInfoEx,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Extensions.cs,Attrs,The length of the statement  "	string cacheKey = (info is Type ? ((Type)info).FullName : info.DeclaringType.FullName + "." + info.Name) + "<" + typeof(T).FullName + ">"; " is 138.
Long Statement,EventStore.Rags,MemberInfoEx,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Extensions.cs,Attrs,The length of the statement  "	where attr.GetType () == typeof(T) || attr.GetType ().IsSubclassOf (typeof(T)) || attr.GetType ().GetInterfaces ().Contains (typeof(T)) " is 135.
Long Statement,EventStore.Rags,FieldInfoExtensions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Extensions.cs,GetEnumShortcuts,The length of the statement  "		throw new InvalidArgDefinitionException ("You can't have an ArgShortcut attribute with a null shortcut and then define a second ArgShortcut attribute with a non-null value."); " is 175.
Long Statement,EventStore.Rags,IEnumerableExtensions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Extensions.cs,Normalize,The length of the statement  "	}.Contains (x.Value.ToString ()) ? true : x.IsTyped' x.Value.ToString () == "+" ? true : x.Value.ToString () == "-" ? false : x.Value.ToString () == "" ? true : x.Value)); " is 171.
Long Statement,EventStore.Rags,IEnumerableExtensions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Extensions.cs,UseAliases,The length of the statement  "				optionSources = optionSources.Select (x => x.Name.Equals (alias' StringComparison.OrdinalIgnoreCase) ? new OptionSource (x.Source' property.Name' x.IsTyped' x.Value) : new OptionSource (x.Source' x.Name' x.IsTyped' x.Value)); " is 225.
Long Statement,EventStore.Rags,NameTranslators,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\NameTranslators.cs,CombineByPascalCase,The length of the statement  "	var regex = new System.Text.RegularExpressions.Regex (@"(?<=[A-Z])(?=[A-Z][a-z])|(?<=[^A-Z])(?=[A-Z])|(?<=[A-Za-z])(?=[^A-Za-z])"); " is 131.
Long Statement,EventStore.Rags,TypeDefaultOptions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\TypeDefaultOptions.cs,Get,The length of the statement  "	return typeof(TOptions).GetProperties ().Select (property => OptionSource.Typed ("<DEFAULT>"' property.Name' property.GetValue (defaultOptions' null))); " is 152.
Long Statement,EventStore.Rags,Yaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Yaml.cs,FromFile,The length of the statement  "		throw new OptionException (String.Format ("An invalid configuration file has been specified. {0}{1}"' Environment.NewLine' ex.Message)' "config"); " is 146.
Long Statement,EventStore.Rags,Yaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Yaml.cs,FromFile,The length of the statement  "		Func<KeyValuePair<YamlNode' YamlNode>' bool> predicate = x => x.Key.ToString () == sectionName && x.Value.GetType () == typeof(YamlMappingNode); " is 144.
Long Statement,EventStore.Rags,Yaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\Yaml.cs,FromFile,The length of the statement  "			options.Add (OptionSource.Typed ("Config File"' yamlElement.Key.ToString ()' yamlMappingNode.ToDictionary (x => x.Key.ToString ()' x => x.Value.ToString ()))); " is 159.
Long Statement,EventStore.Rags.YamlDotNet.Dynamic,DynamicYaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet.Dynamic\DynamicYaml.cs,TryGetValueByKeyAndType,The length of the statement  "	return IsNullableType (type) ? SuccessfullyGetValue (new DynamicYaml ((YamlNode)null)' out result) : FailToGetValue (out result); " is 129.
Long Statement,EventStore.Rags.YamlDotNet.Dynamic,DynamicYaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet.Dynamic\DynamicYaml.cs,IsGenericEnumCollection,The length of the statement  "	return elementType.IsEnum && ConvertableGenericCollectionTypes.Any (genericType => genericType.MakeGenericType (elementType) == type); " is 134.
Long Statement,EventStore.Rags.YamlDotNet.Dynamic,DynamicYaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet.Dynamic\DynamicYaml.cs,IsGenericEnumDictionary,The length of the statement  "	return (keyType.IsEnum || valueType.IsEnum) && ConvertableGenericDictionaryTypes.Any (genericType => genericType.MakeGenericType (keyType' valueType) == type) && IsLegalElementType (keyType) && IsLegalElementType (valueType); " is 225.
Long Statement,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,IsAlphaNumericDashOrUnderscore,The length of the statement  "	return (character >= '0' && character <= '9') || (character >= 'A' && character <= 'Z') || (character >= 'a' && character <= 'z') || character == '_' || character == '-'; " is 170.
Long Statement,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,IsPrintable,The length of the statement  "	return character == '\x9' || character == '\xA' || character == '\xD' || (character >= '\x20' && character <= '\x7E') || character == '\x85' || (character >= '\xA0' && character <= '\xD7FF') || (character >= '\xE000' && character <= '\xFFFD'); " is 243.
Long Statement,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,IsHex,The length of the statement  "	return (character >= '0' && character <= '9') || (character >= 'A' && character <= 'F') || (character >= 'a' && character <= 'f'); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,IsUnicode,The length of the statement  "	return encoding.Equals (Encoding.UTF8) || encoding.Equals (Encoding.Unicode) || encoding.Equals (Encoding.BigEndianUnicode) || encoding.Equals (Encoding.UTF7) || encoding.Equals (Encoding.UTF32); " is 195.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitDocumentStart,The length of the statement  "			WriteIndicator (string.Format (CultureInfo.InvariantCulture' "{0}.{1}"' Constants.MajorVersion' Constants.MinorVersion)' true' false' false); " is 141.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,AnalyzeVersionDirective,The length of the statement  "	if (versionDirective.Version.Major != Constants.MajorVersion || versionDirective.Version.Minor != Constants.MinorVersion) { " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitNode,The length of the statement  "		throw new YamlException (string.Format ("Expected SCALAR' SEQUENCE-START' MAPPING-START' or ALIAS' got {0}"' evt.Type)); " is 120.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteSingleQuotedScalar,The length of the statement  "			if (allowBreaks && !previousSpace && column > bestWidth && index != 0 && index + 1 < value.Length && value [index + 1] != ' ') { " is 128.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,IsPrintable,The length of the statement  "	return character == '\x9' || character == '\xA' || character == '\xD' || (character >= '\x20' && character <= '\x7E') || character == '\x85' || (character >= '\xA0' && character <= '\xD7FF') || (character >= '\xE000' && character <= '\xFFFD'); " is 243.
Long Statement,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckSimpleKey,The length of the statement  "		length = SafeStringLength (anchorData.anchor) + SafeStringLength (tagData.handle) + SafeStringLength (tagData.suffix) + SafeStringLength (scalarData.value); " is 156.
Long Statement,EventStore.Rags.YamlDotNet.Core,EventReader,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\EventReader.cs,Expect,The length of the statement  "		throw new YamlException (@event.Start' @event.End' string.Format (CultureInfo.InvariantCulture' "Expected '{0}'' got '{1}' (at {2})."' typeof(T).Name' @event.GetType ().Name' @event.Start)); " is 190.
Long Statement,EventStore.Rags.YamlDotNet.Core,LookAheadBuffer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\LookAheadBuffer.cs,Skip,The length of the statement  "		throw new ArgumentOutOfRangeException ("length"' "The length must be between 1 and the number of characters in the buffer. Use the Peek() and / or Cache() methods to fill the buffer."); " is 185.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseDocumentStart,The length of the statement  "	if (isImplicit && !(GetCurrentToken () is VersionDirective || GetCurrentToken () is TagDirective || GetCurrentToken () is DocumentStart || GetCurrentToken () is StreamEnd)) { " is 174.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseDocumentContent,The length of the statement  "	if (GetCurrentToken () is VersionDirective || GetCurrentToken () is TagDirective || GetCurrentToken () is DocumentStart || GetCurrentToken () is DocumentEnd || GetCurrentToken () is StreamEnd) { " is 194.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "			ParsingEvent evt = new Events.Scalar (anchorName' tagName' scalar.Value' scalar.Style' isPlainImplicit' isQuotedImplicit' start' scalar.End); " is 141.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "			return new Events.Scalar (anchorName' tagName' string.Empty' ScalarStyle.Plain' isImplicit' false' start' GetCurrentToken ().End); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "		throw new SemanticErrorException (current.Start' current.End' "While parsing a node' did not find expected node content."); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseBlockSequenceEntry,The length of the statement  "		throw new SemanticErrorException (current.Start' current.End' "While parsing a block collection' did not find expected '-' indicator."); " is 136.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseIndentlessSequenceEntry,The length of the statement  "		if (!(GetCurrentToken () is BlockEntry || GetCurrentToken () is Key || GetCurrentToken () is Value || GetCurrentToken () is BlockEnd)) { " is 136.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseBlockMappingKey,The length of the statement  "		throw new SemanticErrorException (current.Start' current.End' "While parsing a block mapping' did not find expected key."); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseFlowSequenceEntry,The length of the statement  "				throw new SemanticErrorException (current.Start' current.End' "While parsing a flow sequence' did not find expected ''' or ']'."); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseFlowMappingKey,The length of the statement  "				throw new SemanticErrorException (current.Start' current.End' "While parsing a flow mapping'  did not find expected ''' or '}'."); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The length of the statement  "	bool isDocumentStart = cursor.LineOffset == 0 && analyzer.Check ('-'' 0) && analyzer.Check ('-'' 1) && analyzer.Check ('-'' 2) && analyzer.IsWhiteBreakOrZero (3); " is 162.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The length of the statement  "	bool isDocumentEnd = cursor.LineOffset == 0 && analyzer.Check ('.'' 0) && analyzer.Check ('.'' 1) && analyzer.Check ('.'' 2) && analyzer.IsWhiteBreakOrZero (3); " is 160.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The length of the statement  "	bool isPlainScalar = !isInvalidPlainScalarCharacter || (analyzer.Check ('-') && !analyzer.IsWhite (1)) || (flowLevel == 0 && (analyzer.Check ("?:")) && !analyzer.IsWhiteBreakOrZero (1)); " is 186.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The length of the statement  "	throw new SyntaxErrorException (mark' mark' "While scanning for the next token' find character that cannot start any token."); " is 126.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanDirective,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a directive' did not find expected comment or line break."); " is 131.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanAnchor,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning an anchor or alias' did not find expected alphabetic or numeric character."); " is 148.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanTag,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a tag' did not find expected whitespace or line break."); " is 128.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "				throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a block scalar' find an intendation indicator equal to 0."); " is 131.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "			throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a block scalar' find an intendation indicator equal to 0."); " is 131.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a block scalar' did not find expected comment or line break."); " is 134.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalarBreaks,The length of the statement  "			throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a block scalar' find a tab character where an intendation space is expected."); " is 150.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "			throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected document indicator."); " is 126.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "			throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected end of stream."); " is 121.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character."); " is 120.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "							throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number."); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code."); " is 133.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,The length of the statement  "					throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a plain scalar' find a tab character that violate intendation."); " is 136.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanDirectiveName,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a directive' could not find expected directive name."); " is 126.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanDirectiveName,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a directive' find unexpected non-alphabetical character."); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveValue,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %YAML directive' did not find expected digit or '.' character."); " is 138.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanTagDirectiveValue,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %TAG directive' did not find expected whitespace."); " is 125.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanTagDirectiveValue,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %TAG directive' did not find expected whitespace or line break."); " is 139.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The length of the statement  "			width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0; " is 126.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The length of the statement  "			throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %YAML directive' find extremely long version number."); " is 128.
Long Statement,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The length of the statement  "		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %YAML directive' did not find expected version number."); " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Core.Events,MappingStart,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\MappingStart.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "Mapping start [anchor = {0}' tag = {1}' isImplicit = {2}' style = {3}]"' Anchor' Tag' isImplicit' style); " is 158.
Long Statement,EventStore.Rags.YamlDotNet.Core.Events,Scalar,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\Scalar.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "Scalar [anchor = {0}' tag = {1}' value = {2}' style = {3}' isPlainImplicit = {4}' isQuotedImplicit = {5}]"' Anchor' Tag' value' style' isPlainImplicit' isQuotedImplicit); " is 223.
Long Statement,EventStore.Rags.YamlDotNet.Core.Events,SequenceStart,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Events\SequenceStart.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "Sequence start [anchor = {0}' tag = {1}' isImplicit = {2}' style = {3}]"' Anchor' Tag' isImplicit' style); " is 159.
Long Statement,EventStore.Rags.YamlDotNet.RepresentationModel,DocumentLoadingState,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\DocumentLoadingState.cs,AddAnchor,The length of the statement  "		throw new DuplicateAnchorException (node.Start' node.End' string.Format (CultureInfo.InvariantCulture' "The anchor '{0}' already exists"' node.Anchor)); " is 152.
Long Statement,EventStore.Rags.YamlDotNet.RepresentationModel,DocumentLoadingState,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\DocumentLoadingState.cs,GetNode,The length of the statement  "		throw new AnchorNotFoundException (start' end' string.Format (CultureInfo.InvariantCulture' "The anchor '{0}' does not exists"' anchor)); " is 137.
Long Statement,EventStore.Rags.YamlDotNet.RepresentationModel,YamlNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlNode.cs,Equals,The length of the statement  "	// Do not use the anchor in the equality comparison because that would prevent anchored nodes from being found in dictionaries. " is 127.
Long Statement,EventStore.Rags.YamlDotNet.Serialization,Serializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Serializer.cs,Serialize,The length of the statement  "	EmitDocument (emitter' new ObjectDescriptor (graph' graph != null ? graph.GetType () : typeof(object)' typeof(object))); " is 120.
Long Statement,EventStore.Rags.YamlDotNet.Serialization,YamlAttributesTypeInspector,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\YamlAttributesTypeInspector.cs,GetProperties,The length of the statement  "	return innerTypeDescriptor.GetProperties (type' container).Where (p => p.GetCustomAttribute<YamlIgnoreAttribute> () == null).Select (p => { " is 139.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.EventEmitters,JsonEventEmitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\EventEmitters\JsonEventEmitter.cs,Emit,The length of the statement  "		throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.EventEmitters,TypeAssigningEventEmitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\EventEmitters\TypeAssigningEventEmitter.cs,Emit,The length of the statement  "		throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.EventEmitters,WriterEventEmitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\EventEmitters\WriterEventEmitter.cs,Emit,The length of the statement  "	emitter.Emit (new Scalar (eventInfo.Anchor' eventInfo.Tag' eventInfo.RenderedValue' eventInfo.Style' eventInfo.IsPlainImplicit' eventInfo.IsQuotedImplicit)); " is 157.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.NodeDeserializers,GenericCollectionNodeDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\NodeDeserializers\GenericCollectionNodeDeserializer.cs,DeserializeHelper,The length of the statement  "			throw new ForwardAnchorNotSupportedException (current.Start' current.End' "Forward alias references are not allowed because this type does not implement IList<>"); " is 163.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.NodeDeserializers,GenericDictionaryNodeDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\NodeDeserializers\GenericDictionaryNodeDeserializer.cs,Deserialize,The length of the statement  "	deserializeHelperMethod.Invoke (iDictionary.GetGenericArguments ()' reader' expectedType' nestedObjectDeserializer' value); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ObjectGraphTraversalStrategies,FullObjectGraphTraversalStrategy,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\FullObjectGraphTraversalStrategy.cs,Traverse,The length of the statement  "		throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 123.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ObjectGraphTraversalStrategies,RoundtripObjectGraphTraversalStrategy,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\RoundtripObjectGraphTraversalStrategy.cs,TraverseProperties,The length of the statement  "	if (!ReflectionUtility.HasDefaultConstructor (value.Type) && !serializer.Converters.Any (c => c.Accepts (value.Type))) { " is 120.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ObjectGraphTraversalStrategies,RoundtripObjectGraphTraversalStrategy,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\RoundtripObjectGraphTraversalStrategy.cs,TraverseProperties,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "Type '{0}' cannot be deserialized because it does not have a default constructor or a type converter."' value.Type)); " is 200.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.TypeInspectors,NamingConventionTypeInspector,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\TypeInspectors\NamingConventionTypeInspector.cs,GetProperties,The length of the statement  "	return innerTypeDescriptor.GetProperties (type' container).Select (p => (IPropertyDescriptor)new PropertyDescriptor (p) { " is 121.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.TypeInspectors,ReadablePropertiesTypeInspector,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\TypeInspectors\ReadablePropertiesTypeInspector.cs,GetProperties,The length of the statement  "	return type.GetProperties (BindingFlags.Instance | BindingFlags.Public).Where (IsValidProperty).Select (p => (IPropertyDescriptor)new ReflectionPropertyDescriptor (p' _typeResolver)); " is 183.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.TypeInspectors,TypeInspectorSkeleton,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\TypeInspectors\TypeInspectorSkeleton.cs,GetProperty,The length of the statement  "			throw new SerializationException (string.Format (CultureInfo.InvariantCulture' "Property '{0}' not found on type '{1}'."' name' type.FullName)); " is 144.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.TypeInspectors,TypeInspectorSkeleton,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\TypeInspectors\TypeInspectorSkeleton.cs,GetProperty,The length of the statement  "			throw new SerializationException (string.Format (CultureInfo.InvariantCulture' "Multiple properties with the name/alias '{0}' already exists on type '{1}'' maybe you're misusing YamlAlias or maybe you are using the wrong naming convention? The matching properties are: {2}"' name' type.FullName' string.Join ("' "' candidates.Select (p => p.Name).ToArray ()))); " is 361.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.Utilities,ReflectionUtility,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\ReflectionUtility.cs,HasDefaultConstructor,The length of the statement  "	return type.IsValueType || type.GetConstructor (BindingFlags.Public | BindingFlags.Instance' null' Type.EmptyTypes' null) != null; " is 130.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.Utilities,StringExtensions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\StringExtensions.cs,ToCamelOrPascalCase,The length of the statement  "	var text = Regex.Replace (str' "([_\\-])(?<char>[a-z])"' match => match.Groups ["char"].Value.ToUpperInvariant ()' RegexOptions.IgnoreCase); " is 140.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.Utilities,StringExtensions,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\StringExtensions.cs,FromCamelCase,The length of the statement  "	str = Regex.Replace (str.ToCamelCase ()' "(?<char>[A-Z])"' match => separator + match.Groups ["char"].Value.ToLowerInvariant ()); " is 129.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.Utilities,TypeConverter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\TypeConverter.cs,RegisterTypeConverter,The length of the statement  "	var alreadyRegistered = TypeDescriptor.GetAttributes (typeof(TConvertible)).OfType<TypeConverterAttribute> ().Any (a => a.ConverterTypeName == typeof(TConverter).AssemblyQualifiedName); " is 185.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.Utilities,TypeConverter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Utilities\TypeConverter.cs,ChangeType,The length of the statement  "			var isCastingOperator = method.IsSpecialName && (method.Name == "op_Implicit" || method.Name == "op_Explicit") && destinationType.IsAssignableFrom (method.ReturnParameter.ParameterType); " is 186.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ValueDeserializers,AliasValueDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ValueDeserializers\AliasValueDeserializer.cs,DeserializeValue,The length of the statement  "			throw new DuplicateAnchorException (nodeEvent.Start' nodeEvent.End' string.Format ("Anchor '{0}' already defined"' anchor)); " is 124.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ValueDeserializers,NodeValueDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ValueDeserializers\NodeValueDeserializer.cs,DeserializeValue,The length of the statement  "		if (deserializer.Deserialize (reader' nodeType' (r' t) => nestedObjectDeserializer.DeserializeValue (r' t' state' nestedObjectDeserializer)' out value)) { " is 154.
Long Statement,EventStore.Rags.YamlDotNet.Serialization.ValueDeserializers,NodeValueDeserializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\ValueDeserializers\NodeValueDeserializer.cs,DeserializeValue,The length of the statement  "	throw new SerializationException (string.Format ("No node deserializer was able to deserialize the node at {0} into type {1}"' reader.Parser.Current.Start' expectedType.AssemblyQualifiedName)); " is 193.
Complex Conditional,EventStore.Rags,TypeMap,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\TypeMap.cs,CanMap,The conditional expression  "Translators.ContainsKey (t) || t.IsEnum || (t.GetInterfaces ().Contains (typeof(IList)) && t.IsGenericType && CanMap (t.GetGenericArguments () [0])) || (t.IsArray && CanMap (t.GetElementType ()))"  is complex.
Complex Conditional,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The conditional expression  "key.StartsWith ("-") && key.EndsWith ("-") || key.StartsWith ("-") && key.EndsWith ("+")"  is complex.
Complex Conditional,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The conditional expression  "next == "true" || next == "false" || next == "0" || next == "1""  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,The conditional expression  "leadingSpace || leadingBreak || trailingSpace || trailingBreak"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitDocumentStart,The conditional expression  "!isFirst && !isDocumentEndWritten && (documentStart.Version != null || documentTagDirectives.Count > 0)"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,SelectScalarStyle,The conditional expression  "(flowLevel != 0 && !scalarData.isFlowPlainAllowed) || (flowLevel == 0 && !scalarData.isBlockPlainAllowed)"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WritePlainScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index + 1 < value.Length && value [index + 1] != ' '"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteSingleQuotedScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index != 0 && index + 1 < value.Length && value [index + 1] != ' '"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteDoubleQuotedScalar,The conditional expression  "!IsPrintable (character) || IsBreak (character) || character == '"' || character == '\\'"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteDoubleQuotedScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index > 0 && index + 1 < value.Length"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteFoldedScalar,The conditional expression  "!previousBreak && character == ' ' && i + 1 < value.Length && value [i + 1] != ' ' && column > bestWidth"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitSequenceStart,The conditional expression  "flowLevel != 0 || isCanonical || sequenceStart.Style == SequenceStyle.Flow || CheckEmptySequence ()"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,EmitMappingStart,The conditional expression  "flowLevel != 0 || isCanonical || mappingStart.Style == MappingStyle.Flow || CheckEmptyMapping ()"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteIndent,The conditional expression  "!isIndentation || column > currentIndent || (column == currentIndent && !isWhitespace)"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseDocumentStart,The conditional expression  "isImplicit && !(GetCurrentToken () is VersionDirective || GetCurrentToken () is TagDirective || GetCurrentToken () is DocumentStart || GetCurrentToken () is StreamEnd)"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseDocumentContent,The conditional expression  "GetCurrentToken () is VersionDirective || GetCurrentToken () is TagDirective || GetCurrentToken () is DocumentStart || GetCurrentToken () is DocumentEnd || GetCurrentToken () is StreamEnd"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Parser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Parser.cs,ParseIndentlessSequenceEntry,The conditional expression  "!(GetCurrentToken () is BlockEntry || GetCurrentToken () is Key || GetCurrentToken () is Value || GetCurrentToken () is BlockEnd)"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The conditional expression  "!isLiteral && StartsWith (leadingBreak' '\n') && !leadingBlank && !trailingBlank"  is complex.
Complex Conditional,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,The conditional expression  "(analyzer.Check (':') && analyzer.IsWhiteBreakOrZero (1)) || (flowLevel > 0 && analyzer.Check ("':?[]{}"))"  is complex.
Magic Number,EventStore.Rags,ArgUsage,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\ArgUsage.cs,GetOptionsUsage,The following statement contains a magic number: foreach (ArgumentUsageInfo usageInfo in usageInfos.OrderBy (x => x.Group)) {  	if (currentGroup != usageInfo.Group && !String.IsNullOrEmpty (usageInfo.Group)) {  		currentGroup = usageInfo.Group;  		rows.Add (new List<ConsoleString> () {  			ConsoleString.Empty'  			ConsoleString.Empty'  			ConsoleString.Empty  		});  		rows.Add (new List<ConsoleString> () {  			new ConsoleString (currentGroup)'  			ConsoleString.Empty'  			ConsoleString.Empty  		});  	}  	var descriptionString = new ConsoleString (usageInfo.Description);  	var aliases = usageInfo.Aliases.OrderBy (a => a.Length).ToList ();  	var maxInlineAliasLength = 8;  	string inlineAliasInfo = "";  	int aliasIndex;  	for (aliasIndex = 0; aliasIndex < aliases.Count; aliasIndex++) {  		var proposedInlineAliases = inlineAliasInfo == string.Empty ? aliases [aliasIndex] : inlineAliasInfo + "' " + aliases [aliasIndex];  		if (proposedInlineAliases.Length <= maxInlineAliasLength) {  			inlineAliasInfo = proposedInlineAliases;  		} else {  			break;  		}  	}  	if (inlineAliasInfo != string.Empty)  		inlineAliasInfo = " (" + inlineAliasInfo + ")";  	rows.Add (new List<ConsoleString> () {  		new ConsoleString ("") + ("-" + usageInfo.Name + inlineAliasInfo)'  		descriptionString'  	});  	for (int i = aliasIndex; i < aliases.Count; i++) {  		rows.Add (new List<ConsoleString> () {  			new ConsoleString ("  " + aliases [i])'  			ConsoleString.Empty'  		});  	}  	foreach (var possibleValue in usageInfo.PossibleValues) {  		rows.Add (new List<ConsoleString> () {  			ConsoleString.Empty'  			new ConsoleString ("  " + possibleValue)'  		});  	}  }  
Magic Number,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The following statement contains a magic number: for (int i = 0; i < args.Length; i++) {  	var token = args [i];  	if (token.StartsWith ("-")) {  		string key = token.Substring (1);  		if (key.Length == 0)  			throw new ArgException ("Missing argument value after '-'");  		string value;  		// Handles a special case --arg-name- where we have a trailing -  		// it's a shortcut way of disabling an option  		if (key.StartsWith ("-") && key.EndsWith ("-") || key.StartsWith ("-") && key.EndsWith ("+")) {  			value = key.Substring (key.Length - 1' 1);  			key = key.Substring (1' key.Length - 2);  		} // Handles long form syntax --argName=argValue.  		else if (key.StartsWith ("-") && key.Contains ("=")) {  			var index = key.IndexOf ("=");  			value = key.Substring (index + 1);  			key = key.Substring (1' index - 1);  		} else {  			if (key.StartsWith ("-")) {  				key = key.Substring (1);  			}  			if (i == args.Length - 1) {  				value = "";  			} else if (IsBool<T> (key)) {  				var next = args [i + 1].ToLower ();  				if (next == "true" || next == "false" || next == "0" || next == "1") {  					i++;  					value = next;  				} else {  					value = "true";  				}  			} else {  				i++;  				value = args [i];  			}  		}  		yield return new Tuple<string' string> (key.TrimStart (new char[] {  			'-'  		})' value);  	}  }  
Magic Number,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The following statement contains a magic number: if (token.StartsWith ("-")) {  	string key = token.Substring (1);  	if (key.Length == 0)  		throw new ArgException ("Missing argument value after '-'");  	string value;  	// Handles a special case --arg-name- where we have a trailing -  	// it's a shortcut way of disabling an option  	if (key.StartsWith ("-") && key.EndsWith ("-") || key.StartsWith ("-") && key.EndsWith ("+")) {  		value = key.Substring (key.Length - 1' 1);  		key = key.Substring (1' key.Length - 2);  	} // Handles long form syntax --argName=argValue.  	else if (key.StartsWith ("-") && key.Contains ("=")) {  		var index = key.IndexOf ("=");  		value = key.Substring (index + 1);  		key = key.Substring (1' index - 1);  	} else {  		if (key.StartsWith ("-")) {  			key = key.Substring (1);  		}  		if (i == args.Length - 1) {  			value = "";  		} else if (IsBool<T> (key)) {  			var next = args [i + 1].ToLower ();  			if (next == "true" || next == "false" || next == "0" || next == "1") {  				i++;  				value = next;  			} else {  				value = "true";  			}  		} else {  			i++;  			value = args [i];  		}  	}  	yield return new Tuple<string' string> (key.TrimStart (new char[] {  		'-'  	})' value);  }  
Magic Number,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The following statement contains a magic number: if (key.StartsWith ("-") && key.EndsWith ("-") || key.StartsWith ("-") && key.EndsWith ("+")) {  	value = key.Substring (key.Length - 1' 1);  	key = key.Substring (1' key.Length - 2);  } // Handles long form syntax --argName=argValue.  else if (key.StartsWith ("-") && key.Contains ("=")) {  	var index = key.IndexOf ("=");  	value = key.Substring (index + 1);  	key = key.Substring (1' index - 1);  } else {  	if (key.StartsWith ("-")) {  		key = key.Substring (1);  	}  	if (i == args.Length - 1) {  		value = "";  	} else if (IsBool<T> (key)) {  		var next = args [i + 1].ToLower ();  		if (next == "true" || next == "false" || next == "0" || next == "1") {  			i++;  			value = next;  		} else {  			value = "true";  		}  	} else {  		i++;  		value = args [i];  	}  }  
Magic Number,EventStore.Rags,CommandLine,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\CommandLine.cs,ParseArgs,The following statement contains a magic number: key = key.Substring (1' key.Length - 2);  
Magic Number,EventStore.Rags.YamlDotNet.Dynamic,DynamicYaml,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet.Dynamic\DynamicYaml.cs,IsGenericEnumDictionary,The following statement contains a magic number: if (genericTypeArgs.Length != 2) {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,AsHex,The following statement contains a magic number: if (character <= 'F') {  	return character - 'A' + 10;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,AsHex,The following statement contains a magic number: return character - 'A' + 10;  
Magic Number,EventStore.Rags.YamlDotNet.Core,CharacterAnalyzer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\CharacterAnalyzer.cs,AsHex,The following statement contains a magic number: return character - 'a' + 10;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,Emitter,The following statement contains a magic number: if (bestWidth <= bestIndent * 2) {  	throw new ArgumentOutOfRangeException ("bestWidth"' "The bestWidth parameter must be greater than bestIndent * 2.");  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: switch (events.Peek ().Type) {  case EventType.DocumentStart:  	accumulate = 1;  	break;  case EventType.SequenceStart:  	accumulate = 2;  	break;  case EventType.MappingStart:  	accumulate = 3;  	break;  default:  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: switch (events.Peek ().Type) {  case EventType.DocumentStart:  	accumulate = 1;  	break;  case EventType.SequenceStart:  	accumulate = 2;  	break;  case EventType.MappingStart:  	accumulate = 3;  	break;  default:  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: accumulate = 2;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: accumulate = 3;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckEmptyDocument,The following statement contains a magic number: foreach (var parsingEvent in events) {  	index++;  	if (index == 2) {  		var scalar = parsingEvent as Scalar;  		if (scalar != null) {  			return string.IsNullOrEmpty (scalar.Value);  		}  		break;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckEmptyDocument,The following statement contains a magic number: if (index == 2) {  	var scalar = parsingEvent as Scalar;  	if (scalar != null) {  		return string.IsNullOrEmpty (scalar.Value);  	}  	break;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckEmptySequence,The following statement contains a magic number: if (events.Count < 2) {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,CheckEmptyMapping,The following statement contains a magic number: if (events.Count < 2) {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length == 0 || !analyzer.IsBreak (value.Length - 1)) {  	chompHint = "-";  } else if (value.Length >= 2 && analyzer.IsBreak (value.Length - 2)) {  	chompHint = "+";  	isOpenEnded = true;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length == 0 || !analyzer.IsBreak (value.Length - 1)) {  	chompHint = "-";  } else if (value.Length >= 2 && analyzer.IsBreak (value.Length - 2)) {  	chompHint = "+";  	isOpenEnded = true;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length >= 2 && analyzer.IsBreak (value.Length - 2)) {  	chompHint = "+";  	isOpenEnded = true;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length >= 2 && analyzer.IsBreak (value.Length - 2)) {  	chompHint = "+";  	isOpenEnded = true;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (_currentIndex < 0) {  	while (_innerParser.MoveNext ()) {  		_allEvents.Add (_innerParser.Current);  	}  	for (int i = _allEvents.Count - 2; i >= 0; --i) {  		var merge = _allEvents [i] as Scalar;  		if (merge != null && merge.Value == "<<") {  			var anchorAlias = _allEvents [i + 1] as AnchorAlias;  			if (anchorAlias != null) {  				var mergedEvents = GetMappingEvents (anchorAlias.Value);  				_allEvents.RemoveRange (i' 2);  				_allEvents.InsertRange (i' mergedEvents);  			}  		}  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (_currentIndex < 0) {  	while (_innerParser.MoveNext ()) {  		_allEvents.Add (_innerParser.Current);  	}  	for (int i = _allEvents.Count - 2; i >= 0; --i) {  		var merge = _allEvents [i] as Scalar;  		if (merge != null && merge.Value == "<<") {  			var anchorAlias = _allEvents [i + 1] as AnchorAlias;  			if (anchorAlias != null) {  				var mergedEvents = GetMappingEvents (anchorAlias.Value);  				_allEvents.RemoveRange (i' 2);  				_allEvents.InsertRange (i' mergedEvents);  			}  		}  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: for (int i = _allEvents.Count - 2; i >= 0; --i) {  	var merge = _allEvents [i] as Scalar;  	if (merge != null && merge.Value == "<<") {  		var anchorAlias = _allEvents [i + 1] as AnchorAlias;  		if (anchorAlias != null) {  			var mergedEvents = GetMappingEvents (anchorAlias.Value);  			_allEvents.RemoveRange (i' 2);  			_allEvents.InsertRange (i' mergedEvents);  		}  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: for (int i = _allEvents.Count - 2; i >= 0; --i) {  	var merge = _allEvents [i] as Scalar;  	if (merge != null && merge.Value == "<<") {  		var anchorAlias = _allEvents [i + 1] as AnchorAlias;  		if (anchorAlias != null) {  			var mergedEvents = GetMappingEvents (anchorAlias.Value);  			_allEvents.RemoveRange (i' 2);  			_allEvents.InsertRange (i' mergedEvents);  		}  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (merge != null && merge.Value == "<<") {  	var anchorAlias = _allEvents [i + 1] as AnchorAlias;  	if (anchorAlias != null) {  		var mergedEvents = GetMappingEvents (anchorAlias.Value);  		_allEvents.RemoveRange (i' 2);  		_allEvents.InsertRange (i' mergedEvents);  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (anchorAlias != null) {  	var mergedEvents = GetMappingEvents (anchorAlias.Value);  	_allEvents.RemoveRange (i' 2);  	_allEvents.InsertRange (i' mergedEvents);  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,MergingParser,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: _allEvents.RemoveRange (i' 2);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,StaleSimpleKeys,The following statement contains a magic number: foreach (var key in simpleKeys) {  	// The specification requires that a simple key  	//  - is limited to a single line'  	//  - is shorter than 1024 characters.  	if (key.IsPossible && (key.Line < cursor.Line || key.Index + 1024 < cursor.Index)) {  		// Check if the potential simple key to be removed is required.  		if (key.IsRequired) {  			var mark = cursor.Mark ();  			throw new SyntaxErrorException (mark' mark' "While scanning a simple key' could not find expected ':'.");  		}  		key.IsPossible = false;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,StaleSimpleKeys,The following statement contains a magic number: if (key.IsPossible && (key.Line < cursor.Line || key.Index + 1024 < cursor.Index)) {  	// Check if the potential simple key to be removed is required.  	if (key.IsRequired) {  		var mark = cursor.Mark ();  		throw new SyntaxErrorException (mark' mark' "While scanning a simple key' could not find expected ':'.");  	}  	key.IsPossible = false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: analyzer.Buffer.Cache (4);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero (3)) {  	bool isDocumentStart = analyzer.Check ('-'' 0) && analyzer.Check ('-'' 1) && analyzer.Check ('-'' 2);  	bool isDocumentEnd = analyzer.Check ('.'' 0) && analyzer.Check ('.'' 1) && analyzer.Check ('.'' 2);  	return isDocumentStart || isDocumentEnd;  } else {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero (3)) {  	bool isDocumentStart = analyzer.Check ('-'' 0) && analyzer.Check ('-'' 1) && analyzer.Check ('-'' 2);  	bool isDocumentEnd = analyzer.Check ('.'' 0) && analyzer.Check ('.'' 1) && analyzer.Check ('.'' 2);  	return isDocumentStart || isDocumentEnd;  } else {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero (3)) {  	bool isDocumentStart = analyzer.Check ('-'' 0) && analyzer.Check ('-'' 1) && analyzer.Check ('-'' 2);  	bool isDocumentEnd = analyzer.Check ('.'' 0) && analyzer.Check ('.'' 1) && analyzer.Check ('.'' 2);  	return isDocumentStart || isDocumentEnd;  } else {  	return false;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: if (analyzer.IsCrLf ()) {  	cursor.SkipLineByOffset (2);  	analyzer.Buffer.Skip (2);  } else if (analyzer.IsBreak ()) {  	cursor.SkipLineByOffset (1);  	analyzer.Buffer.Skip (1);  } else if (!analyzer.IsZero ()) {  	throw new InvalidOperationException ("Not at a break.");  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: if (analyzer.IsCrLf ()) {  	cursor.SkipLineByOffset (2);  	analyzer.Buffer.Skip (2);  } else if (analyzer.IsBreak ()) {  	cursor.SkipLineByOffset (1);  	analyzer.Buffer.Skip (1);  } else if (!analyzer.IsZero ()) {  	throw new InvalidOperationException ("Not at a break.");  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: cursor.SkipLineByOffset (2);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: analyzer.Buffer.Skip (2);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;) {  	// Check that there are no document indicators at the beginning of the line.  	if (IsDocumentIndicator ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected document indicator.");  	}  	// Check for EOF.  	if (analyzer.IsZero ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected end of stream.");  	}  	// Consume non-blank characters.  	bool hasLeadingBlanks = false;  	while (!analyzer.IsWhiteBreakOrZero ()) {  		// Check for an escaped single quote.  		if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  			value.Append ('\'');  			Skip ();  			Skip ();  		} // Check for the right quote.  		else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  			break;  		} // Check for an escaped line break.  		else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  			Skip ();  			SkipLine ();  			hasLeadingBlanks = true;  			break;  		} // Check for an escape sequence.  		else if (!isSingleQuoted && analyzer.Check ('\\')) {  			int codeLength = 0;  			// Check the escape character.  			char escapeCharacter = analyzer.Peek (1);  			switch (escapeCharacter) {  			case 'x':  				codeLength = 2;  				break;  			case 'u':  				codeLength = 4;  				break;  			case 'U':  				codeLength = 8;  				break;  			default:  				char unescapedCharacter;  				if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  					value.Append (unescapedCharacter);  				} else {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  				}  				break;  			}  			Skip ();  			Skip ();  			// Consume an arbitrary escape code.  			if (codeLength > 0) {  				uint character = 0;  				// Scan the character value.  				for (int k = 0; k < codeLength; ++k) {  					if (!analyzer.IsHex (k)) {  						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  					}  					character = (uint)((character << 4) + analyzer.AsHex (k));  				}  				// Check the value and write the character.  				if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  				}  				value.Append ((char)character);  				// Advance the pointer.  				for (int k = 0; k < codeLength; ++k) {  					Skip ();  				}  			}  		} else {  			// It is a non-escaped non-blank character.  			value.Append (ReadCurrentCharacter ());  		}  	}  	// Check if we are at the end of the scalar.  	if (analyzer.Check (isSingleQuoted ? '\'' : '"'))  		break;  	// Consume blank characters.  	while (analyzer.IsWhite () || analyzer.IsBreak ()) {  		if (analyzer.IsWhite ()) {  			// Consume a space or a tab character.  			if (!hasLeadingBlanks) {  				whitespaces.Append (ReadCurrentCharacter ());  			} else {  				Skip ();  			}  		} else {  			// Check if it is a first line break.  			if (!hasLeadingBlanks) {  				whitespaces.Length = 0;  				leadingBreak.Append (ReadLine ());  				hasLeadingBlanks = true;  			} else {  				trailingBreaks.Append (ReadLine ());  			}  		}  	}  	// Join the whitespaces or fold line breaks.  	if (hasLeadingBlanks) {  		// Do we need to fold line breaks?  		if (StartsWith (leadingBreak' '\n')) {  			if (trailingBreaks.Length == 0) {  				value.Append (' ');  			} else {  				value.Append (trailingBreaks.ToString ());  			}  		} else {  			value.Append (leadingBreak.ToString ());  			value.Append (trailingBreaks.ToString ());  		}  		leadingBreak.Length = 0;  		trailingBreaks.Length = 0;  	} else {  		value.Append (whitespaces.ToString ());  		whitespaces.Length = 0;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;) {  	// Check that there are no document indicators at the beginning of the line.  	if (IsDocumentIndicator ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected document indicator.");  	}  	// Check for EOF.  	if (analyzer.IsZero ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected end of stream.");  	}  	// Consume non-blank characters.  	bool hasLeadingBlanks = false;  	while (!analyzer.IsWhiteBreakOrZero ()) {  		// Check for an escaped single quote.  		if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  			value.Append ('\'');  			Skip ();  			Skip ();  		} // Check for the right quote.  		else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  			break;  		} // Check for an escaped line break.  		else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  			Skip ();  			SkipLine ();  			hasLeadingBlanks = true;  			break;  		} // Check for an escape sequence.  		else if (!isSingleQuoted && analyzer.Check ('\\')) {  			int codeLength = 0;  			// Check the escape character.  			char escapeCharacter = analyzer.Peek (1);  			switch (escapeCharacter) {  			case 'x':  				codeLength = 2;  				break;  			case 'u':  				codeLength = 4;  				break;  			case 'U':  				codeLength = 8;  				break;  			default:  				char unescapedCharacter;  				if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  					value.Append (unescapedCharacter);  				} else {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  				}  				break;  			}  			Skip ();  			Skip ();  			// Consume an arbitrary escape code.  			if (codeLength > 0) {  				uint character = 0;  				// Scan the character value.  				for (int k = 0; k < codeLength; ++k) {  					if (!analyzer.IsHex (k)) {  						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  					}  					character = (uint)((character << 4) + analyzer.AsHex (k));  				}  				// Check the value and write the character.  				if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  				}  				value.Append ((char)character);  				// Advance the pointer.  				for (int k = 0; k < codeLength; ++k) {  					Skip ();  				}  			}  		} else {  			// It is a non-escaped non-blank character.  			value.Append (ReadCurrentCharacter ());  		}  	}  	// Check if we are at the end of the scalar.  	if (analyzer.Check (isSingleQuoted ? '\'' : '"'))  		break;  	// Consume blank characters.  	while (analyzer.IsWhite () || analyzer.IsBreak ()) {  		if (analyzer.IsWhite ()) {  			// Consume a space or a tab character.  			if (!hasLeadingBlanks) {  				whitespaces.Append (ReadCurrentCharacter ());  			} else {  				Skip ();  			}  		} else {  			// Check if it is a first line break.  			if (!hasLeadingBlanks) {  				whitespaces.Length = 0;  				leadingBreak.Append (ReadLine ());  				hasLeadingBlanks = true;  			} else {  				trailingBreaks.Append (ReadLine ());  			}  		}  	}  	// Join the whitespaces or fold line breaks.  	if (hasLeadingBlanks) {  		// Do we need to fold line breaks?  		if (StartsWith (leadingBreak' '\n')) {  			if (trailingBreaks.Length == 0) {  				value.Append (' ');  			} else {  				value.Append (trailingBreaks.ToString ());  			}  		} else {  			value.Append (leadingBreak.ToString ());  			value.Append (trailingBreaks.ToString ());  		}  		leadingBreak.Length = 0;  		trailingBreaks.Length = 0;  	} else {  		value.Append (whitespaces.ToString ());  		whitespaces.Length = 0;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;) {  	// Check that there are no document indicators at the beginning of the line.  	if (IsDocumentIndicator ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected document indicator.");  	}  	// Check for EOF.  	if (analyzer.IsZero ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected end of stream.");  	}  	// Consume non-blank characters.  	bool hasLeadingBlanks = false;  	while (!analyzer.IsWhiteBreakOrZero ()) {  		// Check for an escaped single quote.  		if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  			value.Append ('\'');  			Skip ();  			Skip ();  		} // Check for the right quote.  		else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  			break;  		} // Check for an escaped line break.  		else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  			Skip ();  			SkipLine ();  			hasLeadingBlanks = true;  			break;  		} // Check for an escape sequence.  		else if (!isSingleQuoted && analyzer.Check ('\\')) {  			int codeLength = 0;  			// Check the escape character.  			char escapeCharacter = analyzer.Peek (1);  			switch (escapeCharacter) {  			case 'x':  				codeLength = 2;  				break;  			case 'u':  				codeLength = 4;  				break;  			case 'U':  				codeLength = 8;  				break;  			default:  				char unescapedCharacter;  				if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  					value.Append (unescapedCharacter);  				} else {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  				}  				break;  			}  			Skip ();  			Skip ();  			// Consume an arbitrary escape code.  			if (codeLength > 0) {  				uint character = 0;  				// Scan the character value.  				for (int k = 0; k < codeLength; ++k) {  					if (!analyzer.IsHex (k)) {  						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  					}  					character = (uint)((character << 4) + analyzer.AsHex (k));  				}  				// Check the value and write the character.  				if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  				}  				value.Append ((char)character);  				// Advance the pointer.  				for (int k = 0; k < codeLength; ++k) {  					Skip ();  				}  			}  		} else {  			// It is a non-escaped non-blank character.  			value.Append (ReadCurrentCharacter ());  		}  	}  	// Check if we are at the end of the scalar.  	if (analyzer.Check (isSingleQuoted ? '\'' : '"'))  		break;  	// Consume blank characters.  	while (analyzer.IsWhite () || analyzer.IsBreak ()) {  		if (analyzer.IsWhite ()) {  			// Consume a space or a tab character.  			if (!hasLeadingBlanks) {  				whitespaces.Append (ReadCurrentCharacter ());  			} else {  				Skip ();  			}  		} else {  			// Check if it is a first line break.  			if (!hasLeadingBlanks) {  				whitespaces.Length = 0;  				leadingBreak.Append (ReadLine ());  				hasLeadingBlanks = true;  			} else {  				trailingBreaks.Append (ReadLine ());  			}  		}  	}  	// Join the whitespaces or fold line breaks.  	if (hasLeadingBlanks) {  		// Do we need to fold line breaks?  		if (StartsWith (leadingBreak' '\n')) {  			if (trailingBreaks.Length == 0) {  				value.Append (' ');  			} else {  				value.Append (trailingBreaks.ToString ());  			}  		} else {  			value.Append (leadingBreak.ToString ());  			value.Append (trailingBreaks.ToString ());  		}  		leadingBreak.Length = 0;  		trailingBreaks.Length = 0;  	} else {  		value.Append (whitespaces.ToString ());  		whitespaces.Length = 0;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;) {  	// Check that there are no document indicators at the beginning of the line.  	if (IsDocumentIndicator ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected document indicator.");  	}  	// Check for EOF.  	if (analyzer.IsZero ()) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a quoted scalar' find unexpected end of stream.");  	}  	// Consume non-blank characters.  	bool hasLeadingBlanks = false;  	while (!analyzer.IsWhiteBreakOrZero ()) {  		// Check for an escaped single quote.  		if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  			value.Append ('\'');  			Skip ();  			Skip ();  		} // Check for the right quote.  		else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  			break;  		} // Check for an escaped line break.  		else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  			Skip ();  			SkipLine ();  			hasLeadingBlanks = true;  			break;  		} // Check for an escape sequence.  		else if (!isSingleQuoted && analyzer.Check ('\\')) {  			int codeLength = 0;  			// Check the escape character.  			char escapeCharacter = analyzer.Peek (1);  			switch (escapeCharacter) {  			case 'x':  				codeLength = 2;  				break;  			case 'u':  				codeLength = 4;  				break;  			case 'U':  				codeLength = 8;  				break;  			default:  				char unescapedCharacter;  				if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  					value.Append (unescapedCharacter);  				} else {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  				}  				break;  			}  			Skip ();  			Skip ();  			// Consume an arbitrary escape code.  			if (codeLength > 0) {  				uint character = 0;  				// Scan the character value.  				for (int k = 0; k < codeLength; ++k) {  					if (!analyzer.IsHex (k)) {  						throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  					}  					character = (uint)((character << 4) + analyzer.AsHex (k));  				}  				// Check the value and write the character.  				if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  				}  				value.Append ((char)character);  				// Advance the pointer.  				for (int k = 0; k < codeLength; ++k) {  					Skip ();  				}  			}  		} else {  			// It is a non-escaped non-blank character.  			value.Append (ReadCurrentCharacter ());  		}  	}  	// Check if we are at the end of the scalar.  	if (analyzer.Check (isSingleQuoted ? '\'' : '"'))  		break;  	// Consume blank characters.  	while (analyzer.IsWhite () || analyzer.IsBreak ()) {  		if (analyzer.IsWhite ()) {  			// Consume a space or a tab character.  			if (!hasLeadingBlanks) {  				whitespaces.Append (ReadCurrentCharacter ());  			} else {  				Skip ();  			}  		} else {  			// Check if it is a first line break.  			if (!hasLeadingBlanks) {  				whitespaces.Length = 0;  				leadingBreak.Append (ReadLine ());  				hasLeadingBlanks = true;  			} else {  				trailingBreaks.Append (ReadLine ());  			}  		}  	}  	// Join the whitespaces or fold line breaks.  	if (hasLeadingBlanks) {  		// Do we need to fold line breaks?  		if (StartsWith (leadingBreak' '\n')) {  			if (trailingBreaks.Length == 0) {  				value.Append (' ');  			} else {  				value.Append (trailingBreaks.ToString ());  			}  		} else {  			value.Append (leadingBreak.ToString ());  			value.Append (trailingBreaks.ToString ());  		}  		leadingBreak.Length = 0;  		trailingBreaks.Length = 0;  	} else {  		value.Append (whitespaces.ToString ());  		whitespaces.Length = 0;  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: while (!analyzer.IsWhiteBreakOrZero ()) {  	// Check for an escaped single quote.  	if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  		value.Append ('\'');  		Skip ();  		Skip ();  	} // Check for the right quote.  	else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  		break;  	} // Check for an escaped line break.  	else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  		Skip ();  		SkipLine ();  		hasLeadingBlanks = true;  		break;  	} // Check for an escape sequence.  	else if (!isSingleQuoted && analyzer.Check ('\\')) {  		int codeLength = 0;  		// Check the escape character.  		char escapeCharacter = analyzer.Peek (1);  		switch (escapeCharacter) {  		case 'x':  			codeLength = 2;  			break;  		case 'u':  			codeLength = 4;  			break;  		case 'U':  			codeLength = 8;  			break;  		default:  			char unescapedCharacter;  			if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  				value.Append (unescapedCharacter);  			} else {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  			}  			break;  		}  		Skip ();  		Skip ();  		// Consume an arbitrary escape code.  		if (codeLength > 0) {  			uint character = 0;  			// Scan the character value.  			for (int k = 0; k < codeLength; ++k) {  				if (!analyzer.IsHex (k)) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  				}  				character = (uint)((character << 4) + analyzer.AsHex (k));  			}  			// Check the value and write the character.  			if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  			}  			value.Append ((char)character);  			// Advance the pointer.  			for (int k = 0; k < codeLength; ++k) {  				Skip ();  			}  		}  	} else {  		// It is a non-escaped non-blank character.  		value.Append (ReadCurrentCharacter ());  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: while (!analyzer.IsWhiteBreakOrZero ()) {  	// Check for an escaped single quote.  	if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  		value.Append ('\'');  		Skip ();  		Skip ();  	} // Check for the right quote.  	else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  		break;  	} // Check for an escaped line break.  	else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  		Skip ();  		SkipLine ();  		hasLeadingBlanks = true;  		break;  	} // Check for an escape sequence.  	else if (!isSingleQuoted && analyzer.Check ('\\')) {  		int codeLength = 0;  		// Check the escape character.  		char escapeCharacter = analyzer.Peek (1);  		switch (escapeCharacter) {  		case 'x':  			codeLength = 2;  			break;  		case 'u':  			codeLength = 4;  			break;  		case 'U':  			codeLength = 8;  			break;  		default:  			char unescapedCharacter;  			if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  				value.Append (unescapedCharacter);  			} else {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  			}  			break;  		}  		Skip ();  		Skip ();  		// Consume an arbitrary escape code.  		if (codeLength > 0) {  			uint character = 0;  			// Scan the character value.  			for (int k = 0; k < codeLength; ++k) {  				if (!analyzer.IsHex (k)) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  				}  				character = (uint)((character << 4) + analyzer.AsHex (k));  			}  			// Check the value and write the character.  			if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  			}  			value.Append ((char)character);  			// Advance the pointer.  			for (int k = 0; k < codeLength; ++k) {  				Skip ();  			}  		}  	} else {  		// It is a non-escaped non-blank character.  		value.Append (ReadCurrentCharacter ());  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: while (!analyzer.IsWhiteBreakOrZero ()) {  	// Check for an escaped single quote.  	if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  		value.Append ('\'');  		Skip ();  		Skip ();  	} // Check for the right quote.  	else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  		break;  	} // Check for an escaped line break.  	else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  		Skip ();  		SkipLine ();  		hasLeadingBlanks = true;  		break;  	} // Check for an escape sequence.  	else if (!isSingleQuoted && analyzer.Check ('\\')) {  		int codeLength = 0;  		// Check the escape character.  		char escapeCharacter = analyzer.Peek (1);  		switch (escapeCharacter) {  		case 'x':  			codeLength = 2;  			break;  		case 'u':  			codeLength = 4;  			break;  		case 'U':  			codeLength = 8;  			break;  		default:  			char unescapedCharacter;  			if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  				value.Append (unescapedCharacter);  			} else {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  			}  			break;  		}  		Skip ();  		Skip ();  		// Consume an arbitrary escape code.  		if (codeLength > 0) {  			uint character = 0;  			// Scan the character value.  			for (int k = 0; k < codeLength; ++k) {  				if (!analyzer.IsHex (k)) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  				}  				character = (uint)((character << 4) + analyzer.AsHex (k));  			}  			// Check the value and write the character.  			if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  			}  			value.Append ((char)character);  			// Advance the pointer.  			for (int k = 0; k < codeLength; ++k) {  				Skip ();  			}  		}  	} else {  		// It is a non-escaped non-blank character.  		value.Append (ReadCurrentCharacter ());  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: while (!analyzer.IsWhiteBreakOrZero ()) {  	// Check for an escaped single quote.  	if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  		value.Append ('\'');  		Skip ();  		Skip ();  	} // Check for the right quote.  	else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  		break;  	} // Check for an escaped line break.  	else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  		Skip ();  		SkipLine ();  		hasLeadingBlanks = true;  		break;  	} // Check for an escape sequence.  	else if (!isSingleQuoted && analyzer.Check ('\\')) {  		int codeLength = 0;  		// Check the escape character.  		char escapeCharacter = analyzer.Peek (1);  		switch (escapeCharacter) {  		case 'x':  			codeLength = 2;  			break;  		case 'u':  			codeLength = 4;  			break;  		case 'U':  			codeLength = 8;  			break;  		default:  			char unescapedCharacter;  			if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  				value.Append (unescapedCharacter);  			} else {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  			}  			break;  		}  		Skip ();  		Skip ();  		// Consume an arbitrary escape code.  		if (codeLength > 0) {  			uint character = 0;  			// Scan the character value.  			for (int k = 0; k < codeLength; ++k) {  				if (!analyzer.IsHex (k)) {  					throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  				}  				character = (uint)((character << 4) + analyzer.AsHex (k));  			}  			// Check the value and write the character.  			if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  			}  			value.Append ((char)character);  			// Advance the pointer.  			for (int k = 0; k < codeLength; ++k) {  				Skip ();  			}  		}  	} else {  		// It is a non-escaped non-blank character.  		value.Append (ReadCurrentCharacter ());  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  	value.Append ('\'');  	Skip ();  	Skip ();  } // Check for the right quote.  else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  	value.Append ('\'');  	Skip ();  	Skip ();  } // Check for the right quote.  else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  	value.Append ('\'');  	Skip ();  	Skip ();  } // Check for the right quote.  else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (isSingleQuoted && analyzer.Check ('\''' 0) && analyzer.Check ('\''' 1)) {  	value.Append ('\'');  	Skip ();  	Skip ();  } // Check for the right quote.  else if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (analyzer.Check (isSingleQuoted ? '\'' : '"')) {  	break;  } // Check for an escaped line break.  else if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\') && analyzer.IsBreak (1)) {  	Skip ();  	SkipLine ();  	hasLeadingBlanks = true;  	break;  } // Check for an escape sequence.  else if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (!isSingleQuoted && analyzer.Check ('\\')) {  	int codeLength = 0;  	// Check the escape character.  	char escapeCharacter = analyzer.Peek (1);  	switch (escapeCharacter) {  	case 'x':  		codeLength = 2;  		break;  	case 'u':  		codeLength = 4;  		break;  	case 'U':  		codeLength = 8;  		break;  	default:  		char unescapedCharacter;  		if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  			value.Append (unescapedCharacter);  		} else {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  		}  		break;  	}  	Skip ();  	Skip ();  	// Consume an arbitrary escape code.  	if (codeLength > 0) {  		uint character = 0;  		// Scan the character value.  		for (int k = 0; k < codeLength; ++k) {  			if (!analyzer.IsHex (k)) {  				throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  			}  			character = (uint)((character << 4) + analyzer.AsHex (k));  		}  		// Check the value and write the character.  		if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  		}  		value.Append ((char)character);  		// Advance the pointer.  		for (int k = 0; k < codeLength; ++k) {  			Skip ();  		}  	}  } else {  	// It is a non-escaped non-blank character.  	value.Append (ReadCurrentCharacter ());  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: switch (escapeCharacter) {  case 'x':  	codeLength = 2;  	break;  case 'u':  	codeLength = 4;  	break;  case 'U':  	codeLength = 8;  	break;  default:  	char unescapedCharacter;  	if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  		value.Append (unescapedCharacter);  	} else {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  	}  	break;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: switch (escapeCharacter) {  case 'x':  	codeLength = 2;  	break;  case 'u':  	codeLength = 4;  	break;  case 'U':  	codeLength = 8;  	break;  default:  	char unescapedCharacter;  	if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  		value.Append (unescapedCharacter);  	} else {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  	}  	break;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: switch (escapeCharacter) {  case 'x':  	codeLength = 2;  	break;  case 'u':  	codeLength = 4;  	break;  case 'U':  	codeLength = 8;  	break;  default:  	char unescapedCharacter;  	if (simpleEscapeCodes.TryGetValue (escapeCharacter' out unescapedCharacter)) {  		value.Append (unescapedCharacter);  	} else {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find unknown escape character.");  	}  	break;  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: codeLength = 2;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: codeLength = 4;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: codeLength = 8;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: if (codeLength > 0) {  	uint character = 0;  	// Scan the character value.  	for (int k = 0; k < codeLength; ++k) {  		if (!analyzer.IsHex (k)) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  		}  		character = (uint)((character << 4) + analyzer.AsHex (k));  	}  	// Check the value and write the character.  	if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  	}  	value.Append ((char)character);  	// Advance the pointer.  	for (int k = 0; k < codeLength; ++k) {  		Skip ();  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (int k = 0; k < codeLength; ++k) {  	if (!analyzer.IsHex (k)) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  	}  	character = (uint)((character << 4) + analyzer.AsHex (k));  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: character = (uint)((character << 4) + analyzer.AsHex (k));  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do {  	// Check for a URI-escaped octet.  	if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  	}  	// Get the octet.  	int octet = (analyzer.AsHex (1) << 4) + analyzer.AsHex (2);  	// If it is the leading octet' determine the length of the UTF-8 sequence.  	if (width == 0) {  		width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  		if (width == 0) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  		}  	} else {  		// Check if the trailing octet is correct.  		if ((octet & 0xC0) != 0x80) {  			throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  		}  	}  	// Copy the octet and move the pointers.  	charBytes.Add ((byte)octet);  	Skip ();  	Skip ();  	Skip ();  } while (--width > 0);  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: if (!(analyzer.Check ('%') && analyzer.IsHex (1) && analyzer.IsHex (2))) {  	throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' did not find URI escaped octet.");  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: if (width == 0) {  	width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  	if (width == 0) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  	}  } else {  	// Check if the trailing octet is correct.  	if ((octet & 0xC0) != 0x80) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: if (width == 0) {  	width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  	if (width == 0) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  	}  } else {  	// Check if the trailing octet is correct.  	if ((octet & 0xC0) != 0x80) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: if (width == 0) {  	width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  	if (width == 0) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  	}  } else {  	// Check if the trailing octet is correct.  	if ((octet & 0xC0) != 0x80) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  	}  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: width = (octet & 0x80) == 0x00 ? 1 : (octet & 0xE0) == 0xC0 ? 2 : (octet & 0xF0) == 0xE0 ? 3 : (octet & 0xF8) == 0xF0 ? 4 : 0;  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The following statement contains a magic number: while (analyzer.IsDigit ()) {  	// Check if the number is too long.  	if (++length > MaxVersionNumberLength) {  		throw new SyntaxErrorException (start' cursor.Mark ()' "While scanning a %YAML directive' find extremely long version number.");  	}  	value = value * 10 + analyzer.AsDigit ();  	Skip ();  }  
Magic Number,EventStore.Rags.YamlDotNet.Core,Scanner,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The following statement contains a magic number: value = value * 10 + analyzer.AsDigit ();  
Magic Number,EventStore.Rags.YamlDotNet.RepresentationModel,YamlMappingNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlMappingNode.cs,ToString,The following statement contains a magic number: foreach (var child in children) {  	if (text.Length > 2) {  		text.Append ("' ");  	}  	text.Append ("{ ").Append (child.Key).Append ("' ").Append (child.Value).Append (" }");  }  
Magic Number,EventStore.Rags.YamlDotNet.RepresentationModel,YamlMappingNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlMappingNode.cs,ToString,The following statement contains a magic number: if (text.Length > 2) {  	text.Append ("' ");  }  
Magic Number,EventStore.Rags.YamlDotNet.RepresentationModel,YamlNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlNode.cs,CombineHashCodes,The following statement contains a magic number: return unchecked(((h1 << 5) + h1) ^ h2);  
Magic Number,EventStore.Rags.YamlDotNet.RepresentationModel,YamlSequenceNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlSequenceNode.cs,ToString,The following statement contains a magic number: foreach (var child in children) {  	if (text.Length > 2) {  		text.Append ("' ");  	}  	text.Append (child);  }  
Magic Number,EventStore.Rags.YamlDotNet.RepresentationModel,YamlSequenceNode,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\RepresentationModel\YamlSequenceNode.cs,ToString,The following statement contains a magic number: if (text.Length > 2) {  	text.Append ("' ");  }  
Magic Number,EventStore.Rags.YamlDotNet.Serialization,Serializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: if (IsOptionSet (SerializationOptions.Roundtrip)) {  	return new RoundtripObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  } else {  	return new FullObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  }  
Magic Number,EventStore.Rags.YamlDotNet.Serialization,Serializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: if (IsOptionSet (SerializationOptions.Roundtrip)) {  	return new RoundtripObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  } else {  	return new FullObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  }  
Magic Number,EventStore.Rags.YamlDotNet.Serialization,Serializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: return new RoundtripObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  
Magic Number,EventStore.Rags.YamlDotNet.Serialization,Serializer,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: return new FullObjectGraphTraversalStrategy (this' typeDescriptor' typeResolver' 50);  
Missing Default,EventStore.Rags.YamlDotNet.Core,Emitter,F:\newReposMay17\EventStore_EventStore\etc\EventStore.Rags\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following switch statement is missing a default case: switch (evt.Type) {  case EventType.DocumentStart:  case EventType.SequenceStart:  case EventType.MappingStart:  	++level;  	break;  case EventType.DocumentEnd:  case EventType.SequenceEnd:  case EventType.MappingEnd:  	--level;  	break;  }  
