Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,Cyclomatic complexity of the method is 42
Long Parameter List,Gma.UserActivityMonitor,MouseEventExtArgs,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\MouseEventExtArgs.cs,MouseEventExtArgs,The method has 5 parameters.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The length of the statement  "		MouseEventExtArgs e = new MouseEventExtArgs (button' clickCount' mouseHookStruct.Point.X' mouseHookStruct.Point.Y' mouseDelta); " is 127.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The length of the statement  "		if ((s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)) { " is 130.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,EnsureSubscribedToGlobalMouseEvents,The length of the statement  "		s_MouseHookHandle = SetWindowsHookEx (WH_MOUSE_LL' s_MouseDelegate' GetModuleHandle (Process.GetCurrentProcess ().MainModule.ModuleName)' 0); " is 141.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,EnsureSubscribedToGlobalMouseEvents,The length of the statement  "			//Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.  " is 148.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,TryUnsubscribeFromGlobalMouseEvents,The length of the statement  "	if (s_MouseClick == null && s_MouseDown == null && s_MouseMove == null && s_MouseUp == null && s_MouseClickExt == null && s_MouseMoveExt == null && s_MouseWheel == null) { " is 171.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,ForceUnsunscribeFromGlobalMouseEvents,The length of the statement  "			//Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.  " is 148.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The length of the statement  "		KeyboardHookStruct MyKeyboardHookStruct = (KeyboardHookStruct)Marshal.PtrToStructure (lParam' typeof(KeyboardHookStruct)); " is 122.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The length of the statement  "			if (ToAscii (MyKeyboardHookStruct.VirtualKeyCode' MyKeyboardHookStruct.ScanCode' keyState' inBuffer' MyKeyboardHookStruct.Flags) == 1) { " is 136.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,EnsureSubscribedToGlobalKeyboardEvents,The length of the statement  "		s_KeyboardHookHandle = SetWindowsHookEx (WH_KEYBOARD_LL' s_KeyboardDelegate' GetModuleHandle (Process.GetCurrentProcess ().MainModule.ModuleName)' 0); " is 150.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,EnsureSubscribedToGlobalKeyboardEvents,The length of the statement  "			//Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.  " is 148.
Long Statement,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,ForceUnsunscribeFromGlobalKeyboardEvents,The length of the statement  "			//Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.  " is 148.
Complex Conditional,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The conditional expression  "(s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)"  is complex.
Complex Conditional,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,TryUnsubscribeFromGlobalMouseEvents,The conditional expression  "s_MouseClick == null && s_MouseDown == null && s_MouseMove == null && s_MouseUp == null && s_MouseClickExt == null && s_MouseMoveExt == null && s_MouseWheel == null"  is complex.
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//Marshall the data from callback.  	MouseLLHookStruct mouseHookStruct = (MouseLLHookStruct)Marshal.PtrToStructure (lParam' typeof(MouseLLHookStruct));  	//detect button clicked  	MouseButtons button = MouseButtons.None;  	short mouseDelta = 0;  	int clickCount = 0;  	bool mouseDown = false;  	bool mouseUp = false;  	switch (wParam) {  	case WM_LBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONDBLCLK:  		button = MouseButtons.Left;  		clickCount = 2;  		break;  	case WM_RBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONDBLCLK:  		button = MouseButtons.Right;  		clickCount = 2;  		break;  	case WM_MOUSEWHEEL:  		//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   		//One wheel click is defined as WHEEL_DELTA' which is 120.   		//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  		mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  		//TODO: X BUTTONS (I havent them so was unable to test)  		//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   		//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   		//and the low-order word is reserved. This value can be one or more of the following values.   		//Otherwise' MouseData is not used.   		break;  	}  	//generate event   	MouseEventExtArgs e = new MouseEventExtArgs (button' clickCount' mouseHookStruct.Point.X' mouseHookStruct.Point.Y' mouseDelta);  	//Mouse up  	if (s_MouseUp != null && mouseUp) {  		s_MouseUp.Invoke (null' e);  	}  	//Mouse down  	if (s_MouseDown != null && mouseDown) {  		s_MouseDown.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClick != null && clickCount > 0) {  		s_MouseClick.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClickExt != null && clickCount > 0) {  		s_MouseClickExt.Invoke (null' e);  	}  	//If someone listens to double click and a click is heppened  	if (s_MouseDoubleClick != null && clickCount == 2) {  		s_MouseDoubleClick.Invoke (null' e);  	}  	//Wheel was moved  	if (s_MouseWheel != null && mouseDelta != 0) {  		s_MouseWheel.Invoke (null' e);  	}  	//If someone listens to move and there was a change in coordinates raise move event  	if ((s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)) {  		m_OldX = mouseHookStruct.Point.X;  		m_OldY = mouseHookStruct.Point.Y;  		if (s_MouseMove != null) {  			s_MouseMove.Invoke (null' e);  		}  		if (s_MouseMoveExt != null) {  			s_MouseMoveExt.Invoke (null' e);  		}  	}  	if (e.Handled) {  		return -1;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//Marshall the data from callback.  	MouseLLHookStruct mouseHookStruct = (MouseLLHookStruct)Marshal.PtrToStructure (lParam' typeof(MouseLLHookStruct));  	//detect button clicked  	MouseButtons button = MouseButtons.None;  	short mouseDelta = 0;  	int clickCount = 0;  	bool mouseDown = false;  	bool mouseUp = false;  	switch (wParam) {  	case WM_LBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONDBLCLK:  		button = MouseButtons.Left;  		clickCount = 2;  		break;  	case WM_RBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONDBLCLK:  		button = MouseButtons.Right;  		clickCount = 2;  		break;  	case WM_MOUSEWHEEL:  		//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   		//One wheel click is defined as WHEEL_DELTA' which is 120.   		//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  		mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  		//TODO: X BUTTONS (I havent them so was unable to test)  		//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   		//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   		//and the low-order word is reserved. This value can be one or more of the following values.   		//Otherwise' MouseData is not used.   		break;  	}  	//generate event   	MouseEventExtArgs e = new MouseEventExtArgs (button' clickCount' mouseHookStruct.Point.X' mouseHookStruct.Point.Y' mouseDelta);  	//Mouse up  	if (s_MouseUp != null && mouseUp) {  		s_MouseUp.Invoke (null' e);  	}  	//Mouse down  	if (s_MouseDown != null && mouseDown) {  		s_MouseDown.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClick != null && clickCount > 0) {  		s_MouseClick.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClickExt != null && clickCount > 0) {  		s_MouseClickExt.Invoke (null' e);  	}  	//If someone listens to double click and a click is heppened  	if (s_MouseDoubleClick != null && clickCount == 2) {  		s_MouseDoubleClick.Invoke (null' e);  	}  	//Wheel was moved  	if (s_MouseWheel != null && mouseDelta != 0) {  		s_MouseWheel.Invoke (null' e);  	}  	//If someone listens to move and there was a change in coordinates raise move event  	if ((s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)) {  		m_OldX = mouseHookStruct.Point.X;  		m_OldY = mouseHookStruct.Point.Y;  		if (s_MouseMove != null) {  			s_MouseMove.Invoke (null' e);  		}  		if (s_MouseMoveExt != null) {  			s_MouseMoveExt.Invoke (null' e);  		}  	}  	if (e.Handled) {  		return -1;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//Marshall the data from callback.  	MouseLLHookStruct mouseHookStruct = (MouseLLHookStruct)Marshal.PtrToStructure (lParam' typeof(MouseLLHookStruct));  	//detect button clicked  	MouseButtons button = MouseButtons.None;  	short mouseDelta = 0;  	int clickCount = 0;  	bool mouseDown = false;  	bool mouseUp = false;  	switch (wParam) {  	case WM_LBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONDBLCLK:  		button = MouseButtons.Left;  		clickCount = 2;  		break;  	case WM_RBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONDBLCLK:  		button = MouseButtons.Right;  		clickCount = 2;  		break;  	case WM_MOUSEWHEEL:  		//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   		//One wheel click is defined as WHEEL_DELTA' which is 120.   		//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  		mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  		//TODO: X BUTTONS (I havent them so was unable to test)  		//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   		//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   		//and the low-order word is reserved. This value can be one or more of the following values.   		//Otherwise' MouseData is not used.   		break;  	}  	//generate event   	MouseEventExtArgs e = new MouseEventExtArgs (button' clickCount' mouseHookStruct.Point.X' mouseHookStruct.Point.Y' mouseDelta);  	//Mouse up  	if (s_MouseUp != null && mouseUp) {  		s_MouseUp.Invoke (null' e);  	}  	//Mouse down  	if (s_MouseDown != null && mouseDown) {  		s_MouseDown.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClick != null && clickCount > 0) {  		s_MouseClick.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClickExt != null && clickCount > 0) {  		s_MouseClickExt.Invoke (null' e);  	}  	//If someone listens to double click and a click is heppened  	if (s_MouseDoubleClick != null && clickCount == 2) {  		s_MouseDoubleClick.Invoke (null' e);  	}  	//Wheel was moved  	if (s_MouseWheel != null && mouseDelta != 0) {  		s_MouseWheel.Invoke (null' e);  	}  	//If someone listens to move and there was a change in coordinates raise move event  	if ((s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)) {  		m_OldX = mouseHookStruct.Point.X;  		m_OldY = mouseHookStruct.Point.Y;  		if (s_MouseMove != null) {  			s_MouseMove.Invoke (null' e);  		}  		if (s_MouseMoveExt != null) {  			s_MouseMoveExt.Invoke (null' e);  		}  	}  	if (e.Handled) {  		return -1;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//Marshall the data from callback.  	MouseLLHookStruct mouseHookStruct = (MouseLLHookStruct)Marshal.PtrToStructure (lParam' typeof(MouseLLHookStruct));  	//detect button clicked  	MouseButtons button = MouseButtons.None;  	short mouseDelta = 0;  	int clickCount = 0;  	bool mouseDown = false;  	bool mouseUp = false;  	switch (wParam) {  	case WM_LBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Left;  		clickCount = 1;  		break;  	case WM_LBUTTONDBLCLK:  		button = MouseButtons.Left;  		clickCount = 2;  		break;  	case WM_RBUTTONDOWN:  		mouseDown = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONUP:  		mouseUp = true;  		button = MouseButtons.Right;  		clickCount = 1;  		break;  	case WM_RBUTTONDBLCLK:  		button = MouseButtons.Right;  		clickCount = 2;  		break;  	case WM_MOUSEWHEEL:  		//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   		//One wheel click is defined as WHEEL_DELTA' which is 120.   		//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  		mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  		//TODO: X BUTTONS (I havent them so was unable to test)  		//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   		//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   		//and the low-order word is reserved. This value can be one or more of the following values.   		//Otherwise' MouseData is not used.   		break;  	}  	//generate event   	MouseEventExtArgs e = new MouseEventExtArgs (button' clickCount' mouseHookStruct.Point.X' mouseHookStruct.Point.Y' mouseDelta);  	//Mouse up  	if (s_MouseUp != null && mouseUp) {  		s_MouseUp.Invoke (null' e);  	}  	//Mouse down  	if (s_MouseDown != null && mouseDown) {  		s_MouseDown.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClick != null && clickCount > 0) {  		s_MouseClick.Invoke (null' e);  	}  	//If someone listens to click and a click is heppened  	if (s_MouseClickExt != null && clickCount > 0) {  		s_MouseClickExt.Invoke (null' e);  	}  	//If someone listens to double click and a click is heppened  	if (s_MouseDoubleClick != null && clickCount == 2) {  		s_MouseDoubleClick.Invoke (null' e);  	}  	//Wheel was moved  	if (s_MouseWheel != null && mouseDelta != 0) {  		s_MouseWheel.Invoke (null' e);  	}  	//If someone listens to move and there was a change in coordinates raise move event  	if ((s_MouseMove != null || s_MouseMoveExt != null) && (m_OldX != mouseHookStruct.Point.X || m_OldY != mouseHookStruct.Point.Y)) {  		m_OldX = mouseHookStruct.Point.X;  		m_OldY = mouseHookStruct.Point.Y;  		if (s_MouseMove != null) {  			s_MouseMove.Invoke (null' e);  		}  		if (s_MouseMoveExt != null) {  			s_MouseMoveExt.Invoke (null' e);  		}  	}  	if (e.Handled) {  		return -1;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: switch (wParam) {  case WM_LBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONDBLCLK:  	button = MouseButtons.Left;  	clickCount = 2;  	break;  case WM_RBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONDBLCLK:  	button = MouseButtons.Right;  	clickCount = 2;  	break;  case WM_MOUSEWHEEL:  	//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   	//One wheel click is defined as WHEEL_DELTA' which is 120.   	//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  	mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  	//TODO: X BUTTONS (I havent them so was unable to test)  	//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   	//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   	//and the low-order word is reserved. This value can be one or more of the following values.   	//Otherwise' MouseData is not used.   	break;  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: switch (wParam) {  case WM_LBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONDBLCLK:  	button = MouseButtons.Left;  	clickCount = 2;  	break;  case WM_RBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONDBLCLK:  	button = MouseButtons.Right;  	clickCount = 2;  	break;  case WM_MOUSEWHEEL:  	//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   	//One wheel click is defined as WHEEL_DELTA' which is 120.   	//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  	mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  	//TODO: X BUTTONS (I havent them so was unable to test)  	//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   	//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   	//and the low-order word is reserved. This value can be one or more of the following values.   	//Otherwise' MouseData is not used.   	break;  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: switch (wParam) {  case WM_LBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONDBLCLK:  	button = MouseButtons.Left;  	clickCount = 2;  	break;  case WM_RBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONDBLCLK:  	button = MouseButtons.Right;  	clickCount = 2;  	break;  case WM_MOUSEWHEEL:  	//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   	//One wheel click is defined as WHEEL_DELTA' which is 120.   	//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  	mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  	//TODO: X BUTTONS (I havent them so was unable to test)  	//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   	//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   	//and the low-order word is reserved. This value can be one or more of the following values.   	//Otherwise' MouseData is not used.   	break;  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: clickCount = 2;  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: clickCount = 2;  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following statement contains a magic number: if (s_MouseDoubleClick != null && clickCount == 2) {  	s_MouseDoubleClick.Invoke (null' e);  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//read structure KeyboardHookStruct at lParam  	KeyboardHookStruct MyKeyboardHookStruct = (KeyboardHookStruct)Marshal.PtrToStructure (lParam' typeof(KeyboardHookStruct));  	//raise KeyDown  	if (s_KeyDown != null && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {  		Keys keyData = (Keys)MyKeyboardHookStruct.VirtualKeyCode;  		KeyEventArgs e = new KeyEventArgs (keyData);  		s_KeyDown.Invoke (null' e);  		handled = e.Handled;  	}  	// raise KeyPress  	if (s_KeyPress != null && wParam == WM_KEYDOWN) {  		bool isDownShift = ((GetKeyState (VK_SHIFT) & 0x80) == 0x80 ? true : false);  		bool isDownCapslock = (GetKeyState (VK_CAPITAL) != 0 ? true : false);  		byte[] keyState = new byte[256];  		GetKeyboardState (keyState);  		byte[] inBuffer = new byte[2];  		if (ToAscii (MyKeyboardHookStruct.VirtualKeyCode' MyKeyboardHookStruct.ScanCode' keyState' inBuffer' MyKeyboardHookStruct.Flags) == 1) {  			char key = (char)inBuffer [0];  			if ((isDownCapslock ^ isDownShift) && Char.IsLetter (key))  				key = Char.ToUpper (key);  			KeyPressEventArgs e = new KeyPressEventArgs (key);  			s_KeyPress.Invoke (null' e);  			handled = handled || e.Handled;  		}  	}  	// raise KeyUp  	if (s_KeyUp != null && (wParam == WM_KEYUP || wParam == WM_SYSKEYUP)) {  		Keys keyData = (Keys)MyKeyboardHookStruct.VirtualKeyCode;  		KeyEventArgs e = new KeyEventArgs (keyData);  		s_KeyUp.Invoke (null' e);  		handled = handled || e.Handled;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The following statement contains a magic number: if (nCode >= 0) {  	//read structure KeyboardHookStruct at lParam  	KeyboardHookStruct MyKeyboardHookStruct = (KeyboardHookStruct)Marshal.PtrToStructure (lParam' typeof(KeyboardHookStruct));  	//raise KeyDown  	if (s_KeyDown != null && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {  		Keys keyData = (Keys)MyKeyboardHookStruct.VirtualKeyCode;  		KeyEventArgs e = new KeyEventArgs (keyData);  		s_KeyDown.Invoke (null' e);  		handled = e.Handled;  	}  	// raise KeyPress  	if (s_KeyPress != null && wParam == WM_KEYDOWN) {  		bool isDownShift = ((GetKeyState (VK_SHIFT) & 0x80) == 0x80 ? true : false);  		bool isDownCapslock = (GetKeyState (VK_CAPITAL) != 0 ? true : false);  		byte[] keyState = new byte[256];  		GetKeyboardState (keyState);  		byte[] inBuffer = new byte[2];  		if (ToAscii (MyKeyboardHookStruct.VirtualKeyCode' MyKeyboardHookStruct.ScanCode' keyState' inBuffer' MyKeyboardHookStruct.Flags) == 1) {  			char key = (char)inBuffer [0];  			if ((isDownCapslock ^ isDownShift) && Char.IsLetter (key))  				key = Char.ToUpper (key);  			KeyPressEventArgs e = new KeyPressEventArgs (key);  			s_KeyPress.Invoke (null' e);  			handled = handled || e.Handled;  		}  	}  	// raise KeyUp  	if (s_KeyUp != null && (wParam == WM_KEYUP || wParam == WM_SYSKEYUP)) {  		Keys keyData = (Keys)MyKeyboardHookStruct.VirtualKeyCode;  		KeyEventArgs e = new KeyEventArgs (keyData);  		s_KeyUp.Invoke (null' e);  		handled = handled || e.Handled;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The following statement contains a magic number: if (s_KeyPress != null && wParam == WM_KEYDOWN) {  	bool isDownShift = ((GetKeyState (VK_SHIFT) & 0x80) == 0x80 ? true : false);  	bool isDownCapslock = (GetKeyState (VK_CAPITAL) != 0 ? true : false);  	byte[] keyState = new byte[256];  	GetKeyboardState (keyState);  	byte[] inBuffer = new byte[2];  	if (ToAscii (MyKeyboardHookStruct.VirtualKeyCode' MyKeyboardHookStruct.ScanCode' keyState' inBuffer' MyKeyboardHookStruct.Flags) == 1) {  		char key = (char)inBuffer [0];  		if ((isDownCapslock ^ isDownShift) && Char.IsLetter (key))  			key = Char.ToUpper (key);  		KeyPressEventArgs e = new KeyPressEventArgs (key);  		s_KeyPress.Invoke (null' e);  		handled = handled || e.Handled;  	}  }  
Magic Number,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,KeyboardHookProc,The following statement contains a magic number: if (s_KeyPress != null && wParam == WM_KEYDOWN) {  	bool isDownShift = ((GetKeyState (VK_SHIFT) & 0x80) == 0x80 ? true : false);  	bool isDownCapslock = (GetKeyState (VK_CAPITAL) != 0 ? true : false);  	byte[] keyState = new byte[256];  	GetKeyboardState (keyState);  	byte[] inBuffer = new byte[2];  	if (ToAscii (MyKeyboardHookStruct.VirtualKeyCode' MyKeyboardHookStruct.ScanCode' keyState' inBuffer' MyKeyboardHookStruct.Flags) == 1) {  		char key = (char)inBuffer [0];  		if ((isDownCapslock ^ isDownShift) && Char.IsLetter (key))  			key = Char.ToUpper (key);  		KeyPressEventArgs e = new KeyPressEventArgs (key);  		s_KeyPress.Invoke (null' e);  		handled = handled || e.Handled;  	}  }  
Missing Default,Gma.UserActivityMonitor,HookManager,C:\repos\maxtyutmanov_Addicto\Gma.UserActivityMonitor\HookManager.Callbacks.cs,MouseHookProc,The following switch statement is missing a default case: switch (wParam) {  case WM_LBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Left;  	clickCount = 1;  	break;  case WM_LBUTTONDBLCLK:  	button = MouseButtons.Left;  	clickCount = 2;  	break;  case WM_RBUTTONDOWN:  	mouseDown = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONUP:  	mouseUp = true;  	button = MouseButtons.Right;  	clickCount = 1;  	break;  case WM_RBUTTONDBLCLK:  	button = MouseButtons.Right;  	clickCount = 2;  	break;  case WM_MOUSEWHEEL:  	//If the message is WM_MOUSEWHEEL' the high-order word of MouseData member is the wheel delta.   	//One wheel click is defined as WHEEL_DELTA' which is 120.   	//(value >> 16) & 0xffff; retrieves the high-order word from the given 32-bit value  	mouseDelta = (short)((mouseHookStruct.MouseData >> 16) & 0xffff);  	//TODO: X BUTTONS (I havent them so was unable to test)  	//If the message is WM_XBUTTONDOWN' WM_XBUTTONUP' WM_XBUTTONDBLCLK' WM_NCXBUTTONDOWN' WM_NCXBUTTONUP'   	//or WM_NCXBUTTONDBLCLK' the high-order word specifies which X button was pressed or released'   	//and the low-order word is reserved. This value can be one or more of the following values.   	//Otherwise' MouseData is not used.   	break;  }  
