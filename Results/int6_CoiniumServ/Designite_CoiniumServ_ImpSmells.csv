Implementation smell,Namespace,Class,File,Method,Description
Long Method,CoiniumServ.Server.Web.Modules,PoolModule,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\Modules\PoolModule.cs,PoolModule,The method has 210 lines of code.
Long Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The method has 197 lines of code.
Complex Method,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,Run,Cyclomatic complexity of the method is 13
Complex Method,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,QueryBlock,Cyclomatic complexity of the method is 12
Complex Method,CoiniumServ.Utils.Extensions,LinqExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\LinqExtensions.cs,MaxBy,Cyclomatic complexity of the method is 9
Complex Method,CoiniumServ.Utils.Extensions,JsonExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\JsonExtensions.cs,PrettifyJson,Cyclomatic complexity of the method is 33
Complex Method,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadPoolConfigs,Cyclomatic complexity of the method is 8
Complex Method,CoiniumServ.Mining.Software,MiningSoftware,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Mining\Software\MiningSoftware.cs,MiningSoftware,Cyclomatic complexity of the method is 16
Complex Method,CoiniumServ.Daemon,DaemonBase,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonBase.cs,GetJsonResponse,Cyclomatic complexity of the method is 10
Complex Method,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,Cyclomatic complexity of the method is 8
Complex Method,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,HandleInvalidShare,Cyclomatic complexity of the method is 21
Complex Method,CoiniumServ.Server.Mining.Stratum,StratumMiner,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumMiner.cs,Subscribe,Cyclomatic complexity of the method is 16
Complex Method,CoiniumServ.Logging,LogTarget,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogTarget.cs,LogTarget,Cyclomatic complexity of the method is 26
Complex Method,CoiniumServ.Logging,LogManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogManager.cs,EmitConfiguration,Cyclomatic complexity of the method is 10
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 17
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,Cyclomatic complexity of the method is 48
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CheckStyle,Cyclomatic complexity of the method is 8
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindExponent,Cyclomatic complexity of the method is 10
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,Cyclomatic complexity of the method is 16
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivRem,Cyclomatic complexity of the method is 10
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GreatestCommonDivisor,Cyclomatic complexity of the method is 9
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,Cyclomatic complexity of the method is 11
Complex Method,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,Cyclomatic complexity of the method is 11
Long Parameter List,CoiniumServ.Markets.Exchanges,ExchangeApi,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\Exchanges\ExchangeApi.cs,Request,The method has 5 parameters.
Long Parameter List,CoiniumServ.Container,IObjectFactory,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Container\IObjectFactory.cs,GetJobManager,The method has 6 parameters.
Long Parameter List,CoiniumServ.Container,IObjectFactory,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Container\IObjectFactory.cs,GetMiningServer,The method has 6 parameters.
Long Parameter List,CoiniumServ.Container,ObjectFactory,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Container\ObjectFactory.cs,GetJobManager,The method has 6 parameters.
Long Parameter List,CoiniumServ.Container,ObjectFactory,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Container\ObjectFactory.cs,GetMiningServer,The method has 6 parameters.
Long Parameter List,CoiniumServ.Jobs.Manager,JobManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobManager.cs,JobManager,The method has 6 parameters.
Long Parameter List,CoiniumServ.Daemon,DaemonClient,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonClient.cs,Move,The method has 5 parameters.
Long Parameter List,CoiniumServ.Daemon,DaemonClient,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonClient.cs,SendFrom,The method has 6 parameters.
Long Parameter List,CoiniumServ.Payments,Payment,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\Payment.cs,Payment,The method has 5 parameters.
Long Parameter List,CoiniumServ.Persistance.Blocks,PersistedBlock,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Blocks\PersistedBlock.cs,PersistedBlock,The method has 9 parameters.
Long Parameter List,CoiniumServ.Persistance.Blocks,PersistedBlock,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Blocks\PersistedBlock.cs,PersistedBlock,The method has 5 parameters.
Long Parameter List,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The method has 6 parameters.
Long Parameter List,CoiniumServ.Shares,IShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\IShareManager.cs,ProcessShare,The method has 5 parameters.
Long Parameter List,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,ProcessShare,The method has 5 parameters.
Long Parameter List,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Send,The method has 5 parameters.
Long Parameter List,CoiniumServ.Server.Mining.Stratum,StratumMiner,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumMiner.cs,StratumMiner,The method has 6 parameters.
Long Parameter List,CoiniumServ.Server.Mining.Stratum,StratumService,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumService.cs,SubmitWork,The method has 5 parameters.
Long Parameter List,CoiniumServ.Server.Mining.Stratum,StratumServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumServer.cs,StratumServer,The method has 5 parameters.
Long Parameter List,CoiniumServ.Transactions.Script,SignatureScript,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\Script\SignatureScript.cs,SignatureScript,The method has 5 parameters.
Long Parameter List,CoiniumServ.Cryptology,Utils,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Utils.cs,DoubleDigestTwoBuffers,The method has 6 parameters.
Long Parameter List,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The method has 6 parameters.
Long Parameter List,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,JumpOverWhite,The method has 5 parameters.
Long Parameter List,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindSign,The method has 5 parameters.
Long Parameter List,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindExponent,The method has 5 parameters.
Long Parameter List,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The method has 5 parameters.
Long Statement,CoiniumServ.Algorithms,AlgorithmRegistry,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\AlgorithmRegistry.cs,RegisterInstances,The length of the statement  "	// available cryptographic hash functions: http://en.wikipedia.org/wiki/List_of_hash_functions#Cryptographic_hash_functions " is 123.
Long Statement,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,Run,The length of the statement  "		_logger.Information ("Queried {0} pending blocks; {1} got confirmed' {2} got orphaned; took {3:0.000} seconds"' pendingCount' confirmedCount' orphanedCount' (float)_stopWatch.ElapsedMilliseconds / 1000); " is 203.
Long Statement,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,FindPoolAccount,The length of the statement  "		_logger.Error ("Error getting account for pool central wallet address: {0:l} - {1:l}"' _poolConfig.Wallet.Adress' e.Message); " is 125.
Long Statement,CoiniumServ.Markets,MarketManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\MarketManager.cs,GetMarketsFor,The length of the statement  "	return _storage.Where (x => x.MarketCurrency == marketCurrency && x.BaseCurrency == baseCurrency).OrderByDescending (x => x.Bid); " is 129.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M001CreateBlocksTable,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M001CreateBlocksTable.cs,Up,The length of the statement  "	Create.Table ("blocks").WithColumn ("id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("height").AsInt32 ().NotNullable ().WithColumn ("orphaned").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("confirmed").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("blockHash").AsString (65).NotNullable ().WithColumn ("txHash").AsString (65).NotNullable ().WithColumn ("amount").AsDecimal ().NotNullable ().WithColumn ("time").AsDateTime ().NotNullable (); " is 501.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The length of the statement  "	Create.Table ("Account").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("Username").AsString ().NotNullable ().Unique ().WithColumn ("Address").AsString (34).NotNullable ().Unique ().WithColumn ("CreatedAt").AsDateTime ().NotNullable (); " is 272.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The length of the statement  "	Create.Table ("Payment").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("Block").AsInt32 ().ForeignKey ("Block"' "Height").WithColumn ("AccountId").AsInt32 ().ForeignKey ("Account"' "Id").WithColumn ("Amount").AsDecimal ().NotNullable ().WithColumn ("Completed").AsBoolean ().NotNullable ().WithColumn ("CreatedAt").AsDateTime ().NotNullable (); " is 380.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The length of the statement  "	Create.Table ("Transaction").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("AccountId").AsInt32 ().ForeignKey ("Account"' "Id").WithColumn ("PaymentId").AsInt32 ().ForeignKey ("Payment"' "Id").WithColumn ("Amount").AsDecimal ().NotNullable ().WithColumn ("Currency").AsString (4).NotNullable ().WithColumn ("TxHash").AsString (64).NotNullable ().WithColumn ("CreatedAt").AsDateTime ().NotNullable (); " is 436.
Long Statement,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,PrintNetworkInfo,The length of the statement  "	_logger.Information ("symbol: {0:l} algorithm: {1:l} " + "version: {2:l} protocol: {3} wallet: {4} " + "network difficulty: {5:0.00000000} block difficulty: {6:0.00} network hashrate: {7:l} " + "network: {8:l} peers: {9} blocks: {10} errors: {11:l} "' _poolConfig.Coin.Symbol' _poolConfig.Coin.Algorithm' CoinVersion' ProtocolVersion' WalletVersion' Difficulty' Difficulty * _hashAlgorithm.Multiplier' Hashrate.GetReadableHashrate ()' Testnet ? "testnet" : "mainnet"' Connections' Round - 1' string.IsNullOrEmpty (Errors) ? "none" : Errors); " is 541.
Long Statement,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,DetectSubmitBlockSupport,The length of the statement  "	// If the coin supports the submitblock() call it's should return a RPC_DESERIALIZATION_ERROR (-22) - 'Block decode failed' as we just supplied an empty string as block hash. " is 174.
Long Statement,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,DetectSubmitBlockSupport,The length of the statement  "	// otherwise if it doesn't support the call' it should return a RPC_METHOD_NOT_FOUND (-32601) - 'Method not found' error. " is 121.
Long Statement,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,DetectProofOfStakeCoin,The length of the statement  "		/*  By default proof-of-work coins return a floating point as difficulty (https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_lis)." is 140.
Long Statement,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitStorage,The length of the statement  "	var providers = Config.Storage.Layer.Providers.Select (providerConfig => _objectFactory.GetStorageProvider (providerConfig is IMySqlProviderConfig ? StorageProviders.MySql : StorageProviders.Redis' Config' providerConfig)).ToList (); " is 233.
Long Statement,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitNetworkServers,The length of the statement  "		var stratumServer = _objectFactory.GetMiningServer ("Stratum"' Config' this' MinerManager' _jobManager' _banningManager); " is 121.
Long Statement,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitNetworkServers,The length of the statement  "		var getworkServer = _objectFactory.GetMiningServer ("Getwork"' Config' this' MinerManager' _jobManager' _banningManager); " is 121.
Long Statement,CoiniumServ.Utils.Helpers,Enforce,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Enforce.cs,HasItems,The length of the statement  "		throw new ArgumentException (string.Format ("{0} does not contain elements and elements are required. Check the consuming class."' name)); " is 138.
Long Statement,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadGlobalConfig,The length of the statement  "		_logger.Error ("Couldn't read config/config.json! Make sure you rename config/config-example.json as config/config.json."); " is 123.
Long Statement,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadGlobalConfig,The length of the statement  "	_logger.Information ("CoiniumServ {0:l} {1:l} warming-up.."' VersionInfo.CodeName' Assembly.GetAssembly (typeof(Program)).GetName ().Version); " is 142.
Long Statement,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadPoolConfigs,The length of the statement  "			_logger.Error ("Referenced coin configuration file coins/{0:l}.json doesn't exist' skipping pool configuration: pools/{1:l}.json"' coinName' filename); " is 151.
Long Statement,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadPoolConfigs,The length of the statement  "			_logger.Error ("coins/{0:l}.json doesnt't contain a valid coin configuration' skipping pool configuration: pools/{1:l}.json"' coinName' filename); " is 146.
Long Statement,CoiniumServ.Configuration,ConfigManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Configuration\ConfigManager.cs,LoadPoolConfigs,The length of the statement  "	_logger.Information ("Discovered a total of {0} enabled pool configurations: {1:l}"' PoolConfigs.Count' PoolConfigs.Select (config => config.Coin.Name).ToList ()); " is 163.
Long Statement,CoiniumServ.Daemon.Converters,TimeConverter,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Converters\TimeConverter.cs,ReadJson,The length of the statement  "	if (DateTime.TryParseExact (token.ToString ()' "yyyy-MM-dd HH:mm:ss UTC"' CultureInfo.InvariantCulture' DateTimeStyles.AdjustToUniversal' out dateTime)) " is 152.
Long Statement,CoiniumServ.Container,ObjectFactory,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Container\ObjectFactory.cs,GetStorageLayer,The length of the statement  "	return type != StorageLayers.Empty ? _applicationContext.Container.Resolve<IStorageLayer> (type' @params) : _applicationContext.Container.Resolve<IStorageLayer> (type); " is 168.
Long Statement,CoiniumServ.Banning,BanManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanManager.cs,OnShare,The length of the statement  "	if (invalidPercentage < Config.InvalidPercent)// if the miner didn't reach the invalid share percentage' reset his stats. " is 121.
Long Statement,CoiniumServ.Banning,BanManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanManager.cs,OnShare,The length of the statement  "		_logger.Information ("Banned miner {0:l} because of high percentage of invalid shares: {1}%."' miner.Username' invalidPercentage); " is 130.
Long Statement,CoiniumServ.Jobs.Manager,JobManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobManager.cs,CreateAndBroadcastNewJob,The length of the statement  "			_logger.Information ("Broadcasted new job 0x{0:x} to {1} subscribers as no new blocks found for last {2} seconds"' job.Id' count' _poolConfig.Job.RebroadcastTimeout); " is 166.
Long Statement,CoiniumServ.Mining,MinerManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Mining\MinerManager.cs,Authenticate,The length of the statement  "	_logger.Debug (miner.Authenticated ? "Authenticated miner: {0:l} [{1:l}]" : "Miner authentication failed: {0:l} [{1:l}]"' miner.Username' ((IClient)miner).Connection.RemoteEndPoint); " is 182.
Long Statement,CoiniumServ.Daemon,DaemonClient,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonClient.cs,GetBalance,The length of the statement  "	return string.IsNullOrEmpty (account) ? MakeRequest<decimal> ("getbalance"' EmptyString) : MakeRequest<decimal> ("getbalance"' account); " is 136.
Long Statement,CoiniumServ.Daemon,DaemonClient,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonClient.cs,GetBlockTemplate,The length of the statement  "		// bitcoin variants can accept capabilities: https://github.com/bitcoin/bitcoin/blob/7388b74cd2c5e3b71e991d26953c89c059ba6f2f/src/rpcmining.cpp#L298             " is 148.
Long Statement,CoiniumServ.Daemon,DaemonBase,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonBase.cs,MakeHttpRequest,The length of the statement  "	webRequest.UserAgent = string.Format ("CoiniumServ {0:} {1:}"' VersionInfo.CodeName' Assembly.GetAssembly (typeof(Program)).GetName ().Version); " is 144.
Long Statement,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,Run,The length of the statement  "		_logger.Information ("Executed {0} payments' took {1:0.000} seconds"' executedPayments.Count' (float)_stopWatch.ElapsedMilliseconds / 1000); " is 140.
Long Statement,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,GetTransactionCandidates,The length of the statement  "			if (!perUserTransactions.ContainsKey (user.Username))// check if our list of transactions to be executed already contains an entry for the user. " is 144.
Long Statement,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,ExecutePayments,The length of the statement  "		var filtered = paymentsToExecute.Where (x => x.Value.Sum (y => y.Payment.Amount) >= (decimal)_poolConfig.Payments.Minimum).ToDictionary (x => x.Key' x => x.Value); " is 163.
Long Statement,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,ValidatePoolAddress,The length of the statement  "		_logger.Error ("Halted as daemon we are connected to does not own the pool address: {0:l}."' _poolConfig.Wallet.Adress); " is 120.
Long Statement,CoiniumServ.Payments,BlockAccounter,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\BlockAccounter.cs,Run,The length of the statement  "	var rounds = unpaidBlocks.Select (block => _objectFactory.GetPaymentRound (block' _storageLayer' _accountManager)).ToList (); " is 125.
Long Statement,CoiniumServ.Payments,BlockAccounter,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\BlockAccounter.cs,Run,The length of the statement  "		_logger.Information ("Accounted {0} confirmed rounds' took {1:0.000} seconds"' rounds.Count' (float)_stopWatch.ElapsedMilliseconds / 1000); " is 139.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddAccount,The length of the statement  "			connection.Execute (@"INSERT INTO Account(Username' Address' CreatedAt) VALUES (@username' @address' @createdAt)"' new { " is 120.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddBlock,The length of the statement  "			connection.Execute (@"INSERT INTO Block(Height' BlockHash' TxHash' Amount' CreatedAt) VALUES (@height' @blockHash' @txHash' @amount' @createdAt)"' new { " is 152.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,UpdateBlock,The length of the statement  "			connection.Execute (@"UPDATE Block SET Orphaned = @orphaned' Confirmed = @confirmed' Accounted = @accounted' Reward = @reward WHERE Height = @height"' new { " is 156.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetBlock,The length of the statement  "			return connection.Query<PersistedBlock> (@"SELECT Height' Orphaned' Confirmed' Accounted' BlockHash' TxHash' Amount' Reward' CreatedAt From Block WHERE Height = @height"' new { " is 176.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetBlocks,The length of the statement  "			var results = connection.Query<PersistedBlock> (@"SELECT Height' Orphaned' Confirmed' Accounted' BlockHash' TxHash' Amount' Reward' CreatedAt From Block " is 152.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPaidBlocks,The length of the statement  "			var results = connection.Query<PersistedBlock> (@"SELECT b.Height' b.Orphaned' b.Confirmed' b.Accounted' b.BlockHash' b.TxHash' b.Amount' b.Reward' b.CreatedAt " is 159.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetUnpaidBlocks,The length of the statement  "			var results = connection.Query<PersistedBlock> (@"SELECT Height' Orphaned' Confirmed' Accounted' BlockHash' TxHash' Amount' Reward' CreatedAt " is 141.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPendingBlocks,The length of the statement  "			var results = connection.Query<PersistedBlock> (@"SELECT Height' Orphaned' Confirmed' Accounted' BlockHash' TxHash' Amount' Reward' CreatedAt " is 141.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddPayment,The length of the statement  "			connection.Execute (@"INSERT INTO Payment(Block' AccountId' Amount' CreatedAt) VALUES(@blockId' @accountId' @amount' @createdAt)"' new { " is 136.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPendingPayments,The length of the statement  "			var results = connection.Query<Payment> (@"SELECT Id' Block' AccountId' Amount' Completed FROM Payment Where Completed = false ORDER BY Id ASC"); " is 145.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPaymentsForBlock,The length of the statement  "			var results = connection.Query<PaymentDetails> (@"SELECT p.Id as PaymentId' t.Id as TransactionId' p.AccountId' a.Address' p.Block' p.Amount as Amount' " is 151.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPaymentsForAccount,The length of the statement  "			var results = connection.Query<PaymentDetails> (@"SELECT p.Id as PaymentId' t.Id as TransactionId' p.AccountId' a.Address' p.Block' p.Amount as Amount' " is 151.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPaymentDetailsByTransactionId,The length of the statement  "			return connection.Query<PaymentDetails> (@"SELECT p.Id as PaymentId' t.Id as TransactionId' p.AccountId' a.Address' p.Block' p.Amount as Amount' " is 144.
Long Statement,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetPaymentDetailsByPaymentId,The length of the statement  "			return connection.Query<PaymentDetails> (@"SELECT p.Id as PaymentId' t.Id as TransactionId' p.AccountId' a.Address' p.Block' p.Amount as Amount' " is 144.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,GetUnpaidBlocks,The length of the statement  "	// this function is not supported as this functionality is only required by payment processors which mpos itself is already one so and handles itself. " is 150.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,AddPayment,The length of the statement  "	// this function is not supported as this functionality is only required by payment processors which mpos itself is already one so and handles itself. " is 150.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,UpdatePayment,The length of the statement  "	// this function is not supported as this functionality is only required by payment processors which mpos itself is already one so and handles itself. " is 150.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,AddTransaction,The length of the statement  "	// this function is not supported as this functionality is only required by payment processors which mpos itself is already one so and handles itself. " is 150.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,AddShare,The length of the statement  "			connection.Execute (@"INSERT INTO shares(rem_host' username' our_result' upstream_result' reason' solution' difficulty'time)" is 124.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,GetShares,The length of the statement  "	// this function is not supported as this functionality is only required by payment processors which mpos itself is already one so and handles itself. " is 150.
Long Statement,CoiniumServ.Persistance.Layers.Mpos,MposStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Mpos\MposStorage.Blocks.cs,GetHashrateData,The length of the statement  "			var results = connection.Query (@"SELECT username' sum(difficulty) AS shares FROM shares WHERE our_result='Y' GROUP BY username"); " is 130.
Long Statement,CoiniumServ.Persistance.Providers.MySql,MySqlProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\MySql\MySqlProvider.cs,Initialize,The length of the statement  "		ConnectionString = string.Format ("Server={0};Port={1};Uid={2};Password={3};Database={4};"' _config.Host' _config.Port' _config.Username' _config.Password' _config.Database); " is 174.
Long Statement,CoiniumServ.Persistance.Providers.MySql,MySqlProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\MySql\MySqlProvider.cs,Initialize,The length of the statement  "			_logger.Information ("Mysql storage initialized: {0:l}:{1}' database: {2:l}."' _config.Host' _config.Port' _config.Database); " is 125.
Long Statement,CoiniumServ.Persistance.Providers.MySql,MySqlProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\MySql\MySqlProvider.cs,Initialize,The length of the statement  "		_logger.Error ("Mysql storage initialization failed: {0:l}:{1}' database: {2:l} - {3:l}"' _config.Host' _config.Port' _config.Database' e.Message); " is 147.
Long Statement,CoiniumServ.Daemon.Responses,Transaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\Transaction.cs,GetPoolOutput,The length of the statement  "	// case 1) some of bitcoin variants can include the "address" in the transaction detail and we can basically find the output comparing against it. " is 146.
Long Statement,CoiniumServ.Daemon.Responses,Transaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\Transaction.cs,GetPoolOutput,The length of the statement  "	// case 2) some other bitcoin variants can include "address account" name in transaction detail and we again find the output comparing against it. " is 146.
Long Statement,CoiniumServ.Jobs.Tracker,JobTracker,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Tracker\JobTracker.cs,CleanUp,The length of the statement  "	_jobs = _jobs.Where (j => j.Value.CreationTime >= delta || j.Value == Current).ToDictionary (kvp => kvp.Key' kvp => kvp.Value); " is 127.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "	// TODO: we should try different submission techniques and probably more then once: https://github.com/ahmedbodi/stratum-mining/blob/master/lib/bitcoin_rpc.py#L65-123 " is 166.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "		if (expectedTxHash != genTxHash)// make sure our calculated generated transaction and one reported by coin daemon matches. " is 122.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "			_logger.Debug ("Submitted block [{0}] doesn't seem to belong us as reported generation transaction hash [{1:l}] doesn't match our expected one [{2:l}]"' block.Height' genTxHash' expectedTxHash); " is 194.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "			_logger.Debug ("Submitted block [{0}] doesn't seem to belong us as we can't read the generation transaction on our records [{1:l}]"' block.Height' block.Tx.First ()); " is 166.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "			_logger.Debug ("Submitted block [{0}] doesn't seem to belong us as generation transaction doesn't contain an output for pool's central wallet address: {0:}"' block.Height' _poolConfig.Wallet.Adress); " is 199.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,SubmitBlock,The length of the statement  "		_logger.Debug ("We thought a block was found but it was rejected by the coin daemon; [{0:l}] - reason; {1:l}"' share.BlockHash.ToHexString ()' e.Message); " is 154.
Long Statement,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,FindPoolAccount,The length of the statement  "		_logger.Error ("Error getting account for pool central wallet address: {0:l} - {1:l}"' _poolConfig.Wallet.Adress' e.Message); " is 125.
Long Statement,CoiniumServ.Server.Web,NancyBootstrapper,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\NancyBootstrapper.cs,ApplicationStartup,The length of the statement  "		ctx.ViewBag.Title = string.IsNullOrEmpty (ctx.ViewBag.Header) ? _configManager.StackConfig.Name : string.Format ("{0} - {1}"' _configManager.StackConfig.Name' ctx.ViewBag.Header); " is 179.
Long Statement,CoiniumServ.Server.Web,NancyBootstrapper,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\NancyBootstrapper.cs,ConfigureConventions,The length of the statement  "	nancyConventions.StaticContentsConventions.Add (StaticContentConventionBuilder.AddFile ("/favicon.ico"' "/Content/favicon.ico")); " is 129.
Long Statement,CoiniumServ.Server.Web,NancyBootstrapper,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\NancyBootstrapper.cs,ConfigureConventions,The length of the statement  "	nancyConventions.StaticContentsConventions.Add (StaticContentConventionBuilder.AddFile ("/robots.txt"' "/Content/robots.txt")); " is 127.
Long Statement,CoiniumServ.Server.Web,WebServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\WebServer.cs,Start,The length of the statement  "		_logger.Error ("Need elevated privileges to listen on port {0}' try running as administrator - {1:l}"' Port' e.Message); " is 120.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,ConnectionDataEventArgs,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\ConnectionDataEventArgs.cs,ToString,The length of the statement  "	return Connection.RemoteEndPoint != null ? string.Format ("{0}: {1} bytes"' Connection.RemoteEndPoint' Data.Count ()) : string.Format ("Not Connected: {0} bytes"' Data.Count ()); " is 178.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// The “backlog” parameter to Socket.Listen is how many connections the OS may accept on behalf of the application. This is not  " is 127.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// the total number of active connections; it is only how many connections will be established if the application “gets behind”.  " is 128.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// The .NET docs fail to mention that int.MaxValue can be used to invoke the “dynamic backlog” feature (Windows Server systems only)'  " is 133.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// essentially leaving it up to the OS. It is tempting to set this value very high (e.g.' always passing int.MaxValue)' but this would  " is 134.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// hurt system performance (on non-server machines) by pre-allocating a large amount of scarce resources. This value should be set to a  " is 135.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,Listen,The length of the statement  "		// reasonable amount (usually between 2 and 5)' based on how many connections one is realistically expecting and how quickly they can be  " is 136.
Long Statement,CoiniumServ.Server.Mining.Stratum.Sockets,SocketServer,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\Sockets\SocketServer.cs,DisconnectAll,The length of the statement  "		foreach (var connection in Connections.ToList ())// using ToList() to get a copy in order to prevent any modified collection exceptions. " is 136.
Long Statement,CoiniumServ.Server.Mining.Stratum,StratumMiner,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumMiner.cs,ProcessRequest,The length of the statement  "		_logger.Error ("Disconnecting miner {0:l} as we recieved an invalid json-rpc request - {1:l}"' Username ?? Connection.RemoteEndPoint.ToString ()' e.Message); " is 157.
Long Statement,CoiniumServ.Server.Mining.Stratum,StratumMiner,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumMiner.cs,SetDifficulty,The length of the statement  "	// store the previous difficulty (so we can still accept shares targeted for last difficulty when vardiff sets a new difficulty). " is 129.
Long Statement,CoiniumServ.Server.Mining.Stratum,StratumService,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumService.cs,SubscribeMiner,The length of the statement  "		// Hex-encoded' per-connection unique string which will be used for coinbase serialization later. (http://mining.bitcoin.cz/stratum-mining) " is 139.
Long Statement,CoiniumServ.Server.Mining.Stratum,StratumService,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumService.cs,SubscribeMiner,The length of the statement  "	// Represents expected length of extranonce2 which will be generated by the miner. (http://mining.bitcoin.cz/stratum-mining) " is 124.
Long Statement,CoiniumServ.Jobs,ExtraNonce,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\ExtraNonce.cs,InitCounter,The length of the statement  "	// init the ExtraNonce counter - last 5 most-significant bits represents instanceId' the rest is just an iterator of jobs. " is 122.
Long Statement,CoiniumServ.Transactions,Outputs,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\Outputs.cs,Add,The length of the statement  "	var recipientScript = _coinConfig.Options.IsProofOfStakeHybrid && poolCentralAddress ? Coin.Coinbase.Utils.PubKeyToScript (result.PubKey) // pos coins use pubkey within script for pool central address. " is 201.
Long Statement,CoiniumServ.Transactions,GenerationTransaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\GenerationTransaction.cs,Create,The length of the statement  "		var signatureScriptLenght = (UInt32)(Inputs.First ().SignatureScript.Initial.Length + ExtraNonce.ExtraNoncePlaceholder.Length + Inputs.First ().SignatureScript.Final.Length); " is 174.
Long Statement,CoiniumServ.Logging,LogManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogManager.cs,Initialize,The length of the statement  "	            _mainConfig.WriteTo.ColoredConsole(LogEventLevel.Information' ConsoleLogFormat); // use information level for release mode." is 123.
Long Statement,CoiniumServ.Logging,SourceEnricher,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogManager.cs,Enrich,The length of the statement  "	logEvent.AddPropertyIfAbsent (logEvent.Properties.Keys.Contains ("SourceContext") ? propertyFactory.CreateProperty ("Source"' logEvent.Properties ["SourceContext"].ToString ().Replace ("\""' "").Split ('.').Last ()) : propertyFactory.CreateProperty ("Source"' "n/a")); " is 268.
Long Statement,CoiniumServ.Utils.Platform,PlatformManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Platform\PlatformManager.cs,PrintPlatformBanner,The length of the statement  "	Log.ForContext<PlatformManager> ().Information ("Running over {0:l}' framework: {1:l} (v{2:l})."' Framework == Frameworks.DotNet ? ".Net" : string.Format ("Mono {0}"' MonoVersion)' IsDotNet45 ? "4.5" : "4"' FrameworkVersion); " is 225.
Long Statement,CoiniumServ.Coin.Coinbase,Utils,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Utils.cs,HashCoinbase,The length of the statement  "	// TODO: fix this according - https://github.com/zone117x/node-stratum-pool/blob/eb4b62e9c4de8a8cde83c2b3756ca1a45f02b957/lib/jobManager.js#L69 " is 143.
Long Statement,CoiniumServ.Server.Commands,StatsCommand,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Commands\Stats.cs,Detailed,The length of the statement  "	if (PerformanceCounterCategory.Exists ("Processor") && PerformanceCounterCategory.CounterExists ("% Processor Time"' "Processor")) { " is 132.
Long Statement,CoiniumServ.Server.Commands,StatsCommand,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Commands\Stats.cs,Detailed,The length of the statement  "	if (PerformanceCounterCategory.Exists (".NET CLR Exceptions") && PerformanceCounterCategory.CounterExists ("# of Exceps Thrown"' ".NET CLR Exceptions")) { " is 154.
Long Statement,CoiniumServ.Server.Commands,UptimeCommand,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Commands\Uptime.cs,Uptime,The length of the statement  "	return string.Format ("Uptime: {0} days' {1} hours' {2} minutes' {3} seconds."' uptime.Days' uptime.Hours' uptime.Minutes' uptime.Seconds); " is 139.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The length of the statement  "			if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator))) " is 127.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The length of the statement  "			if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) { " is 159.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The length of the statement  "				exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent)); " is 147.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CheckStyle,The length of the statement  "				exc = new ArgumentException ("With AllowHexSpecifier only " + "AllowLeadingWhite and AllowTrailingWhite " + "are permitted."); " is 126.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindSign,The length of the statement  "	if ((pos + nfi.NegativeSign.Length) <= s.Length && string.CompareOrdinal (s' pos' nfi.NegativeSign' 0' nfi.NegativeSign.Length) == 0) { " is 135.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindSign,The length of the statement  "	} else if ((pos + nfi.PositiveSign.Length) <= s.Length && string.CompareOrdinal (s' pos' nfi.PositiveSign' 0' nfi.PositiveSign.Length) == 0) { " is 142.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindCurrency,The length of the statement  "	if ((pos + nfi.CurrencySymbol.Length) <= s.Length && s.Substring (pos' nfi.CurrencySymbol.Length) == nfi.CurrencySymbol) { " is 122.
Long Statement,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The length of the statement  "	if (value.sign == -1 || baseValue == 1.0d || baseValue == -1.0d || baseValue == Double.NegativeInfinity || double.IsNaN (baseValue)) " is 132.
Complex Conditional,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The conditional expression  "sign == 1 && radix > 10 && (last < '0' || last > '9')"  is complex.
Complex Conditional,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The conditional expression  "AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))"  is complex.
Complex Conditional,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The conditional expression  "value.sign == -1 || baseValue == 1.0d || baseValue == -1.0d || baseValue == Double.NegativeInfinity || double.IsNaN (baseValue)"  is complex.
Complex Conditional,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The conditional expression  "bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)"  is complex.
Empty Catch Block,CoiniumServ.Markets.Exchanges,BittrexClient,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\Exchanges\BittrexClient.cs,GetMarkets,The method has an empty catch block.
Empty Catch Block,CoiniumServ.Jobs.Manager,JobManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobManager.cs,BlockPoller,The method has an empty catch block.
Empty Catch Block,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,GetTransactionCandidates,The method has an empty catch block.
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptN,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptN.cs,ScryptN,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptN,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptN.cs,ScryptN,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptN,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptN.cs,Hash,The following statement contains a magic number: return SCrypt.ComputeDerivedKey (input' input' n' _r' _p' null' 32);  
Magic Number,CoiniumServ.Algorithms.Implementations,Blake,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Blake.cs,Blake,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Blake,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Blake.cs,Blake,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Fugue,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Fugue.cs,Fugue,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Fugue,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Fugue.cs,Fugue,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Groestl,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Groestl.cs,Groestl,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Groestl,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Groestl.cs,Groestl,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Keccak,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Keccak.cs,Keccak,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,Keccak,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Keccak.cs,Keccak,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 8);  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptOg,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptOg.cs,ScryptOg,The following statement contains a magic number: _n = 64;  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptOg,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptOg.cs,ScryptOg,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptOg,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptOg.cs,ScryptOg,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,ScryptOg,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\ScryptOg.cs,Hash,The following statement contains a magic number: return SCrypt.ComputeDerivedKey (input' input' _n' _r' _p' null' 32);  
Magic Number,CoiniumServ.Algorithms.Implementations,Scrypt,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Scrypt.cs,Scrypt,The following statement contains a magic number: _n = 1024;  
Magic Number,CoiniumServ.Algorithms.Implementations,Scrypt,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Scrypt.cs,Scrypt,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,Scrypt,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Scrypt.cs,Scrypt,The following statement contains a magic number: Multiplier = (UInt32)Math.Pow (2' 16);  
Magic Number,CoiniumServ.Algorithms.Implementations,Scrypt,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Algorithms\Implementations\Scrypt.cs,Hash,The following statement contains a magic number: return SCrypt.ComputeDerivedKey (input' input' _n' _r' _p' null' 32);  
Magic Number,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,Run,The following statement contains a magic number: if (pendingCount > 0)  	_logger.Information ("Queried {0} pending blocks; {1} got confirmed' {2} got orphaned; took {3:0.000} seconds"' pendingCount' confirmedCount' orphanedCount' (float)_stopWatch.ElapsedMilliseconds / 1000);  else  	_logger.Information ("No pending blocks found");  
Magic Number,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,Run,The following statement contains a magic number: _logger.Information ("Queried {0} pending blocks; {1} got confirmed' {2} got orphaned; took {3:0.000} seconds"' pendingCount' confirmedCount' orphanedCount' (float)_stopWatch.ElapsedMilliseconds / 1000);  
Magic Number,CoiniumServ.Markets,MarketsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\MarketsConfig.cs,MarketsConfig,The following statement contains a magic number: try {  	// load the config data.  	UpdateInterval = config.updateInterval == 0 ? 60 : config.updateInterval;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<MarketsConfig> ().Error (e' "Error loading website statistics configuration");  }  
Magic Number,CoiniumServ.Markets,MarketsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\MarketsConfig.cs,MarketsConfig,The following statement contains a magic number: UpdateInterval = config.updateInterval == 0 ? 60 : config.updateInterval;  
Magic Number,CoiniumServ.Markets,MarketManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\MarketManager.cs,Run,The following statement contains a magic number: _logger.Debug ("Recached market data - took {0:0.000} seconds"' (float)_stopWatch.ElapsedMilliseconds / 1000);  
Magic Number,CoiniumServ.Markets,MarketManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Markets\MarketManager.cs,Run,The following statement contains a magic number: _timer.Change (_config.UpdateInterval * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M001CreateBlocksTable,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M001CreateBlocksTable.cs,Up,The following statement contains a magic number: Create.Table ("blocks").WithColumn ("id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("height").AsInt32 ().NotNullable ().WithColumn ("orphaned").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("confirmed").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("blockHash").AsString (65).NotNullable ().WithColumn ("txHash").AsString (65).NotNullable ().WithColumn ("amount").AsDecimal ().NotNullable ().WithColumn ("time").AsDateTime ().NotNullable ();  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M001CreateBlocksTable,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M001CreateBlocksTable.cs,Up,The following statement contains a magic number: Create.Table ("blocks").WithColumn ("id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("height").AsInt32 ().NotNullable ().WithColumn ("orphaned").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("confirmed").AsBoolean ().NotNullable ().WithDefaultValue (false).WithColumn ("blockHash").AsString (65).NotNullable ().WithColumn ("txHash").AsString (65).NotNullable ().WithColumn ("amount").AsDecimal ().NotNullable ().WithColumn ("time").AsDateTime ().NotNullable ();  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The following statement contains a magic number: Create.Table ("Account").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("Username").AsString ().NotNullable ().Unique ().WithColumn ("Address").AsString (34).NotNullable ().Unique ().WithColumn ("CreatedAt").AsDateTime ().NotNullable ();  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The following statement contains a magic number: Create.Table ("Transaction").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("AccountId").AsInt32 ().ForeignKey ("Account"' "Id").WithColumn ("PaymentId").AsInt32 ().ForeignKey ("Payment"' "Id").WithColumn ("Amount").AsDecimal ().NotNullable ().WithColumn ("Currency").AsString (4).NotNullable ().WithColumn ("TxHash").AsString (64).NotNullable ().WithColumn ("CreatedAt").AsDateTime ().NotNullable ();  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid.Migrations,M002Payments,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\Migrations\M002Payments.cs,Up,The following statement contains a magic number: Create.Table ("Transaction").WithColumn ("Id").AsInt32 ().NotNullable ().PrimaryKey ().Identity ().WithColumn ("AccountId").AsInt32 ().ForeignKey ("Account"' "Id").WithColumn ("PaymentId").AsInt32 ().ForeignKey ("Payment"' "Id").WithColumn ("Amount").AsDecimal ().NotNullable ().WithColumn ("Currency").AsString (4).NotNullable ().WithColumn ("TxHash").AsString (64).NotNullable ().WithColumn ("CreatedAt").AsDateTime ().NotNullable ();  
Magic Number,CoiniumServ.Pools,ProfitInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\ProfitInfo.cs,SetPrices,The following statement contains a magic number: PriceInBtc = Math.Round ((decimal)coinMarket.Bid' 8);  
Magic Number,CoiniumServ.Pools,ProfitInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\ProfitInfo.cs,SetPrices,The following statement contains a magic number: PriceInUsd = Math.Round ((decimal)btcMarket.Bid * PriceInBtc' 8);  
Magic Number,CoiniumServ.Pools,ProfitInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\ProfitInfo.cs,CalculateProfitability,The following statement contains a magic number: BlocksPerMhPerHour = interval / ((_networkInfo.Difficulty * Math.Pow (2' 32)) / hashrate);  
Magic Number,CoiniumServ.Pools,ProfitInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\ProfitInfo.cs,CalculateProfitability,The following statement contains a magic number: BlocksPerMhPerHour = interval / ((_networkInfo.Difficulty * Math.Pow (2' 32)) / hashrate);  
Magic Number,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,Recache,The following statement contains a magic number: try// read getblocktemplate() based data.   {  	var blockTemplate = _daemonClient.GetBlockTemplate (_poolConfig.Coin.Options.BlockTemplateModeRequired);  	Reward = (UInt64)blockTemplate.Coinbasevalue / 100000000;  	// coinbasevalue is in satoshis' convert it to actual coins.  } catch (RpcException e) {  	_logger.Error ("Can not read getblocktemplate(): {0:l}"' e.Message);  	Reward = 0;  }  
Magic Number,CoiniumServ.Pools,NetworkInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\NetworkInfo.cs,Recache,The following statement contains a magic number: Reward = (UInt64)blockTemplate.Coinbasevalue / 100000000;  
Magic Number,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitHashAlgorithm,The following statement contains a magic number: try {  	HashAlgorithm = _objectFactory.GetHashAlgorithm (Config.Coin);  	_shareMultiplier = Math.Pow (2' 32) / HashAlgorithm.Multiplier;  	// will be used in hashrate calculation.  	return true;  } catch (TinyIoCResolutionException) {  	_logger.Error ("Unknown hash algorithm: {0:l}' pool initilization failed"' Config.Coin.Algorithm);  	return false;  }  
Magic Number,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitHashAlgorithm,The following statement contains a magic number: try {  	HashAlgorithm = _objectFactory.GetHashAlgorithm (Config.Coin);  	_shareMultiplier = Math.Pow (2' 32) / HashAlgorithm.Multiplier;  	// will be used in hashrate calculation.  	return true;  } catch (TinyIoCResolutionException) {  	_logger.Error ("Unknown hash algorithm: {0:l}' pool initilization failed"' Config.Coin.Algorithm);  	return false;  }  
Magic Number,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitHashAlgorithm,The following statement contains a magic number: _shareMultiplier = Math.Pow (2' 32) / HashAlgorithm.Multiplier;  
Magic Number,CoiniumServ.Pools,Pool,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Pools\Pool.cs,InitHashAlgorithm,The following statement contains a magic number: _shareMultiplier = Math.Pow (2' 32) / HashAlgorithm.Multiplier;  
Magic Number,CoiniumServ.Utils.Extensions,StringExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\StringExtensions.cs,HexToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i) {  	string temp = String.Concat (str [i * 2]' str [i * 2 + 1]);  	res [i] = Convert.ToByte (temp' 16);  }  
Magic Number,CoiniumServ.Utils.Extensions,StringExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\StringExtensions.cs,HexToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i) {  	string temp = String.Concat (str [i * 2]' str [i * 2 + 1]);  	res [i] = Convert.ToByte (temp' 16);  }  
Magic Number,CoiniumServ.Utils.Extensions,StringExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\StringExtensions.cs,HexToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i) {  	string temp = String.Concat (str [i * 2]' str [i * 2 + 1]);  	res [i] = Convert.ToByte (temp' 16);  }  
Magic Number,CoiniumServ.Utils.Extensions,StringExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\StringExtensions.cs,HexToByteArray,The following statement contains a magic number: res [i] = Convert.ToByte (temp' 16);  
Magic Number,CoiniumServ.Utils.Extensions,ArrayExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\ArrayExtensions.cs,ReverseByteOrder,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	for (var i = 0; i < 8; i++) {  		var value = BitConverter.ToUInt32 (bytes' i * 4).BigEndian ();  		stream.WriteValueU32 (value);  	}  	result = stream.ToArray ();  }  
Magic Number,CoiniumServ.Utils.Extensions,ArrayExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\ArrayExtensions.cs,ReverseByteOrder,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	for (var i = 0; i < 8; i++) {  		var value = BitConverter.ToUInt32 (bytes' i * 4).BigEndian ();  		stream.WriteValueU32 (value);  	}  	result = stream.ToArray ();  }  
Magic Number,CoiniumServ.Utils.Extensions,ArrayExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\ArrayExtensions.cs,ReverseByteOrder,The following statement contains a magic number: for (var i = 0; i < 8; i++) {  	var value = BitConverter.ToUInt32 (bytes' i * 4).BigEndian ();  	stream.WriteValueU32 (value);  }  
Magic Number,CoiniumServ.Utils.Extensions,ArrayExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\ArrayExtensions.cs,ReverseByteOrder,The following statement contains a magic number: for (var i = 0; i < 8; i++) {  	var value = BitConverter.ToUInt32 (bytes' i * 4).BigEndian ();  	stream.WriteValueU32 (value);  }  
Magic Number,CoiniumServ.Utils.Extensions,EnumerableExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: foreach (byte value in collection) {  	if (i > 0 && ((i % 16) == 0)) {  		output.Append (hex);  		output.Append (' ');  		output.Append (text);  		output.Append (Environment.NewLine);  		hex.Clear ();  		text.Clear ();  	}  	hex.Append (value.ToString ("X2"));  	hex.Append (' ');  	text.Append (string.Format ("{0}"' (char.IsWhiteSpace ((char)value) && (char)value != ' ') ? '.' : (char)value));  	// prettify text  	++i;  }  
Magic Number,CoiniumServ.Utils.Extensions,EnumerableExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: if (i > 0 && ((i % 16) == 0)) {  	output.Append (hex);  	output.Append (' ');  	output.Append (text);  	output.Append (Environment.NewLine);  	hex.Clear ();  	text.Clear ();  }  
Magic Number,CoiniumServ.Utils.Extensions,EnumerableExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: if (text.Length < 16) {  	hexstring = hexstring.PadRight (48);  	// pad the hex representation in-case it's smaller than a regular 16 value line.  }  
Magic Number,CoiniumServ.Utils.Extensions,EnumerableExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: if (text.Length < 16) {  	hexstring = hexstring.PadRight (48);  	// pad the hex representation in-case it's smaller than a regular 16 value line.  }  
Magic Number,CoiniumServ.Utils.Extensions,EnumerableExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: hexstring = hexstring.PadRight (48);  
Magic Number,CoiniumServ.Utils.Extensions,JsonExtensions,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Extensions\JsonExtensions.cs,PrettifyJson,The following statement contains a magic number: try {  	input = input.Replace ('\"'' '\'');  	var output = new StringBuilder (input.Length * 2);  	char? quote = null;  	int depth = 0;  	for (int i = 0; i < input.Length; ++i) {  		char ch = input [i];  		switch (ch) {  		case '{':  		case '[':  			output.Append (ch);  			if (!quote.HasValue) {  				output.AppendLine ();  				output.Append (Indent.Repeat (++depth));  			}  			break;  		case '}':  		case ']':  			if (quote.HasValue)  				output.Append (ch);  			else {  				output.AppendLine ();  				output.Append (Indent.Repeat (--depth));  				output.Append (ch);  			}  			break;  		case '"':  		case '\'':  			output.Append (ch);  			if (quote.HasValue) {  				if (!output.IsEscaped (i))  					quote = null;  			} else  				quote = ch;  			break;  		case ''':  			output.Append (ch);  			if (!quote.HasValue) {  				output.AppendLine ();  				output.Append (Indent.Repeat (depth));  			}  			break;  		case ':':  			if (quote.HasValue)  				output.Append (ch);  			else  				output.Append (" : ");  			break;  		default:  			if (quote.HasValue || !char.IsWhiteSpace (ch))  				output.Append (ch);  			break;  		}  	}  	return output.ToString ();  } catch (Exception) {  	return input;  	// in case we fail to prettify json' handle the exception and just return the input.  }  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableHashrate,The following statement contains a magic number: do {  	rate = rate / 1000;  	index++;  } while (rate > 1000);  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableHashrate,The following statement contains a magic number: do {  	rate = rate / 1000;  	index++;  } while (rate > 1000);  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableHashrate,The following statement contains a magic number: rate = rate / 1000;  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableDifficulty,The following statement contains a magic number: if (difficulty < 1000)  	return difficulty.ToString (CultureInfo.InvariantCulture);  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableDifficulty,The following statement contains a magic number: do {  	rate = rate / 1000;  	index++;  } while (rate > 1000);  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableDifficulty,The following statement contains a magic number: do {  	rate = rate / 1000;  	index++;  } while (rate > 1000);  
Magic Number,CoiniumServ.Utils.Helpers,Humanize,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Humanize.cs,GetReadableDifficulty,The following statement contains a magic number: rate = rate / 1000;  
Magic Number,CoiniumServ.Utils.Helpers,Enforce,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\Enforce.cs,GetName,The following statement contains a magic number: if (methodBody != null) {  	var il = methodBody.GetILAsByteArray ();  	// bytes 2-6 represent the field handle  	var fieldHandle = BitConverter.ToInt32 (il' 2);  	// resolve the handle  	var field = argument.Target.GetType ().Module.ResolveField (fieldHandle);  	return field.Name;  }  
Magic Number,CoiniumServ.Utils.Helpers,TimeHelpers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\TimeHelpers.cs,NowInUnixTimestamp,The following statement contains a magic number: return (Int32)(DateTime.UtcNow.Subtract (new DateTime (1970' 1' 1))).TotalSeconds;  
Magic Number,CoiniumServ.Utils.Helpers,TimeHelpers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\TimeHelpers.cs,ToUnixTimestamp,The following statement contains a magic number: return (int)Math.Truncate ((value.ToUniversalTime ().Subtract (new DateTime (1970' 1' 1))).TotalSeconds);  
Magic Number,CoiniumServ.Utils.Helpers,TimeHelpers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Helpers\TimeHelpers.cs,UnixTimestamp,The following statement contains a magic number: return (int)Math.Truncate ((value.ToUniversalTime ().Subtract (new DateTime (1970' 1' 1))).TotalSeconds);  
Magic Number,CoiniumServ.Banning,BanManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanManager.cs,CheckBans,The following statement contains a magic number: _timer.Change (Config.PurgeInterval * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Duration = config.duration == 0 ? 600 : config.duration;  	InvalidPercent = config.invalidPercent == 0 ? 50 : config.invalidPercent;  	CheckThreshold = config.checkThreshold == 0 ? 100 : config.checkThreshold;  	PurgeInterval = config.purgeInterval == 0 ? 300 : config.purgeInterval;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<BanConfig> ().Error (e' "Error loading banning configuration");  }  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Duration = config.duration == 0 ? 600 : config.duration;  	InvalidPercent = config.invalidPercent == 0 ? 50 : config.invalidPercent;  	CheckThreshold = config.checkThreshold == 0 ? 100 : config.checkThreshold;  	PurgeInterval = config.purgeInterval == 0 ? 300 : config.purgeInterval;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<BanConfig> ().Error (e' "Error loading banning configuration");  }  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Duration = config.duration == 0 ? 600 : config.duration;  	InvalidPercent = config.invalidPercent == 0 ? 50 : config.invalidPercent;  	CheckThreshold = config.checkThreshold == 0 ? 100 : config.checkThreshold;  	PurgeInterval = config.purgeInterval == 0 ? 300 : config.purgeInterval;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<BanConfig> ().Error (e' "Error loading banning configuration");  }  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Duration = config.duration == 0 ? 600 : config.duration;  	InvalidPercent = config.invalidPercent == 0 ? 50 : config.invalidPercent;  	CheckThreshold = config.checkThreshold == 0 ? 100 : config.checkThreshold;  	PurgeInterval = config.purgeInterval == 0 ? 300 : config.purgeInterval;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<BanConfig> ().Error (e' "Error loading banning configuration");  }  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: Duration = config.duration == 0 ? 600 : config.duration;  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: InvalidPercent = config.invalidPercent == 0 ? 50 : config.invalidPercent;  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: CheckThreshold = config.checkThreshold == 0 ? 100 : config.checkThreshold;  
Magic Number,CoiniumServ.Banning,BanConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Banning\BanConfig.cs,BanConfig,The following statement contains a magic number: PurgeInterval = config.purgeInterval == 0 ? 300 : config.purgeInterval;  
Magic Number,CoiniumServ.Jobs.Manager,JobConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobConfig.cs,JobConfig,The following statement contains a magic number: try {  	// load the config data.  	BlockRefreshInterval = config.blockRefreshInterval == 0 ? 1000 : config.blockRefreshInterval;  	RebroadcastTimeout = config.rebroadcastTimeout == 0 ? 55 : config.rebroadcastTimeout;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<JobConfig> ().Error (e' "Error loading job configuration");  }  
Magic Number,CoiniumServ.Jobs.Manager,JobConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobConfig.cs,JobConfig,The following statement contains a magic number: try {  	// load the config data.  	BlockRefreshInterval = config.blockRefreshInterval == 0 ? 1000 : config.blockRefreshInterval;  	RebroadcastTimeout = config.rebroadcastTimeout == 0 ? 55 : config.rebroadcastTimeout;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<JobConfig> ().Error (e' "Error loading job configuration");  }  
Magic Number,CoiniumServ.Jobs.Manager,JobConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobConfig.cs,JobConfig,The following statement contains a magic number: BlockRefreshInterval = config.blockRefreshInterval == 0 ? 1000 : config.blockRefreshInterval;  
Magic Number,CoiniumServ.Jobs.Manager,JobConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobConfig.cs,JobConfig,The following statement contains a magic number: RebroadcastTimeout = config.rebroadcastTimeout == 0 ? 55 : config.rebroadcastTimeout;  
Magic Number,CoiniumServ.Jobs.Manager,JobManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobManager.cs,CreateAndBroadcastNewJob,The following statement contains a magic number: for (var i = 0; i < 3; i++)// try creating a new job 5 times at least.   {  	job = GetNewJob ();  	// create a new job.  	if (job != null)  		break;  }  
Magic Number,CoiniumServ.Jobs.Manager,JobManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Manager\JobManager.cs,CreateAndBroadcastNewJob,The following statement contains a magic number: _reBroadcastTimer.Change (_poolConfig.Job.RebroadcastTimeout * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Mining,MinerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Mining\MinerConfig.cs,MinerConfig,The following statement contains a magic number: try {  	// load the config data.  	ValidateUsername = config.validateUsername;  	Timeout = config.timeout == 0 ? 300 : config.timeout;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<MinerConfig> ().Error (e' "Error loading miner configuration");  }  
Magic Number,CoiniumServ.Mining,MinerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Mining\MinerConfig.cs,MinerConfig,The following statement contains a magic number: Timeout = config.timeout == 0 ? 300 : config.timeout;  
Magic Number,CoiniumServ.Daemon,DaemonBase,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\DaemonBase.cs,DaemonBase,The following statement contains a magic number: _timeout = daemonConfig.Timeout * 1000;  
Magic Number,CoiniumServ.Payments.Config,PaymentConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\Config\PaymentConfig.cs,PaymentConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Interval = config.interval == 0 ? 60 : config.interval;  	Minimum = config.minimum == 0 ? 0.01 : config.minimum;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<PaymentConfig> ().Error (e' "Error loading payment configuration");  }  
Magic Number,CoiniumServ.Payments.Config,PaymentConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\Config\PaymentConfig.cs,PaymentConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	Interval = config.interval == 0 ? 60 : config.interval;  	Minimum = config.minimum == 0 ? 0.01 : config.minimum;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<PaymentConfig> ().Error (e' "Error loading payment configuration");  }  
Magic Number,CoiniumServ.Payments.Config,PaymentConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\Config\PaymentConfig.cs,PaymentConfig,The following statement contains a magic number: Interval = config.interval == 0 ? 60 : config.interval;  
Magic Number,CoiniumServ.Payments.Config,PaymentConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\Config\PaymentConfig.cs,PaymentConfig,The following statement contains a magic number: Minimum = config.minimum == 0 ? 0.01 : config.minimum;  
Magic Number,CoiniumServ.Payments,PaymentManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentManager.cs,PaymentManager,The following statement contains a magic number: _timer = new Timer (Run' null' _poolConfig.Payments.Interval * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Payments,PaymentManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentManager.cs,Run,The following statement contains a magic number: _timer.Change (_poolConfig.Payments.Interval * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,Run,The following statement contains a magic number: if (executedPayments.Count > 0)  	_logger.Information ("Executed {0} payments' took {1:0.000} seconds"' executedPayments.Count' (float)_stopWatch.ElapsedMilliseconds / 1000);  else  	_logger.Information ("No pending payments found");  
Magic Number,CoiniumServ.Payments,PaymentProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\PaymentProcessor.cs,Run,The following statement contains a magic number: _logger.Information ("Executed {0} payments' took {1:0.000} seconds"' executedPayments.Count' (float)_stopWatch.ElapsedMilliseconds / 1000);  
Magic Number,CoiniumServ.Payments,BlockAccounter,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\BlockAccounter.cs,Run,The following statement contains a magic number: if (rounds.Count > 0)  	_logger.Information ("Accounted {0} confirmed rounds' took {1:0.000} seconds"' rounds.Count' (float)_stopWatch.ElapsedMilliseconds / 1000);  else  	_logger.Information ("No pending blocks waiting to get accounted found");  
Magic Number,CoiniumServ.Payments,BlockAccounter,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Payments\BlockAccounter.cs,Run,The following statement contains a magic number: _logger.Information ("Accounted {0} confirmed rounds' took {1:0.000} seconds"' rounds.Count' (float)_stopWatch.ElapsedMilliseconds / 1000);  
Magic Number,CoiniumServ.Persistance.Blocks,PersistedBlock,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Blocks\PersistedBlock.cs,PersistedBlock,The following statement contains a magic number: if (confirmations == -1)  	Status = BlockStatus.Orphaned;  else  	Status = confirmations > 120 ? BlockStatus.Confirmed : BlockStatus.Pending;  
Magic Number,CoiniumServ.Persistance.Blocks,PersistedBlock,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Blocks\PersistedBlock.cs,PersistedBlock,The following statement contains a magic number: Status = confirmations > 120 ? BlockStatus.Confirmed : BlockStatus.Pending;  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,MigrationManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\MigrationManager.cs,Check,The following statement contains a magic number: try {  	var announcer = new TextWriterAnnouncer (WriteLog);  	var assembly = Assembly.GetExecutingAssembly ();  	var migrationContext = new RunnerContext (announcer);  	var options = new MigrationOptions {  		PreviewOnly = false'  		Timeout = 60  	};  	var factory = new FluentMigrator.Runner.Processors.MySql.MySqlProcessorFactory ();  	var processor = factory.Create (_provider.ConnectionString' announcer' options);  	var runner = new MigrationRunner (assembly' migrationContext' processor);  	runner.MigrateUp (true);  } catch (InvalidMigrationException e) {  	_logger.Error ("An invalid migration exception occured; {0:l}"' e.Message);  } catch (MySqlException e) {  	_logger.Error ("An exception occured while running migration manager; {0:l}"' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddShare,The following statement contains a magic number: try {  	if (!IsEnabled || !_redisProvider.IsConnected)  		return;  	//_client.StartPipe(); // batch the commands.  	// add the share to round   	var currentKey = string.Format ("{0}:shares:round:current"' _coin);  	var miner = (IStratumMiner)share.Miner;  	_redisProvider.Client.HIncrByFloat (currentKey' miner.Username' (double)miner.Difficulty);  	// increment shares stats.  	var statsKey = string.Format ("{0}:stats"' _coin);  	_redisProvider.Client.HIncrBy (statsKey' share.IsValid ? "validShares" : "invalidShares"' 1);  	// add to hashrate  	if (share.IsValid) {  		var hashrateKey = string.Format ("{0}:hashrate"' _coin);  		var randomModifier = Convert.ToString (miner.ValidShareCount' 16).PadLeft (8' '0');  		string modifiedUsername = miner.Username + randomModifier;  		var entry = string.Format ("{0}:{1}"' (double)miner.Difficulty' modifiedUsername);  		_redisProvider.Client.ZAdd (hashrateKey' Tuple.Create (TimeHelpers.NowInUnixTimestamp ()' entry));  	}  	//_client.EndPipe(); // execute the batch commands.  } catch (Exception e) {  	_logger.Error ("An exception occured while comitting share: {0:l}"' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddShare,The following statement contains a magic number: try {  	if (!IsEnabled || !_redisProvider.IsConnected)  		return;  	//_client.StartPipe(); // batch the commands.  	// add the share to round   	var currentKey = string.Format ("{0}:shares:round:current"' _coin);  	var miner = (IStratumMiner)share.Miner;  	_redisProvider.Client.HIncrByFloat (currentKey' miner.Username' (double)miner.Difficulty);  	// increment shares stats.  	var statsKey = string.Format ("{0}:stats"' _coin);  	_redisProvider.Client.HIncrBy (statsKey' share.IsValid ? "validShares" : "invalidShares"' 1);  	// add to hashrate  	if (share.IsValid) {  		var hashrateKey = string.Format ("{0}:hashrate"' _coin);  		var randomModifier = Convert.ToString (miner.ValidShareCount' 16).PadLeft (8' '0');  		string modifiedUsername = miner.Username + randomModifier;  		var entry = string.Format ("{0}:{1}"' (double)miner.Difficulty' modifiedUsername);  		_redisProvider.Client.ZAdd (hashrateKey' Tuple.Create (TimeHelpers.NowInUnixTimestamp ()' entry));  	}  	//_client.EndPipe(); // execute the batch commands.  } catch (Exception e) {  	_logger.Error ("An exception occured while comitting share: {0:l}"' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddShare,The following statement contains a magic number: if (share.IsValid) {  	var hashrateKey = string.Format ("{0}:hashrate"' _coin);  	var randomModifier = Convert.ToString (miner.ValidShareCount' 16).PadLeft (8' '0');  	string modifiedUsername = miner.Username + randomModifier;  	var entry = string.Format ("{0}:{1}"' (double)miner.Difficulty' modifiedUsername);  	_redisProvider.Client.ZAdd (hashrateKey' Tuple.Create (TimeHelpers.NowInUnixTimestamp ()' entry));  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,AddShare,The following statement contains a magic number: if (share.IsValid) {  	var hashrateKey = string.Format ("{0}:hashrate"' _coin);  	var randomModifier = Convert.ToString (miner.ValidShareCount' 16).PadLeft (8' '0');  	string modifiedUsername = miner.Username + randomModifier;  	var entry = string.Format ("{0}:{1}"' (double)miner.Difficulty' modifiedUsername);  	_redisProvider.Client.ZAdd (hashrateKey' Tuple.Create (TimeHelpers.NowInUnixTimestamp ()' entry));  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetHashrateData,The following statement contains a magic number: try {  	if (!IsEnabled || !_redisProvider.IsConnected)  		return hashrates;  	var key = string.Format ("{0}:hashrate"' _coin);  	var results = _redisProvider.Client.ZRangeByScore (key' since' double.PositiveInfinity);  	foreach (var result in results) {  		var data = result.Split (':');  		var share = double.Parse (data [0].Replace ('''' '.')' CultureInfo.InvariantCulture);  		var worker = data [1].Substring (0' data [1].Length - 8);  		if (!hashrates.ContainsKey (worker))  			hashrates.Add (worker' 0);  		hashrates [worker] += share;  	}  } catch (Exception e) {  	_logger.Error ("An exception occured while getting hashrate data: {0:l}"' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Layers.Hybrid,HybridStorage,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Layers\Hybrid\HybridStorage.Accounts.cs,GetHashrateData,The following statement contains a magic number: foreach (var result in results) {  	var data = result.Split (':');  	var share = double.Parse (data [0].Replace ('''' '.')' CultureInfo.InvariantCulture);  	var worker = data [1].Substring (0' data [1].Length - 8);  	if (!hashrates.ContainsKey (worker))  		hashrates.Add (worker' 0);  	hashrates [worker] += share;  }  
Magic Number,CoiniumServ.Persistance.Providers.MySql,MySqlProviderConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\MySql\MySqlProviderConfig.cs,MySqlProviderConfig,The following statement contains a magic number: try {  	// load the config data.  	Host = string.IsNullOrEmpty (config.host) ? "127.0.0.1" : config.host;  	Port = config.port == 0 ? 3306 : config.port;  	Username = config.user;  	Password = config.password;  	Database = config.database;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<MySqlProviderConfig> ().Error (e' "Error loading mysql configuration");  }  
Magic Number,CoiniumServ.Persistance.Providers.MySql,MySqlProviderConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\MySql\MySqlProviderConfig.cs,MySqlProviderConfig,The following statement contains a magic number: Port = config.port == 0 ? 3306 : config.port;  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProviderConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProviderConfig.cs,RedisProviderConfig,The following statement contains a magic number: try {  	// load the config data.  	Host = string.IsNullOrEmpty (config.host) ? "127.0.0.1" : config.host;  	Port = config.port == 0 ? 6379 : config.port;  	Password = config.password;  	DatabaseId = config.databaseId;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<RedisProviderConfig> ().Error (e' "Error loading redis configuration");  }  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProviderConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProviderConfig.cs,RedisProviderConfig,The following statement contains a magic number: Port = config.port == 0 ? 6379 : config.port;  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProvider.cs,Initialize,The following statement contains a magic number: try {  	// create the connection  	Client = new RedisClient (_config.Host' _config.Port) {  		ReconnectAttempts = 3'  		ReconnectWait = 200  	};  	// select the database  	Client.Select (_config.DatabaseId);  	// authenticate if needed.  	if (!string.IsNullOrEmpty (_config.Password))  		Client.Auth (_config.Password);  	// check the version  	var version = GetVersion ();  	if (version < _requiredMinimumVersion)  		throw new Exception (string.Format ("You are using redis version {0}' minimum required version is 2.6"' version));  	_logger.Information ("Redis storage initialized: {0:l}:{1}' v{2:l}."' _config.Host' _config.Port' version);  } catch (Exception e) {  	_logger.Error ("Redis storage initialization failed: {0:l}:{1} - {2:l}"' _config.Host' _config.Port' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProvider.cs,Initialize,The following statement contains a magic number: try {  	// create the connection  	Client = new RedisClient (_config.Host' _config.Port) {  		ReconnectAttempts = 3'  		ReconnectWait = 200  	};  	// select the database  	Client.Select (_config.DatabaseId);  	// authenticate if needed.  	if (!string.IsNullOrEmpty (_config.Password))  		Client.Auth (_config.Password);  	// check the version  	var version = GetVersion ();  	if (version < _requiredMinimumVersion)  		throw new Exception (string.Format ("You are using redis version {0}' minimum required version is 2.6"' version));  	_logger.Information ("Redis storage initialized: {0:l}:{1}' v{2:l}."' _config.Host' _config.Port' version);  } catch (Exception e) {  	_logger.Error ("Redis storage initialization failed: {0:l}:{1} - {2:l}"' _config.Host' _config.Port' e.Message);  }  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProvider.cs,Initialize,The following statement contains a magic number: Client = new RedisClient (_config.Host' _config.Port) {  	ReconnectAttempts = 3'  	ReconnectWait = 200  };  
Magic Number,CoiniumServ.Persistance.Providers.Redis,RedisProvider,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Persistance\Providers\Redis\RedisProvider.cs,Initialize,The following statement contains a magic number: Client = new RedisClient (_config.Host' _config.Port) {  	ReconnectAttempts = 3'  	ReconnectWait = 200  };  
Magic Number,CoiniumServ.Server.Web.Config,WebServerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\Config\WebServerConfig.cs,WebServerConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	BindInterface = string.IsNullOrEmpty (config.bind) ? "localhost" : config.bind;  	Port = config.port == 0 ? 80 : config.port;  	Template = string.IsNullOrEmpty (config.template) ? "default" : config.template;  	Feed = string.IsNullOrEmpty (config.feed) ? "" : config.feed;  	Backend = new BackendConfig (config.backend);  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<WebServerConfig> ().Error (e' "Error loading web-server configuration");  }  
Magic Number,CoiniumServ.Server.Web.Config,WebServerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Web\Config\WebServerConfig.cs,WebServerConfig,The following statement contains a magic number: Port = config.port == 0 ? 80 : config.port;  
Magic Number,CoiniumServ.Statistics,StatisticsManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsManager.cs,Recache,The following statement contains a magic number: _logger.Debug ("Recached statistics - took {0:0.000} seconds"' (float)_stopWatch.ElapsedMilliseconds / 1000);  
Magic Number,CoiniumServ.Statistics,StatisticsManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsManager.cs,Recache,The following statement contains a magic number: _recacheTimer.Change (_config.UpdateInterval * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Statistics,StatisticsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsConfig.cs,StatisticsConfig,The following statement contains a magic number: try {  	// load the config data.  	UpdateInterval = config.updateInterval == 0 ? 60 : config.updateInterval;  	HashrateWindow = config.hashrateWindow == 0 ? 300 : config.hashrateWindow;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<StatisticsConfig> ().Error (e' "Error loading website statistics configuration");  }  
Magic Number,CoiniumServ.Statistics,StatisticsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsConfig.cs,StatisticsConfig,The following statement contains a magic number: try {  	// load the config data.  	UpdateInterval = config.updateInterval == 0 ? 60 : config.updateInterval;  	HashrateWindow = config.hashrateWindow == 0 ? 300 : config.hashrateWindow;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<StatisticsConfig> ().Error (e' "Error loading website statistics configuration");  }  
Magic Number,CoiniumServ.Statistics,StatisticsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsConfig.cs,StatisticsConfig,The following statement contains a magic number: UpdateInterval = config.updateInterval == 0 ? 60 : config.updateInterval;  
Magic Number,CoiniumServ.Statistics,StatisticsConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Statistics\StatisticsConfig.cs,StatisticsConfig,The following statement contains a magic number: HashrateWindow = config.hashrateWindow == 0 ? 300 : config.hashrateWindow;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetMHashps > 0)  	NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  else if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetMHashps * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkGhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  else if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetworkGhps * 1000 * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: if (NetworkMhps > 0)  	NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  else if (NetworkHashps > 0)  	NetworkHashPerSec = NetworkHashps;  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  
Magic Number,CoiniumServ.Daemon.Responses,MiningInfo,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Responses\MiningInfo.cs,OnDeserializedMethod,The following statement contains a magic number: NetworkHashPerSec = (UInt64)(NetworkMhps * 1000 * 1000);  
Magic Number,CoiniumServ.Jobs.Tracker,JobTracker,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Tracker\JobTracker.cs,JobTracker,The following statement contains a magic number: _cleanupTimer.Change (_cleanupFrequency * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Jobs.Tracker,JobTracker,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\Tracker\JobTracker.cs,CleanUp,The following statement contains a magic number: _cleanupTimer.Change (_cleanupFrequency * 1000' Timeout.Infinite);  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: if (extraNonce2.Length / 2 != ExtraNonce.ExpectedExtraNonce2Size) {  	Error = ShareError.IncorrectExtraNonce2Size;  	return;  }  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: ExtraNonce2 = Convert.ToUInt32 (extraNonce2' 16);  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: if (nTimeString.Length != 8) {  	Error = ShareError.IncorrectNTimeSize;  	return;  }  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: NTime = Convert.ToUInt32 (nTimeString' 16);  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: if (NTime < job.BlockTemplate.CurTime || NTime > submitTime + 7200) {  	Error = ShareError.NTimeOutOfRange;  	return;  }  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: if (nonceString.Length != 8) {  	Error = ShareError.IncorrectNonceSize;  	return;  }  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: Nonce = Convert.ToUInt32 (nonceString' 16);  
Magic Number,CoiniumServ.Shares,Share,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\Share.cs,Share,The following statement contains a magic number: if (Job.Target >= HeaderValue) {  	IsBlockCandidate = true;  	BlockHex = Serializers.SerializeBlock (Job' HeaderBuffer' CoinbaseBuffer' miner.Pool.Config.Coin.Options.IsProofOfStakeHybrid);  	BlockHash = HeaderBuffer.DoubleDigest ().ReverseBuffer ();  } else {  	IsBlockCandidate = false;  	BlockHash = HeaderBuffer.DoubleDigest ().ReverseBuffer ();  	// Check if share difficulty reaches miner difficulty.  	var lowDifficulty = Difficulty / miner.Difficulty < 0.99;  	// share difficulty should be equal or more then miner's target difficulty.  	if (!lowDifficulty)  		// if share difficulty is high enough to match miner's current difficulty.  		return;  	// just accept the share.  	if (Difficulty >= miner.PreviousDifficulty)  		// if the difficulty matches miner's previous difficulty before the last vardiff triggered difficulty change  		return;  	// still accept the share.  	// if the share difficulty can't match miner's current difficulty or previous difficulty                  	Error = ShareError.LowDifficultyShare;  	// then just reject the share with low difficult share error.  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  	MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  	TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  	RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  	VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<VardiffConfig> ().Error (e' "Error loading vardiff configuration");  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  	MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  	TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  	RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  	VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<VardiffConfig> ().Error (e' "Error loading vardiff configuration");  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  	MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  	TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  	RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  	VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<VardiffConfig> ().Error (e' "Error loading vardiff configuration");  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  	MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  	TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  	RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  	VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<VardiffConfig> ().Error (e' "Error loading vardiff configuration");  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  	MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  	TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  	RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  	VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<VardiffConfig> ().Error (e' "Error loading vardiff configuration");  }  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: MinimumDifficulty = config.minDiff == 0 ? 8 : (float)config.minDiff;  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: MaximumDifficulty = config.maxDiff == 0 ? 512 : (float)config.maxDiff;  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: TargetTime = config.targetTime == 0 ? 15 : config.targetTime;  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: RetargetTime = config.retargetTime == 0 ? 90 : config.retargetTime;  
Magic Number,CoiniumServ.Vardiff,VardiffConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffConfig.cs,VardiffConfig,The following statement contains a magic number: VariancePercent = config.variancePercent == 0 ? 30 : config.variancePercent;  
Magic Number,CoiniumServ.Vardiff,VardiffManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffManager.cs,VardiffManager,The following statement contains a magic number: _bufferSize = Config.RetargetTime / Config.TargetTime * 4;  
Magic Number,CoiniumServ.Vardiff,VardiffManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffManager.cs,OnShare,The following statement contains a magic number: if (miner.VardiffBuffer == null) {  	miner.LastVardiffRetarget = now - Config.RetargetTime / 2;  	miner.LastVardiffTimestamp = now;  	miner.VardiffBuffer = new RingBuffer (_bufferSize);  	return;  }  
Magic Number,CoiniumServ.Vardiff,VardiffManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Vardiff\VardiffManager.cs,OnShare,The following statement contains a magic number: miner.LastVardiffRetarget = now - Config.RetargetTime / 2;  
Magic Number,CoiniumServ.Server.Mining.Stratum,StratumServerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumServerConfig.cs,StratumServerConfig,The following statement contains a magic number: try {  	// load the config data.  	Enabled = config.enabled;  	BindInterface = string.IsNullOrEmpty (config.bind) ? "0.0.0.0" : config.bind;  	Port = config.port;  	Diff = config.diff == 0 ? 16 : (float)config.diff;  	Vardiff = new VardiffConfig (config.vardiff);  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<StratumServerConfig> ().Error (e' "Error loading stratum server configuration");  }  
Magic Number,CoiniumServ.Server.Mining.Stratum,StratumServerConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Mining\Stratum\StratumServerConfig.cs,StratumServerConfig,The following statement contains a magic number: Diff = config.diff == 0 ? 16 : (float)config.diff;  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: if (Ll > 1) {  	while (true) {  		if (Ll == 1)  			break;  		steps.Add (L [1]);  		if (Ll % 2 == 1)  			L.Add (L [L.Count - 1]);  		var Ld = new List<byte[]> ();  		foreach (int i in Range.From (startL).To (Ll).WithStepSize (2)) {  			Ld.Add (MerkleJoin (L [i]' L [i + 1]));  		}  		L = new List<byte[]> {  			null  		};  		L.AddRange (Ld);  		Ll = L.Count;  	}  }  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: if (Ll > 1) {  	while (true) {  		if (Ll == 1)  			break;  		steps.Add (L [1]);  		if (Ll % 2 == 1)  			L.Add (L [L.Count - 1]);  		var Ld = new List<byte[]> ();  		foreach (int i in Range.From (startL).To (Ll).WithStepSize (2)) {  			Ld.Add (MerkleJoin (L [i]' L [i + 1]));  		}  		L = new List<byte[]> {  			null  		};  		L.AddRange (Ld);  		Ll = L.Count;  	}  }  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: while (true) {  	if (Ll == 1)  		break;  	steps.Add (L [1]);  	if (Ll % 2 == 1)  		L.Add (L [L.Count - 1]);  	var Ld = new List<byte[]> ();  	foreach (int i in Range.From (startL).To (Ll).WithStepSize (2)) {  		Ld.Add (MerkleJoin (L [i]' L [i + 1]));  	}  	L = new List<byte[]> {  		null  	};  	L.AddRange (Ld);  	Ll = L.Count;  }  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: while (true) {  	if (Ll == 1)  		break;  	steps.Add (L [1]);  	if (Ll % 2 == 1)  		L.Add (L [L.Count - 1]);  	var Ld = new List<byte[]> ();  	foreach (int i in Range.From (startL).To (Ll).WithStepSize (2)) {  		Ld.Add (MerkleJoin (L [i]' L [i + 1]));  	}  	L = new List<byte[]> {  		null  	};  	L.AddRange (Ld);  	Ll = L.Count;  }  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: if (Ll % 2 == 1)  	L.Add (L [L.Count - 1]);  
Magic Number,CoiniumServ.Cryptology.Merkle,MerkleTree,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Merkle\MerkleTree.cs,CalculateSteps,The following statement contains a magic number: foreach (int i in Range.From (startL).To (Ll).WithStepSize (2)) {  	Ld.Add (MerkleJoin (L [i]' L [i + 1]));  }  
Magic Number,CoiniumServ.Jobs,ExtraNonce,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Jobs\ExtraNonce.cs,InitCounter,The following statement contains a magic number: _counter = instanceId << 27;  
Magic Number,CoiniumServ.Transactions,GenerationTransaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\GenerationTransaction.cs,GenerationTransaction,The following statement contains a magic number: Inputs = new List<TxIn> {  	new TxIn {  		PreviousOutput = new OutPoint {  			Hash = Hash.ZeroHash'  			Index = (UInt32)Math.Pow (2' 32) - 1  		}'  		Sequence = 0x0'  		SignatureScript = new SignatureScript (blockTemplate.Height' blockTemplate.CoinBaseAux.Flags' TimeHelpers.NowInUnixTimestamp ()' (byte)extraNonce.ExtraNoncePlaceholder.Length' "/CoiniumServ/")  	}  };  
Magic Number,CoiniumServ.Transactions,GenerationTransaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\GenerationTransaction.cs,GenerationTransaction,The following statement contains a magic number: Inputs = new List<TxIn> {  	new TxIn {  		PreviousOutput = new OutPoint {  			Hash = Hash.ZeroHash'  			Index = (UInt32)Math.Pow (2' 32) - 1  		}'  		Sequence = 0x0'  		SignatureScript = new SignatureScript (blockTemplate.Height' blockTemplate.CoinBaseAux.Flags' TimeHelpers.NowInUnixTimestamp ()' (byte)extraNonce.ExtraNoncePlaceholder.Length' "/CoiniumServ/")  	}  };  
Magic Number,CoiniumServ.Transactions,GenerationTransaction,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Transactions\GenerationTransaction.cs,GenerationTransaction,The following statement contains a magic number: foreach (var pair in poolConfig.Rewards) {  	var amount = blockReward * pair.Value / 100;  	// calculate the amount he recieves based on the percent of his shares.  	blockReward -= amount;  	Outputs.AddRecipient (pair.Key' amount);  }  
Magic Number,CoiniumServ.Coin.Address,Base58,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Address\Base58.cs,DecodeChecked,The following statement contains a magic number: if (tmp.Length < 4)  	throw new AddressFormatException ("Input too short");  
Magic Number,CoiniumServ.Coin.Address,Base58,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Address\Base58.cs,DecodeChecked,The following statement contains a magic number: Array.Copy (tmp' tmp.Length - 4' checksum' 0' 4);  
Magic Number,CoiniumServ.Coin.Address,Base58,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Address\Base58.cs,DecodeChecked,The following statement contains a magic number: Array.Copy (tmp' tmp.Length - 4' checksum' 0' 4);  
Magic Number,CoiniumServ.Coin.Address,Base58,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Address\Base58.cs,DecodeChecked,The following statement contains a magic number: Array.Copy (tmp' 0' bytes' 0' tmp.Length - 4);  
Magic Number,CoiniumServ.Coin.Address,Base58,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Address\Base58.cs,DecodeChecked,The following statement contains a magic number: Array.Copy (tmp' 0' hash' 0' 4);  
Magic Number,CoiniumServ.Daemon.Config,DaemonConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Config\DaemonConfig.cs,DaemonConfig,The following statement contains a magic number: try {  	// load the config data.  	Host = string.IsNullOrEmpty (config.host) ? "0.0.0.0" : config.host;  	Port = config.port;  	Username = config.username;  	Password = config.password;  	Timeout = config.timeout == 0 ? 5 : config.timeout;  	Valid = true;  } catch (Exception e) {  	Valid = false;  	Log.Logger.ForContext<DaemonConfig> ().Error (e' "Error loading daemon configuration");  }  
Magic Number,CoiniumServ.Daemon.Config,DaemonConfig,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Daemon\Config\DaemonConfig.cs,DaemonConfig,The following statement contains a magic number: Timeout = config.timeout == 0 ? 5 : config.timeout;  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeHeader,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	stream.WriteValueU32 (nonce.BigEndian ());  	stream.WriteValueU32 (Convert.ToUInt32 (job.EncodedDifficulty' 16).BigEndian ());  	stream.WriteValueU32 (nTime.BigEndian ());  	stream.WriteBytes (merkleRoot);  	stream.WriteBytes (job.PreviousBlockHash.HexToByteArray ());  	stream.WriteValueU32 (job.BlockTemplate.Version.BigEndian ());  	result = stream.ToArray ();  	result = result.ReverseBytes ();  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeHeader,The following statement contains a magic number: stream.WriteValueU32 (Convert.ToUInt32 (job.EncodedDifficulty' 16).BigEndian ());  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: if (value >= 1 && value <= 16)  	return new byte[] {  		0x01'  		(byte)value  	};  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: while (value > 127) {  	buffer [lenght++] = (byte)(value & 0xff);  	value >>= 8;  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: while (value > 127) {  	buffer [lenght++] = (byte)(value & 0xff);  	value >>= 8;  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: value >>= 8;  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: if (value >= 1 && value <= 16)  	return new byte[] {  		0x01'  		(byte)value  	};  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: while (value > 127) {  	buffer [lenght++] = (byte)(value & 0xff);  	value >>= 8;  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: while (value > 127) {  	buffer [lenght++] = (byte)(value & 0xff);  	value >>= 8;  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeNumber,The following statement contains a magic number: value >>= 8;  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if (input.Length < 253)  	return ArrayHelpers.Combine (new[] {  		(byte)input.Length  	}' Encoding.UTF8.GetBytes (input));  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	if (input.Length < 0x10000) {  		stream.WriteValueU8 (253);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	} else if ((long)input.Length < 0x100000000) {  		stream.WriteValueU8 (254);  		stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  		// write packed length.  	} else {  		stream.WriteValueU8 (255);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	}  	stream.WriteString (input);  	result = stream.ToArray ();  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	if (input.Length < 0x10000) {  		stream.WriteValueU8 (253);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	} else if ((long)input.Length < 0x100000000) {  		stream.WriteValueU8 (254);  		stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  		// write packed length.  	} else {  		stream.WriteValueU8 (255);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	}  	stream.WriteString (input);  	result = stream.ToArray ();  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: using (var stream = new MemoryStream ()) {  	if (input.Length < 0x10000) {  		stream.WriteValueU8 (253);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	} else if ((long)input.Length < 0x100000000) {  		stream.WriteValueU8 (254);  		stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  		// write packed length.  	} else {  		stream.WriteValueU8 (255);  		stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  		// write packed length.  	}  	stream.WriteString (input);  	result = stream.ToArray ();  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if (input.Length < 0x10000) {  	stream.WriteValueU8 (253);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  } else if ((long)input.Length < 0x100000000) {  	stream.WriteValueU8 (254);  	stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  	// write packed length.  } else {  	stream.WriteValueU8 (255);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if (input.Length < 0x10000) {  	stream.WriteValueU8 (253);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  } else if ((long)input.Length < 0x100000000) {  	stream.WriteValueU8 (254);  	stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  	// write packed length.  } else {  	stream.WriteValueU8 (255);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if (input.Length < 0x10000) {  	stream.WriteValueU8 (253);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  } else if ((long)input.Length < 0x100000000) {  	stream.WriteValueU8 (254);  	stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  	// write packed length.  } else {  	stream.WriteValueU8 (255);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: stream.WriteValueU8 (253);  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if ((long)input.Length < 0x100000000) {  	stream.WriteValueU8 (254);  	stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  	// write packed length.  } else {  	stream.WriteValueU8 (255);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: if ((long)input.Length < 0x100000000) {  	stream.WriteValueU8 (254);  	stream.WriteValueU32 (((UInt32)input.Length).LittleEndian ());  	// write packed length.  } else {  	stream.WriteValueU8 (255);  	stream.WriteValueU16 (((UInt16)input.Length).LittleEndian ());  	// write packed length.  }  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: stream.WriteValueU8 (254);  
Magic Number,CoiniumServ.Coin.Coinbase,Serializers,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Serializers.cs,SerializeString,The following statement contains a magic number: stream.WriteValueU8 (255);  
Magic Number,CoiniumServ.Coin.Coinbase,Utils,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Utils.cs,CoinAddressToScript,The following statement contains a magic number: if (decoded.Length != 25) {  	Log.Error ("invalid address length for {0:l}"' address);  	return null;  }  
Magic Number,CoiniumServ.Coin.Coinbase,Utils,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Coin\Coinbase\Utils.cs,PubKeyToScript,The following statement contains a magic number: if (pubKey.Length != 33) {  	Log.Error ("invalid pubkey length for {0:l}"' key);  	return null;  }  
Magic Number,CoiniumServ.Cryptology,Hash,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Hash.cs,Hash,The following statement contains a magic number: if (bytes.Length != 32)  	throw new ArgumentOutOfRangeException ();  
Magic Number,CoiniumServ.Cryptology,Hash,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Hash.cs,Hash,The following statement contains a magic number: Debug.Assert (@string.Length == 64);  
Magic Number,CoiniumServ.Cryptology,Hash,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Cryptology\Hash.cs,GetHashCode,The following statement contains a magic number: return _bytes != null ? _bytes.Aggregate (1' (current' element) => 31 * current + element) : 0;  
Magic Number,CoiniumServ.Utils.Commands,CommandGroup,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Commands\CommandGroup.cs,Fallback,The following statement contains a magic number: return output.Substring (0' output.Length - 2) + ".";  
Magic Number,CoiniumServ.Server.Commands,StatsCommand,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Server\Commands\Stats.cs,Detailed,The following statement contains a magic number: output.AppendFormat ("GC Allocated Memory: {0}KB "' GC.GetTotalMemory (true) / 1024);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value > 0) {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  } else {  	sign = -1;  	value = -value;  	uint low = (uint)value;  	uint high = (uint)((ulong)value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint[high != 0 ? 2 : 1];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint[high != 0 ? 2 : 1];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  	sign = 0;  	data = ZERO;  } else {  	sign = 1;  	uint low = (uint)value;  	uint high = (uint)(value >> 32);  	data = new uint[high != 0 ? 2 : 1];  	data [0] = low;  	if (high != 0)  		data [1] = high;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint[high != 0 ? 2 : 1];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Negative,The following statement contains a magic number: return ((v [7] & 0x80) != 0);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Mantissa,The following statement contains a magic number: return (ulong)((ulong)i1 | ((ulong)i2 << 32));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: sign = (short)((bits [3] & DecimalSignMask) != 0 ? -1 : 1);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  	data [2] = (uint)bits [2];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  	data [2] = (uint)bits [2];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  	data [2] = (uint)bits [2];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [2] = (uint)bits [2];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [2] = (uint)bits [2];  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  	while (value [len - 1] == 0) {  		if (--len == 0) {  			sign = 0;  			data = ZERO;  			return;  		}  	}  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	}  	size = len & 0x3;  	if (size > 0) {  		int idx = data.Length - 1;  		for (int i = 0; i < size; ++i)  			data [idx] |= (uint)(value [j++] << (i * 8));  	}  } else {  	int full_words' size;  	full_words = size = len / 4;  	if ((len & 0x3) != 0)  		++size;  	data = new uint[size];  	uint word' borrow = 1;  	ulong sub = 0;  	int j = 0;  	for (int i = 0; i < full_words; ++i) {  		word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  		sub = (ulong)word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [i] = ~word;  	}  	size = len & 0x3;  	if (size > 0) {  		word = 0;  		uint store_mask = 0;  		for (int i = 0; i < size; ++i) {  			word |= (uint)(value [j++] << (i * 8));  			store_mask = (store_mask << 8) | 0xFF;  		}  		sub = word - borrow;  		word = (uint)sub;  		borrow = (uint)(sub >> 32) & 0x1u;  		data [data.Length - 1] = ~word & store_mask;  	}  	if (borrow != 0)  		//FIXME I believe this can't happen' can someone write a test for it?  		throw new Exception ("non zero final carry");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: full_words = size = len / 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [i] = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 0) {  	int idx = data.Length - 1;  	for (int i = 0; i < size; ++i)  		data [idx] |= (uint)(value [j++] << (i * 8));  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < size; ++i)  	data [idx] |= (uint)(value [j++] << (i * 8));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: data [idx] |= (uint)(value [j++] << (i * 8));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: full_words = size = len / 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	sub = (ulong)word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [i] = ~word;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	sub = (ulong)word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [i] = ~word;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	sub = (ulong)word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [i] = ~word;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < full_words; ++i) {  	word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  	sub = (ulong)word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [i] = ~word;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: word = (uint)value [j++] | (uint)(value [j++] << 8) | (uint)(value [j++] << 16) | (uint)(value [j++] << 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: borrow = (uint)(sub >> 32) & 0x1u;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 0) {  	word = 0;  	uint store_mask = 0;  	for (int i = 0; i < size; ++i) {  		word |= (uint)(value [j++] << (i * 8));  		store_mask = (store_mask << 8) | 0xFF;  	}  	sub = word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [data.Length - 1] = ~word & store_mask;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 0) {  	word = 0;  	uint store_mask = 0;  	for (int i = 0; i < size; ++i) {  		word |= (uint)(value [j++] << (i * 8));  		store_mask = (store_mask << 8) | 0xFF;  	}  	sub = word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [data.Length - 1] = ~word & store_mask;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 0) {  	word = 0;  	uint store_mask = 0;  	for (int i = 0; i < size; ++i) {  		word |= (uint)(value [j++] << (i * 8));  		store_mask = (store_mask << 8) | 0xFF;  	}  	sub = word - borrow;  	word = (uint)sub;  	borrow = (uint)(sub >> 32) & 0x1u;  	data [data.Length - 1] = ~word & store_mask;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < size; ++i) {  	word |= (uint)(value [j++] << (i * 8));  	store_mask = (store_mask << 8) | 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < size; ++i) {  	word |= (uint)(value [j++] << (i * 8));  	store_mask = (store_mask << 8) | 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: word |= (uint)(value [j++] << (i * 8));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: store_mask = (store_mask << 8) | 0xFF;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: borrow = (uint)(sub >> 32) & 0x1u;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x & 0x33333333) + ((x >> 2) & 0x33333333);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x + (x >> 4)) & 0x0F0F0F0F;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 8);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 16);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,PopulationCount,The following statement contains a magic number: return (int)((x * 0x0101010101010101UL) >> 56);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: return 32 - PopulationCount (value);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,LeadingZeroCount,The following statement contains a magic number: return 64 - PopulationCount (value);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,BitScanBackward,The following statement contains a magic number: for (int i = 31; i >= 0; --i) {  	uint mask = 1u << i;  	if ((word & mask) == mask)  		return i;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10' null);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: if (format == null || format == "")  	return ToString (10' provider);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10' provider);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: switch (format [0]) {  case 'd':  case 'D':  case 'g':  case 'G':  case 'r':  case 'R':  	return ToStringWithPadding (format' 10' provider);  case 'x':  case 'X':  	return ToStringWithPadding (format' 16' null);  default:  	throw new FormatException (string.Format ("format '{0}' not implemented"' format));  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: switch (format [0]) {  case 'd':  case 'D':  case 'g':  case 'G':  case 'r':  case 'R':  	return ToStringWithPadding (format' 10' provider);  case 'x':  case 'X':  	return ToStringWithPadding (format' 16' null);  default:  	throw new FormatException (string.Format ("format '{0}' not implemented"' format));  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: return ToStringWithPadding (format' 10' provider);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: return ToStringWithPadding (format' 16' null);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 0; i < v.Length; ++i) {  	uint word = v [i];  	carry = (ulong)~word + carry;  	word = (uint)carry;  	carry = (uint)(carry >> 32);  	res [i] = word;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: carry = (uint)(carry >> 32);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 1; i < idx; ++i)  	mask = (mask << 8) | 0xFF;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: mask = (mask << 8) | 0xFF;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1)  	a = this;  else {  	uint[] dt = data;  	if (radix > 10)  		dt = MakeTwoComplement (dt);  	a = new BigInteger (1' dt);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: if (radix > 10)  	dt = MakeTwoComplement (dt);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == -1 && radix == 10) {  	NumberFormatInfo info = null;  	if (provider != null)  		info = provider.GetFormat (typeof(NumberFormatInfo)) as NumberFormatInfo;  	if (info != null) {  		string str = info.NegativeSign;  		for (int i = str.Length - 1; i >= 0; --i)  			digits.Add (str [i]);  	} else {  		digits.Add ('-');  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1 && radix > 10 && (last < '0' || last > '9'))  	digits.Add ('0');  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: while (pos < s.Length) {  	if (!ValidDigit (s [pos]' AllowHexSpecifier)) {  		if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator)))  			continue;  		if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) {  			decimalPointPos = nDigits;  			continue;  		}  		break;  	}  	nDigits++;  	if (AllowHexSpecifier) {  		hexDigit = s [pos++];  		if (Char.IsDigit (hexDigit))  			digitValue = (byte)(hexDigit - '0');  		else if (Char.IsLower (hexDigit))  			digitValue = (byte)(hexDigit - 'a' + 10);  		else  			digitValue = (byte)(hexDigit - 'A' + 10);  		if (firstHexDigit && (byte)digitValue >= 8)  			negative = true;  		number = number * 16 + digitValue;  		firstHexDigit = false;  		continue;  	}  	number = number * 10 + (byte)(s [pos++] - '0');  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: while (pos < s.Length) {  	if (!ValidDigit (s [pos]' AllowHexSpecifier)) {  		if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator)))  			continue;  		if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) {  			decimalPointPos = nDigits;  			continue;  		}  		break;  	}  	nDigits++;  	if (AllowHexSpecifier) {  		hexDigit = s [pos++];  		if (Char.IsDigit (hexDigit))  			digitValue = (byte)(hexDigit - '0');  		else if (Char.IsLower (hexDigit))  			digitValue = (byte)(hexDigit - 'a' + 10);  		else  			digitValue = (byte)(hexDigit - 'A' + 10);  		if (firstHexDigit && (byte)digitValue >= 8)  			negative = true;  		number = number * 16 + digitValue;  		firstHexDigit = false;  		continue;  	}  	number = number * 10 + (byte)(s [pos++] - '0');  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: while (pos < s.Length) {  	if (!ValidDigit (s [pos]' AllowHexSpecifier)) {  		if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator)))  			continue;  		if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) {  			decimalPointPos = nDigits;  			continue;  		}  		break;  	}  	nDigits++;  	if (AllowHexSpecifier) {  		hexDigit = s [pos++];  		if (Char.IsDigit (hexDigit))  			digitValue = (byte)(hexDigit - '0');  		else if (Char.IsLower (hexDigit))  			digitValue = (byte)(hexDigit - 'a' + 10);  		else  			digitValue = (byte)(hexDigit - 'A' + 10);  		if (firstHexDigit && (byte)digitValue >= 8)  			negative = true;  		number = number * 16 + digitValue;  		firstHexDigit = false;  		continue;  	}  	number = number * 10 + (byte)(s [pos++] - '0');  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: while (pos < s.Length) {  	if (!ValidDigit (s [pos]' AllowHexSpecifier)) {  		if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator)))  			continue;  		if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) {  			decimalPointPos = nDigits;  			continue;  		}  		break;  	}  	nDigits++;  	if (AllowHexSpecifier) {  		hexDigit = s [pos++];  		if (Char.IsDigit (hexDigit))  			digitValue = (byte)(hexDigit - '0');  		else if (Char.IsLower (hexDigit))  			digitValue = (byte)(hexDigit - 'a' + 10);  		else  			digitValue = (byte)(hexDigit - 'A' + 10);  		if (firstHexDigit && (byte)digitValue >= 8)  			negative = true;  		number = number * 16 + digitValue;  		firstHexDigit = false;  		continue;  	}  	number = number * 10 + (byte)(s [pos++] - '0');  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: while (pos < s.Length) {  	if (!ValidDigit (s [pos]' AllowHexSpecifier)) {  		if (AllowThousands && (FindOther (ref pos' s' nfi.NumberGroupSeparator) || FindOther (ref pos' s' nfi.CurrencyGroupSeparator)))  			continue;  		if (AllowDecimalPoint && decimalPointPos < 0 && (FindOther (ref pos' s' nfi.NumberDecimalSeparator) || FindOther (ref pos' s' nfi.CurrencyDecimalSeparator))) {  			decimalPointPos = nDigits;  			continue;  		}  		break;  	}  	nDigits++;  	if (AllowHexSpecifier) {  		hexDigit = s [pos++];  		if (Char.IsDigit (hexDigit))  			digitValue = (byte)(hexDigit - '0');  		else if (Char.IsLower (hexDigit))  			digitValue = (byte)(hexDigit - 'a' + 10);  		else  			digitValue = (byte)(hexDigit - 'A' + 10);  		if (firstHexDigit && (byte)digitValue >= 8)  			negative = true;  		number = number * 16 + digitValue;  		firstHexDigit = false;  		continue;  	}  	number = number * 10 + (byte)(s [pos++] - '0');  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (AllowHexSpecifier) {  	hexDigit = s [pos++];  	if (Char.IsDigit (hexDigit))  		digitValue = (byte)(hexDigit - '0');  	else if (Char.IsLower (hexDigit))  		digitValue = (byte)(hexDigit - 'a' + 10);  	else  		digitValue = (byte)(hexDigit - 'A' + 10);  	if (firstHexDigit && (byte)digitValue >= 8)  		negative = true;  	number = number * 16 + digitValue;  	firstHexDigit = false;  	continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (AllowHexSpecifier) {  	hexDigit = s [pos++];  	if (Char.IsDigit (hexDigit))  		digitValue = (byte)(hexDigit - '0');  	else if (Char.IsLower (hexDigit))  		digitValue = (byte)(hexDigit - 'a' + 10);  	else  		digitValue = (byte)(hexDigit - 'A' + 10);  	if (firstHexDigit && (byte)digitValue >= 8)  		negative = true;  	number = number * 16 + digitValue;  	firstHexDigit = false;  	continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (AllowHexSpecifier) {  	hexDigit = s [pos++];  	if (Char.IsDigit (hexDigit))  		digitValue = (byte)(hexDigit - '0');  	else if (Char.IsLower (hexDigit))  		digitValue = (byte)(hexDigit - 'a' + 10);  	else  		digitValue = (byte)(hexDigit - 'A' + 10);  	if (firstHexDigit && (byte)digitValue >= 8)  		negative = true;  	number = number * 16 + digitValue;  	firstHexDigit = false;  	continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (AllowHexSpecifier) {  	hexDigit = s [pos++];  	if (Char.IsDigit (hexDigit))  		digitValue = (byte)(hexDigit - '0');  	else if (Char.IsLower (hexDigit))  		digitValue = (byte)(hexDigit - 'a' + 10);  	else  		digitValue = (byte)(hexDigit - 'A' + 10);  	if (firstHexDigit && (byte)digitValue >= 8)  		negative = true;  	number = number * 16 + digitValue;  	firstHexDigit = false;  	continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (Char.IsDigit (hexDigit))  	digitValue = (byte)(hexDigit - '0');  else if (Char.IsLower (hexDigit))  	digitValue = (byte)(hexDigit - 'a' + 10);  else  	digitValue = (byte)(hexDigit - 'A' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (Char.IsDigit (hexDigit))  	digitValue = (byte)(hexDigit - '0');  else if (Char.IsLower (hexDigit))  	digitValue = (byte)(hexDigit - 'a' + 10);  else  	digitValue = (byte)(hexDigit - 'A' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (Char.IsLower (hexDigit))  	digitValue = (byte)(hexDigit - 'a' + 10);  else  	digitValue = (byte)(hexDigit - 'A' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (Char.IsLower (hexDigit))  	digitValue = (byte)(hexDigit - 'a' + 10);  else  	digitValue = (byte)(hexDigit - 'A' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: digitValue = (byte)(hexDigit - 'a' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: digitValue = (byte)(hexDigit - 'A' + 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (firstHexDigit && (byte)digitValue >= 8)  	negative = true;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: number = number * 16 + digitValue;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: number = number * 10 + (byte)(s [pos++] - '0');  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (AllowHexSpecifier && negative) {  	BigInteger mask = BigInteger.Pow (16' nDigits) - 1;  	number = (number ^ mask) + 1;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (exponent < 0) {  	//  	// Any non-zero values after decimal point are not allowed  	//  	BigInteger remainder;  	number = BigInteger.DivRem (number' BigInteger.Pow (10' -exponent)' out remainder);  	if (!remainder.IsZero) {  		if (!tryParse)  			exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  		return false;  	}  } else if (exponent > 0) {  	number = BigInteger.Pow (10' exponent) * number;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (exponent < 0) {  	//  	// Any non-zero values after decimal point are not allowed  	//  	BigInteger remainder;  	number = BigInteger.DivRem (number' BigInteger.Pow (10' -exponent)' out remainder);  	if (!remainder.IsZero) {  		if (!tryParse)  			exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  		return false;  	}  } else if (exponent > 0) {  	number = BigInteger.Pow (10' exponent) * number;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (exponent < 0) {  	//  	// Any non-zero values after decimal point are not allowed  	//  	BigInteger remainder;  	number = BigInteger.DivRem (number' BigInteger.Pow (10' -exponent)' out remainder);  	if (!remainder.IsZero) {  		if (!tryParse)  			exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  		return false;  	}  } else if (exponent > 0) {  	number = BigInteger.Pow (10' exponent) * number;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: number = BigInteger.DivRem (number' BigInteger.Pow (10' -exponent)' out remainder);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (!remainder.IsZero) {  	if (!tryParse)  		exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  	return false;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (!tryParse)  	exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: exc = new OverflowException ("Value too large or too small. exp=" + exponent + " rem = " + remainder + " pow = " + BigInteger.Pow (10' -exponent));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (exponent > 0) {  	number = BigInteger.Pow (10' exponent) * number;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: number = BigInteger.Pow (10' exponent) * number;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindExponent,The following statement contains a magic number: for (; i < s.Length; i++) {  	if (!Char.IsDigit (s [i])) {  		exc = tryParse ? null : GetFormatException ();  		return true;  	}  	// Reduce the risk of throwing an overflow exc  	exp = checked(exp * 10 - (int)(s [i] - '0'));  	if (exp < Int32.MinValue || exp > Int32.MaxValue) {  		exc = tryParse ? null : new OverflowException ("Value too large or too small.");  		return true;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FindExponent,The following statement contains a magic number: exp = checked(exp * 10 - (int)(s [i] - '0'));  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < len; i++) {  	c = s [i];  	if (c == '\0') {  		i = len;  		continue;  	}  	if (c >= '0' && c <= '9') {  		byte d = (byte)(c - '0');  		val = val * 10 + d;  		digits_seen = true;  	} else if (!ProcessTrailingWhitespace (tryParse' s' i' ref exc))  		return false;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: if (c >= '0' && c <= '9') {  	byte d = (byte)(c - '0');  	val = val * 10 + d;  	digits_seen = true;  } else if (!ProcessTrailingWhitespace (tryParse' s' i' ref exc))  	return false;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Parse,The following statement contains a magic number: val = val * 10 + d;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  	if ((value.data [length] & (1 << curBit)) != 0) {  		bitCount = curBit + length * 32;  		break;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  	if ((value.data [length] & (1 << curBit)) != 0) {  		bitCount = curBit + length * 32;  		break;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: if ((value.data [length] & (1 << curBit)) != 0) {  	bitCount = curBit + length * 32;  	break;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: bitCount = curBit + length * 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: for (long curbit = bitlen; curbit >= 0; --curbit) {  	if ((value & testBit).sign != 0)  		c += d;  	d *= 0.5;  	testBit = testBit >> 1;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: d *= 0.5;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log,The following statement contains a magic number: return (System.Math.Log (c) + System.Math.Log (2) * bitlen) / System.Math.Log (baseValue);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Log10,The following statement contains a magic number: return Log (value' 10);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  	return 1;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  	return sign;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  	if ((x & 0xFF000000u) != 0)  		return 4;  	return 3;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  	if ((x & 0xFF000000u) != 0)  		return 4;  	return 3;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFF000000u) != 0)  	return 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: return 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: return 3;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFF00u) != 0)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,TopByte,The following statement contains a magic number: return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  	return 4;  else if ((word & 0xFF0000u) != 0xFF0000u)  	return 3;  else if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  	return 4;  else if ((word & 0xFF0000u) != 0xFF0000u)  	return 3;  else if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  	return 4;  else if ((word & 0xFF0000u) != 0xFF0000u)  	return 3;  else if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: return 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF0000u) != 0xFF0000u)  	return 3;  else if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF0000u) != 0xFF0000u)  	return 3;  else if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: return 3;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF00u) != 0xFF00u)  	return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: return 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	extra = TopByte (topWord);  	uint mask = 0x80u << ((extra - 1) * 8);  	if ((topWord & mask) != 0) {  		needExtraZero = true;  	}  } else {  	extra = TopByte (topWord);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  	int j = 0;  	int end = data.Length - 1;  	for (int i = 0; i < end; ++i) {  		uint word = data [i];  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	while (extra-- > 0) {  		res [j++] = (byte)topWord;  		topWord >>= 8;  	}  } else {  	int j = 0;  	int end = data.Length - 1;  	uint carry = 1' word;  	ulong add;  	for (int i = 0; i < end; ++i) {  		word = data [i];  		add = (ulong)~word + carry;  		word = (uint)add;  		carry = (uint)(add >> 32);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  	}  	add = (ulong)~topWord + (carry);  	word = (uint)add;  	carry = (uint)(add >> 32);  	if (carry == 0) {  		int ex = FirstNonFFByte (word);  		bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  		int to = ex + (needExtra ? 1 : 0);  		if (to != extra)  			res = Resize (res' bytes + to);  		while (ex-- > 0) {  			res [j++] = (byte)word;  			word >>= 8;  		}  		if (needExtra)  			res [j++] = 0xFF;  	} else {  		res = Resize (res' bytes + 5);  		res [j++] = (byte)word;  		res [j++] = (byte)(word >> 8);  		res [j++] = (byte)(word >> 16);  		res [j++] = (byte)(word >> 24);  		res [j++] = 0xFF;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	uint word = data [i];  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	uint word = data [i];  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	uint word = data [i];  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 8);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 16);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: while (extra-- > 0) {  	res [j++] = (byte)topWord;  	topWord >>= 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: topWord >>= 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	word = data [i];  	add = (ulong)~word + carry;  	word = (uint)add;  	carry = (uint)(add >> 32);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	word = data [i];  	add = (ulong)~word + carry;  	word = (uint)add;  	carry = (uint)(add >> 32);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	word = data [i];  	add = (ulong)~word + carry;  	word = (uint)add;  	carry = (uint)(add >> 32);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; ++i) {  	word = data [i];  	add = (ulong)~word + carry;  	word = (uint)add;  	carry = (uint)(add >> 32);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: carry = (uint)(add >> 32);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 8);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 16);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: carry = (uint)(add >> 32);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (carry == 0) {  	int ex = FirstNonFFByte (word);  	bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  	int to = ex + (needExtra ? 1 : 0);  	if (to != extra)  		res = Resize (res' bytes + to);  	while (ex-- > 0) {  		res [j++] = (byte)word;  		word >>= 8;  	}  	if (needExtra)  		res [j++] = 0xFF;  } else {  	res = Resize (res' bytes + 5);  	res [j++] = (byte)word;  	res [j++] = (byte)(word >> 8);  	res [j++] = (byte)(word >> 16);  	res [j++] = (byte)(word >> 24);  	res [j++] = 0xFF;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: while (ex-- > 0) {  	res [j++] = (byte)word;  	word >>= 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: word >>= 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res = Resize (res' bytes + 5);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 8);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 16);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: res [j++] = (byte)(word >> 24);  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < sl; i++) {  	sum = sum + a [i] + b [i];  	res [i] = (uint)sum;  	sum >>= 32;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: sum >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < bl; i++) {  	sum = sum + a [i];  	res [i] = (uint)sum;  	sum >>= 32;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: sum >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < sl; ++i) {  	borrow = (ulong)a [i] - b [i] - borrow;  	res [i] = (uint)borrow;  	borrow = (borrow >> 32) & 0x1;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: borrow = (borrow >> 32) & 0x1;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: for (; i < bl; i++) {  	borrow = (ulong)a [i] - borrow;  	res [i] = (uint)borrow;  	borrow = (borrow >> 32) & 0x1;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: borrow = (borrow >> 32) & 0x1;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (i = 0; i < len; i++) {  	sum = sum + a [i];  	res [i] = (uint)sum;  	sum >>= 32;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreAdd,The following statement contains a magic number: sum >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < len; i++) {  	borrow = (ulong)a [i] - borrow;  	res [i] = (uint)borrow;  	borrow = (borrow >> 32) & 0x1;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,CoreSub,The following statement contains a magic number: borrow = (borrow >> 32) & 0x1;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	value <<= 16;  	shift += 16;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	value <<= 16;  	shift += 16;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	value <<= 8;  	shift += 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	value <<= 8;  	shift += 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	value <<= 4;  	shift += 4;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	value <<= 4;  	shift += 4;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	value <<= 2;  	shift += 2;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	value <<= 2;  	shift += 2;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Normalize,The following statement contains a magic number: if (shift > 0) {  	int rshift = 32 - shift;  	for (i = 0; i < l; i++) {  		uint ui = u [i];  		un [i] = (ui << shift) | carry;  		carry = ui >> rshift;  	}  } else {  	for (i = 0; i < l; i++) {  		un [i] = u [i];  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,Unnormalize,The following statement contains a magic number: if (shift > 0) {  	int lshift = 32 - shift;  	uint carry = 0;  	for (int i = length - 1; i >= 0; i--) {  		uint uni = un [i];  		r [i] = (uni >> shift) | carry;  		carry = (uni << lshift);  	}  } else {  	for (int i = 0; i < length; i++) {  		r [i] = un [i];  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  	}  	Unnormalize (un' out r' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (; ;) {  	// Estimate too big ?  	//  	if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  		qq--;  		rr += (ulong)vn [n - 1];  		if (rr < Base)  			continue;  	}  	break;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (; ;) {  	// Estimate too big ?  	//  	if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  		qq--;  		rr += (ulong)vn [n - 1];  		if (rr < Base)  			continue;  	}  	break;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  	qq--;  	rr += (ulong)vn [n - 1];  	if (rr < Base)  		continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  	qq--;  	rr += (ulong)vn [n - 1];  	if (rr < Base)  		continue;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	ulong p = vn [i] * qq;  	t = (long)un [i + j] - (long)(uint)p - b;  	un [i + j] = (uint)t;  	p >>= 32;  	t >>= 32;  	b = (long)p - t;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	ulong p = vn [i] * qq;  	t = (long)un [i + j] - (long)(uint)p - b;  	un [i + j] = (uint)t;  	p >>= 32;  	t >>= 32;  	b = (long)p - t;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: p >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: t >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (t < 0) {  	q [j]--;  	ulong c = 0;  	for (i = 0; i < n; i++) {  		c = (ulong)vn [i] + un [j + i] + c;  		un [j + i] = (uint)c;  		c >>= 32;  	}  	c += (ulong)un [j + n];  	un [j + n] = (uint)c;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	c = (ulong)vn [i] + un [j + i] + c;  	un [j + i] = (uint)c;  	c >>= 32;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigInteger,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: c >>= 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_denominator = 1 << 52;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)) {  	throw new ArgumentException ("invalid Decimal"' "value");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)) {  	throw new ArgumentException ("invalid Decimal"' "value");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)) {  	throw new ArgumentException ("invalid Decimal"' "value");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)) {  	throw new ArgumentException ("invalid Decimal"' "value");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits [3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits [3] & DecimalScaleMask) > (28 << 16)) {  	throw new ArgumentException ("invalid Decimal"' "value");  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_numerator = (new BigInteger (ul) << 32) | (uint)bits [0];  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_denominator = BigInteger.Pow (10' scale);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: exp = (int)(du.uu >> 52) & 0x7FF;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (exp == 0) {  	// Denormalized number.  	isFinite = true;  	if (man != 0)  		exp = -1074;  } else if (exp == 0x7FF) {  	// NaN or Infinite.  	isFinite = false;  	exp = Int32.MaxValue;  } else {  	isFinite = true;  	man |= 0x0010000000000000;  	// mask in the implied leading 53rd significand bit  	exp -= 1075;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (exp == 0) {  	// Denormalized number.  	isFinite = true;  	if (man != 0)  		exp = -1074;  } else if (exp == 0x7FF) {  	// NaN or Infinite.  	isFinite = false;  	exp = Int32.MaxValue;  } else {  	isFinite = true;  	man |= 0x0010000000000000;  	// mask in the implied leading 53rd significand bit  	exp -= 1075;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (man != 0)  	exp = -1074;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: exp = -1074;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (exp == 0x7FF) {  	// NaN or Infinite.  	isFinite = false;  	exp = Int32.MaxValue;  } else {  	isFinite = true;  	man |= 0x0010000000000000;  	// mask in the implied leading 53rd significand bit  	exp -= 1075;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: exp -= 1075;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0) {  	du.uu = 0;  } else {  	// Normalize so that 0x0010 0000 0000 0000 is the highest bit set  	int cbitShift = CbitHighZero (man) - 11;  	if (cbitShift < 0)  		man >>= -cbitShift;  	else  		man <<= cbitShift;  	// Move the point to just behind the leading 1: 0x001.0 0000 0000 0000  	// (52 bits) and skew the exponent (by 0x3FF == 1023)  	exp += 1075;  	if (exp >= 0x7FF) {  		// Infinity  		du.uu = 0x7FF0000000000000;  	} else if (exp <= 0) {  		// Denormalized  		exp--;  		if (exp < -52) {  			// Underflow to zero  			du.uu = 0;  		} else {  			du.uu = man >> -exp;  		}  	} else {  		// Mask off the implicit high bit  		du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0) {  	du.uu = 0;  } else {  	// Normalize so that 0x0010 0000 0000 0000 is the highest bit set  	int cbitShift = CbitHighZero (man) - 11;  	if (cbitShift < 0)  		man >>= -cbitShift;  	else  		man <<= cbitShift;  	// Move the point to just behind the leading 1: 0x001.0 0000 0000 0000  	// (52 bits) and skew the exponent (by 0x3FF == 1023)  	exp += 1075;  	if (exp >= 0x7FF) {  		// Infinity  		du.uu = 0x7FF0000000000000;  	} else if (exp <= 0) {  		// Denormalized  		exp--;  		if (exp < -52) {  			// Underflow to zero  			du.uu = 0;  		} else {  			du.uu = man >> -exp;  		}  	} else {  		// Mask off the implicit high bit  		du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0) {  	du.uu = 0;  } else {  	// Normalize so that 0x0010 0000 0000 0000 is the highest bit set  	int cbitShift = CbitHighZero (man) - 11;  	if (cbitShift < 0)  		man >>= -cbitShift;  	else  		man <<= cbitShift;  	// Move the point to just behind the leading 1: 0x001.0 0000 0000 0000  	// (52 bits) and skew the exponent (by 0x3FF == 1023)  	exp += 1075;  	if (exp >= 0x7FF) {  		// Infinity  		du.uu = 0x7FF0000000000000;  	} else if (exp <= 0) {  		// Denormalized  		exp--;  		if (exp < -52) {  			// Underflow to zero  			du.uu = 0;  		} else {  			du.uu = man >> -exp;  		}  	} else {  		// Mask off the implicit high bit  		du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0) {  	du.uu = 0;  } else {  	// Normalize so that 0x0010 0000 0000 0000 is the highest bit set  	int cbitShift = CbitHighZero (man) - 11;  	if (cbitShift < 0)  		man >>= -cbitShift;  	else  		man <<= cbitShift;  	// Move the point to just behind the leading 1: 0x001.0 0000 0000 0000  	// (52 bits) and skew the exponent (by 0x3FF == 1023)  	exp += 1075;  	if (exp >= 0x7FF) {  		// Infinity  		du.uu = 0x7FF0000000000000;  	} else if (exp <= 0) {  		// Denormalized  		exp--;  		if (exp < -52) {  			// Underflow to zero  			du.uu = 0;  		} else {  			du.uu = man >> -exp;  		}  	} else {  		// Mask off the implicit high bit  		du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  	}  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: exp += 1075;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (exp >= 0x7FF) {  	// Infinity  	du.uu = 0x7FF0000000000000;  } else if (exp <= 0) {  	// Denormalized  	exp--;  	if (exp < -52) {  		// Underflow to zero  		du.uu = 0;  	} else {  		du.uu = man >> -exp;  	}  } else {  	// Mask off the implicit high bit  	du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (exp >= 0x7FF) {  	// Infinity  	du.uu = 0x7FF0000000000000;  } else if (exp <= 0) {  	// Denormalized  	exp--;  	if (exp < -52) {  		// Underflow to zero  		du.uu = 0;  	} else {  		du.uu = man >> -exp;  	}  } else {  	// Mask off the implicit high bit  	du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (exp <= 0) {  	// Denormalized  	exp--;  	if (exp < -52) {  		// Underflow to zero  		du.uu = 0;  	} else {  		du.uu = man >> -exp;  	}  } else {  	// Mask off the implicit high bit  	du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (exp <= 0) {  	// Denormalized  	exp--;  	if (exp < -52) {  		// Underflow to zero  		du.uu = 0;  	} else {  		du.uu = man >> -exp;  	}  } else {  	// Mask off the implicit high bit  	du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (exp < -52) {  	// Underflow to zero  	du.uu = 0;  } else {  	du.uu = man >> -exp;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((uu & 0xFFFFFFFF00000000) == 0)  	return 32 + CbitHighZero ((uint)uu);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: return 32 + CbitHighZero ((uint)uu);  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero ((uint)(uu >> 32));  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if (u == 0)  	return 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: return 32;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0) {  	cbit += 16;  	u <<= 16;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0) {  	cbit += 16;  	u <<= 16;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: cbit += 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: u <<= 16;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0) {  	cbit += 8;  	u <<= 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0) {  	cbit += 8;  	u <<= 8;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: cbit += 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: u <<= 8;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0) {  	cbit += 4;  	u <<= 4;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0) {  	cbit += 4;  	u <<= 4;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: cbit += 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: u <<= 4;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0) {  	cbit += 2;  	u <<= 2;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0) {  	cbit += 2;  	u <<= 2;  }  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: cbit += 2;  
Magic Number,CoiniumServ.Utils.Numerics,BigRational,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Utils\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: u <<= 2;  
Missing Default,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,Run,The following switch statement is missing a default case: switch (block.Status) {  case BlockStatus.Pending:  	break;  case BlockStatus.Orphaned:  	_storageLayer.MoveOrphanedShares (block);  	// move existing shares for contributed miners to current round.  	_storageLayer.UpdateBlock (block);  	// update block in our persistance layer.  	orphanedCount++;  	break;  case BlockStatus.Confirmed:  	_storageLayer.UpdateBlock (block);  	// update block in our persistance layer.  	confirmedCount++;  	break;  }  
Missing Default,CoiniumServ.Blocks,BlockProcessor,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Blocks\BlockProcessor.cs,QueryBlock,The following switch statement is missing a default case: switch (poolOutput.Category) {  case "immature":  	block.Status = BlockStatus.Pending;  	break;  case "orphan":  	block.Status = BlockStatus.Orphaned;  	break;  case "generate":  	block.Status = BlockStatus.Confirmed;  	break;  }  
Missing Default,CoiniumServ.Mining.Software,MiningSoftware,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Mining\Software\MiningSoftware.cs,MiningSoftware,The following switch statement is missing a default case: switch (entry) {  case "ati":  	Platforms = Platforms | Platforms.Ati;  	break;  case "asic":  	Platforms = Platforms | Platforms.Asic;  	break;  case "cpu":  	Platforms = Platforms | Platforms.Cpu;  	break;  case "nvidia":  	Platforms = Platforms | Platforms.Nvidia;  	break;  }  
Missing Default,CoiniumServ.Shares,ShareManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Shares\ShareManager.cs,HandleInvalidShare,The following switch statement is missing a default case: switch (share.Error) {  case ShareError.DuplicateShare:  	exception = new DuplicateShareError (share.Nonce);  	break;  case ShareError.IncorrectExtraNonce2Size:  	exception = new OtherError ("Incorrect extranonce2 size");  	break;  case ShareError.IncorrectNTimeSize:  	exception = new OtherError ("Incorrect nTime size");  	break;  case ShareError.IncorrectNonceSize:  	exception = new OtherError ("Incorrect nonce size");  	break;  case ShareError.JobNotFound:  	exception = new JobNotFoundError (share.JobId);  	break;  case ShareError.LowDifficultyShare:  	exception = new LowDifficultyShare (share.Difficulty);  	break;  case ShareError.NTimeOutOfRange:  	exception = new OtherError ("nTime out of range");  	break;  }  
Missing Default,CoiniumServ.Logging,LogTarget,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogTarget.cs,LogTarget,The following switch statement is missing a default case: switch ((string)config.level) {  case "verbose":  	Level = LogEventLevel.Verbose;  	break;  case "debug":  	Level = LogEventLevel.Debug;  	break;  case "information":  	Level = LogEventLevel.Information;  	break;  case "warning":  	Level = LogEventLevel.Warning;  	break;  case "error":  	Level = LogEventLevel.Error;  	break;  case "fatal":  	Level = LogEventLevel.Fatal;  	break;  }  
Missing Default,CoiniumServ.Logging,LogManager,F:\newReposMay17\int6_CoiniumServ\src\CoiniumServ\Logging\LogManager.cs,EmitConfiguration,The following switch statement is missing a default case: switch (target.Type) {  case LogTargetType.File:  	CreateFileLog (_mainConfig' target);  	break;  case LogTargetType.Packet:  	CreatePacketLog (_packetLoggerConfig' target);  	break;  }  
