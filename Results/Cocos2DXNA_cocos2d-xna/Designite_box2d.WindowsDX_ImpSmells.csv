Implementation smell,Namespace,Class,File,Method,Description
Long Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The method has 115 lines of code.
Long Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygons,The method has 125 lines of code.
Long Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,The method has 116 lines of code.
Long Method,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve3,The method has 133 lines of code.
Long Method,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,The method has 181 lines of code.
Long Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,InsertLeaf,The method has 119 lines of code.
Long Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,Balance,The method has 122 lines of code.
Long Method,Box2D.Collision,b2EPCollider,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2EPCollider.cs,Collide,The method has 368 lines of code.
Long Method,Box2D.Collision,b2WorldManifold,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Manifold.cs,Initialize,The method has 142 lines of code.
Long Method,Box2D.Collision,b2TimeOfImpact,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Compute,The method has 223 lines of code.
Long Method,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,Solve,The method has 181 lines of code.
Long Method,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,SolveTOI,The method has 111 lines of code.
Long Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,Solve,The method has 195 lines of code.
Long Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The method has 295 lines of code.
Long Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,InitializeVelocityConstraints,The method has 190 lines of code.
Long Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method has 332 lines of code.
Long Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PrismaticJoint.cs,InitVelocityConstraints,The method has 118 lines of code.
Long Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The method has 103 lines of code.
Long Method,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2RevoluteJoint.cs,InitVelocityConstraints,The method has 107 lines of code.
Long Method,Box2D.Dynamics.Joints,b2WheelJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,The method has 114 lines of code.
Complex Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2GetPointStates,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygons,Cyclomatic complexity of the method is 9
Complex Method,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,Cyclomatic complexity of the method is 12
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,InsertLeaf,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,Balance,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,RebuildBottomUp,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2EPCollider,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2EPCollider.cs,Collide,Cyclomatic complexity of the method is 21
Complex Method,Box2D.Collision,b2TimeOfImpact,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Compute,Cyclomatic complexity of the method is 17
Complex Method,Box2D.Dynamics,b2ContactManager,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2ContactManager.cs,Destroy,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Dynamics,b2ContactManager,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2ContactManager.cs,AddPair,Cyclomatic complexity of the method is 12
Complex Method,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,Solve,Cyclomatic complexity of the method is 20
Complex Method,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,SolveTOI,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DestroyBody,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,CreateJoint,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DestroyJoint,Cyclomatic complexity of the method is 14
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,Solve,Cyclomatic complexity of the method is 25
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,Cyclomatic complexity of the method is 30
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DrawDebugData,Cyclomatic complexity of the method is 17
Complex Method,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,Dump,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Joints,b2WheelJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 9
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollideCircles,The method has 5 parameters. Parameters: manifold' circleA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The method has 5 parameters. Parameters: manifold' polygonA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygons,The method has 5 parameters. Parameters: manifold' polyA' xfA' polyB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2EdgeSeparation,The method has 5 parameters. Parameters: poly1' xf1' edge1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,The method has 5 parameters. Parameters: manifold' edgeA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollideEdgeAndPolygon,The method has 5 parameters. Parameters: manifold' edgeA' xfA' polygonB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2ClipSegmentToLine,The method has 5 parameters. Parameters: vOut' vIn' normal' offset' vertexIndexA
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2TestOverlap,The method has 6 parameters. Parameters: shapeA' indexA' shapeB' indexB' xfA' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The method has 5 parameters. Parameters: edgeIndex' poly1' xf1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2FindIncidentEdge,The method has 6 parameters. Parameters: c' poly1' xf1' edge1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,ReadCache,The method has 5 parameters. Parameters: cache' proxyA' transformA' proxyB' transformB
Long Parameter List,Box2D.Collision,b2EPCollider,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2EPCollider.cs,Collide,The method has 5 parameters. Parameters: manifold' edgeA' xfA' polygonB' xfB
Long Parameter List,Box2D.Collision,b2WorldManifold,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Manifold.cs,Initialize,The method has 5 parameters. Parameters: manifold' xfA' radiusA' xfB' radiusB
Long Parameter List,Box2D.Collision,b2SeparationFunction,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Initialize,The method has 8 parameters. Parameters: cache' proxyA' sweepA' proxyB' sweepB' t1' xfA' xfB
Long Parameter List,Box2D.Dynamics.Joints,b2PulleyJointDef,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PullyJointDef.cs,Initialize,The method has 7 parameters. Parameters: bA' bB' groundA' groundB' anchorA' anchorB' r
Long Statement,Box2D.Collision,b2ClipVertex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,Dump,The length of the statement  "            System.Diagnostics.Debug.WriteLine("b2ClipVertex {{ v={0}'{1} - feature={4}@{2}'{5}@{3} }}"' v.x' v.y' id.indexA' id.indexB' id.typeA' id.typeB); " is 145.
Long Statement,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2TestOverlap,The length of the statement  "//            Console.WriteLine("{2} vs {3}: distance={0} after {1} iters"' output.distance' output.iterations' shapeA.ShapeType' shapeB.ShapeType); " is 148.
Long Statement,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The length of the statement  "            float dx = (xf2.q.c * poly2.Centroid.x - xf2.q.s * poly2.Centroid.y) + xf2.p.x - ((xf1.q.c * poly1.Centroid.x - xf1.q.s * poly1.Centroid.y) + xf1.p.x); " is 151.
Long Statement,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The length of the statement  "            float dy = (xf2.q.s * poly2.Centroid.x + xf2.q.c * poly2.Centroid.y) + xf2.p.y - ((xf1.q.s * poly1.Centroid.x + xf1.q.c * poly1.Centroid.y) + xf1.p.y); " is 151.
Long Statement,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeMass,The length of the statement  "            massData.I += massData.mass * (b2Math.b2Dot(ref massData.center' ref massData.center) - b2Math.b2Dot(ref center' ref center)); " is 126.
Long Statement,Box2D.Common,b2Vec2,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Common\b2Vec2.cs,Set,The length of the statement  "                System.Diagnostics.Debug.WriteLine("Invalid vector - this message is here for the sake of a breakpoint Set({0}'{1})"' x' y); " is 124.
Long Statement,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The length of the statement  "                m_TOIIsland = new b2Island(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener); " is 128.
Long Statement,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "                    // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires " is 120.
Long Statement,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveTOIPositionConstraints,The length of the statement  "                    float C = b2Math.b2Clamp(b2Settings.b2_toiBaugarte * (separation + b2Settings.b2_linearSlop)' -b2Settings.b2_maxLinearCorrection' 0.0f); " is 136.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The length of the statement  "                    C2 = b2Math.b2Clamp(translation - m_lowerTranslation + b2Settings.b2_linearSlop' -b2Settings.b2_maxLinearCorrection' 0.0f); " is 123.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The length of the statement  "                    C2 = b2Math.b2Clamp(translation - m_upperTranslation - b2Settings.b2_linearSlop' 0.0f' b2Settings.b2_maxLinearCorrection); " is 122.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2PrismaticJoint.cs,GetJointSpeed,The length of the statement  "            float speed = b2Math.b2Dot(d' b2Math.b2Cross(wA' ref axis)) + b2Math.b2Dot(axis' vB + b2Math.b2Cross(wB' ref rB) - vA - b2Math.b2Cross(wA' ref rA)); " is 148.
Long Statement,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2RevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "                    float C = b2Math.b2Clamp(angle - m_lowerAngle' -b2Settings.b2_maxAngularCorrection' b2Settings.b2_maxAngularCorrection); " is 120.
Complex Conditional,Box2D.Dynamics,b2ContactManager,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2ContactManager.cs,AddPair,The conditional expression  "fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB"  is complex.
Complex Conditional,Box2D.Dynamics,b2ContactManager,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2ContactManager.cs,AddPair,The conditional expression  "fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA"  is complex.
Virtual Method Call from Constructor,Box2D.Collision.Shapes,b2ChainShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2ChainShape.cs,b2ChainShape,The constructor "b2ChainShape" calls a virtual method "CreateChain".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetJointType".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetJointType".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalXAxisA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalXAxisA".
Magic Number,Box2D,b2ArrayPool<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,Create,The following statement contains a magic number: if (pow)              {                  var l = 2;                  while (l < length) l <<= 1;                  length = l;              }
Magic Number,Box2D,PoolEntry,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,Add,The following statement contains a magic number: if (Count == Elements.Length)                  {                      var newElements = new T[Elements.Length * 2][];                      Array.Copy(Elements' newElements' Elements.Length);                      Elements = newElements;                  }
Magic Number,Box2D,b2ReusedObject<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,Create,The following statement contains a magic number: if (_count == _created.Length)              {                  var tmp = _created;                  _created = new T[_created.Length * 2];                  Array.Copy(tmp' _created' _count);              }
Magic Number,Box2D,b2IntStack,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,b2IntStack,The following statement contains a magic number: _capacity = 128;
Magic Number,Box2D,b2IntStack,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,b2IntStack,The following statement contains a magic number: _array = b2ArrayPool<int>.Create(128' true);
Magic Number,Box2D,b2IntStack,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\b2InternalClasses.cs,Push,The following statement contains a magic number: if (_count >= _capacity - 1)              {                  _capacity *= 2;                  var newArray = b2ArrayPool<int>.Create(_capacity' true);                  Array.Copy(_array' newArray' _array.Length);                  b2ArrayPool<int>.Free(_array);                  _array = newArray;              }
Magic Number,Box2D.Collision,b2AABB,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2AABB.cs,RayCast,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  float p_i' lb' ub' d_i' absd_i;                  p_i = (i == 0 ? p.x : p.y);                  lb = (i == 0 ? LowerBound.x : LowerBound.y);                  ub = (i == 0 ? UpperBound.x : UpperBound.y);                  absd_i = (i == 0 ? absD.x : absD.y);                  d_i = (i == 0 ? d.x : d.y);                    if (absd_i < b2Settings.b2_epsilon)                  {                      // Parallel.                      if (p_i < lb || ub < p_i)                      {                          output.fraction = 0f;                          output.normal = b2Vec2.Zero;                          return false;                      }                  }                  else                  {                      float inv_d = 1.0f / d_i;                      float t1 = (lb - p_i) * inv_d;                      float t2 = (ub - p_i) * inv_d;                        // Sign of the normal vector.                      float s = -1.0f;                        if (t1 > t2)                      {                          b2Math.b2Swap(ref t1' ref t2);                          s = 1.0f;                      }                        // Push the min up                      if (t1 > tmin)                      {                          normal.SetZero();                          if (i == 0)                          {                              normal.x = s;                          }                          else                          {                              normal.y = s;                          }                          tmin = t1;                      }                        // Pull the max down                      tmax = tmax < t2 ? tmax : t2;                        if (tmin > tmax)                      {                          output.fraction = 0f;                          output.normal = b2Vec2.Zero;                          return false;                      }                  }              }
Magic Number,Box2D.Collision,b2BroadPhase,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2BroadPhase.cs,b2BroadPhase,The following statement contains a magic number: m_pairCapacity = 16;
Magic Number,Box2D.Collision,b2BroadPhase,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2BroadPhase.cs,b2BroadPhase,The following statement contains a magic number: m_moveCapacity = 16;
Magic Number,Box2D.Collision,b2BroadPhase,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2BroadPhase.cs,BufferMove,The following statement contains a magic number: if (m_moveCount == m_moveCapacity)              {                  int[] oldBuffer = m_moveBuffer;                  m_moveCapacity *= 2;                  m_moveBuffer = new int[m_moveCapacity];                  oldBuffer.CopyTo(m_moveBuffer' 0);              }
Magic Number,Box2D.Collision,b2BroadPhase,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2BroadPhase.cs,QueryCallback,The following statement contains a magic number: if (m_pairCount == m_pairCapacity)              {                  b2Pair[] oldBuffer = m_pairBuffer;                  m_pairCapacity *= 2;                  m_pairBuffer = new b2Pair[m_pairCapacity];                  oldBuffer.CopyTo(m_pairBuffer' 0);              }
Magic Number,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: if (np < 2)              {                  return;              }
Magic Number,Box2D.Collision,b2Collision,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: if (np < 2)              {                  return;              }
Magic Number,Box2D.Collision,b2SimplexCache,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Defaults,The following statement contains a magic number: indexA = new int[3];
Magic Number,Box2D.Collision,b2SimplexCache,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Defaults,The following statement contains a magic number: indexB = new int[3];
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices = new b2SimplexVertex[3];
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices[2] = new b2SimplexVertex();
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices_2 = m_vertices[2];
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,ReadCache,The following statement contains a magic number: Debug.Assert(cache.count <= 3);
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetSearchDirection,The following statement contains a magic number: switch (m_count)              {                  case 1:                      dir.x = -m_vertices_0.w.x;                      dir.y = -m_vertices_0.w.y;                      return;                    case 2:                  {                      float e12x = m_vertices_1.w.x - m_vertices_0.w.x;                      float e12y = m_vertices_1.w.y - m_vertices_0.w.y;                        float sgn = e12x * -m_vertices_0.w.y - e12y * -m_vertices_0.w.x;                        if (sgn > 0.0f)                      {                          // Origin is left of e12.                          dir.x = -e12y;                          dir.y = e12x;                      }                      else                      {                          // Origin is right of e12.                          dir.x = e12y;                          dir.y = -e12x;                      }                      return;                  }                    default:                      Debug.Assert(false);                      dir = b2Vec2.Zero;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;                    case 1:                      point = m_vertices_0.w;                      return;                    case 2:                      point.x = m_vertices_0.a * m_vertices_0.w.x + m_vertices_1.a * m_vertices_1.w.x;                      point.y = m_vertices_0.a * m_vertices_0.w.y + m_vertices_1.a * m_vertices_1.w.y;                      return;                    case 3:                      point.x = 0;                      point.y = 0;                      return;                    default:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;                    case 1:                      point = m_vertices_0.w;                      return;                    case 2:                      point.x = m_vertices_0.a * m_vertices_0.w.x + m_vertices_1.a * m_vertices_1.w.x;                      point.y = m_vertices_0.a * m_vertices_0.w.y + m_vertices_1.a * m_vertices_1.w.y;                      return;                    case 3:                      point.x = 0;                      point.y = 0;                      return;                    default:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (m_count)  			{  			case 0:      			Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  				  			case 1:                  pA = m_vertices_0.wA;                  pB = m_vertices_0.wB;  				break;  				  			case 2:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y;                  pB.x = m_vertices_0.a * m_vertices_0.wB.x + m_vertices_1.a * m_vertices_1.wB.x;                  pB.y = m_vertices_0.a * m_vertices_0.wB.y + m_vertices_1.a * m_vertices_1.wB.y;  				break;  				  			case 3:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x + m_vertices_2.a * m_vertices_2.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y + m_vertices_2.a * m_vertices_2.wA.y;  				pB = pA;  				break;  				  			default:  				Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (m_count)  			{  			case 0:      			Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  				  			case 1:                  pA = m_vertices_0.wA;                  pB = m_vertices_0.wB;  				break;  				  			case 2:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y;                  pB.x = m_vertices_0.a * m_vertices_0.wB.x + m_vertices_1.a * m_vertices_1.wB.x;                  pB.y = m_vertices_0.a * m_vertices_0.wB.y + m_vertices_1.a * m_vertices_1.wB.y;  				break;  				  			case 3:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x + m_vertices_2.a * m_vertices_2.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y + m_vertices_2.a * m_vertices_2.wA.y;  				pB = pA;  				break;  				  			default:  				Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetMetric,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      float x = m_vertices_0.w.x - m_vertices_1.w.x;                      float y = m_vertices_0.w.y - m_vertices_1.w.y;                      return (float) Math.Sqrt(x * x + y * y);                    case 3:                      float ax = m_vertices_1.w.x - m_vertices_0.w.x;                      float ay = m_vertices_1.w.y - m_vertices_0.w.y;                      float bx = m_vertices_2.w.x - m_vertices_0.w.x;                      float by = m_vertices_2.w.y - m_vertices_0.w.y;                      return ax * by - ay * bx;                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,GetMetric,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      float x = m_vertices_0.w.x - m_vertices_1.w.x;                      float y = m_vertices_0.w.y - m_vertices_1.w.y;                      return (float) Math.Sqrt(x * x + y * y);                    case 3:                      float ax = m_vertices_1.w.x - m_vertices_0.w.x;                      float ay = m_vertices_1.w.y - m_vertices_0.w.y;                      float bx = m_vertices_2.w.x - m_vertices_0.w.x;                      float by = m_vertices_2.w.y - m_vertices_0.w.y;                      return ax * by - ay * bx;                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve2,The following statement contains a magic number: m_count = 2;
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)  			{  				float inv_d12 = 1.0f / (d12_1 + d12_2);                  m_vertices_0.a = d12_1 * inv_d12;                  m_vertices_1.a = d12_2 * inv_d12;  				m_count = 2;  				return;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)  			{  				float inv_d13 = 1.0f / (d13_1 + d13_2);                  m_vertices_0.a = d13_1 * inv_d13;                  m_vertices_2.a = d13_2 * inv_d13;  				m_count = 2;    			    m_vertices_1.wA = m_vertices_2.wA;  			    m_vertices_1.wB = m_vertices_2.wB;  			    m_vertices_1.w = m_vertices_2.w;  			    m_vertices_1.a = m_vertices_2.a;  			    m_vertices_1.indexA = m_vertices_2.indexA;  			    m_vertices_1.indexB = m_vertices_2.indexB;    			    return;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)  			{  				float inv_d23 = 1.0f / (d23_1 + d23_2);  				m_vertices_1.a = d23_1 * inv_d23;  				m_vertices_2.a = d23_2 * inv_d23;  				m_count = 2;    			    m_vertices_0.wA = m_vertices_2.wA;  			    m_vertices_0.wB = m_vertices_2.wB;  			    m_vertices_0.w = m_vertices_2.w;  			    m_vertices_0.a = m_vertices_2.a;  			    m_vertices_0.indexA = m_vertices_2.indexA;  			    m_vertices_0.indexB = m_vertices_2.indexB;    			    return;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: m_count = 3;
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: int k_maxIters = 20;
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: while (iter < k_maxIters)  			{  				// Copy simplex so we can identify duplicates.  				saveCount = simplex.m_count;  				for (int i = 0; i < saveCount; ++i)  				{  					saveA[i] = vertices[i].indexA;  					saveB[i] = vertices[i].indexB;  				}  				  				switch (simplex.m_count)  				{  				case 1:  					break;  					  				case 2:  					simplex.Solve2();  					break;  					  				case 3:  					simplex.Solve3();  					break;  					  				default:  					Debug.Assert(false);  					break;  				}  				  				// If we have 3 points' then the origin is in the corresponding triangle.  				if (simplex.m_count == 3)  				{  					break;  				}  				  				// Compute closest point.  			    b2Vec2 p;                  simplex.GetClosestPoint(out p);  			    distanceSqr2 = p.x * p.x + p.y * p.y;    			    // Ensure progress  				if (distanceSqr2 >= distanceSqr1)  				{  					//break;  				}  				distanceSqr1 = distanceSqr2;  				  				// Get search direction.  			    b2Vec2 d;                  simplex.GetSearchDirection(out d);  				  				// Ensure the search direction is numerically fit.  				if ((d.x * d.x + d.y * d.y) < b2Settings.b2_epsilon * b2Settings.b2_epsilon)  				{  					// The origin is probably contained by a line segment  					// or triangle. Thus the shapes are overlapped.  					  					// We can't return zero here even though there may be overlap.  					// In case the simplex is a point' segment' or triangle it is difficult  					// to determine if the origin is contained in the CSO or very close to it.  					break;  				}  				  				// Compute a tentative new simplex vertex using support points.  				b2SimplexVertex vertex = vertices[simplex.m_count];    			    var q = input.transformA.q;                    b2Vec2 b;                  b.x = q.c * -d.x + q.s * -d.y;                  b.y = -q.s * -d.x + q.c * -d.y;                    vertex.indexA = proxyA.GetSupport(ref b);    			    var vA = proxyA.m_vertices[vertex.indexA];                    vertex.wA.x = (q.c * vA.x - q.s * vA.y) + input.transformA.p.x;                  vertex.wA.y = (q.s * vA.x + q.c * vA.y) + input.transformA.p.y;    			    //                b2Vec2 wBLocal = new b2Vec2();  			    q = input.transformB.q;                  b.x = q.c * d.x + q.s * d.y;                  b.y = -q.s * d.x + q.c * d.y;    			    vertex.indexB = proxyB.GetSupport(ref b);    			    var vB = proxyB.m_vertices[vertex.indexB];                    vertex.wB.x = (input.transformB.q.c * vB.x - input.transformB.q.s * vB.y) + input.transformB.p.x;                  vertex.wB.y = (input.transformB.q.s * vB.x + input.transformB.q.c * vB.y) + input.transformB.p.y;                    vertex.w.x = vertex.wB.x - vertex.wA.x;                  vertex.w.y = vertex.wB.y - vertex.wA.y;  				  				// Iteration count is equated to the number of support point calls.  				++iter;  				++b2DistanceProxy.b2_gjkIters;  				  				// Check for duplicate support points. This is the main termination criteria.  				bool duplicate = false;  				for (int i = 0; i < saveCount; ++i)  				{  					if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i])  					{  						duplicate = true;  						break;  					}  				}  				  				// If we found a duplicate support point we must exit to avoid cycling.  				if (duplicate)  				{  					break;  				}  				  				// New vertex is ok and needed.  				++simplex.m_count;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: while (iter < k_maxIters)  			{  				// Copy simplex so we can identify duplicates.  				saveCount = simplex.m_count;  				for (int i = 0; i < saveCount; ++i)  				{  					saveA[i] = vertices[i].indexA;  					saveB[i] = vertices[i].indexB;  				}  				  				switch (simplex.m_count)  				{  				case 1:  					break;  					  				case 2:  					simplex.Solve2();  					break;  					  				case 3:  					simplex.Solve3();  					break;  					  				default:  					Debug.Assert(false);  					break;  				}  				  				// If we have 3 points' then the origin is in the corresponding triangle.  				if (simplex.m_count == 3)  				{  					break;  				}  				  				// Compute closest point.  			    b2Vec2 p;                  simplex.GetClosestPoint(out p);  			    distanceSqr2 = p.x * p.x + p.y * p.y;    			    // Ensure progress  				if (distanceSqr2 >= distanceSqr1)  				{  					//break;  				}  				distanceSqr1 = distanceSqr2;  				  				// Get search direction.  			    b2Vec2 d;                  simplex.GetSearchDirection(out d);  				  				// Ensure the search direction is numerically fit.  				if ((d.x * d.x + d.y * d.y) < b2Settings.b2_epsilon * b2Settings.b2_epsilon)  				{  					// The origin is probably contained by a line segment  					// or triangle. Thus the shapes are overlapped.  					  					// We can't return zero here even though there may be overlap.  					// In case the simplex is a point' segment' or triangle it is difficult  					// to determine if the origin is contained in the CSO or very close to it.  					break;  				}  				  				// Compute a tentative new simplex vertex using support points.  				b2SimplexVertex vertex = vertices[simplex.m_count];    			    var q = input.transformA.q;                    b2Vec2 b;                  b.x = q.c * -d.x + q.s * -d.y;                  b.y = -q.s * -d.x + q.c * -d.y;                    vertex.indexA = proxyA.GetSupport(ref b);    			    var vA = proxyA.m_vertices[vertex.indexA];                    vertex.wA.x = (q.c * vA.x - q.s * vA.y) + input.transformA.p.x;                  vertex.wA.y = (q.s * vA.x + q.c * vA.y) + input.transformA.p.y;    			    //                b2Vec2 wBLocal = new b2Vec2();  			    q = input.transformB.q;                  b.x = q.c * d.x + q.s * d.y;                  b.y = -q.s * d.x + q.c * d.y;    			    vertex.indexB = proxyB.GetSupport(ref b);    			    var vB = proxyB.m_vertices[vertex.indexB];                    vertex.wB.x = (input.transformB.q.c * vB.x - input.transformB.q.s * vB.y) + input.transformB.p.x;                  vertex.wB.y = (input.transformB.q.s * vB.x + input.transformB.q.c * vB.y) + input.transformB.p.y;                    vertex.w.x = vertex.wB.x - vertex.wA.x;                  vertex.w.y = vertex.wB.y - vertex.wA.y;  				  				// Iteration count is equated to the number of support point calls.  				++iter;  				++b2DistanceProxy.b2_gjkIters;  				  				// Check for duplicate support points. This is the main termination criteria.  				bool duplicate = false;  				for (int i = 0; i < saveCount; ++i)  				{  					if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i])  					{  						duplicate = true;  						break;  					}  				}  				  				// If we found a duplicate support point we must exit to avoid cycling.  				if (duplicate)  				{  					break;  				}  				  				// New vertex is ok and needed.  				++simplex.m_count;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: while (iter < k_maxIters)  			{  				// Copy simplex so we can identify duplicates.  				saveCount = simplex.m_count;  				for (int i = 0; i < saveCount; ++i)  				{  					saveA[i] = vertices[i].indexA;  					saveB[i] = vertices[i].indexB;  				}  				  				switch (simplex.m_count)  				{  				case 1:  					break;  					  				case 2:  					simplex.Solve2();  					break;  					  				case 3:  					simplex.Solve3();  					break;  					  				default:  					Debug.Assert(false);  					break;  				}  				  				// If we have 3 points' then the origin is in the corresponding triangle.  				if (simplex.m_count == 3)  				{  					break;  				}  				  				// Compute closest point.  			    b2Vec2 p;                  simplex.GetClosestPoint(out p);  			    distanceSqr2 = p.x * p.x + p.y * p.y;    			    // Ensure progress  				if (distanceSqr2 >= distanceSqr1)  				{  					//break;  				}  				distanceSqr1 = distanceSqr2;  				  				// Get search direction.  			    b2Vec2 d;                  simplex.GetSearchDirection(out d);  				  				// Ensure the search direction is numerically fit.  				if ((d.x * d.x + d.y * d.y) < b2Settings.b2_epsilon * b2Settings.b2_epsilon)  				{  					// The origin is probably contained by a line segment  					// or triangle. Thus the shapes are overlapped.  					  					// We can't return zero here even though there may be overlap.  					// In case the simplex is a point' segment' or triangle it is difficult  					// to determine if the origin is contained in the CSO or very close to it.  					break;  				}  				  				// Compute a tentative new simplex vertex using support points.  				b2SimplexVertex vertex = vertices[simplex.m_count];    			    var q = input.transformA.q;                    b2Vec2 b;                  b.x = q.c * -d.x + q.s * -d.y;                  b.y = -q.s * -d.x + q.c * -d.y;                    vertex.indexA = proxyA.GetSupport(ref b);    			    var vA = proxyA.m_vertices[vertex.indexA];                    vertex.wA.x = (q.c * vA.x - q.s * vA.y) + input.transformA.p.x;                  vertex.wA.y = (q.s * vA.x + q.c * vA.y) + input.transformA.p.y;    			    //                b2Vec2 wBLocal = new b2Vec2();  			    q = input.transformB.q;                  b.x = q.c * d.x + q.s * d.y;                  b.y = -q.s * d.x + q.c * d.y;    			    vertex.indexB = proxyB.GetSupport(ref b);    			    var vB = proxyB.m_vertices[vertex.indexB];                    vertex.wB.x = (input.transformB.q.c * vB.x - input.transformB.q.s * vB.y) + input.transformB.p.x;                  vertex.wB.y = (input.transformB.q.s * vB.x + input.transformB.q.c * vB.y) + input.transformB.p.y;                    vertex.w.x = vertex.wB.x - vertex.wA.x;                  vertex.w.y = vertex.wB.y - vertex.wA.y;  				  				// Iteration count is equated to the number of support point calls.  				++iter;  				++b2DistanceProxy.b2_gjkIters;  				  				// Check for duplicate support points. This is the main termination criteria.  				bool duplicate = false;  				for (int i = 0; i < saveCount; ++i)  				{  					if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i])  					{  						duplicate = true;  						break;  					}  				}  				  				// If we found a duplicate support point we must exit to avoid cycling.  				if (duplicate)  				{  					break;  				}  				  				// New vertex is ok and needed.  				++simplex.m_count;  			}
Magic Number,Box2D.Collision,b2DistanceProxy,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DistanceProxy.cs,Create,The following statement contains a magic number: bp.m_buffer = new b2Vec2[2];
Magic Number,Box2D.Collision,b2DistanceProxy,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DistanceProxy.cs,Set,The following statement contains a magic number: switch (shape.ShapeType)              {                  case b2ShapeType.e_circle:                      {                          b2CircleShape circle = (b2CircleShape)shape;                          m_buffer[0] = circle.Position;                          m_vertices = m_buffer;                          m_count = 1;                          m_radius = circle.Radius;                      }                      break;                    case b2ShapeType.e_polygon:                      {                          b2PolygonShape polygon = (b2PolygonShape)shape;                          m_vertices = polygon.Vertices;                          m_count = polygon.VertexCount;                          m_radius = polygon.Radius;                      }                      break;                    case b2ShapeType.e_chain:                      {                          b2ChainShape chain = (b2ChainShape)shape;                          Debug.Assert(0 <= index && index < chain.Count);                            m_buffer[0] = chain.Vertices[index];                          if (index + 1 < chain.Count)                          {                              m_buffer[1] = chain.Vertices[index + 1];                          }                          else                          {                              m_buffer[1] = chain.Vertices[0];                          }                            m_vertices = m_buffer;                          m_count = 2;                          m_radius = chain.Radius;                      }                      break;                    case b2ShapeType.e_edge:                      {                          b2EdgeShape edge = (b2EdgeShape)shape;                          m_buffer[0] = edge.Vertex1;                          m_buffer[1] = edge.Vertex2;                          m_vertices = m_buffer;                          m_count = 2;                          m_radius = edge.Radius;                      }                      break;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Box2D.Collision,b2DistanceProxy,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DistanceProxy.cs,Set,The following statement contains a magic number: switch (shape.ShapeType)              {                  case b2ShapeType.e_circle:                      {                          b2CircleShape circle = (b2CircleShape)shape;                          m_buffer[0] = circle.Position;                          m_vertices = m_buffer;                          m_count = 1;                          m_radius = circle.Radius;                      }                      break;                    case b2ShapeType.e_polygon:                      {                          b2PolygonShape polygon = (b2PolygonShape)shape;                          m_vertices = polygon.Vertices;                          m_count = polygon.VertexCount;                          m_radius = polygon.Radius;                      }                      break;                    case b2ShapeType.e_chain:                      {                          b2ChainShape chain = (b2ChainShape)shape;                          Debug.Assert(0 <= index && index < chain.Count);                            m_buffer[0] = chain.Vertices[index];                          if (index + 1 < chain.Count)                          {                              m_buffer[1] = chain.Vertices[index + 1];                          }                          else                          {                              m_buffer[1] = chain.Vertices[0];                          }                            m_vertices = m_buffer;                          m_count = 2;                          m_radius = chain.Radius;                      }                      break;                    case b2ShapeType.e_edge:                      {                          b2EdgeShape edge = (b2EdgeShape)shape;                          m_buffer[0] = edge.Vertex1;                          m_buffer[1] = edge.Vertex2;                          m_vertices = m_buffer;                          m_count = 2;                          m_radius = edge.Radius;                      }                      break;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,b2DynamicTree,The following statement contains a magic number: m_nodeCapacity = 16;
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,AllocateNode,The following statement contains a magic number: if (m_freeList == b2TreeNode.b2_nullNode)              {                  Debug.Assert(m_nodeCount == m_nodeCapacity);                    // The free list is empty. Rebuild a bigger pool.                  b2TreeNode[]  oldNodes = m_nodes;                  m_nodeCapacity *= 2;                  m_nodes = new b2TreeNode[m_nodeCapacity];    				// initialize new b2TreeNode                  oldNodes.CopyTo(m_nodes' 0);                    // Build a linked list for the free list. The parent                  // pointer becomes the "next" pointer.                  for (int i = m_nodeCount; i < m_nodeCapacity - 1; ++i)                  {  					if (m_nodes[i] == null)  						m_nodes[i] = new b2TreeNode();                        m_nodes[i].parentOrNext = i + 1;                      m_nodes[i].height = -1;                  }    				if (m_nodes[m_nodeCapacity - 1] == null)  					m_nodes[m_nodeCapacity - 1] = new b2TreeNode();                    m_nodes[m_nodeCapacity - 1].parentOrNext = b2TreeNode.b2_nullNode;                  m_nodes[m_nodeCapacity - 1].height = -1;                  m_freeList = m_nodeCount;              }
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2DynamicTree.cs,Balance,The following statement contains a magic number: if (A.IsLeaf() || A.height < 2)              {                  return iA;              }
Magic Number,Box2D.Collision,b2SeparationFunction,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Initialize,The following statement contains a magic number: Debug.Assert(0 < count && count < 3);
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: int k_maxIterations = 20;
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: while (true)  			{                  // Get the distance between shapes. We can also use the results                  // to get a separating axis.                  sweepA.GetTransform(out distanceInput.transformA' t1);                  sweepB.GetTransform(out distanceInput.transformB' t1);  				  				b2DistanceOutput distanceOutput;  				b2Simplex.b2Distance(out distanceOutput' ref cache' ref distanceInput);  				  				// If the shapes are overlapped' we give up on continuous collision.  				if (distanceOutput.distance <= 0.0f)  				{  					// Failure!  					output.state = b2ImpactState.e_overlapped;  					output.t = 0.0f;  					break;  				}  				  				if (distanceOutput.distance < target + tolerance)  				{  					// Victory!  					output.state = b2ImpactState.e_touching;  					output.t = t1;  					break;  				}  				  				// Initialize the separating axis.  				b2SeparationFunction fcn = new b2SeparationFunction();                  fcn.Initialize(ref cache' proxyA' ref sweepA' proxyB' ref sweepB' t1'                      ref distanceInput.transformA' ref distanceInput.transformB);  				#if false  				// Dump the curve seen by the root finder  				{  					int N = 100;  					float dx = 1.0f / N;  					float xs[N+1];  					float fs[N+1];  					  					float x = 0.0f;  					  					for (int i = 0; i <= N; ++i)  					{  						sweepA.GetTransform(&xfA' x);  						sweepB.GetTransform(&xfB' x);  						float f = fcn.Evaluate(xfA' xfB) - target;  						  						printf("%g %g\n"' x' f);  						  						xs[i] = x;  						fs[i] = f;  						  						x += dx;  					}  				}  				#endif  				  				// Compute the TOI on the separating axis. We do this by successively  				// resolving the deepest point. This loop is bounded by the number of vertices.  				bool done = false;  				float t2 = tMax;  				int pushBackIter = 0;  				while(true)  				{  					// Find the deepest point at t2. Store the witness point indices.  					int indexA' indexB;  					float s2 = fcn.FindMinSeparation(out indexA' out indexB' t2);  					  					// Is the final configuration separated?  					if (s2 > target + tolerance)  					{  						// Victory!  						output.state = b2ImpactState.e_separated;  						output.t = tMax;  						done = true;  						break;  					}  					  					// Has the separation reached tolerance?  					if (s2 > target - tolerance)  					{  						// Advance the sweeps  						t1 = t2;  						break;  					}  					  					// Compute the initial separation of the witness points.  					float s1 = fcn.Evaluate(indexA' indexB' t1);  					  					// Check for initial overlap. This might happen if the root finder  					// runs out of iterations.  					if (s1 < target - tolerance)  					{  						output.state = b2ImpactState.e_failed;  						output.t = t1;  						done = true;  						break;  					}  					  					// Check for touching  					if (s1 <= target + tolerance)  					{  						// Victory! t1 should hold the TOI (could be 0.0).  						output.state = b2ImpactState.e_touching;  						output.t = t1;  						done = true;  						break;  					}  					  					// Compute 1D root of: f(x) - target = 0  					int rootIterCount = 0;  					float a1 = t1' a2 = t2;  					while (true)  					{  						// Use a mix of the secant rule and bisection.  						float t;  						if (rootIterCount % 1 == 1) // even/odd  						{  							// Secant rule to improve convergence.  							t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  						}  						else  						{  							// Bisection to guarantee progress.  							t = 0.5f * (a1 + a2);  						}  						  						float s = fcn.Evaluate(indexA' indexB' t);  						  						if (b2Math.b2Abs(s - target) < tolerance)  						{  							// t2 holds a tentative value for t1  							t2 = t;  							break;  						}  						  						// Ensure we continue to bracket the root.  						if (s > target)  						{  							a1 = t;  							s1 = s;  						}  						else  						{  							a2 = t;  							s2 = s;  						}  						  						++rootIterCount;  						++b2_toiRootIters;  						  						if (rootIterCount == 50)  						{  							break;  						}  					}  					  					b2_toiMaxRootIters = Math.Max(b2_toiMaxRootIters' rootIterCount);  					  					++pushBackIter;  					  					if (pushBackIter == b2Settings.b2_maxPolygonVertices)  					{  						break;  					}  				}  				  				++iter;  				++b2_toiIters;  				  				if (done)  				{  					break;  				}  				  				if (iter == k_maxIterations)  				{  					// Root finder got stuck. Semi-victory.  					output.state = b2ImpactState.e_failed;  					output.t = t1;  					break;  				}  			}
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2ChainShape.cs,CreateLoop,The following statement contains a magic number: PrevVertex = Vertices[Count - 2];
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2ChainShape.cs,GetChildEdge,The following statement contains a magic number: if (index < Count - 2)              {                  edge.Vertex3 = Vertices[index + 2];                  edge.HasVertex3 = true;              }              else              {                  edge.Vertex3 = NextVertex;                  edge.HasVertex3 = HasNextVertex;              }
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2ChainShape.cs,GetChildEdge,The following statement contains a magic number: if (index < Count - 2)              {                  edge.Vertex3 = Vertices[index + 2];                  edge.HasVertex3 = true;              }              else              {                  edge.Vertex3 = NextVertex;                  edge.HasVertex3 = HasNextVertex;              }
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: m_vertexCount = 4;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[2].Set(hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[3].Set(-hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[2].Set(0.0f' 1.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[3].Set(-1.0f' 0.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: m_vertexCount = 4;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[2].Set(hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[3].Set(-hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[2].Set(0.0f' 1.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[3].Set(-1.0f' 0.0f);
Magic Number,Box2D.Common,b2Math,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Box2D.Common,b2Math,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Box2D.Common,b2Math,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Box2D.Common,b2Math,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: if (m_bodyCapacity < bodyCapacity)              {                  m_bodyCapacity = 128;                  while (m_bodyCapacity < bodyCapacity) m_bodyCapacity <<= 1;                    m_bodies = new b2Body[m_bodyCapacity];                  //m_velocities = new b2Velocity[m_bodyCapacity];                  //m_positions = new b2Position[m_bodyCapacity];              }
Magic Number,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: if (m_contactCapacity < contactCapacity)              {                  m_contactCapacity = 128;                  while (m_contactCapacity < contactCapacity) m_contactCapacity <<= 1;                    m_contacts = new b2Contact[m_contactCapacity];              }
Magic Number,Box2D.Dynamics,b2Island,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: if (m_jointCapacity < jointCapacity)              {                  m_jointCapacity = 128;                  while (m_jointCapacity < jointCapacity) m_jointCapacity <<= 1;                    m_joints = new b2Joint[m_jointCapacity];              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: if (m_TOIIsland == null)              {                  m_TOIIsland = new b2Island(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener);              }              else              {                  m_TOIIsland.Reset(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener);              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: if (m_TOIIsland == null)              {                  m_TOIIsland = new b2Island(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener);              }              else              {                  m_TOIIsland.Reset(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener);              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: for (; ; )              {  #if PROFILING                  m_profile.toiSolverIterations++;  #endif                  // Find the first TOI.                  b2Contact minContact = null;                  float minAlpha = 1.0f;                    for (b2Contact c = m_contactManager.ContactList; c != null; c = c.Next)                  {                      // Is this contact disabled?                      if ((c.Flags & b2ContactFlags.e_enabledFlag) == 0)                      {                          continue;                      }                        // Prevent excessive sub-stepping.                      if (c.m_toiCount > b2Settings.b2_maxSubSteps)                      {                          continue;                      }                        float alpha = 1.0f;                      if ((c.Flags & b2ContactFlags.e_toiFlag) != 0)                      {                          // This contact has a valid cached TOI.                          alpha = c.m_toi;                      }                      else                      {                          b2Fixture fA = c.FixtureA;                          b2Fixture fB = c.FixtureB;                            // Is there a sensor?                          if (fA.m_isSensor || fB.m_isSensor)                          {                              continue;                          }                            b2Body bA = fA.Body;                          b2Body bB = fB.Body;                            b2BodyType typeA = bA.BodyType;                          b2BodyType typeB = bB.BodyType;                            bool activeA = (bA.BodyFlags & b2BodyFlags.e_awakeFlag) != 0 && typeA != b2BodyType.b2_staticBody;                          bool activeB = (bB.BodyFlags & b2BodyFlags.e_awakeFlag) != 0 && typeB != b2BodyType.b2_staticBody;                            // Is at least one body active (awake and dynamic or kinematic)?                          if (activeA == false && activeB == false)                          {                              continue;                          }                            bool collideA = (bA.BodyFlags & b2BodyFlags.e_bulletFlag) != 0 || typeA != b2BodyType.b2_dynamicBody;                          bool collideB = (bB.BodyFlags & b2BodyFlags.e_bulletFlag) != 0 || typeB != b2BodyType.b2_dynamicBody;                            // Are these two non-bullet dynamic bodies?                          if (collideA == false && collideB == false)                          {                              continue;                          }                            // Compute the TOI for this contact.                          // Put the sweeps onto the same time interval.                          float alpha0 = bA.Sweep.alpha0;                            if (bA.Sweep.alpha0 < bB.Sweep.alpha0)                          {                              alpha0 = bB.Sweep.alpha0;                              bA.Sweep.Advance(alpha0);                          }                          else if (bB.Sweep.alpha0 < bA.Sweep.alpha0)                          {                              alpha0 = bA.Sweep.alpha0;                              bB.Sweep.Advance(alpha0);                          }                            int indexA = c.m_indexA;                          int indexB = c.m_indexB;                            // Compute the time of impact in interval [0' minTOI]                          b2TOIInput input = b2TOIInput.Zero;                          input.proxyA.Set(fA.Shape' indexA);                          input.proxyB.Set(fB.Shape' indexB);                          input.sweepA = bA.Sweep;                          input.sweepB = bB.Sweep;                          input.tMax = 1.0f;    #if PROFILING                          computeTimer.Reset();  #endif                          b2TOIOutput output;                          b2TimeOfImpact.Compute(out output' ref input);                            // Console.WriteLine("TOI Output={0}' t={1}"' output.state' output.t);    #if PROFILING                          m_profile.computeTOI += computeTimer.GetMilliseconds();  #endif                          // Console.WriteLine("b2TimeOfImpact.compute tool {0:F4} ms"' m_profile.computeTOI);                            // Beta is the fraction of the remaining portion of the .                          float beta = output.t;                          if (output.state == b2ImpactState.e_touching)                          {                              alpha = Math.Min(alpha0 + (1.0f - alpha0) * beta' 1.0f);                          }                          else                          {                              alpha = 1.0f;                          }                            c.m_toi = alpha;                          c.Flags |= b2ContactFlags.e_toiFlag;                      }                        if (alpha < minAlpha)                      {                          // This is the minimum TOI found so far.                          minContact = c;                          minAlpha = alpha;                      }                  }                    if (minContact == null || b2Settings.b2_alphaEpsilon < minAlpha)                  {                      // No more TOI events. Done!                      m_stepComplete = true;                      break;                  }                  {  #if PROFILING                      b2Timer bt = new b2Timer();  #endif                      // Advance the bodies to the TOI.                      b2Fixture fA = minContact.FixtureA;                      b2Fixture fB = minContact.FixtureB;                      b2Body bA = fA.Body;                      b2Body bB = fB.Body;                        b2Sweep backup1 = bA.Sweep;                      b2Sweep backup2 = bB.Sweep;                        bA.Advance(minAlpha);                      bB.Advance(minAlpha);                        // The TOI contact likely has some new contact points.                      minContact.Update(m_contactManager.ContactListener);                      minContact.Flags &= ~b2ContactFlags.e_toiFlag;                      ++minContact.m_toiCount;                        // Is the contact solid?                      if ((minContact.Flags & b2ContactFlags.e_enabledFlag) == 0 || (minContact.Flags & b2ContactFlags.e_touchingFlag) == 0)                      {                          // Restore the sweeps.                          minContact.SetEnabled(false);                          bA.Sweep = backup1;                          bB.Sweep = backup2;                          bA.SynchronizeTransform();                          bB.SynchronizeTransform();                          continue;                      }                        bA.SetAwake(true);                      bB.SetAwake(true);                        // Build the island                      island.Clear();                      island.Add(bA);                      island.Add(bB);                      island.Add(minContact);                        bA.BodyFlags |= b2BodyFlags.e_islandFlag;                      bB.BodyFlags |= b2BodyFlags.e_islandFlag;                      minContact.Flags |= b2ContactFlags.e_islandFlag;                        // Get contacts on bodyA and bodyB.                      bodies[0] = bA;                      bodies[1] = bB;                      for (int i = 0; i < 2; ++i)                      {                          b2Body body = bodies[i];                          if (body.BodyType == b2BodyType.b2_dynamicBody)                          {                              for (b2ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                              {                                  if (island.m_bodyCount == island.m_bodyCapacity)                                  {                                      break;                                  }                                    if (island.m_contactCount == island.m_contactCapacity)                                  {                                      break;                                  }                                    b2Contact contact = ce.Contact;                                    // Has this contact already been added to the island?                                  if ((contact.Flags & b2ContactFlags.e_islandFlag) != 0)                                  {                                      continue;                                  }                                    // Only add static' kinematic' or bullet bodies.                                  b2Body other = ce.Other;                                  if (other.BodyType == b2BodyType.b2_dynamicBody &&                                      (body.BodyFlags & b2BodyFlags.e_bulletFlag) == 0 && (other.BodyFlags & b2BodyFlags.e_bulletFlag) == 0)                                  {                                      continue;                                  }                                    // Skip sensors.                                  bool sensorA = contact.FixtureA.m_isSensor;                                  bool sensorB = contact.FixtureB.m_isSensor;                                  if (sensorA || sensorB)                                  {                                      continue;                                  }                                    // Tentatively advance the body to the TOI.                                  b2Sweep backup = other.Sweep;                                  if ((other.BodyFlags & b2BodyFlags.e_islandFlag) != 0)                                  {                                      other.Advance(minAlpha);                                  }                                    // Update the contact points                                  contact.Update(m_contactManager.ContactListener);                                    // Was the contact disabled by the user?                                  if ((contact.Flags & b2ContactFlags.e_enabledFlag) == 0)                                  {                                      other.Sweep = backup;                                      other.SynchronizeTransform();                                      continue;                                  }                                    // Are there contact points?                                  if ((contact.Flags & b2ContactFlags.e_touchingFlag) == 0)                                  {                                      other.Sweep = backup;                                      other.SynchronizeTransform();                                      continue;                                  }                                    // Add the contact to the island                                  contact.Flags |= b2ContactFlags.e_islandFlag;                                  island.Add(contact);                                    // Has the other body already been added to the island?                                  if ((other.BodyFlags & b2BodyFlags.e_islandFlag) != 0)                                  {                                      continue;                                  }                                    // Add the other body to the island.                                  other.BodyFlags |= b2BodyFlags.e_islandFlag;                                    if (other.BodyType != b2BodyType.b2_staticBody)                                  {                                      other.SetAwake(true);                                  }                                    island.Add(other);                              }                          }                      }                        b2TimeStep subStep;                      subStep.dt = (1.0f - minAlpha) * step.dt;                      subStep.inv_dt = 1.0f / subStep.dt;                      subStep.dtRatio = 1.0f;                      subStep.positionIterations = 20;                      subStep.velocityIterations = step.velocityIterations;                      subStep.warmStarting = false;                      island.SolveTOI(ref subStep' bA.IslandIndex' bB.IslandIndex);                        // Reset island flags and synchronize broad-phase proxies.                      for (int i = 0' count = island.m_bodyCount; i < count; ++i)                      {                          b2Body body = island.m_bodies[i];                          body.BodyFlags &= ~b2BodyFlags.e_islandFlag;                            if (body.BodyType != b2BodyType.b2_dynamicBody)                          {                              continue;                          }                            body.SynchronizeFixtures();                            // Invalidate all contact TOIs on this displaced body.                          for (b2ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                          {                              ce.Contact.Flags &= ~(b2ContactFlags.e_toiFlag | b2ContactFlags.e_islandFlag);                          }                      }                        // Commit fixture proxy movements to the broad-phase so that new contacts are created.                      // Also' some contacts can be destroyed.                      m_contactManager.FindNewContacts();                        if (m_subStepping)                      {                          m_stepComplete = false;                          break;                      }  #if PROFILING                      m_profile.solveTOIAdvance += bt.GetMilliseconds();  #endif                  }              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: for (; ; )              {  #if PROFILING                  m_profile.toiSolverIterations++;  #endif                  // Find the first TOI.                  b2Contact minContact = null;                  float minAlpha = 1.0f;                    for (b2Contact c = m_contactManager.ContactList; c != null; c = c.Next)                  {                      // Is this contact disabled?                      if ((c.Flags & b2ContactFlags.e_enabledFlag) == 0)                      {                          continue;                      }                        // Prevent excessive sub-stepping.                      if (c.m_toiCount > b2Settings.b2_maxSubSteps)                      {                          continue;                      }                        float alpha = 1.0f;                      if ((c.Flags & b2ContactFlags.e_toiFlag) != 0)                      {                          // This contact has a valid cached TOI.                          alpha = c.m_toi;                      }                      else                      {                          b2Fixture fA = c.FixtureA;                          b2Fixture fB = c.FixtureB;                            // Is there a sensor?                          if (fA.m_isSensor || fB.m_isSensor)                          {                              continue;                          }                            b2Body bA = fA.Body;                          b2Body bB = fB.Body;                            b2BodyType typeA = bA.BodyType;                          b2BodyType typeB = bB.BodyType;                            bool activeA = (bA.BodyFlags & b2BodyFlags.e_awakeFlag) != 0 && typeA != b2BodyType.b2_staticBody;                          bool activeB = (bB.BodyFlags & b2BodyFlags.e_awakeFlag) != 0 && typeB != b2BodyType.b2_staticBody;                            // Is at least one body active (awake and dynamic or kinematic)?                          if (activeA == false && activeB == false)                          {                              continue;                          }                            bool collideA = (bA.BodyFlags & b2BodyFlags.e_bulletFlag) != 0 || typeA != b2BodyType.b2_dynamicBody;                          bool collideB = (bB.BodyFlags & b2BodyFlags.e_bulletFlag) != 0 || typeB != b2BodyType.b2_dynamicBody;                            // Are these two non-bullet dynamic bodies?                          if (collideA == false && collideB == false)                          {                              continue;                          }                            // Compute the TOI for this contact.                          // Put the sweeps onto the same time interval.                          float alpha0 = bA.Sweep.alpha0;                            if (bA.Sweep.alpha0 < bB.Sweep.alpha0)                          {                              alpha0 = bB.Sweep.alpha0;                              bA.Sweep.Advance(alpha0);                          }                          else if (bB.Sweep.alpha0 < bA.Sweep.alpha0)                          {                              alpha0 = bA.Sweep.alpha0;                              bB.Sweep.Advance(alpha0);                          }                            int indexA = c.m_indexA;                          int indexB = c.m_indexB;                            // Compute the time of impact in interval [0' minTOI]                          b2TOIInput input = b2TOIInput.Zero;                          input.proxyA.Set(fA.Shape' indexA);                          input.proxyB.Set(fB.Shape' indexB);                          input.sweepA = bA.Sweep;                          input.sweepB = bB.Sweep;                          input.tMax = 1.0f;    #if PROFILING                          computeTimer.Reset();  #endif                          b2TOIOutput output;                          b2TimeOfImpact.Compute(out output' ref input);                            // Console.WriteLine("TOI Output={0}' t={1}"' output.state' output.t);    #if PROFILING                          m_profile.computeTOI += computeTimer.GetMilliseconds();  #endif                          // Console.WriteLine("b2TimeOfImpact.compute tool {0:F4} ms"' m_profile.computeTOI);                            // Beta is the fraction of the remaining portion of the .                          float beta = output.t;                          if (output.state == b2ImpactState.e_touching)                          {                              alpha = Math.Min(alpha0 + (1.0f - alpha0) * beta' 1.0f);                          }                          else                          {                              alpha = 1.0f;                          }                            c.m_toi = alpha;                          c.Flags |= b2ContactFlags.e_toiFlag;                      }                        if (alpha < minAlpha)                      {                          // This is the minimum TOI found so far.                          minContact = c;                          minAlpha = alpha;                      }                  }                    if (minContact == null || b2Settings.b2_alphaEpsilon < minAlpha)                  {                      // No more TOI events. Done!                      m_stepComplete = true;                      break;                  }                  {  #if PROFILING                      b2Timer bt = new b2Timer();  #endif                      // Advance the bodies to the TOI.                      b2Fixture fA = minContact.FixtureA;                      b2Fixture fB = minContact.FixtureB;                      b2Body bA = fA.Body;                      b2Body bB = fB.Body;                        b2Sweep backup1 = bA.Sweep;                      b2Sweep backup2 = bB.Sweep;                        bA.Advance(minAlpha);                      bB.Advance(minAlpha);                        // The TOI contact likely has some new contact points.                      minContact.Update(m_contactManager.ContactListener);                      minContact.Flags &= ~b2ContactFlags.e_toiFlag;                      ++minContact.m_toiCount;                        // Is the contact solid?                      if ((minContact.Flags & b2ContactFlags.e_enabledFlag) == 0 || (minContact.Flags & b2ContactFlags.e_touchingFlag) == 0)                      {                          // Restore the sweeps.                          minContact.SetEnabled(false);                          bA.Sweep = backup1;                          bB.Sweep = backup2;                          bA.SynchronizeTransform();                          bB.SynchronizeTransform();                          continue;                      }                        bA.SetAwake(true);                      bB.SetAwake(true);                        // Build the island                      island.Clear();                      island.Add(bA);                      island.Add(bB);                      island.Add(minContact);                        bA.BodyFlags |= b2BodyFlags.e_islandFlag;                      bB.BodyFlags |= b2BodyFlags.e_islandFlag;                      minContact.Flags |= b2ContactFlags.e_islandFlag;                        // Get contacts on bodyA and bodyB.                      bodies[0] = bA;                      bodies[1] = bB;                      for (int i = 0; i < 2; ++i)                      {                          b2Body body = bodies[i];                          if (body.BodyType == b2BodyType.b2_dynamicBody)                          {                              for (b2ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                              {                                  if (island.m_bodyCount == island.m_bodyCapacity)                                  {                                      break;                                  }                                    if (island.m_contactCount == island.m_contactCapacity)                                  {                                      break;                                  }                                    b2Contact contact = ce.Contact;                                    // Has this contact already been added to the island?                                  if ((contact.Flags & b2ContactFlags.e_islandFlag) != 0)                                  {                                      continue;                                  }                                    // Only add static' kinematic' or bullet bodies.                                  b2Body other = ce.Other;                                  if (other.BodyType == b2BodyType.b2_dynamicBody &&                                      (body.BodyFlags & b2BodyFlags.e_bulletFlag) == 0 && (other.BodyFlags & b2BodyFlags.e_bulletFlag) == 0)                                  {                                      continue;                                  }                                    // Skip sensors.                                  bool sensorA = contact.FixtureA.m_isSensor;                                  bool sensorB = contact.FixtureB.m_isSensor;                                  if (sensorA || sensorB)                                  {                                      continue;                                  }                                    // Tentatively advance the body to the TOI.                                  b2Sweep backup = other.Sweep;                                  if ((other.BodyFlags & b2BodyFlags.e_islandFlag) != 0)                                  {                                      other.Advance(minAlpha);                                  }                                    // Update the contact points                                  contact.Update(m_contactManager.ContactListener);                                    // Was the contact disabled by the user?                                  if ((contact.Flags & b2ContactFlags.e_enabledFlag) == 0)                                  {                                      other.Sweep = backup;                                      other.SynchronizeTransform();                                      continue;                                  }                                    // Are there contact points?                                  if ((contact.Flags & b2ContactFlags.e_touchingFlag) == 0)                                  {                                      other.Sweep = backup;                                      other.SynchronizeTransform();                                      continue;                                  }                                    // Add the contact to the island                                  contact.Flags |= b2ContactFlags.e_islandFlag;                                  island.Add(contact);                                    // Has the other body already been added to the island?                                  if ((other.BodyFlags & b2BodyFlags.e_islandFlag) != 0)                                  {                                      continue;                                  }                                    // Add the other body to the island.                                  other.BodyFlags |= b2BodyFlags.e_islandFlag;                                    if (other.BodyType != b2BodyType.b2_staticBody)                                  {                                      other.SetAwake(true);                                  }                                    island.Add(other);                              }                          }                      }                        b2TimeStep subStep;                      subStep.dt = (1.0f - minAlpha) * step.dt;                      subStep.inv_dt = 1.0f / subStep.dt;                      subStep.dtRatio = 1.0f;                      subStep.positionIterations = 20;                      subStep.velocityIterations = step.velocityIterations;                      subStep.warmStarting = false;                      island.SolveTOI(ref subStep' bA.IslandIndex' bB.IslandIndex);                        // Reset island flags and synchronize broad-phase proxies.                      for (int i = 0' count = island.m_bodyCount; i < count; ++i)                      {                          b2Body body = island.m_bodies[i];                          body.BodyFlags &= ~b2BodyFlags.e_islandFlag;                            if (body.BodyType != b2BodyType.b2_dynamicBody)                          {                              continue;                          }                            body.SynchronizeFixtures();                            // Invalidate all contact TOIs on this displaced body.                          for (b2ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                          {                              ce.Contact.Flags &= ~(b2ContactFlags.e_toiFlag | b2ContactFlags.e_islandFlag);                          }                      }                        // Commit fixture proxy movements to the broad-phase so that new contacts are created.                      // Also' some contacts can be destroyed.                      m_contactManager.FindNewContacts();                        if (m_subStepping)                      {                          m_stepComplete = false;                          break;                      }  #if PROFILING                      m_profile.solveTOIAdvance += bt.GetMilliseconds();  #endif                  }              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: if ((flags & b2DrawFlags.e_aabbBit) != 0)              {                  b2Color color = new b2Color(0.9f' 0.3f' 0.9f);                  b2BroadPhase bp = m_contactManager.BroadPhase;                    for (b2Body b = m_bodyList; b != null; b = b.Next)                  {                      if (b.IsActive() == false)                      {                          continue;                      }                        for (b2Fixture f = b.FixtureList; f != null; f = f.Next)                      {                          for (int i = 0; i < f.ProxyCount; ++i)                          {                              b2FixtureProxy proxy = f.Proxies[i];                              b2AABB aabb;                              bp.GetFatAABB(proxy.proxyId' out aabb);                              b2Vec2[] vs = new b2Vec2[4];                              vs[0].Set(aabb.LowerBound.x' aabb.LowerBound.y);                              vs[1].Set(aabb.UpperBound.x' aabb.LowerBound.y);                              vs[2].Set(aabb.UpperBound.x' aabb.UpperBound.y);                              vs[3].Set(aabb.LowerBound.x' aabb.UpperBound.y);                                m_debugDraw.DrawPolygon(vs' 4' color);                          }                      }                  }              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: if ((flags & b2DrawFlags.e_aabbBit) != 0)              {                  b2Color color = new b2Color(0.9f' 0.3f' 0.9f);                  b2BroadPhase bp = m_contactManager.BroadPhase;                    for (b2Body b = m_bodyList; b != null; b = b.Next)                  {                      if (b.IsActive() == false)                      {                          continue;                      }                        for (b2Fixture f = b.FixtureList; f != null; f = f.Next)                      {                          for (int i = 0; i < f.ProxyCount; ++i)                          {                              b2FixtureProxy proxy = f.Proxies[i];                              b2AABB aabb;                              bp.GetFatAABB(proxy.proxyId' out aabb);                              b2Vec2[] vs = new b2Vec2[4];                              vs[0].Set(aabb.LowerBound.x' aabb.LowerBound.y);                              vs[1].Set(aabb.UpperBound.x' aabb.LowerBound.y);                              vs[2].Set(aabb.UpperBound.x' aabb.UpperBound.y);                              vs[3].Set(aabb.LowerBound.x' aabb.UpperBound.y);                                m_debugDraw.DrawPolygon(vs' 4' color);                          }                      }                  }              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: if ((flags & b2DrawFlags.e_aabbBit) != 0)              {                  b2Color color = new b2Color(0.9f' 0.3f' 0.9f);                  b2BroadPhase bp = m_contactManager.BroadPhase;                    for (b2Body b = m_bodyList; b != null; b = b.Next)                  {                      if (b.IsActive() == false)                      {                          continue;                      }                        for (b2Fixture f = b.FixtureList; f != null; f = f.Next)                      {                          for (int i = 0; i < f.ProxyCount; ++i)                          {                              b2FixtureProxy proxy = f.Proxies[i];                              b2AABB aabb;                              bp.GetFatAABB(proxy.proxyId' out aabb);                              b2Vec2[] vs = new b2Vec2[4];                              vs[0].Set(aabb.LowerBound.x' aabb.LowerBound.y);                              vs[1].Set(aabb.UpperBound.x' aabb.LowerBound.y);                              vs[2].Set(aabb.UpperBound.x' aabb.UpperBound.y);                              vs[3].Set(aabb.LowerBound.x' aabb.UpperBound.y);                                m_debugDraw.DrawPolygon(vs' 4' color);                          }                      }                  }              }
Magic Number,Box2D.Dynamics,b2World,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: if ((flags & b2DrawFlags.e_aabbBit) != 0)              {                  b2Color color = new b2Color(0.9f' 0.3f' 0.9f);                  b2BroadPhase bp = m_contactManager.BroadPhase;                    for (b2Body b = m_bodyList; b != null; b = b.Next)                  {                      if (b.IsActive() == false)                      {                          continue;                      }                        for (b2Fixture f = b.FixtureList; f != null; f = f.Next)                      {                          for (int i = 0; i < f.ProxyCount; ++i)                          {                              b2FixtureProxy proxy = f.Proxies[i];                              b2AABB aabb;                              bp.GetFatAABB(proxy.proxyId' out aabb);                              b2Vec2[] vs = new b2Vec2[4];                              vs[0].Set(aabb.LowerBound.x' aabb.LowerBound.y);                              vs[1].Set(aabb.UpperBound.x' aabb.LowerBound.y);                              vs[2].Set(aabb.UpperBound.x' aabb.UpperBound.y);                              vs[3].Set(aabb.LowerBound.x' aabb.UpperBound.y);                                m_debugDraw.DrawPolygon(vs' 4' color);                          }                      }                  }              }
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,The following statement contains a magic number: if (m_constraints == null || def.count > m_constraints.Length)              {                  var count = def.count;                  var oldCount = 0;                    var capacity = 4;                  while (capacity < count)                  {                      capacity *= 2;                  }                    if (m_constraints == null)                  {                      m_constraints = new b2ContactConstraint[capacity];                  }                  else                  {                      oldCount = m_constraints.Length;                      Array.Resize(ref m_constraints' capacity);                  }                    for (int i = oldCount; i < capacity; i++)                  {                      m_constraints[i] = new b2ContactConstraint();                  }              }
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,The following statement contains a magic number: if (m_constraints == null || def.count > m_constraints.Length)              {                  var count = def.count;                  var oldCount = 0;                    var capacity = 4;                  while (capacity < count)                  {                      capacity *= 2;                  }                    if (m_constraints == null)                  {                      m_constraints = new b2ContactConstraint[capacity];                  }                  else                  {                      oldCount = m_constraints.Length;                      Array.Resize(ref m_constraints' capacity);                  }                    for (int i = oldCount; i < capacity; i++)                  {                      m_constraints[i] = new b2ContactConstraint();                  }              }
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: for (int i = 0' count = m_count; i < count; ++i)              {                  var vc = m_constraints[i];                    float radiusA = vc.radiusA;                  float radiusB = vc.radiusB;                  b2Manifold manifold = vc.contact.m_manifold;                    var bodyA = vc.BodyA;                  var bodyB = vc.BodyB;                    float mA = vc.invMassA;                  float mB = vc.invMassB;                  float iA = vc.invIA;                  float iB = vc.invIB;                  b2Vec2 localCenterA = vc.localCenterA;                  b2Vec2 localCenterB = vc.localCenterB;                    b2Vec2 cA = bodyA.InternalPosition.c;                  float aA = bodyA.InternalPosition.a;                  b2Vec2 vA = bodyA.InternalVelocity.v;                  float wA = bodyA.InternalVelocity.w;                    b2Vec2 cB = bodyB.InternalPosition.c;                  float aB = bodyB.InternalPosition.a;                  b2Vec2 vB = bodyB.InternalVelocity.v;                  float wB = bodyB.InternalVelocity.w;                    Debug.Assert(manifold.pointCount > 0);                    b2Transform xfA' xfB;                    xfA.q.s = (float)Math.Sin(aA);                  xfA.q.c = (float)Math.Cos(aA);                    xfB.q.s = (float)Math.Sin(aB);                  xfB.q.c = (float)Math.Cos(aB);                    xfA.p.x = cA.x - (xfA.q.c * localCenterA.x - xfA.q.s * localCenterA.y);                  xfA.p.y = cA.y - (xfA.q.s * localCenterA.x + xfA.q.c * localCenterA.y);                                    xfB.p.x = cB.x - (xfB.q.c * localCenterB.x - xfB.q.s * localCenterB.y);                  xfB.p.y = cB.y - (xfB.q.s * localCenterB.x + xfB.q.c * localCenterB.y);                    //b2WorldManifold worldManifold = new b2WorldManifold();                  b2WorldManifold worldManifold = _b2WorldManifold;                  worldManifold.Initialize(manifold' ref xfA' radiusA' ref xfB' radiusB);                    vc.normal = worldManifold.normal;                    float normalx = vc.normal.x;                  float normaly = vc.normal.y;                    float tangentx = normaly; //  b2Math.b2Cross(vc.normal' 1.0f);                  float tangenty = -normalx;                    int pointCount = vc.pointCount;                  for (int j = 0; j < pointCount; ++j)                  {                      var vcp = vc.points[j];                        var point = worldManifold.points[j];                        vcp.rA.x = point.x - cA.x;                      vcp.rA.y = point.y - cA.y;                        vcp.rB.x = point.x - cB.x;                      vcp.rB.y = point.y - cB.y;                        float rnA = vcp.rA.x * normaly - vcp.rA.y * normalx;                      float rnB = vcp.rB.x * normaly - vcp.rB.y * normalx;                        float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;                        vcp.normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;                        float rtA = vcp.rA.x * tangenty - vcp.rA.y * tangentx;                      float rtB = vcp.rB.x * tangenty - vcp.rB.y * tangentx;                        float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;                        vcp.tangentMass = kTangent > 0.0f ? 1.0f / kTangent : 0.0f;                        // Setup a velocity bias for restitution.                      vcp.velocityBias = 0.0f;                        float bx = -wB * vcp.rB.y;                      float by = wB * vcp.rB.x;                      float ax = -wA * vcp.rA.y;                      float ay = wA * vcp.rA.x;                        float vRel = normalx * (vB.x + bx - vA.x - ax) + normaly * (vB.y + by - vA.y - ay);                      if (vRel < -b2Settings.b2_velocityThreshold)                      {                          vcp.velocityBias = -vc.restitution * vRel;                      }                  }                    // If we have two points' then prepare the block solver.                  if (vc.pointCount == 2)                  {                      var vcp1 = vc.points[0];                      var vcp2 = vc.points[1];                        float rn1A = vcp1.rA.x * normaly - vcp1.rA.y * normalx;                      float rn1B = vcp1.rB.x * normaly - vcp1.rB.y * normalx;                      float rn2A = vcp2.rA.x * normaly - vcp2.rA.y * normalx;                      float rn2B = vcp2.rB.x * normaly - vcp2.rB.y * normalx;                        float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;                      float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;                      float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;                        // Ensure a reasonable condition number.                      float k_maxConditionNumber = 1000.0f;                      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))                      {                          vc.K.ex.x = k11;                          vc.K.ex.y = k12;                          vc.K.ey.x = k12;                          vc.K.ey.y = k22;                          vc.K.GetInverse(out vc.normalMass);                      }                      else                      {                          // The constraints are redundant' just use one.                          // TODO_ERIN use deepest?                          vc.pointCount = 1;                      }                  }              }
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < m_count; ++i)              {                  var vc = m_constraints[i];                    var bodyA = vc.BodyA;                  var bodyB = vc.BodyB;                    float mA = vc.invMassA;                  float iA = vc.invIA;                  float mB = vc.invMassB;                  float iB = vc.invIB;                  int pointCount = vc.pointCount;                    b2Vec2 vA = bodyA.InternalVelocity.v;                  float wA = bodyA.InternalVelocity.w;                  b2Vec2 vB = bodyB.InternalVelocity.v;                  float wB = bodyB.InternalVelocity.w;                    float normalx = vc.normal.x;                  float normaly = vc.normal.y;                    float tangentx = normaly; // b2Math.b2Cross(normal' 1.0f);                  float tangenty = -normalx;                  float friction = vc.friction;                      Debug.Assert(pointCount == 1 || pointCount == 2);                    // Solve tangent constraints first because non-penetration is more important                  // than friction.                  for (int j = 0; j < pointCount; ++j)                  {                      var vcp = vc.points[j];                        // Relative velocity at contact                      /*                          b.m_x = -s * a.m_y;                          b.m_y = s * a.m_x;                       */                        // b2Vec2 dv = vB + b2Math.b2Cross(wB' ref vcp.rB) - vA - b2Math.b2Cross(wA' ref vcp.rA);                      float dvx = vB.x + (-wB * vcp.rB.y) - vA.x - (-wA * vcp.rA.y);                      float dvy = vB.y + (wB * vcp.rB.x) - vA.y - (wA * vcp.rA.x);                        // Compute tangent force                      float vt = dvx * tangentx + dvy * tangenty; // b2Math.b2Dot(dv' tangent);                      float lambda = vcp.tangentMass * (-vt);                        // b2Math.b2Clamp the accumulated force                      float maxFriction = friction * vcp.normalImpulse;                      float newImpulse = vcp.tangentImpulse + lambda;                      if (newImpulse < -maxFriction)                      {                          newImpulse = -maxFriction;                      }                      else if (newImpulse > maxFriction)                      {                          newImpulse = maxFriction;                      }                        lambda = newImpulse - vcp.tangentImpulse;                      vcp.tangentImpulse = newImpulse;                        // Apply contact impulse                      // P = lambda * tangent;                      float Px = lambda * tangentx;                      float Py = lambda * tangenty;                        // vA -= mA * P;                      vA.x -= mA * Px;                      vA.y -= mA * Py;                       // wA -= iA * b2Math.b2Cross(vcp.rA' P);                      wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);                        // vB += mB * P;                      vB.x += mB * Px;                      vB.y += mB * Py;                         // wB += iB * b2Math.b2Cross(vcp.rB' P);                      wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);                        //vc.points[j] = vcp;                  }                    // Solve normal constraints                  if (vc.pointCount == 1)                  {                      var vcp = vc.points[0];                        // Relative velocity at contact                      // b2Vec2 dv = vB + b2Math.b2Cross(wB' ref vcp.rB) - vA - b2Math.b2Cross(wA' ref vcp.rA);                      float dvx = vB.x + (-wB * vcp.rB.y) - vA.x - (-wA * vcp.rA.y);                      float dvy = vB.y + (wB * vcp.rB.x) - vA.y - (wA * vcp.rA.x);                        // Compute normal impulse                      float vn = dvx * normalx + dvy * normaly; //b2Math.b2Dot(ref dv' ref normal);                      float lambda = -vcp.normalMass * (vn - vcp.velocityBias);                        // b2Math.b2Clamp the accumulated impulse                      float newImpulse = vcp.normalImpulse + lambda;                      if (newImpulse < 0f)                      {                          newImpulse = 0f;                      }                      lambda = newImpulse - vcp.normalImpulse;                      vcp.normalImpulse = newImpulse;                        // Apply contact impulse                      //b2Vec2 P = lambda * normal;                      float Px = lambda * normalx;                      float Py = lambda * normaly;                        // vA -= mA * P;                      vA.x -= mA * Px;                      vA.y -= mA * Py;                        // wA -= iA * b2Math.b2Cross(vcp.rA' P);                      wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);                        // vB += mB * P;                      vB.x += mB * Px;                      vB.y += mB * Py;                        // wB += iB * b2Math.b2Cross(vcp.rB' P);                      wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);                                            //vc.points[0] = vcp;                  }                  else                  {                      // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).                      // Build the mini LCP for this contact patch                      //                      // vn = A * x + b' vn >= 0' ' vn >= 0' x >= 0 and vn_i * x_i = 0 with i = 1..2                      //                      // A = J * W * JT and J = ( -n' -r1 x n' n' r2 x n )                      // b = vn0 - velocityBias                      //                      // The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i                      // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases                      // vn1 = 0 and vn2 = 0' x1 = 0 and x2 = 0' x1 = 0 and vn2 = 0' x2 = 0 and vn1 = 0 need to be tested. The first valid                      // solution that satisfies the problem is chosen.                      //                       // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires                      // that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).                      //                      // Substitute:                      //                       // x = a + d                      //                       // a := old total impulse                      // x := new total impulse                      // d := incremental impulse                       //                      // For the current iteration we extend the formula for the incremental impulse                      // to compute the new total impulse:                      //                      // vn = A * d + b                      //    = A * (x - a) + b                      //    = A * x + b - A * a                      //    = A * x + b'                      // b' = b - A * a;                        var cp1 = vc.points[0];                      var cp2 = vc.points[1];                        float ax = cp1.normalImpulse;                      float ay = cp2.normalImpulse;                      Debug.Assert(ax >= 0.0f && ay >= 0.0f);                        // Relative velocity at contact                      // vB + b2Math.b2Cross(wB' ref cp1.rB) - vA - b2Math.b2Cross(wA' ref cp1.rA);                      float dv1x = vB.x + (-wB * cp1.rB.y) - vA.x - (-wA * cp1.rA.y);                      float dv1y = vB.y + (wB * cp1.rB.x) - vA.y - (wA * cp1.rA.x);                        // vB + b2Math.b2Cross(wB' ref cp2.rB) - vA - b2Math.b2Cross(wA' ref cp2.rA);                      float dv2x = vB.x + (-wB * cp2.rB.y) - vA.x - (-wA * cp2.rA.y);                      float dv2y = vB.y + (wB * cp2.rB.x) - vA.y - (wA * cp2.rA.x);                        // Compute normal velocity                      float vn1 = dv1x * normalx + dv1y * normaly;// b2Math.b2Dot(ref dv1' ref normal);                      float vn2 = dv2x * normalx + dv2y * normaly;// b2Math.b2Dot(ref dv2' ref normal);                        float bx = vn1 - cp1.velocityBias;                      float by = vn2 - cp2.velocityBias;                        // Compute b'                      // (A.ex.x * v.x + A.ey.x * v.y' A.ex.y * v.x + A.ey.y * v.y)                      bx -= (vc.K.ex.x * ax + vc.K.ey.x * ay);                      by -= (vc.K.ex.y * ax + vc.K.ey.y * ay);                      // b -= b2Math.b2Mul(vc.K' a);                        //            float k_errorTol = 1e-3f;                      #region Iteration                       while (true)                      {                          //                          // Case 1: vn = 0                          //                          // 0 = A * x + b'                          //                          // Solve for x:                          //                          // x = - inv(A) * b'                          //                          float xx = -(vc.normalMass.ex.x * bx + vc.normalMass.ey.x * by);                          float xy = -(vc.normalMass.ex.y * bx + vc.normalMass.ey.y * by);                            if (xx >= 0.0f && xy >= 0.0f)                          {                              // Get the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float P1x = dx * normalx;                              float P1y = dx * normaly;                                float P2x = dy * normalx;                              float P2y = dy * normaly;                                float P12x = P1x + P2x;                              float P12y = P1y + P2y;                                vA.x -= mA * P12x;                              vA.y -= mA * P12y;                              wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));                                vB.x += mB * P12x;                              vB.y += mB * P12y;                              wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));                                // Accumulate                              cp1.normalImpulse = xx;                              cp2.normalImpulse = xy;    #if B2_DEBUG_SOLVER                      // Postconditions                      dv1 = vB + b2Math.b2Cross(wB' cp1.rB) - vA - b2Math.b2Cross(wA' cp1.rA);                      dv2 = vB + b2Math.b2Cross(wB' cp2.rB) - vA - b2Math.b2Cross(wA' cp2.rA);                        // Compute normal velocity                      vn1 = b2Math.b2Dot(dv1' normal);                      vn2 = b2Math.b2Dot(dv2' normal);                        Debug.Assert(b2Abs(vn1 - cp1.velocityBias) < k_errorTol);                      Debug.Assert(b2Abs(vn2 - cp2.velocityBias) < k_errorTol);  #endif                              break;                          }                            //                          // Case 2: vn1 = 0 and x2 = 0                          //                          //   0 = a11 * x1 + a12 * 0 + b1'                           // vn2 = a21 * x1 + a22 * 0 + b2'                          //                          xx = -cp1.normalMass * bx;                          xy = 0.0f;                          vn1 = 0.0f;                          vn2 = vc.K.ex.y * xx + by;                            if (xx >= 0.0f && vn2 >= 0.0f)                          {                              // Get the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float P1x = dx * normalx;                              float P1y = dx * normaly;                                float P2x = dy * normalx;                              float P2y = dy * normaly;                                float P12x = P1x + P2x;                              float P12y = P1y + P2y;                                vA.x -= mA * P12x;                              vA.y -= mA * P12y;                              wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));                                vB.x += mB * P12x;                              vB.y += mB * P12y;                              wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));                                // Accumulate                              cp1.normalImpulse = xx;                              cp2.normalImpulse = xy;    #if B2_DEBUG_SOLVER                      // Postconditions                      dv1 = vB + b2Math.b2Cross(wB' cp1.rB) - vA - b2Math.b2Cross(wA' cp1.rA);                        // Compute normal velocity                      vn1 = b2Math.b2Dot(dv1' normal);                        Debug.Assert(b2Abs(vn1 - cp1.velocityBias) < k_errorTol);  #endif                              break;                          }                              //                          // Case 3: vn2 = 0 and x1 = 0                          //                          // vn1 = a11 * 0 + a12 * x2 + b1'                           //   0 = a21 * 0 + a22 * x2 + b2'                          //                          xx = 0.0f;                          xy = -cp2.normalMass * by;                          vn1 = vc.K.ey.x * xy + bx;                          vn2 = 0.0f;                            if (xy >= 0.0f && vn1 >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float P1x = dx * normalx;                              float P1y = dx * normaly;                                float P2x = dy * normalx;                              float P2y = dy * normaly;                                float P12x = P1x + P2x;                              float P12y = P1y + P2y;                                vA.x -= mA * P12x;                              vA.y -= mA * P12y;                              wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));                                vB.x += mB * P12x;                              vB.y += mB * P12y;                              wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));                                // Accumulate                              cp1.normalImpulse = xx;                              cp2.normalImpulse = xy;    #if B2_DEBUG_SOLVER                      // Postconditions                      dv2 = vB + b2Math.b2Cross(wB' cp2.rB) - vA - b2Math.b2Cross(wA' cp2.rA);                        // Compute normal velocity                      vn2 = b2Math.b2Dot(dv2' normal);                        Debug.Assert(b2Abs(vn2 - cp2.velocityBias) < k_errorTol);  #endif                              break;                          }                            //                          // Case 4: x1 = 0 and x2 = 0                          //                           // vn1 = b1                          // vn2 = b2;                          xx = 0.0f;                          xy = 0.0f;                          vn1 = bx;                          vn2 = by;                            if (vn1 >= 0.0f && vn2 >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float P1x = dx * normalx;                              float P1y = dx * normaly;                                float P2x = dy * normalx;                              float P2y = dy * normaly;                                float P12x = P1x + P2x;                              float P12y = P1y + P2y;                                vA.x -= mA * P12x;                              vA.y -= mA * P12y;                              wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));                                vB.x += mB * P12x;                              vB.y += mB * P12y;                              wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));                                // Accumulate                              cp1.normalImpulse = xx;                              cp2.normalImpulse = xy;                                break;                          }                              // No solution' give up. This is hit sometimes' but it doesn't seem to matter.                          break;                      }                      #endregion                  }                    bodyA.InternalVelocity.v = vA;                  bodyA.InternalVelocity.w = wA;                  bodyB.InternalVelocity.v = vB;                  bodyB.InternalVelocity.w = wB;              }
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,Initialize,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < count3; ++i)              {                  b2Vec2 p1 = m_ps[i];                  b2Vec2 p2 = m_ps[i + 1];                  b2Vec2 p3 = m_ps[i + 2];                    b2Vec2 d1 = p2 - p1;                  b2Vec2 d2 = p3 - p2;                    float a = b2Math.b2Cross(ref d1' ref d2);                  float b = b2Math.b2Dot(ref d1' ref d2);                    m_as[i] = b2Math.b2Atan2(a' b);              }
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,SetAngle,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: for (int i = 0; i < count3; ++i)              {                  b2Vec2 p1 = m_ps[i];                  b2Vec2 p2 = m_ps[i + 1];                  b2Vec2 p3 = m_ps[i + 2];                    float m1 = m_ims[i];                  float m2 = m_ims[i + 1];                  float m3 = m_ims[i + 2];                    b2Vec2 d1 = p2 - p1;                  b2Vec2 d2 = p3 - p2;                    float L1sqr = d1.LengthSquared;                  float L2sqr = d2.LengthSquared;                    if (L1sqr * L2sqr == 0.0f)                  {                      continue;                  }                    float a = b2Math.b2Cross(ref d1' ref d2);                  float b = b2Math.b2Dot(ref d1' ref d2);                    float angle = b2Math.b2Atan2(a' b);                    b2Vec2 Jd1 = (-1.0f / L1sqr) * d1.Skew();                  b2Vec2 Jd2 = (1.0f / L2sqr) * d2.Skew();                    b2Vec2 J1 = -Jd1;                  b2Vec2 J2 = Jd1 - Jd2;                  b2Vec2 J3 = Jd2;                    float mass = m1 * b2Math.b2Dot(ref J1' ref J1) + m2 * b2Math.b2Dot(ref J2' ref J2) + m3 * b2Math.b2Dot(ref J3' ref J3);                  if (mass == 0.0f)                  {                      continue;                  }                    mass = 1.0f / mass;                    float C = angle - m_as[i];                    while (C > b2Settings.b2_pi)                  {                      angle -= 2f * (float)Math.PI;                      C = angle - m_as[i];                  }                    while (C < -(float)Math.PI)                  {                      angle += 2.0f * (float)Math.PI;                      C = angle - m_as[i];                  }                    float impulse = -m_k3 * mass * C;                    p1 += (m1 * impulse) * J1;                  p2 += (m2 * impulse) * J2;                  p3 += (m3 * impulse) * J3;                    m_ps[i] = p1;                  m_ps[i + 1] = p2;                  m_ps[i + 2] = p3;              }
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: for (int i = 0; i < count3; ++i)              {                  b2Vec2 p1 = m_ps[i];                  b2Vec2 p2 = m_ps[i + 1];                  b2Vec2 p3 = m_ps[i + 2];                    float m1 = m_ims[i];                  float m2 = m_ims[i + 1];                  float m3 = m_ims[i + 2];                    b2Vec2 d1 = p2 - p1;                  b2Vec2 d2 = p3 - p2;                    float L1sqr = d1.LengthSquared;                  float L2sqr = d2.LengthSquared;                    if (L1sqr * L2sqr == 0.0f)                  {                      continue;                  }                    float a = b2Math.b2Cross(ref d1' ref d2);                  float b = b2Math.b2Dot(ref d1' ref d2);                    float angle = b2Math.b2Atan2(a' b);                    b2Vec2 Jd1 = (-1.0f / L1sqr) * d1.Skew();                  b2Vec2 Jd2 = (1.0f / L2sqr) * d2.Skew();                    b2Vec2 J1 = -Jd1;                  b2Vec2 J2 = Jd1 - Jd2;                  b2Vec2 J3 = Jd2;                    float mass = m1 * b2Math.b2Dot(ref J1' ref J1) + m2 * b2Math.b2Dot(ref J2' ref J2) + m3 * b2Math.b2Dot(ref J3' ref J3);                  if (mass == 0.0f)                  {                      continue;                  }                    mass = 1.0f / mass;                    float C = angle - m_as[i];                    while (C > b2Settings.b2_pi)                  {                      angle -= 2f * (float)Math.PI;                      C = angle - m_as[i];                  }                    while (C < -(float)Math.PI)                  {                      angle += 2.0f * (float)Math.PI;                      C = angle - m_as[i];                  }                    float impulse = -m_k3 * mass * C;                    p1 += (m1 * impulse) * J1;                  p2 += (m2 * impulse) * J2;                  p3 += (m3 * impulse) * J3;                    m_ps[i] = p1;                  m_ps[i + 1] = p2;                  m_ps[i + 2] = p3;              }
Magic Number,Box2D.Rope,b2Rope,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: for (int i = 0; i < count3; ++i)              {                  b2Vec2 p1 = m_ps[i];                  b2Vec2 p2 = m_ps[i + 1];                  b2Vec2 p3 = m_ps[i + 2];                    float m1 = m_ims[i];                  float m2 = m_ims[i + 1];                  float m3 = m_ims[i + 2];                    b2Vec2 d1 = p2 - p1;                  b2Vec2 d2 = p3 - p2;                    float L1sqr = d1.LengthSquared;                  float L2sqr = d2.LengthSquared;                    if (L1sqr * L2sqr == 0.0f)                  {                      continue;                  }                    float a = b2Math.b2Cross(ref d1' ref d2);                  float b = b2Math.b2Dot(ref d1' ref d2);                    float angle = b2Math.b2Atan2(a' b);                    b2Vec2 Jd1 = (-1.0f / L1sqr) * d1.Skew();                  b2Vec2 Jd2 = (1.0f / L2sqr) * d2.Skew();                    b2Vec2 J1 = -Jd1;                  b2Vec2 J2 = Jd1 - Jd2;                  b2Vec2 J3 = Jd2;                    float mass = m1 * b2Math.b2Dot(ref J1' ref J1) + m2 * b2Math.b2Dot(ref J2' ref J2) + m3 * b2Math.b2Dot(ref J3' ref J3);                  if (mass == 0.0f)                  {                      continue;                  }                    mass = 1.0f / mass;                    float C = angle - m_as[i];                    while (C > b2Settings.b2_pi)                  {                      angle -= 2f * (float)Math.PI;                      C = angle - m_as[i];                  }                    while (C < -(float)Math.PI)                  {                      angle += 2.0f * (float)Math.PI;                      C = angle - m_as[i];                  }                    float impulse = -m_k3 * mass * C;                    p1 += (m1 * impulse) * J1;                  p2 += (m2 * impulse) * J2;                  p3 += (m3 * impulse) * J3;                    m_ps[i] = p1;                  m_ps[i + 1] = p2;                  m_ps[i + 2] = p3;              }
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((212' 241)' (266' 295))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((214' 240)' (320' 346)' (268' 294))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((214' 238)' (370' 394)' (268' 292)' (320' 344))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((318' 338)' (368' 388))
Missing Default,Box2D.Collision,b2WorldManifold,C:\repos\Cocos2DXNA_cocos2d-xna\box2d\Collision\b2Manifold.cs,Initialize,The following switch statement is missing a default case: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
