Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The method has 156 lines of code.
Long Method,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The method has 87 lines of code.
Complex Method,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,Cyclomatic complexity of the method is 10
Complex Method,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeEncrypt,Cyclomatic complexity of the method is 8
Complex Method,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeDecrypt,Cyclomatic complexity of the method is 8
Complex Method,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,ConnectAsync,Cyclomatic complexity of the method is 13
Complex Method,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,ProcessReceivedDataAsync,Cyclomatic complexity of the method is 7
Complex Method,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,Dispose,Cyclomatic complexity of the method is 11
Complex Method,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,Cyclomatic complexity of the method is 12
Complex Method,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,Cyclomatic complexity of the method is 19
Complex Method,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,DecodeEncryptedMessage,Cyclomatic complexity of the method is 7
Complex Method,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,Cyclomatic complexity of the method is 8
Long Parameter List,SharpMTProto,MTProtoClientBuilder,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\MTProtoClientBuilder.cs,MTProtoClientBuilder,The method has 8 parameters.
Long Parameter List,SharpMTProto,IMTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\IMTProtoClientConnection.cs,RequestAsync,The method has 4 parameters.
Long Parameter List,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,MTProtoClientConnection,The method has 5 parameters.
Long Parameter List,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,RequestAsync,The method has 4 parameters.
Long Parameter List,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,SendAsync,The method has 4 parameters.
Long Parameter List,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,DH,The method has 4 parameters.
Long Parameter List,SharpMTProto.Services,IEncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\IEncryptionServices.cs,DH,The method has 4 parameters.
Long Parameter List,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,AuthKeyNegotiator,The method has 7 parameters.
Long Parameter List,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The method has 4 parameters.
Long Parameter List,SharpMTProto.Messaging,IMessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,EncodeEncryptedMessage,The method has 5 parameters.
Long Parameter List,SharpMTProto.Messaging,IMessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,DecodeEncryptedMessage,The method has 5 parameters.
Long Parameter List,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,MessageCodec,The method has 4 parameters.
Long Parameter List,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,EncodeEncryptedMessage,The method has 5 parameters.
Long Parameter List,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,DecodeEncryptedMessage,The method has 5 parameters.
Long Parameter List,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The method has 5 parameters.
Long Parameter List,SharpMTProto.Messaging,Request,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Request.cs,Request,The method has 4 parameters.
Long Identifier,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,RequestAsync,The length of the parameter timeoutCancellationTokenSource is 30.
Long Identifier,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,SendAsync,The length of the parameter timeoutCancellationTokenSource is 30.
Long Statement,SharpMTProto,MTProtoClientBuilder,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\MTProtoClientBuilder.cs,CreateDefault,The length of the statement  "	return new MTProtoClientBuilder (clientTransportFactory' tlRig' messageIdGenerator' messageCodec' hashServices' encryptionServices' nonceGenerator' keyChain); " is 158.
Long Statement,SharpMTProto,MTProtoClientBuilder,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\MTProtoClientBuilder.cs,BuildConnection,The length of the statement  "	return new MTProtoClientConnection (clientTransportConfig' _clientTransportFactory' _tlRig' _messageIdGenerator' _messageCodec); " is 128.
Long Statement,SharpMTProto,MTProtoClientBuilder,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\MTProtoClientBuilder.cs,BuildAuthKeyNegotiator,The length of the statement  "	return new AuthKeyNegotiator (clientTransportConfig' this' _tlRig' _nonceGenerator' _hashServices' _encryptionServices' _keyChain); " is 131.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,RequestAsync,The length of the statement  "	using (CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource (timeoutCancellationTokenSource.Token' cancellationToken' _connectionCancellationToken)) { " is 175.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,SendAsync,The length of the statement  "	byte[] messageBytes = EncodeMessage (CreateMessage (requestBody' flags.HasFlag (MessageSendingFlags.ContentRelated))' flags.HasFlag (MessageSendingFlags.Encrypted)); " is 165.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,SendAsync,The length of the statement  "	using (CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource (timeoutCancellationTokenSource.Token' cancellationToken' _connectionCancellationToken)) { " is 175.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,CreateRequest,The length of the statement  "	var request = new Request<TResponse> (CreateMessage (body' flags.HasFlag (MessageSendingFlags.ContentRelated))' flags' SendRequestAsync' cancellationToken); " is 156.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The length of the statement  "				throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length)); " is 182.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The length of the statement  "				throw new InvalidMessageException (string.Format ("Invalid session ID {0}. Expected {1}."' sessionId' _config.SessionId)); " is 122.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,EncodeMessage,The length of the statement  "	byte[] messageBytes = isEncrypted ? _messageCodec.EncodeEncryptedMessage (message' _config.AuthKey' _config.Salt' _config.SessionId' Sender.Client) : _messageCodec.EncodePlainMessage (message); " is 193.
Long Statement,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ThrowIfEncryptionIsNotSupported,The length of the statement  "		throw new InvalidOperationException ("Encryption is not supported. Setup encryption first by calling Configure() method."); " is 123.
Long Statement,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,ProcessReceivedDataAsync,The length of the statement  "				if (_nextPacketDataBuffer == null || _nextPacketDataBuffer.Length < _nextPacketBytesCountLeft || _nextPacketStreamer == null) { " is 127.
Long Statement,SharpMTProto.Transport,ClientTransportFactory,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\ClientTransportFactory.cs,CreateTransport,The length of the statement  "	throw new NotSupportedException (string.Format ("Transport type '{0}' is not supported."' clientTransportConfig.TransportName)); " is 128.
Long Statement,SharpMTProto.Transport,TcpTransportPacket,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpTransportPacket.cs,InitAndCheckConsistency,The length of the statement  "			throw new TransportException (string.Format ("Invalid packet length. Expected: {0}' actual: {1}."' expectedLength' length)); " is 124.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "		Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8")))); " is 262.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "			throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash."); " is 136.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "		/****************************************************************************************************************************************" is 137.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p." is 130.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7." is 125.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future." is 136.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table." is 123.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51" is 136.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051" is 136.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8" is 136.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "                 ****************************************************************************************************************************************/ " is 137.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The length of the statement  "			Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ())); " is 184.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CheckNonce,The length of the statement  "		throw new InvalidResponseException (string.Format ("Expected nonce {0:X16} differs from the actual nonce {1:X16}."' expectedNonce' actualNonce)); " is 145.
Long Statement,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The length of the statement  "	// tmp_aes_iv := substr (SHA1(server_nonce + new_nonce)' 12' 8) + SHA1(new_nonce + new_nonce) + substr (new_nonce' 0' 4); " is 121.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * 16: msg_id too low (most likely' client time is wrong; it would be worthwhile to synchronize it using msg_id notifications" is 124.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             *     and re-send the original message with the “correct” msg_id or wrap it in a container with a new msg_id if the original" is 124.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * 17: msg_id too high (similar to the previous case' the client time has to be synchronized' and the message re-sent with the correct msg_id)" is 141.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * 32: msg_seqno too low (the server has already received a message with a lower msg_id but with either a higher or an equal and odd seqno)" is 138.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * 33: msg_seqno too high (similarly' there is a message with a higher msg_id but with either a lower or an equal and odd seqno)" is 127.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * 48: incorrect server salt (in this case' the bad_server_salt response is received with the correct salt' and the message is to be re-sent with it)" is 148.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * The intention is that error_code values are grouped (error_code >> 4): for example' the codes 0x40 - 0x4f correspond to errors in container decomposition." is 156.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * Important: if server_salt has changed on the server or if client time is incorrect' any query will result in a notification in the above format." is 146.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * The client must check that it has' in fact' recently sent a message with the specified msg_id' and if that is the case'" is 121.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * update its time correction value (the difference between the client’s and the server’s clocks) and the server salt based on msg_id" is 132.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "             * In the meantime' the original message (the one that caused the error message to be returned) must also be re-sent with a better msg_id and/or server_salt." is 156.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "	Log.Warning (string.Format ("Bad message notification received with error code: {0} ({1})."' response.ErrorCode' errorCode)); " is 125.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "		Log.Warning (string.Format ("Bad message (MsgId: 0x{0:X}) was found' but message sequence number is not the same ({1}) as server expected ({2}). Ignored."' response.BadMsgId' request.Message.Seqno' response.BadMsgSeqno)); " is 221.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "			Log.Warning (string.Format ("Error code must be '{0}' for a BadServerSalt notification' but found '{1}'."' ErrorCode.IncorrectServerSalt' errorCode)); " is 150.
Long Statement,SharpMTProto.Messaging.Handlers,BadMsgNotificationHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\BadMsgNotificationHandler.cs,HandleInternalAsync,The length of the statement  "		Log.Debug (string.Format ("Bad server salt was in outgoing message (MsgId = 0x{0:X}' Seqno = {1}). Error code = {2}."' badServerSalt.BadMsgId' badServerSalt.BadMsgSeqno' errorCode)); " is 182.
Long Statement,SharpMTProto.Messaging.Handlers,ResponseDispatcher,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\ResponseDispatcher.cs,DispatchAsync,The length of the statement  "	IResponseHandler handler = _handlers.Where (pair => pair.Key.IsAssignableFromEx (responseType)).Select (pair => pair.Value).FirstOrDefault (); " is 142.
Long Statement,SharpMTProto.Messaging.Handlers,ResponseDispatcher,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\ResponseDispatcher.cs,DispatchAsync,The length of the statement  "			Log.WarningWithData (string.Format ("No handler found for response of type '{0}' and there is no fallback handler. Message was ignored."' responseType.Name)); " is 158.
Long Statement,SharpMTProto.Messaging.Handlers,ResponseDispatcher,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\ResponseDispatcher.cs,AddHandler,The length of the statement  "			Log.Warning (string.Format ("Prevented addition of another handler '{0}' for response of type '{1}'."' handler.GetType ()' handler.ResponseType.Name)); " is 151.
Long Statement,SharpMTProto.Messaging.Handlers,ResponseHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\ResponseHandler.cs,HandleAsync,The length of the statement  "		throw new MTProtoException (string.Format ("Expected response type to be '{0}'' but found '{1}'."' ResponseTypeInternal' responseMessage.Body.GetType ())); " is 155.
Long Statement,SharpMTProto.Messaging.Handlers,RpcResultHandler,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Handlers\RpcResultHandler.cs,HandleInternalAsync,The length of the statement  "		Log.Warning (string.Format ("Ignored response of type '{1}' for not existed request with MsgId: 0x{0:X8}."' rpcResult.ReqMsgId' result.GetType ())); " is 148.
Long Statement,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,DecodeEncryptedMessage,The length of the statement  "			throw new InvalidAuthKey (string.Format ("Message encrypted with auth key with id={0}' but auth key provided for decryption with id={1}."' authKeyId' providedAuthKeyId)); " is 170.
Long Statement,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,DecodeEncryptedMessage,The length of the statement  "		throw new InvalidMessageException (string.Format ("Expected message key to be {0}' but actual is {1}."' expectedMsgKey' msgKey)); " is 129.
Long Statement,SharpMTProto.Messaging,MessageSerializer,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageSerializer.cs,ReadTypedBody,The length of the statement  "		throw new TLSerializationException (String.Format ("Body length ({0}) is greated than available to read bytes till end ({1})."' bodyLength' streamer.BytesTillEnd)); " is 164.
Long Statement,SharpMTProto.Messaging,Request,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\Request.cs,SetResponse,The length of the statement  "		throw new MTProtoException (string.Format ("Wrong response type {0}. Expected: {1}."' response.GetType ()' typeof(TResponse).Name)); " is 132.
Long Statement,SharpMTProto.Messaging,RequestsManager,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\RequestsManager.cs,GetFirstOrDefault,The length of the statement  "	return _requests.Values.FirstOrDefault (r => r.CanSetResponse (response) && (!r.Flags.HasFlag (MessageSendingFlags.RPC) || includeRpc)); " is 136.
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: try {  	Log.Debug ("Processing incoming message.");  	ulong authKeyId;  	using (var streamer = new TLStreamer (messageBytes)) {  		if (messageBytes.Length == 4) {  			int error = streamer.ReadInt32 ();  			Log.Debug ("Received error code: {0}."' error);  			return;  		}  		if (messageBytes.Length < 20) {  			throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length));  		}  		authKeyId = streamer.ReadUInt64 ();  	}  	IMessage message;  	if (authKeyId == 0) {  		// Assume the message bytes has a plain (unencrypted) message.  		Log.Debug (string.Format ("Auth key ID = 0x{0:X16}. Assume this is a plain (unencrypted) message."' authKeyId));  		message = _messageCodec.DecodePlainMessage (messageBytes);  		if (!IsIncomingMessageIdValid (message.MsgId)) {  			throw new InvalidMessageException (string.Format ("Message ID = 0x{0:X16} is invalid."' message.MsgId));  		}  	} else {  		// Assume the stream has an encrypted message.  		Log.Debug (string.Format ("Auth key ID = 0x{0:X16}. Assume this is encrypted message."' authKeyId));  		if (!IsEncryptionSupported) {  			Log.Debug ("Encryption is not supported by this connection.");  			return;  		}  		ulong salt' sessionId;  		message = _messageCodec.DecodeEncryptedMessage (messageBytes' _config.AuthKey' Sender.Server' out salt' out sessionId);  		// TODO: check salt.  		if (sessionId != _config.SessionId) {  			throw new InvalidMessageException (string.Format ("Invalid session ID {0}. Expected {1}."' sessionId' _config.SessionId));  		}  		Log.Debug (string.Format ("Received encrypted message. Message ID = 0x{0:X16}."' message.MsgId));  	}  	ProcessIncomingMessage (message);  } catch (Exception e) {  	Log.Error (e' "Failed to receive a message.");  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: try {  	Log.Debug ("Processing incoming message.");  	ulong authKeyId;  	using (var streamer = new TLStreamer (messageBytes)) {  		if (messageBytes.Length == 4) {  			int error = streamer.ReadInt32 ();  			Log.Debug ("Received error code: {0}."' error);  			return;  		}  		if (messageBytes.Length < 20) {  			throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length));  		}  		authKeyId = streamer.ReadUInt64 ();  	}  	IMessage message;  	if (authKeyId == 0) {  		// Assume the message bytes has a plain (unencrypted) message.  		Log.Debug (string.Format ("Auth key ID = 0x{0:X16}. Assume this is a plain (unencrypted) message."' authKeyId));  		message = _messageCodec.DecodePlainMessage (messageBytes);  		if (!IsIncomingMessageIdValid (message.MsgId)) {  			throw new InvalidMessageException (string.Format ("Message ID = 0x{0:X16} is invalid."' message.MsgId));  		}  	} else {  		// Assume the stream has an encrypted message.  		Log.Debug (string.Format ("Auth key ID = 0x{0:X16}. Assume this is encrypted message."' authKeyId));  		if (!IsEncryptionSupported) {  			Log.Debug ("Encryption is not supported by this connection.");  			return;  		}  		ulong salt' sessionId;  		message = _messageCodec.DecodeEncryptedMessage (messageBytes' _config.AuthKey' Sender.Server' out salt' out sessionId);  		// TODO: check salt.  		if (sessionId != _config.SessionId) {  			throw new InvalidMessageException (string.Format ("Invalid session ID {0}. Expected {1}."' sessionId' _config.SessionId));  		}  		Log.Debug (string.Format ("Received encrypted message. Message ID = 0x{0:X16}."' message.MsgId));  	}  	ProcessIncomingMessage (message);  } catch (Exception e) {  	Log.Error (e' "Failed to receive a message.");  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: using (var streamer = new TLStreamer (messageBytes)) {  	if (messageBytes.Length == 4) {  		int error = streamer.ReadInt32 ();  		Log.Debug ("Received error code: {0}."' error);  		return;  	}  	if (messageBytes.Length < 20) {  		throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length));  	}  	authKeyId = streamer.ReadUInt64 ();  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: using (var streamer = new TLStreamer (messageBytes)) {  	if (messageBytes.Length == 4) {  		int error = streamer.ReadInt32 ();  		Log.Debug ("Received error code: {0}."' error);  		return;  	}  	if (messageBytes.Length < 20) {  		throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length));  	}  	authKeyId = streamer.ReadUInt64 ();  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: if (messageBytes.Length == 4) {  	int error = streamer.ReadInt32 ();  	Log.Debug ("Received error code: {0}."' error);  	return;  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,ProcessIncomingMessageBytes,The following statement contains a magic number: if (messageBytes.Length < 20) {  	throw new InvalidMessageException (string.Format ("Invalid message length: {0} bytes. Expected to be at least 20 bytes for message or 4 bytes for error code."' messageBytes.Length));  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,GetNextSessionId,The following statement contains a magic number: return ((ulong)Rnd.Next () << 32) + (ulong)Rnd.Next ();  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,Dispose,The following statement contains a magic number: if (isDisposing) {  	Disconnect ().Wait (5000);  	_clientTransport.Dispose ();  }  
Magic Number,SharpMTProto,MTProtoClientConnection,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\MTProtoClientConnection.cs,Dispose,The following statement contains a magic number: Disconnect ().Wait (5000);  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeEncrypt,The following statement contains a magic number: Array.Copy (iv' iv.Length / 2' iv2' 0' iv2.Length);  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeEncrypt,The following statement contains a magic number: using (var aes = new AesCryptoServiceProvider ()) {  	aes.Mode = CipherMode.ECB;  	aes.KeySize = key.Length * 8;  	aes.Padding = PaddingMode.None;  	aes.IV = iv1;  	aes.Key = key;  	int blockSize = aes.BlockSize / 8;  	var xPrev = new byte[blockSize];  	Buffer.BlockCopy (iv2' 0' xPrev' 0' blockSize);  	var yPrev = new byte[blockSize];  	Buffer.BlockCopy (iv1' 0' yPrev' 0' blockSize);  	using (var encrypted = new MemoryStream ()) {  		using (var bw = new BinaryWriter (encrypted)) {  			var x = new byte[blockSize];  			ICryptoTransform encryptor = aes.CreateEncryptor ();  			for (int i = 0; i < data.Length; i += blockSize) {  				Buffer.BlockCopy (data' i' x' 0' blockSize);  				byte[] y = Xor (encryptor.TransformFinalBlock (Xor (x' yPrev)' 0' blockSize)' xPrev);  				Buffer.BlockCopy (x' 0' xPrev' 0' blockSize);  				Buffer.BlockCopy (y' 0' yPrev' 0' blockSize);  				bw.Write (y);  			}  		}  		return encrypted.ToArray ();  	}  }  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeEncrypt,The following statement contains a magic number: using (var aes = new AesCryptoServiceProvider ()) {  	aes.Mode = CipherMode.ECB;  	aes.KeySize = key.Length * 8;  	aes.Padding = PaddingMode.None;  	aes.IV = iv1;  	aes.Key = key;  	int blockSize = aes.BlockSize / 8;  	var xPrev = new byte[blockSize];  	Buffer.BlockCopy (iv2' 0' xPrev' 0' blockSize);  	var yPrev = new byte[blockSize];  	Buffer.BlockCopy (iv1' 0' yPrev' 0' blockSize);  	using (var encrypted = new MemoryStream ()) {  		using (var bw = new BinaryWriter (encrypted)) {  			var x = new byte[blockSize];  			ICryptoTransform encryptor = aes.CreateEncryptor ();  			for (int i = 0; i < data.Length; i += blockSize) {  				Buffer.BlockCopy (data' i' x' 0' blockSize);  				byte[] y = Xor (encryptor.TransformFinalBlock (Xor (x' yPrev)' 0' blockSize)' xPrev);  				Buffer.BlockCopy (x' 0' xPrev' 0' blockSize);  				Buffer.BlockCopy (y' 0' yPrev' 0' blockSize);  				bw.Write (y);  			}  		}  		return encrypted.ToArray ();  	}  }  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeEncrypt,The following statement contains a magic number: aes.KeySize = key.Length * 8;  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeDecrypt,The following statement contains a magic number: Array.Copy (iv' iv.Length / 2' iv2' 0' iv2.Length);  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeDecrypt,The following statement contains a magic number: using (var aes = new AesCryptoServiceProvider ()) {  	aes.Mode = CipherMode.ECB;  	aes.KeySize = key.Length * 8;  	aes.Padding = PaddingMode.None;  	aes.IV = iv1;  	aes.Key = key;  	int blockSize = aes.BlockSize / 8;  	var xPrev = new byte[blockSize];  	Buffer.BlockCopy (iv1' 0' xPrev' 0' blockSize);  	var yPrev = new byte[blockSize];  	Buffer.BlockCopy (iv2' 0' yPrev' 0' blockSize);  	using (var decrypted = new MemoryStream ()) {  		using (var bw = new BinaryWriter (decrypted)) {  			var x = new byte[blockSize];  			ICryptoTransform decryptor = aes.CreateDecryptor ();  			for (int i = 0; i < encryptedData.Length; i += blockSize) {  				Buffer.BlockCopy (encryptedData' i' x' 0' blockSize);  				byte[] y = Xor (decryptor.TransformFinalBlock (Xor (x' yPrev)' 0' blockSize)' xPrev);  				Buffer.BlockCopy (x' 0' xPrev' 0' blockSize);  				Buffer.BlockCopy (y' 0' yPrev' 0' blockSize);  				bw.Write (y);  			}  		}  		return decrypted.ToArray ();  	}  }  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeDecrypt,The following statement contains a magic number: using (var aes = new AesCryptoServiceProvider ()) {  	aes.Mode = CipherMode.ECB;  	aes.KeySize = key.Length * 8;  	aes.Padding = PaddingMode.None;  	aes.IV = iv1;  	aes.Key = key;  	int blockSize = aes.BlockSize / 8;  	var xPrev = new byte[blockSize];  	Buffer.BlockCopy (iv1' 0' xPrev' 0' blockSize);  	var yPrev = new byte[blockSize];  	Buffer.BlockCopy (iv2' 0' yPrev' 0' blockSize);  	using (var decrypted = new MemoryStream ()) {  		using (var bw = new BinaryWriter (decrypted)) {  			var x = new byte[blockSize];  			ICryptoTransform decryptor = aes.CreateDecryptor ();  			for (int i = 0; i < encryptedData.Length; i += blockSize) {  				Buffer.BlockCopy (encryptedData' i' x' 0' blockSize);  				byte[] y = Xor (decryptor.TransformFinalBlock (Xor (x' yPrev)' 0' blockSize)' xPrev);  				Buffer.BlockCopy (x' 0' xPrev' 0' blockSize);  				Buffer.BlockCopy (y' 0' yPrev' 0' blockSize);  				bw.Write (y);  			}  		}  		return decrypted.ToArray ();  	}  }  
Magic Number,SharpMTProto.Services,EncryptionServices,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Services\EncryptionServices.cs,Aes256IgeDecrypt,The following statement contains a magic number: aes.KeySize = key.Length * 8;  
Magic Number,SharpMTProto.Services,MessageIdGenerator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\MessageIdGenerator.cs,GetNextMessageId,The following statement contains a magic number: messageId = (messageId * 4294967 + (messageId * 296 / 1000)) & X4Mask;  
Magic Number,SharpMTProto.Services,MessageIdGenerator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\MessageIdGenerator.cs,GetNextMessageId,The following statement contains a magic number: messageId = (messageId * 4294967 + (messageId * 296 / 1000)) & X4Mask;  
Magic Number,SharpMTProto.Services,MessageIdGenerator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\MessageIdGenerator.cs,GetNextMessageId,The following statement contains a magic number: messageId = (messageId * 4294967 + (messageId * 296 / 1000)) & X4Mask;  
Magic Number,SharpMTProto.Services,MessageIdGenerator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\MessageIdGenerator.cs,GetNextMessageId,The following statement contains a magic number: if (messageId <= _lastMessageId) {  	messageId = _lastMessageId + 4;  }  
Magic Number,SharpMTProto.Services,MessageIdGenerator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Services\MessageIdGenerator.cs,GetNextMessageId,The following statement contains a magic number: messageId = _lastMessageId + 4;  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,StartReceiver,The following statement contains a magic number: return Task.Run (async () => {  	var args = new SocketAsyncEventArgs ();  	args.SetBuffer (_readerBuffer' 0' _readerBuffer.Length);  	var awaitable = new SocketAwaitable (args);  	while (!token.IsCancellationRequested && _socket.IsConnected ()) {  		try {  			if (_socket.Available == 0) {  				await Task.Delay (10' token);  				continue;  			}  			await _socket.ReceiveAsync (awaitable);  		} catch (SocketException e) {  			Log.Debug (e);  		}  		if (args.SocketError != SocketError.Success) {  			break;  		}  		int bytesRead = args.BytesTransferred;  		if (bytesRead <= 0) {  			break;  		}  		try {  			await ProcessReceivedDataAsync (new ArraySegment<byte> (_readerBuffer' 0' bytesRead));  		} catch (Exception e) {  			Log.Error (e' "Critical error while precessing received data.");  			break;  		}  	}  	try {  		await DisconnectAsync ();  	} catch (Exception e) {  		Log.Debug (e);  	}  }' token);  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,StartReceiver,The following statement contains a magic number: while (!token.IsCancellationRequested && _socket.IsConnected ()) {  	try {  		if (_socket.Available == 0) {  			await Task.Delay (10' token);  			continue;  		}  		await _socket.ReceiveAsync (awaitable);  	} catch (SocketException e) {  		Log.Debug (e);  	}  	if (args.SocketError != SocketError.Success) {  		break;  	}  	int bytesRead = args.BytesTransferred;  	if (bytesRead <= 0) {  		break;  	}  	try {  		await ProcessReceivedDataAsync (new ArraySegment<byte> (_readerBuffer' 0' bytesRead));  	} catch (Exception e) {  		Log.Error (e' "Critical error while precessing received data.");  		break;  	}  }  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,StartReceiver,The following statement contains a magic number: try {  	if (_socket.Available == 0) {  		await Task.Delay (10' token);  		continue;  	}  	await _socket.ReceiveAsync (awaitable);  } catch (SocketException e) {  	Log.Debug (e);  }  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,StartReceiver,The following statement contains a magic number: if (_socket.Available == 0) {  	await Task.Delay (10' token);  	continue;  }  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,StartReceiver,The following statement contains a magic number: await Task.Delay (10' token);  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,Dispose,The following statement contains a magic number: if (_receiverTask != null) {  	if (!_receiverTask.IsCompleted) {  		_receiverTask.Wait (1000);  	}  	if (_receiverTask.IsCompleted) {  		_receiverTask.Dispose ();  	} else {  		Log.Warning ("Receiver task did not completed on transport disposing.");  	}  	_receiverTask = null;  }  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,Dispose,The following statement contains a magic number: if (!_receiverTask.IsCompleted) {  	_receiverTask.Wait (1000);  }  
Magic Number,SharpMTProto.Transport,TcpClientTransport,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.NET45\Transport\TcpClientTransport.cs,Dispose,The following statement contains a magic number: _receiverTask.Wait (1000);  
Magic Number,SharpMTProto.Transport,TcpClientTransportConfig,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpClientTransportConfig.cs,TcpClientTransportConfig,The following statement contains a magic number: ConnectTimeout = TimeSpan.FromMilliseconds (5000);  
Magic Number,SharpMTProto.Transport,TcpClientTransportConfig,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpClientTransportConfig.cs,TcpClientTransportConfig,The following statement contains a magic number: MaxBufferSize = 2048;  
Magic Number,SharpMTProto.Transport,TcpTransportPacket,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpTransportPacket.cs,ComputeCrc32,The following statement contains a magic number: return BigMath.Utils.Crc32.Compute (_data' 0' _data.Length - 4);  
Magic Number,SharpMTProto.Transport,TcpTransportPacket,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpTransportPacket.cs,InitAndCheckConsistency,The following statement contains a magic number: using (var streamer = new TLStreamer (_data)) {  	int expectedLength = streamer.ReadInt32 ();  	if (length != expectedLength) {  		throw new TransportException (string.Format ("Invalid packet length. Expected: {0}' actual: {1}."' expectedLength' length));  	}  	Number = streamer.ReadInt32 ();  	streamer.Seek (-4' SeekOrigin.End);  	Crc32 = streamer.ReadUInt32 ();  }  
Magic Number,SharpMTProto.Transport,TcpTransportPacket,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpTransportPacket.cs,InitAndCheckConsistency,The following statement contains a magic number: streamer.Seek (-4' SeekOrigin.End);  
Magic Number,SharpMTProto.Transport,TcpTransportPacket,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Transport\TcpTransportPacket.cs,GetPayloadCopy,The following statement contains a magic number: Buffer.BlockCopy (_data' 8' buffer' offset' PayloadLength);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: try {  	Int128 nonce = _nonceGenerator.GetNonce (16).ToInt128 ();  	Log.Debug (string.Format ("Creating auth key (nonce = {0:X16})..."' nonce));  	// Connecting.  	Log.Debug ("Connecting...");  	MTProtoConnectResult result = await connection.Connect (cancellationToken);  	if (result != MTProtoConnectResult.Success) {  		throw new CouldNotConnectException ("Connection trial was unsuccessful."' result);  	}  	// Requesting PQ.  	Log.Debug ("Requesting PQ...");  	var resPQ = await methods.ReqPqAsync (new ReqPqArgs {  		Nonce = nonce  	}) as ResPQ;  	if (resPQ == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' resPQ.Nonce);  	Log.Debug (string.Format ("Response PQ = {0}' server nonce = {1:X16}' {2}."' resPQ.Pq.ToHexString ()' resPQ.ServerNonce' resPQ.ServerPublicKeyFingerprints.Aggregate ("public keys fingerprints:"' (text' fingerprint) => text + " " + fingerprint.ToString ("X8"))));  	Int128 serverNonce = resPQ.ServerNonce;  	byte[] serverNonceBytes = serverNonce.ToBytes ();  	// Requesting DH params.  	PQInnerData pqInnerData;  	ReqDHParamsArgs reqDhParamsArgs = CreateReqDhParamsArgs (resPQ' out pqInnerData);  	Int256 newNonce = pqInnerData.NewNonce;  	byte[] newNonceBytes = newNonce.ToBytes ();  	Log.Debug (string.Format ("Requesting DH params with the new nonce: {0:X32}..."' newNonce));  	IServerDHParams serverDHParams = await methods.ReqDHParamsAsync (reqDhParamsArgs);  	if (serverDHParams == null) {  		throw new InvalidResponseException ();  	}  	var dhParamsFail = serverDHParams as ServerDHParamsFail;  	if (dhParamsFail != null) {  		if (CheckNewNonceHash (newNonce' dhParamsFail.NewNonceHash)) {  			throw new MTProtoException ("Requesting of the server DH params failed.");  		}  		throw new InvalidResponseException ("The new nonce hash received from the server does NOT match with hash of the sent new nonce hash.");  	}  	var dhParamsOk = serverDHParams as ServerDHParamsOk;  	if (dhParamsOk == null) {  		throw new InvalidResponseException ();  	}  	CheckNonce (nonce' dhParamsOk.Nonce);  	CheckNonce (serverNonce' dhParamsOk.ServerNonce);  	Log.Debug ("Received server DH params. Computing temp AES key and IV...");  	byte[] tmpAesKey;  	byte[] tmpAesIV;  	ComputeTmpAesKeyAndIV (newNonceBytes' serverNonceBytes' out tmpAesKey' out tmpAesIV);  	Log.Debug ("Decrypting server DH inner data...");  	ServerDHInnerData serverDHInnerData = DecryptServerDHInnerData (dhParamsOk.EncryptedAnswer' tmpAesKey' tmpAesIV);  	// TODO: Implement checking.  	#region Checking instructions  	/****************************************************************************************************************************************                  *                   * Client is expected to check whether p = dh_prime is a safe 2048-bit prime (meaning that both p and (p-1)/2 are prime'                  * and that 2^2047 < p < 2^2048)' and that g generates a cyclic subgroup of prime order (p-1)/2' i.e. is a quadratic residue mod p.                  * Since g is always equal to 2' 3' 4' 5' 6 or 7' this is easily done using quadratic reciprocity law'                  * yielding a simple condition on p mod 4g — namely' p mod 8 = 7 for g = 2; p mod 3 = 2 for g = 3;                  * no extra condition for g = 4; p mod 5 = 1 or 4 for g = 5; p mod 24 = 19 or 23 for g = 6; and p mod 7 = 3' 5 or 6 for g = 7.                  * After g and p have been checked by the client' it makes sense to cache the result' so as not to repeat lengthy computations in future.                  *                   * If the verification takes too long time (which is the case for older mobile devices)' one might initially                  * run only 15 Miller—Rabin iterations for verifying primeness of p and (p - 1)/2 with error probability not exceeding                  * one billionth' and do more iterations later in the background.                  *                   * Another optimization is to embed into the client application code a small table with some known “good” couples (g'p)                  * (or just known safe primes p' since the condition on g is easily verified during execution)'                  * checked during code generation phase' so as to avoid doing such verification during runtime altogether.                  * Server changes these values rarely' thus one usually has to put the current value of server's dh_prime into such a table.                  *                   * For example' current value of dh_prime equals (in big-endian byte order):                  * C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51                  * F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051                  * 907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F8                  * 7FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B                  *                   * IMPORTANT: Apart from the conditions on the Diffie-Hellman prime dh_prime and generator g'                  * both sides are to check that g' g_a and g_b are greater than 1 and less than dh_prime - 1.                  * We recommend checking that g_a and g_b are between 2^{2048-64} and dh_prime - 2^{2048-64} as well.                  *                   ****************************************************************************************************************************************/  	#endregion  	byte[] authKeyAuxHash = null;  	// Setting of client DH params.  	for (int retry = 0; retry < AuthRetryCount; retry++) {  		Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  		byte[] b = _nonceGenerator.GetNonce (256);  		byte[] g = serverDHInnerData.G.ToBytes (false);  		byte[] ga = serverDHInnerData.GA;  		byte[] p = serverDHInnerData.DhPrime;  		DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  		byte[] authKey = dhOutParams.S;  		var clientDHInnerData = new ClientDHInnerData {  			Nonce = nonce'  			ServerNonce = serverNonce'  			RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  			GB = dhOutParams.GB  		};  		Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  		// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  		authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  		byte[] data = _tlRig.Serialize (clientDHInnerData);  		// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  		byte[] dataWithHash = PrependHashAndAlign (data' 16);  		// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  		byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  		var setClientDHParamsArgs = new SetClientDHParamsArgs {  			Nonce = nonce'  			ServerNonce = serverNonce'  			EncryptedData = encryptedData  		};  		Log.Debug ("Setting client DH params...");  		ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  		var dhGenOk = setClientDHParamsAnswer as DhGenOk;  		if (dhGenOk != null) {  			Log.Debug ("OK.");  			CheckNonce (nonce' dhGenOk.Nonce);  			CheckNonce (serverNonce' dhGenOk.ServerNonce);  			Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  			CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  			Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  			var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  			return new AuthInfo (authKey' initialSalt);  		}  		var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  		if (dhGenRetry != null) {  			Log.Debug ("Retry.");  			CheckNonce (nonce' dhGenRetry.Nonce);  			CheckNonce (serverNonce' dhGenRetry.ServerNonce);  			Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  			CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  			continue;  		}  		var dhGenFail = setClientDHParamsAnswer as DhGenFail;  		if (dhGenFail != null) {  			Log.Debug ("Fail.");  			CheckNonce (nonce' dhGenFail.Nonce);  			CheckNonce (serverNonce' dhGenFail.ServerNonce);  			Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  			CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  			throw new MTProtoException ("Failed to set client DH params.");  		}  	}  	throw new MTProtoException (string.Format ("Failed to negotiate an auth key in {0} trials."' AuthRetryCount));  } catch (Exception e) {  	Log.Error (e' "Could not create auth key.");  	throw;  } finally {  	if (connection != null) {  		connection.Dispose ();  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: for (int retry = 0; retry < AuthRetryCount; retry++) {  	Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  	byte[] b = _nonceGenerator.GetNonce (256);  	byte[] g = serverDHInnerData.G.ToBytes (false);  	byte[] ga = serverDHInnerData.GA;  	byte[] p = serverDHInnerData.DhPrime;  	DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  	byte[] authKey = dhOutParams.S;  	var clientDHInnerData = new ClientDHInnerData {  		Nonce = nonce'  		ServerNonce = serverNonce'  		RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  		GB = dhOutParams.GB  	};  	Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  	// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  	authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  	byte[] data = _tlRig.Serialize (clientDHInnerData);  	// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  	byte[] dataWithHash = PrependHashAndAlign (data' 16);  	// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  	byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  	var setClientDHParamsArgs = new SetClientDHParamsArgs {  		Nonce = nonce'  		ServerNonce = serverNonce'  		EncryptedData = encryptedData  	};  	Log.Debug ("Setting client DH params...");  	ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  	var dhGenOk = setClientDHParamsAnswer as DhGenOk;  	if (dhGenOk != null) {  		Log.Debug ("OK.");  		CheckNonce (nonce' dhGenOk.Nonce);  		CheckNonce (serverNonce' dhGenOk.ServerNonce);  		Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  		CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  		Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  		var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  		return new AuthInfo (authKey' initialSalt);  	}  	var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  	if (dhGenRetry != null) {  		Log.Debug ("Retry.");  		CheckNonce (nonce' dhGenRetry.Nonce);  		CheckNonce (serverNonce' dhGenRetry.ServerNonce);  		Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  		CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  		continue;  	}  	var dhGenFail = setClientDHParamsAnswer as DhGenFail;  	if (dhGenFail != null) {  		Log.Debug ("Fail.");  		CheckNonce (nonce' dhGenFail.Nonce);  		CheckNonce (serverNonce' dhGenFail.ServerNonce);  		Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  		CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  		throw new MTProtoException ("Failed to set client DH params.");  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: for (int retry = 0; retry < AuthRetryCount; retry++) {  	Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  	byte[] b = _nonceGenerator.GetNonce (256);  	byte[] g = serverDHInnerData.G.ToBytes (false);  	byte[] ga = serverDHInnerData.GA;  	byte[] p = serverDHInnerData.DhPrime;  	DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  	byte[] authKey = dhOutParams.S;  	var clientDHInnerData = new ClientDHInnerData {  		Nonce = nonce'  		ServerNonce = serverNonce'  		RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  		GB = dhOutParams.GB  	};  	Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  	// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  	authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  	byte[] data = _tlRig.Serialize (clientDHInnerData);  	// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  	byte[] dataWithHash = PrependHashAndAlign (data' 16);  	// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  	byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  	var setClientDHParamsArgs = new SetClientDHParamsArgs {  		Nonce = nonce'  		ServerNonce = serverNonce'  		EncryptedData = encryptedData  	};  	Log.Debug ("Setting client DH params...");  	ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  	var dhGenOk = setClientDHParamsAnswer as DhGenOk;  	if (dhGenOk != null) {  		Log.Debug ("OK.");  		CheckNonce (nonce' dhGenOk.Nonce);  		CheckNonce (serverNonce' dhGenOk.ServerNonce);  		Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  		CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  		Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  		var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  		return new AuthInfo (authKey' initialSalt);  	}  	var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  	if (dhGenRetry != null) {  		Log.Debug ("Retry.");  		CheckNonce (nonce' dhGenRetry.Nonce);  		CheckNonce (serverNonce' dhGenRetry.ServerNonce);  		Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  		CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  		continue;  	}  	var dhGenFail = setClientDHParamsAnswer as DhGenFail;  	if (dhGenFail != null) {  		Log.Debug ("Fail.");  		CheckNonce (nonce' dhGenFail.Nonce);  		CheckNonce (serverNonce' dhGenFail.ServerNonce);  		Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  		CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  		throw new MTProtoException ("Failed to set client DH params.");  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: for (int retry = 0; retry < AuthRetryCount; retry++) {  	Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  	byte[] b = _nonceGenerator.GetNonce (256);  	byte[] g = serverDHInnerData.G.ToBytes (false);  	byte[] ga = serverDHInnerData.GA;  	byte[] p = serverDHInnerData.DhPrime;  	DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  	byte[] authKey = dhOutParams.S;  	var clientDHInnerData = new ClientDHInnerData {  		Nonce = nonce'  		ServerNonce = serverNonce'  		RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  		GB = dhOutParams.GB  	};  	Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  	// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  	authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  	byte[] data = _tlRig.Serialize (clientDHInnerData);  	// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  	byte[] dataWithHash = PrependHashAndAlign (data' 16);  	// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  	byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  	var setClientDHParamsArgs = new SetClientDHParamsArgs {  		Nonce = nonce'  		ServerNonce = serverNonce'  		EncryptedData = encryptedData  	};  	Log.Debug ("Setting client DH params...");  	ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  	var dhGenOk = setClientDHParamsAnswer as DhGenOk;  	if (dhGenOk != null) {  		Log.Debug ("OK.");  		CheckNonce (nonce' dhGenOk.Nonce);  		CheckNonce (serverNonce' dhGenOk.ServerNonce);  		Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  		CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  		Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  		var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  		return new AuthInfo (authKey' initialSalt);  	}  	var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  	if (dhGenRetry != null) {  		Log.Debug ("Retry.");  		CheckNonce (nonce' dhGenRetry.Nonce);  		CheckNonce (serverNonce' dhGenRetry.ServerNonce);  		Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  		CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  		continue;  	}  	var dhGenFail = setClientDHParamsAnswer as DhGenFail;  	if (dhGenFail != null) {  		Log.Debug ("Fail.");  		CheckNonce (nonce' dhGenFail.Nonce);  		CheckNonce (serverNonce' dhGenFail.ServerNonce);  		Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  		CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  		throw new MTProtoException ("Failed to set client DH params.");  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: for (int retry = 0; retry < AuthRetryCount; retry++) {  	Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  	byte[] b = _nonceGenerator.GetNonce (256);  	byte[] g = serverDHInnerData.G.ToBytes (false);  	byte[] ga = serverDHInnerData.GA;  	byte[] p = serverDHInnerData.DhPrime;  	DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  	byte[] authKey = dhOutParams.S;  	var clientDHInnerData = new ClientDHInnerData {  		Nonce = nonce'  		ServerNonce = serverNonce'  		RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  		GB = dhOutParams.GB  	};  	Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  	// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  	authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  	byte[] data = _tlRig.Serialize (clientDHInnerData);  	// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  	byte[] dataWithHash = PrependHashAndAlign (data' 16);  	// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  	byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  	var setClientDHParamsArgs = new SetClientDHParamsArgs {  		Nonce = nonce'  		ServerNonce = serverNonce'  		EncryptedData = encryptedData  	};  	Log.Debug ("Setting client DH params...");  	ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  	var dhGenOk = setClientDHParamsAnswer as DhGenOk;  	if (dhGenOk != null) {  		Log.Debug ("OK.");  		CheckNonce (nonce' dhGenOk.Nonce);  		CheckNonce (serverNonce' dhGenOk.ServerNonce);  		Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  		CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  		Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  		var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  		return new AuthInfo (authKey' initialSalt);  	}  	var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  	if (dhGenRetry != null) {  		Log.Debug ("Retry.");  		CheckNonce (nonce' dhGenRetry.Nonce);  		CheckNonce (serverNonce' dhGenRetry.ServerNonce);  		Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  		CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  		continue;  	}  	var dhGenFail = setClientDHParamsAnswer as DhGenFail;  	if (dhGenFail != null) {  		Log.Debug ("Fail.");  		CheckNonce (nonce' dhGenFail.Nonce);  		CheckNonce (serverNonce' dhGenFail.ServerNonce);  		Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  		CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  		throw new MTProtoException ("Failed to set client DH params.");  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: for (int retry = 0; retry < AuthRetryCount; retry++) {  	Log.Debug (string.Format ("Trial #{0} to set client DH params..."' retry + 1));  	byte[] b = _nonceGenerator.GetNonce (256);  	byte[] g = serverDHInnerData.G.ToBytes (false);  	byte[] ga = serverDHInnerData.GA;  	byte[] p = serverDHInnerData.DhPrime;  	DHOutParams dhOutParams = _encryptionServices.DH (b' g' ga' p);  	byte[] authKey = dhOutParams.S;  	var clientDHInnerData = new ClientDHInnerData {  		Nonce = nonce'  		ServerNonce = serverNonce'  		RetryId = authKeyAuxHash == null ? 0 : authKeyAuxHash.ToUInt64 ()'  		GB = dhOutParams.GB  	};  	Log.Debug (string.Format ("DH data: B={0}' G={1}' GB={2}' P={3}' S={4}."' b.ToHexString ()' g.ToHexString ()' dhOutParams.GB.ToHexString ()' p.ToHexString ()' authKey.ToHexString ()));  	// byte[] authKeyHash = ComputeSHA1(authKey).Skip(HashLength - 8).Take(8).ToArray(); // Not used in client.  	authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  	byte[] data = _tlRig.Serialize (clientDHInnerData);  	// data_with_hash := SHA1(data) + data + (0-15 random bytes); such that length be divisible by 16;  	byte[] dataWithHash = PrependHashAndAlign (data' 16);  	// encrypted_data := AES256_ige_encrypt (data_with_hash' tmp_aes_key' tmp_aes_iv);  	byte[] encryptedData = _encryptionServices.Aes256IgeEncrypt (dataWithHash' tmpAesKey' tmpAesIV);  	var setClientDHParamsArgs = new SetClientDHParamsArgs {  		Nonce = nonce'  		ServerNonce = serverNonce'  		EncryptedData = encryptedData  	};  	Log.Debug ("Setting client DH params...");  	ISetClientDHParamsAnswer setClientDHParamsAnswer = await methods.SetClientDHParamsAsync (setClientDHParamsArgs);  	var dhGenOk = setClientDHParamsAnswer as DhGenOk;  	if (dhGenOk != null) {  		Log.Debug ("OK.");  		CheckNonce (nonce' dhGenOk.Nonce);  		CheckNonce (serverNonce' dhGenOk.ServerNonce);  		Int128 newNonceHash1 = ComputeNewNonceHash (newNonce' 1' authKeyAuxHash);  		CheckNonce (newNonceHash1' dhGenOk.NewNonceHash1);  		Log.Debug (string.Format ("Negotiated auth key: {0}."' authKey.ToHexString ()));  		var initialSalt = ComputeInitialSalt (newNonceBytes' serverNonceBytes);  		return new AuthInfo (authKey' initialSalt);  	}  	var dhGenRetry = setClientDHParamsAnswer as DhGenRetry;  	if (dhGenRetry != null) {  		Log.Debug ("Retry.");  		CheckNonce (nonce' dhGenRetry.Nonce);  		CheckNonce (serverNonce' dhGenRetry.ServerNonce);  		Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  		CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  		continue;  	}  	var dhGenFail = setClientDHParamsAnswer as DhGenFail;  	if (dhGenFail != null) {  		Log.Debug ("Fail.");  		CheckNonce (nonce' dhGenFail.Nonce);  		CheckNonce (serverNonce' dhGenFail.ServerNonce);  		Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  		CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  		throw new MTProtoException ("Failed to set client DH params.");  	}  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: authKeyAuxHash = ComputeSHA1 (authKey).Take (8).ToArray ();  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: if (dhGenRetry != null) {  	Log.Debug ("Retry.");  	CheckNonce (nonce' dhGenRetry.Nonce);  	CheckNonce (serverNonce' dhGenRetry.ServerNonce);  	Int128 newNonceHash2 = ComputeNewNonceHash (newNonce' 2' authKeyAuxHash);  	CheckNonce (newNonceHash2' dhGenRetry.NewNonceHash2);  	continue;  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateAuthKey,The following statement contains a magic number: if (dhGenFail != null) {  	Log.Debug ("Fail.");  	CheckNonce (nonce' dhGenFail.Nonce);  	CheckNonce (serverNonce' dhGenFail.ServerNonce);  	Int128 newNonceHash3 = ComputeNewNonceHash (newNonce' 3' authKeyAuxHash);  	CheckNonce (newNonceHash3' dhGenFail.NewNonceHash3);  	throw new MTProtoException ("Failed to set client DH params.");  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,DecryptServerDHInnerData,The following statement contains a magic number: if ((answerWithHash.Length % 16) != 0) {  	throw new InvalidResponseException ("Decrypted ServerDHInnerData with hash has invalid length.");  }  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: tmpAesKey = new byte[32];  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (spnHash' 0' tmpAesKey' HashLength' 12);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: tmpAesIV = new byte[32];  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (spnHash' 12' tmpAesIV' 0' 8);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (spnHash' 12' tmpAesIV' 0' 8);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (npnHash' 0' tmpAesIV' 8' HashLength);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (newNonceBytes' 0' tmpAesIV' 28' 4);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,ComputeTmpAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (newNonceBytes' 0' tmpAesIV' 28' 4);  
Magic Number,SharpMTProto.Authentication,AuthKeyNegotiator,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\AuthKeyNegotiator.cs,CreateReqDhParamsArgs,The following statement contains a magic number: Debug.Assert ((dataHash.Length + data.Length) <= 255);  
Magic Number,SharpMTProto.Authentication,KeyChain,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Authentication\KeyChain.cs,ComputeFingerprint,The following statement contains a magic number: return hash.ToUInt64 (hash.Length - 8);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAuthKeyId,The following statement contains a magic number: return authKeySHA1.ToUInt64 (authKeySHA1.Length - 8' true);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeMsgKey,The following statement contains a magic number: return innerDataSHA1.ToInt128 (innerDataSHA1.Length - 16' true);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: switch (sender) {  case Sender.Client:  	x = 0;  	break;  case Sender.Server:  	x = 8;  	break;  default:  	throw new ArgumentOutOfRangeException ("sender");  }  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: x = 8;  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' x' buffer' MsgKeyLength' 32);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 32 + x' buffer' 0' 16);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 32 + x' buffer' 0' 16);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (msgKeyBytes' 0' buffer' 16' MsgKeyLength);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 48 + x' buffer' 16 + MsgKeyLength' 16);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 48 + x' buffer' 16 + MsgKeyLength' 16);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 48 + x' buffer' 16 + MsgKeyLength' 16);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 64 + x' buffer' 0' 32);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 64 + x' buffer' 0' 32);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (msgKeyBytes' 0' buffer' 32' MsgKeyLength);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 96 + x' buffer' MsgKeyLength' 32);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (authKey' 96 + x' buffer' MsgKeyLength' 32);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: aesKey = new byte[32];  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1A' 0' aesKey' 0' 8);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1B' 8' aesKey' 8' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1B' 8' aesKey' 8' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1B' 8' aesKey' 8' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 4' aesKey' 20' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 4' aesKey' 20' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 4' aesKey' 20' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: aesIV = new byte[32];  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1A' 8' aesIV' 0' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1A' 8' aesIV' 0' 12);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1B' 0' aesIV' 12' 8);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1B' 0' aesIV' 12' 8);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 16' aesIV' 20' 4);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 16' aesIV' 20' 4);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1C' 16' aesIV' 20' 4);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1D' 0' aesIV' 24' 8);  
Magic Number,SharpMTProto.Messaging,MessageCodec,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageCodec.cs,ComputeAesKeyAndIV,The following statement contains a magic number: Buffer.BlockCopy (sha1D' 0' aesIV' 24' 8);  
Magic Number,SharpMTProto.Messaging,MessageSerializer,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageSerializer.cs,WriteTypedBody,The following statement contains a magic number: streamer.Position += 4;  
Magic Number,SharpMTProto.Messaging,MessageSerializer,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Messaging\MessageSerializer.cs,WriteTypedBody,The following statement contains a magic number: streamer.Position = bodyStartPosition - 4;  
Magic Number,SharpMTProto.Schema,Message,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Schema\SharpMTProto.Schema.Ex.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = MsgId.GetHashCode ();  	hashCode = (hashCode * 397) ^ (int)Seqno;  	hashCode = (hashCode * 397) ^ (Body != null ? Body.GetHashCode () : 0);  	return hashCode;  }  
Magic Number,SharpMTProto.Schema,Message,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Schema\SharpMTProto.Schema.Ex.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = MsgId.GetHashCode ();  	hashCode = (hashCode * 397) ^ (int)Seqno;  	hashCode = (hashCode * 397) ^ (Body != null ? Body.GetHashCode () : 0);  	return hashCode;  }  
Magic Number,SharpMTProto.Schema,Message,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Schema\SharpMTProto.Schema.Ex.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (int)Seqno;  
Magic Number,SharpMTProto.Schema,Message,D:\newReposJune17\Taggersoft_SharpMTProto\src\SharpMTProto.Shared\Schema\SharpMTProto.Schema.Ex.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (Body != null ? Body.GetHashCode () : 0);  
