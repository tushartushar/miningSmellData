Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The method has 106 lines of code.
Long Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,The method has 127 lines of code.
Complex Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,Cyclomatic complexity of the method is 8
Complex Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,Cyclomatic complexity of the method is 24
Complex Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,Cyclomatic complexity of the method is 8
Complex Method,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,Cyclomatic complexity of the method is 12
Long Parameter List,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,KinectFaceTrackingResult,The method has 5 parameters. Parameters: faceModel' constructedFaceModel' builderStatus' faceAlignment' mapper
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognizer,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognizer.cs,CalcEigenObjects,The method has 5 parameters. Parameters: trainingImages' maxIter' eps' eigenImages' avg
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The method has 6 parameters. Parameters: input' maxIteration' eps' eigVecs' eigVals' avg
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,EigenDecomposite,The method has 9 parameters. Parameters: obj' objStep' nEigObjs' eigInput' eigStep' avg' avgStep' size' coeffs
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The method has 7 parameters. Parameters: obj' objStep' eigObj' eigStep' avg' avgStep' size
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The method has 11 parameters. Parameters: nObjects' input' objStep' output' eigStep' size' maxIteration' eps' avg' avgStep' eigVals
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The method has 7 parameters. Parameters: nObjects' input' objStep1' avg' avgStep' size' covarMatrix
Long Parameter List,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,The method has 5 parameters. Parameters: a' v' e' n' eps
Long Identifier,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,,The length of the parameter BOUNDING_HIGH_DETAIL_FACE_POINTS is 32.
Long Statement,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,MakeGrayscale,The length of the statement  "                g.DrawImage(original' new Rectangle(0' 0' newWidth' newHeight)' 0' 0' original.Width' original.Height' GraphicsUnit.Pixel' attributes); " is 135.
Long Statement,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,CopyBitmapToByteArray,The length of the statement  "            var bits = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' bitmap.PixelFormat); " is 144.
Long Statement,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualize,The length of the statement  "            var bits = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 145.
Long Statement,Sacknet.KinectFacialRecognition,KinectFacialRecognitionEngine,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFacialRecognitionEngine.cs,FaceFrameArrived,The length of the statement  "            if (this.Processors.Any(x => x.RequiresFaceModelBuilder) && newTrackingId.HasValue && this.currentTrackingId != newTrackingId) " is 126.
Long Statement,Sacknet.KinectFacialRecognition,KinectFacialRecognitionEngine,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFacialRecognitionEngine.cs,FaceFrameArrived,The length of the statement  "                    this.fmb = this.faceSource.OpenModelBuilder(FaceModelBuilderAttributes.HairColor | FaceModelBuilderAttributes.SkinColor); " is 121.
Long Statement,Sacknet.KinectFacialRecognition,KinectFacialRecognitionEngine,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFacialRecognitionEngine.cs,RecognizerWorker_DoWork,The length of the statement  "                var faceTrackingResult = new KinectFaceTrackingResult(this.faceModel' this.constructedFaceModel' status' this.faceAlignment' this.Kinect.CoordinateMapper); " is 155.
Long Statement,Sacknet.KinectFacialRecognition,KinectFacialRecognitionEngine,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFacialRecognitionEngine.cs,ImageToBitmap,The length of the statement  "            BitmapData bmapdata = bmap.LockBits(new System.Drawing.Rectangle(0' 0' width' height)' ImageLockMode.WriteOnly' bmap.PixelFormat); " is 130.
Long Statement,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The length of the statement  "            var hairColorDistance = Math.Sqrt(Math.Pow(shc.R - thc.R' 2) + Math.Pow(shc.G - thc.G' 2) + Math.Pow(shc.B - thc.B' 2)); " is 120.
Long Statement,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The length of the statement  "            var skinColorDistance = Math.Sqrt(Math.Pow(ssc.R - tsc.R' 2) + Math.Pow(ssc.G - tsc.G' 2) + Math.Pow(ssc.B - tsc.B' 2)); " is 120.
Long Statement,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognizer,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognizer.cs,Recognize,The length of the statement  "            return (this.EigenDistanceThreshold <= 0 || eigenDistance < this.EigenDistanceThreshold) ? this.Labels[index] : string.Empty; " is 125.
Complex Conditional,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,EigenDecomposite,The conditional expression  "size.Width > objStep || size.Width > eigStep || size.Width > avgStep || size.Height < 1"  is complex.
Complex Conditional,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The conditional expression  "size.Width > objStep || size.Width > eigStep || size.Width > avgStep || size.Height < 1"  is complex.
Complex Conditional,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The conditional expression  "size.Width > objStep || size.Width > eigStep || size.Width > avgStep || size.Height < 1"  is complex.
Virtual Method Call from Constructor,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,FaceModelRecognitionProcessor,The constructor "FaceModelRecognitionProcessor" calls a virtual method "SetTargetFaces".
Virtual Method Call from Constructor,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognitionProcessor.cs,EigenObjectRecognitionProcessor,The constructor "EigenObjectRecognitionProcessor" calls a virtual method "SetTargetFaces".
Magic Number,Sacknet.KinectFacialRecognition,Extensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\Extensions.cs,ExtractFaceRotationInRadians,The following statement contains a magic number: pitch = (float)Math.Atan2(2 * ((y * z) + (w * x))' (w * w) - (x * x) - (y * y) + (z * z));
Magic Number,Sacknet.KinectFacialRecognition,Extensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\Extensions.cs,ExtractFaceRotationInRadians,The following statement contains a magic number: yaw = (float)Math.Asin(2 * ((w * y) - (x * z))) * -1;
Magic Number,Sacknet.KinectFacialRecognition,Extensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\Extensions.cs,ExtractFaceRotationInRadians,The following statement contains a magic number: roll = (float)Math.Atan2(2 * ((x * y) + (w * z))' (w * w) + (x * x) - (y * y) - (z * z));
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,CopyGrayscaleBitmapToByteArray,The following statement contains a magic number: if (bitmap.PixelFormat == System.Drawing.Imaging.PixelFormat.Format32bppArgb)              {                  step /= 4;                  byte[] result = new byte[step * bitmap.Height];                    for (int i = 0; i < result.Length; i++)                      result[i] = baseResult[i * 4];                    return result;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,CopyGrayscaleBitmapToByteArray,The following statement contains a magic number: if (bitmap.PixelFormat == System.Drawing.Imaging.PixelFormat.Format32bppArgb)              {                  step /= 4;                  byte[] result = new byte[step * bitmap.Height];                    for (int i = 0; i < result.Length; i++)                      result[i] = baseResult[i * 4];                    return result;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualize,The following statement contains a magic number: for (int i = 0; i < rawData.Length; i += 4)              {                  // Update pixels according to LUT                  rawData[i + (int)RGB.R] = (byte)histLut[(int)RGB.R' rawData[i + (int)RGB.R]];                  rawData[i + (int)RGB.G] = (byte)histLut[(int)RGB.G' rawData[i + (int)RGB.G]];                  rawData[i + (int)RGB.B] = (byte)histLut[(int)RGB.B' rawData[i + (int)RGB.B]];              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: int['] imageLut = new int[3' 256];
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: int['] imageLut = new int[3' 256];
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: float scaleFactor = (float)(255.0 / (rawData.Length / 4));
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: float scaleFactor = (float)(255.0 / (rawData.Length / 4));
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,HistogramEqualizationLut,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  sumr += imageHist[(int)RGB.R' i];                  int valr = (int)(sumr * scaleFactor);                  imageLut[(int)RGB.R' i] = valr > 255 ? 255 : valr;                    sumg += imageHist[(int)RGB.G' i];                  int valg = (int)(sumg * scaleFactor);                  imageLut[(int)RGB.G' i] = valg > 255 ? 255 : valg;                    sumb += imageHist[(int)RGB.B' i];                  int valb = (int)(sumb * scaleFactor);                  imageLut[(int)RGB.B' i] = valb > 255 ? 255 : valb;              }
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,ImageHistogram,The following statement contains a magic number: var result = new int[3' 256];
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,ImageHistogram,The following statement contains a magic number: var result = new int[3' 256];
Magic Number,Sacknet.KinectFacialRecognition,BitmapExtensions,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\BitmapExtensions.cs,ImageHistogram,The following statement contains a magic number: for (int i = 0; i < rawData.Length; i += 4)              {                  result[(int)RGB.R' rawData[i + (int)RGB.R]]++;                  result[(int)RGB.G' rawData[i + (int)RGB.G]]++;                  result[(int)RGB.B' rawData[i + (int)RGB.B]]++;              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFacialRecognitionEngine,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFacialRecognitionEngine.cs,KinectFacialRecognitionEngine,The following statement contains a magic number: this.colorImageBuffer = new byte[4 * kinect.ColorFrameSource.FrameDescription.LengthInPixels];
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: foreach (var vertexMap in vertexMaps)              {                  var xDistance = vertexMap.Vertex.X - avgXValue;                  var yDistance = vertexMap.Vertex.Y - avgYValue;                    vertexMap.Distance = Math.Sqrt(Math.Pow(xDistance' 2) + Math.Pow(yDistance' 2));                  var angle = Math.Atan2(yDistance' xDistance);                    vertexMap.Degree = (int)((angle > 0 ? angle : ((2 * Math.PI) + angle)) * 360 / (2 * Math.PI));              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: foreach (var vertexMap in vertexMaps)              {                  var xDistance = vertexMap.Vertex.X - avgXValue;                  var yDistance = vertexMap.Vertex.Y - avgYValue;                    vertexMap.Distance = Math.Sqrt(Math.Pow(xDistance' 2) + Math.Pow(yDistance' 2));                  var angle = Math.Atan2(yDistance' xDistance);                    vertexMap.Degree = (int)((angle > 0 ? angle : ((2 * Math.PI) + angle)) * 360 / (2 * Math.PI));              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: foreach (var vertexMap in vertexMaps)              {                  var xDistance = vertexMap.Vertex.X - avgXValue;                  var yDistance = vertexMap.Vertex.Y - avgYValue;                    vertexMap.Distance = Math.Sqrt(Math.Pow(xDistance' 2) + Math.Pow(yDistance' 2));                  var angle = Math.Atan2(yDistance' xDistance);                    vertexMap.Degree = (int)((angle > 0 ? angle : ((2 * Math.PI) + angle)) * 360 / (2 * Math.PI));              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: foreach (var vertexMap in vertexMaps)              {                  var xDistance = vertexMap.Vertex.X - avgXValue;                  var yDistance = vertexMap.Vertex.Y - avgYValue;                    vertexMap.Distance = Math.Sqrt(Math.Pow(xDistance' 2) + Math.Pow(yDistance' 2));                  var angle = Math.Atan2(yDistance' xDistance);                    vertexMap.Degree = (int)((angle > 0 ? angle : ((2 * Math.PI) + angle)) * 360 / (2 * Math.PI));              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: foreach (var vertexMap in vertexMaps)              {                  var xDistance = vertexMap.Vertex.X - avgXValue;                  var yDistance = vertexMap.Vertex.Y - avgYValue;                    vertexMap.Distance = Math.Sqrt(Math.Pow(xDistance' 2) + Math.Pow(yDistance' 2));                  var angle = Math.Atan2(yDistance' xDistance);                    vertexMap.Degree = (int)((angle > 0 ? angle : ((2 * Math.PI) + angle)) * 360 / (2 * Math.PI));              }
Magic Number,Sacknet.KinectFacialRecognition,KinectFaceTrackingResult,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceTrackingResult.cs,CalculateBoundingHighDefinitionFacePoints,The following statement contains a magic number: return vertexMaps.GroupBy(x => x.Degree / 5).OrderBy(x => x.Key).Select(vertexMapGroup =>              {                  var maxDistance = vertexMapGroup.Max(x => x.Distance);                  return vertexMapGroup.First(x => x.Distance == maxDistance).Index;              }).ToList();
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,FaceModelRecognitionProcessor,The following statement contains a magic number: this.Threshold = 25;
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var hairColorDistance = Math.Sqrt(Math.Pow(shc.R - thc.R' 2) + Math.Pow(shc.G - thc.G' 2) + Math.Pow(shc.B - thc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var hairColorDistance = Math.Sqrt(Math.Pow(shc.R - thc.R' 2) + Math.Pow(shc.G - thc.G' 2) + Math.Pow(shc.B - thc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var hairColorDistance = Math.Sqrt(Math.Pow(shc.R - thc.R' 2) + Math.Pow(shc.G - thc.G' 2) + Math.Pow(shc.B - thc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var skinColorDistance = Math.Sqrt(Math.Pow(ssc.R - tsc.R' 2) + Math.Pow(ssc.G - tsc.G' 2) + Math.Pow(ssc.B - tsc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var skinColorDistance = Math.Sqrt(Math.Pow(ssc.R - tsc.R' 2) + Math.Pow(ssc.G - tsc.G' 2) + Math.Pow(ssc.B - tsc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: var skinColorDistance = Math.Sqrt(Math.Pow(ssc.R - tsc.R' 2) + Math.Pow(ssc.G - tsc.G' 2) + Math.Pow(ssc.B - tsc.B' 2));
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: score += Math.Min(5' hairColorDistance / 10);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: score += Math.Min(5' hairColorDistance / 10);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: score += Math.Min(5' skinColorDistance / 10);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,ScoreFaceDifferences,The following statement contains a magic number: score += Math.Min(5' skinColorDistance / 10);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,UIntToColor,The following statement contains a magic number: byte a = (byte)(color >> 24);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,UIntToColor,The following statement contains a magic number: byte r = (byte)(color >> 16);
Magic Number,Sacknet.KinectFacialRecognition.KinectFaceModel,FaceModelRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\KinectFaceModel\FaceModelRecognitionProcessor.cs,UIntToColor,The following statement contains a magic number: byte g = (byte)(color >> 8);
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognitionProcessor.cs,EigenObjectRecognitionProcessor,The following statement contains a magic number: this.Threshold = 1750;
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognitionProcessor.cs,Process,The following statement contains a magic number: lock (this.processingMutex)              {                  using (var croppedBmp = trackingResults.GetCroppedFace(colorSpaceBitmap))                  {                      using (var grayBmp = croppedBmp.MakeGrayscale(100' 100))                      {                          grayBmp.HistogramEqualize();                            string key = null;                          double eigenDistance = -1;                            if (this.Recognizer != null)                              key = this.Recognizer.Recognize(grayBmp' out eigenDistance);                            // Save detection info                          return new EigenObjectRecognitionProcessorResult                          {                              Score = eigenDistance'                              Image = (Bitmap)grayBmp.Clone()'                              Key = key                          };                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognitionProcessor,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognitionProcessor.cs,Process,The following statement contains a magic number: lock (this.processingMutex)              {                  using (var croppedBmp = trackingResults.GetCroppedFace(colorSpaceBitmap))                  {                      using (var grayBmp = croppedBmp.MakeGrayscale(100' 100))                      {                          grayBmp.HistogramEqualize();                            string key = null;                          double eigenDistance = -1;                            if (this.Recognizer != null)                              key = this.Recognizer.Recognize(grayBmp' out eigenDistance);                            // Save detection info                          return new EigenObjectRecognitionProcessorResult                          {                              Score = eigenDistance'                              Image = (Bitmap)grayBmp.Clone()'                              Key = key                          };                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjectRecognizer,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjectRecognizer.cs,GetEigenDistances,The following statement contains a magic number: foreach (var eigenValue in this.EigenValues)              {                  // norm = ||arr1-arr2||_L2 = sqrt( sum_I (arr1(I)-arr2(I))^2 )                  double sum = 0;                    for (var i = 0; i < eigenValue.Length; i++)                  {                      sum += Math.Pow(decomp[i] - eigenValue[i]' 2);                  }                    result.Add(Math.Sqrt(sum));              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,EigenDecomposite,The following statement contains a magic number: if (nEigObjs < 2)                  throw new EigenObjectException("Must have at least 2 training images for recognition!");
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcDecompCoeff,The following statement contains a magic number: for (i = 0; i < size.Height; i++)              {                  var iObj = i * objStep;                  var iEig = i * eigStep;                  var iAvg = i * avgStep;                    for (k = 0; k < size.Width - 4; k += 4)                  {                      double o = (double)obj[iObj + k];                      double e = eigObj[iEig + k];                      double a = avg[iAvg + k];                        w += e * (o - a);                      o = (double)obj[iObj + k + 1];                      e = eigObj[iEig + k + 1];                      a = avg[iAvg + k + 1];                      w += e * (o - a);                      o = (double)obj[iObj + k + 2];                      e = eigObj[iEig + k + 2];                      a = avg[iAvg + k + 2];                      w += e * (o - a);                      o = (double)obj[iObj + k + 3];                      e = eigObj[iEig + k + 3];                      a = avg[iAvg + k + 3];                      w += e * (o - a);                  }                    for (; k < size.Width; k++)                      w += eigObj[iEig + k] * ((double)obj[iObj + k] - avg[iAvg + k]);              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: if (nObjects < 2)                  throw new EigenObjectException("CV_BADFACTOR_ERR");
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcEigenObjects,The following statement contains a magic number: {                  int k' p' l;                    /* e.o. annulation */                  for (i = 0; i < m1; i++)                  {                      double[] be = output[i];                        for (p = 0; p < eigSize.Height; p++)                          for (l = 0; l < eigSize.Width; l++)                              be[(p * eigStep) + l] = 0.0f;                  }                    for (k = 0; k < nObjects; k++)                  {                      byte[] bv = input[k];                        for (i = 0; i < m1; i++)                      {                          double v = eigVals[i] * ev[(i * nObjects) + k];                          double[] be = output[i];                          byte[] bu = bv;                            bf = avg;                            for (p = 0; p < size.Height; p++)                          {                              int iBu = p * objStep1;                              int iBf = p * avgStep;                              int iBe = p * eigStep1;                                for (l = 0; l < size.Width - 3; l += 4)                              {                                  double f = bf[iBf + l];                                  byte u = bu[iBu + l];                                    be[iBe + l] += v * (u - f);                                  f = bf[iBf + l + 1];                                  u = bu[iBu + l + 1];                                  be[iBe + l + 1] += v * (u - f);                                  f = bf[iBf + l + 2];                                  u = bu[iBu + l + 2];                                  be[iBe + l + 2] += v * (u - f);                                  f = bf[iBf + l + 3];                                  u = bu[iBu + l + 3];                                  be[iBe + l + 3] += v * (u - f);                              }                                for (; l < size.Width; l++)                                  be[iBe + l] += v * (bu[iBu + l] - bf[iBf + l]);                          }                      }                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: if (nObjects < 2)                  throw new EigenObjectException("Must have at least 2 training images for recognition!");
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,CalcCovarMatrixEx,The following statement contains a magic number: for (i = 0; i < nObjects; i++)              {                  byte[] bu = objects[i];                    for (j = i; j < nObjects; j++)                  {                      int k' l;                      double w = 0f;                      double[] a = avg;                      byte[] bu1 = bu;                      byte[] bu2 = objects[j];                        for (k = 0; k < size.Height; k++)                      {                          int kBu1 = k * objStep;                          int kBu2 = k * objStep;                          int kA = k * avgStep;                            for (l = 0; l < size.Width - 3; l += 4)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                              f = a[kA + l + 1];                              u1 = bu1[kBu1 + l + 1];                              u2 = bu2[kBu2 + l + 1];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 2];                              u1 = bu1[kBu1 + l + 2];                              u2 = bu2[kBu2 + l + 2];                              w += (u1 - f) * (u2 - f);                              f = a[kA + l + 3];                              u1 = bu1[kBu1 + l + 3];                              u2 = bu2[kBu2 + l + 3];                              w += (u1 - f) * (u2 - f);                          }                            for (; l < size.Width; l++)                          {                              double f = a[kA + l];                              byte u1 = bu1[kBu1 + l];                              byte u2 = bu2[kBu2 + l];                                w += (u1 - f) * (u2 - f);                          }                      }                        covarMatrix[(i * nObjects) + j] = covarMatrix[(j * nObjects) + i] = w;                  }              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,The following statement contains a magic number: while (aMax > ax)              {                  aMax /= n;                                    do                  {                      int p' q;                      int v1 = 0' a1 = 0;                        ind = 0;                      for (p = 0; p < n - 1; p++' a1 += n' v1 += n)                      {                          int a2 = n * (p + 1)' v2 = n * (p + 1);                            for (q = p + 1; q < n; q++' a2 += n' v2 += n)                          {                              double x' y' c' s' c2' s2' z;                              int a3 = 0;                              double apq = a[a1 + q]' app' aqq' aip' aiq' vpi' vqi;                                if (Math.Abs(apq) < aMax)                                  continue;                                ind = 1;                                /*---- Calculation of rotation angle's sine & cosine ----*/                              app = a[a1 + p];                              aqq = a[a2 + q];                              y = 5.0e-1 * (app - aqq);                              x = -apq / Math.Sqrt((double)(apq * apq) + (double)(y * y));                              if (y < 0.0)                                  x = -x;                              s = x / Math.Sqrt(2.0 * (1.0 + Math.Sqrt(1.0 - (x * x))));                              s2 = s * s;                              c = Math.Sqrt(1.0 - s2);                              c2 = c * c;                              z = 2.0 * apq * c * s;                                /*---- Apq annulation ----*/                              for (i = 0; i < p; i++' a3 += n)                              {                                  aip = a[a3 + p];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a3 + p] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < q; i++' a3 += n)                              {                                  aip = a[a1 + i];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < n; i++)                              {                                  aip = a[a1 + i];                                  aiq = a[a2 + i];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a2 + i] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                a[a1 + p] = (app * c2) + (aqq * s2) - z;                              a[a2 + q] = (app * s2) + (aqq * c2) + z;                              a[a1 + q] = a[a2 + p] = 0.0f;                          }               /*q */                      }                   /*p */                  }                  while (ind > 0);                    aMax /= n;              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,The following statement contains a magic number: while (aMax > ax)              {                  aMax /= n;                                    do                  {                      int p' q;                      int v1 = 0' a1 = 0;                        ind = 0;                      for (p = 0; p < n - 1; p++' a1 += n' v1 += n)                      {                          int a2 = n * (p + 1)' v2 = n * (p + 1);                            for (q = p + 1; q < n; q++' a2 += n' v2 += n)                          {                              double x' y' c' s' c2' s2' z;                              int a3 = 0;                              double apq = a[a1 + q]' app' aqq' aip' aiq' vpi' vqi;                                if (Math.Abs(apq) < aMax)                                  continue;                                ind = 1;                                /*---- Calculation of rotation angle's sine & cosine ----*/                              app = a[a1 + p];                              aqq = a[a2 + q];                              y = 5.0e-1 * (app - aqq);                              x = -apq / Math.Sqrt((double)(apq * apq) + (double)(y * y));                              if (y < 0.0)                                  x = -x;                              s = x / Math.Sqrt(2.0 * (1.0 + Math.Sqrt(1.0 - (x * x))));                              s2 = s * s;                              c = Math.Sqrt(1.0 - s2);                              c2 = c * c;                              z = 2.0 * apq * c * s;                                /*---- Apq annulation ----*/                              for (i = 0; i < p; i++' a3 += n)                              {                                  aip = a[a3 + p];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a3 + p] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < q; i++' a3 += n)                              {                                  aip = a[a1 + i];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < n; i++)                              {                                  aip = a[a1 + i];                                  aiq = a[a2 + i];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a2 + i] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                a[a1 + p] = (app * c2) + (aqq * s2) - z;                              a[a2 + q] = (app * s2) + (aqq * c2) + z;                              a[a1 + q] = a[a2 + p] = 0.0f;                          }               /*q */                      }                   /*p */                  }                  while (ind > 0);                    aMax /= n;              }
Magic Number,Sacknet.KinectFacialRecognition.ManagedEigenObject,EigenObjects,C:\repos\mrosack_Sacknet.KinectFacialRecognition\Sacknet.KinectFacialRecognition\ManagedEigenObject\EigenObjects.cs,JacobiEigens,The following statement contains a magic number: while (aMax > ax)              {                  aMax /= n;                                    do                  {                      int p' q;                      int v1 = 0' a1 = 0;                        ind = 0;                      for (p = 0; p < n - 1; p++' a1 += n' v1 += n)                      {                          int a2 = n * (p + 1)' v2 = n * (p + 1);                            for (q = p + 1; q < n; q++' a2 += n' v2 += n)                          {                              double x' y' c' s' c2' s2' z;                              int a3 = 0;                              double apq = a[a1 + q]' app' aqq' aip' aiq' vpi' vqi;                                if (Math.Abs(apq) < aMax)                                  continue;                                ind = 1;                                /*---- Calculation of rotation angle's sine & cosine ----*/                              app = a[a1 + p];                              aqq = a[a2 + q];                              y = 5.0e-1 * (app - aqq);                              x = -apq / Math.Sqrt((double)(apq * apq) + (double)(y * y));                              if (y < 0.0)                                  x = -x;                              s = x / Math.Sqrt(2.0 * (1.0 + Math.Sqrt(1.0 - (x * x))));                              s2 = s * s;                              c = Math.Sqrt(1.0 - s2);                              c2 = c * c;                              z = 2.0 * apq * c * s;                                /*---- Apq annulation ----*/                              for (i = 0; i < p; i++' a3 += n)                              {                                  aip = a[a3 + p];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a3 + p] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < q; i++' a3 += n)                              {                                  aip = a[a1 + i];                                  aiq = a[a3 + q];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a3 + q] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                for (; i < n; i++)                              {                                  aip = a[a1 + i];                                  aiq = a[a2 + i];                                  vpi = v[v1 + i];                                  vqi = v[v2 + i];                                  a[a1 + i] = (aip * c) - (aiq * s);                                  a[a2 + i] = (aiq * c) + (aip * s);                                  v[v1 + i] = (vpi * c) - (vqi * s);                                  v[v2 + i] = (vqi * c) + (vpi * s);                              }                                a[a1 + p] = (app * c2) + (aqq * s2) - z;                              a[a2 + q] = (app * s2) + (aqq * c2) + z;                              a[a1 + q] = a[a2 + p] = 0.0f;                          }               /*q */                      }                   /*p */                  }                  while (ind > 0);                    aMax /= n;              }
