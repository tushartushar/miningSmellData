Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,SendBatch,Cyclomatic complexity of the method is 8
Complex Method,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,Reader,Cyclomatic complexity of the method is 8
Complex Method,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,Cyclomatic complexity of the method is 9
Long Statement,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,connect,The length of the statement  "                    SetSocketKeepAliveValues (client.Client' (int)Configuration.KeepAlivePeriod.TotalMilliseconds' (int)Configuration.KeepAliveRetryPeriod.TotalMilliseconds); " is 154.
Long Statement,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,SetSocketKeepAliveValues,The length of the statement  "            BitConverter.GetBytes ((uint)KeepAliveTime).CopyTo (inOptionValues' System.Runtime.InteropServices.Marshal.SizeOf (dummy)); " is 123.
Long Statement,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,SetSocketKeepAliveValues,The length of the statement  "            BitConverter.GetBytes ((uint)KeepAliveInterval).CopyTo (inOptionValues' System.Runtime.InteropServices.Marshal.SizeOf (dummy) * 2); " is 131.
Long Statement,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,CheckIsApnsCertificate,The length of the statement  "                    throw new ArgumentOutOfRangeException ("Your Certificate does not appear to be issued by Apple!  Please check to ensure you have the correct certificate!"); " is 156.
Long Statement,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,CheckIsApnsCertificate,The length of the statement  "                    throw new ArgumentOutOfRangeException ("Your Certificate is not a valid certificate for connecting to Apple's APNS servers"); " is 125.
Long Statement,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,CheckIsApnsCertificate,The length of the statement  "                    throw new ArgumentOutOfRangeException ("You are using a certificate created for connecting only to the Sandbox APNS server but have selected a different server environment to connect to."); " is 189.
Long Statement,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,CheckIsApnsCertificate,The length of the statement  "                    throw new ArgumentOutOfRangeException ("You are using a certificate created for connecting only to the Production APNS server but have selected a different server environment to connect to."); " is 192.
Long Statement,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,IsDeviceRegistrationIdValid,The length of the statement  "            var r = new System.Text.RegularExpressions.Regex (@"^[0-9A-F]+$"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 122.
Long Statement,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The length of the statement  "            stream.AuthenticateAsClient(Configuration.FeedbackHost' certificates' System.Security.Authentication.SslProtocols.Tls' false); " is 126.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,connect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,connect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,disconnect,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToString,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The method has an empty catch block.
Empty Catch Block,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The method has an empty catch block.
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,Reader,The following statement contains a magic number: readCancelToken.CancelAfter (750);
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,Reader,The following statement contains a magic number: while (!readCancelToken.IsCancellationRequested) {                    // See if there's data to read                  if (client.Client.Available > 0) {                      Log.Info ("APNS-Client[{0}]: Data Available..."' id);                      len = await networkStream.ReadAsync (buffer' 0' buffer.Length).ConfigureAwait (false);                      Log.Info ("APNS-Client[{0}]: Finished Read."' id);                      break;                  }                    // Let's not tie up too much CPU waiting...                  await Task.Delay (50).ConfigureAwait (false);              }
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,Reader,The following statement contains a magic number: var identifier = IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (buffer' 2));
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,socketCanWrite,The following statement contains a magic number: var p = client.Client.Poll (1000' SelectMode.SelectWrite);
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,SetSocketKeepAliveValues,The following statement contains a magic number: byte[] inOptionValues = new byte[System.Runtime.InteropServices.Marshal.SizeOf (dummy) * 3];
Magic Number,PushSharp.Apple,ApnsConnection,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConnection.cs,SetSocketKeepAliveValues,The following statement contains a magic number: BitConverter.GetBytes ((uint)KeepAliveInterval).CopyTo (inOptionValues' System.Runtime.InteropServices.Marshal.SizeOf (dummy) * 2);
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: MillisecondsToWaitBeforeMessageDeclaredSuccess = 3000;
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: ConnectionTimeout = 10000;
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: MaxConnectionAttempts = 3;
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: FeedbackIntervalMinutes = 10;
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: KeepAlivePeriod = TimeSpan.FromMinutes (20);
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: KeepAliveRetryPeriod = TimeSpan.FromSeconds (30);
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: InternalBatchSize = 1000;
Magic Number,PushSharp.Apple,ApnsConfiguration,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsConfiguration.cs,Initialize,The following statement contains a magic number: InternalBatchingWaitPeriod = TimeSpan.FromMilliseconds (750);
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,GetNextIdentifier,The following statement contains a magic number: lock (nextIdentifierLock) {                  if (nextIdentifier >= int.MaxValue - 10)                      nextIdentifier = 1;                    return nextIdentifier++;              }
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: byte[] deviceToken = new byte[DeviceToken.Length / 2];
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: for (int i = 0; i < deviceToken.Length; i++) {                  try {                      deviceToken [i] = byte.Parse (DeviceToken.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);                  } catch (Exception) {                      throw new NotificationException ("Invalid DeviceToken"' this);                  }              }
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: for (int i = 0; i < deviceToken.Length; i++) {                  try {                      deviceToken [i] = byte.Parse (DeviceToken.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);                  } catch (Exception) {                      throw new NotificationException ("Invalid DeviceToken"' this);                  }              }
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: builder.AddRange (BitConverter.GetBytes (IPAddress.HostToNetworkOrder ((Int16)4)));
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: builder.AddRange (BitConverter.GetBytes (IPAddress.HostToNetworkOrder ((Int16)4)));
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: var priority = LowPriority ? (byte)5 : (byte)10;
Magic Number,PushSharp.Apple,ApnsNotification,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsNotification.cs,ToBytes,The following statement contains a magic number: var priority = LowPriority ? (byte)5 : (byte)10;
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: byte[] buffer = new byte[4096];
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
Magic Number,PushSharp.Apple,FeedbackService,C:\repos\Redth_PushSharp\PushSharp.Apple\ApnsFeedbackService.cs,Check,The following statement contains a magic number: while (recd > 0)              {                  // Add the received data to a list buffer to work with (easier to manipulate)                  for (int i = 0; i < recd; i++)                      data.Add (buffer [i]);                                    //Process each complete notification "packet" available in the buffer                  while (data.Count >= (4 + 2 + 32)) // Minimum size for a valid packet                  {                      var secondsBuffer = data.GetRange (0' 4).ToArray ();                      var tokenLengthBuffer = data.GetRange (4' 2).ToArray ();                        // Get our seconds since epoch                      // Check endianness and reverse if needed                      if (BitConverter.IsLittleEndian)                          Array.Reverse (secondsBuffer);                      var seconds = BitConverter.ToInt32 (secondsBuffer' 0);                        //Add seconds since 1970 to that date' in UTC                      var timestamp = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (seconds);                        //flag to allow feedback times in UTC or local' but default is local                      if (!Configuration.FeedbackTimeIsUTC)                          timestamp = timestamp.ToLocalTime();                          if (BitConverter.IsLittleEndian)                          Array.Reverse (tokenLengthBuffer);                      var tokenLength = BitConverter.ToInt16 (tokenLengthBuffer' 0);                        if (data.Count >= 4 + 2 + tokenLength) {                            var tokenBuffer = data.GetRange (6' tokenLength).ToArray ();                          // Strings shouldn't care about endian-ness... this shouldn't be reversed                          //if (BitConverter.IsLittleEndian)                          //    Array.Reverse (tokenBuffer);                          var token = BitConverter.ToString (tokenBuffer).Replace ("-"' "").ToLower ().Trim ();                            // Remove what we parsed from the buffer                          data.RemoveRange (0' 4 + 2 + tokenLength);                            // Raise the event to the consumer                          var evt = FeedbackReceived;                          if (evt != null)                              evt (token' timestamp);                      } else {                          continue;                      }                    }                    //Read the next feedback                  recd = stream.Read (buffer' 0' buffer.Length);              }
