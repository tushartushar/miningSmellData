Implementation smell,Namespace,Class,File,Method,Description
Long Method,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The method has 422 lines of code.
Complex Method,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,Cyclomatic complexity of the method is 64
Complex Method,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,Cyclomatic complexity of the method is 10
Complex Method,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,CurveSegments,Cyclomatic complexity of the method is 23
Complex Method,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,Cyclomatic complexity of the method is 77
Complex Method,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,SetRevitDataForm,Cyclomatic complexity of the method is 11
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The length of the statement  "	pManager.AddBooleanParameter ("Trigger"' "T"' "Trigger to stream the data from Grasshopper to another application."' GH_ParamAccess.item' false); " is 145.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The length of the statement  "	pManager.AddCurveParameter ("Curve"' "C"' "Single arc' line' or closed planar curves.  Closed planar curves can be used to generate floor' wall or roof sketches' or single segment non-closed arcs or lines can be used for line based family generation."' GH_ParamAccess.tree); " is 274.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The length of the statement  "	pManager.AddVectorParameter ("Orientation on Face"' "F"' "Orientation of the element in relation to the face it will be hosted to"' GH_ParamAccess.tree); " is 153.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterOutputParams,The length of the statement  "	pManager.AddTextParameter ("Selected Object"' "Obj"' "Object information that Lyrebird will create or modify"' GH_ParamAccess.item); " is 132.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "						System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch."); " is 183.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "							LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z); " is 155.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "										message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary."; " is 229.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary."; " is 229.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "				message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active."; " is 158.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The length of the statement  "			sb.AppendLine (string.Format ("Parameter{0}: {1}  /  {2}  /  {3}"' (i + 1).ToString (CultureInfo.InvariantCulture)' rp.ParameterName' rp.StorageType' type)); " is 157.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,DisplayForm,The length of the statement  "			//System.Windows.Forms.MessageBox.Show("The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active."); " is 176.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The length of the statement  "				Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType' " is 192.
Long Statement,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The length of the statement  "			param.Description = "Parameter Name: " + inputParameters [i].ParameterName + "\nIs Type: " + inputParameters [i].IsType.ToString () + "\nStorageType: " + inputParameters [i].StorageType; " is 186.
Long Statement,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The length of the statement  "	pManager.AddIntegerParameter ("Category"' "C"' "1 = Images\n2 = Levels\n3 = Materials\n4 = Phases"' GH_ParamAccess.item' 3); " is 124.
Long Statement,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterOutputParams,The length of the statement  "	pManager.AddTextParameter ("Elements"' "E"' "Elements retrieved from the Revit document.\nThey are in the format of NAME'ELEMENTID"' GH_ParamAccess.list); " is 154.
Empty Catch Block,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,SolveInstance,The method has an empty catch block.
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GHClient,The following statement contains a magic number: if (appVersion == 1) {  	r2014 = true;  	r2015 = false;  	r2016 = false;  } else if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GHClient,The following statement contains a magic number: if (appVersion == 1) {  	r2014 = true;  	r2015 = false;  	r2016 = false;  } else if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GHClient,The following statement contains a magic number: if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GHClient,The following statement contains a magic number: if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GHClient,The following statement contains a magic number: if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The following statement contains a magic number: pManager [2].Optional = true;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The following statement contains a magic number: pManager [3].Optional = true;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The following statement contains a magic number: pManager [4].Optional = true;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RegisterInputParams,The following statement contains a magic number: pManager [5].Optional = true;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: DA.GetDataTree (2' out adaptPoints);  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: DA.GetDataTree (3' out curves);  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: DA.GetDataTree (4' out orientations);  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: DA.GetDataTree (5' out faceOrientations);  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand && (familyName == null || familyName == "Not Selected")) {  	message = "Please select a family/type by double-clicking on the component before running the command.";  } else if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand && (familyName == null || familyName == "Not Selected")) {  	message = "Please select a family/type by double-clicking on the component before running the command.";  } else if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand && (familyName == null || familyName == "Not Selected")) {  	message = "Please select a family/type by double-clicking on the component before running the command.";  } else if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand && (familyName == null || familyName == "Not Selected")) {  	message = "Please select a family/type by double-clicking on the component before running the command.";  } else if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand && (familyName == null || familyName == "Not Selected")) {  	message = "Please select a family/type by double-clicking on the component before running the command.";  } else if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (runCommand) {  	// Get the scale  	GHInfo ghi = new GHInfo ();  	GHScale scale = ghi.GetScale (Rhino.RhinoDoc.ActiveDoc);  	// Send to Revit  	LyrebirdChannel channel = new LyrebirdChannel (appVersion);  	channel.Create ();  	if (channel != null) {  		string documentName = channel.DocumentName ();  		if (documentName != null) {  			// Create RevitObjects  			List<RevitObject> obj = new List<RevitObject> ();  			#region OriginPoint Based  			if (origPoints != null && origPoints.Branches.Count > 0) {  				List<RevitObject> tempObjs = new List<RevitObject> ();  				// make sure the branches match the datacount  				if (origPoints.Branches.Count == origPoints.DataCount) {  					for (int i = 0; i < origPoints.Branches.Count; i++) {  						GH_Point ghpt = origPoints [i] [0];  						LyrebirdPoint point = new LyrebirdPoint {  							X = ghpt.Value.X'  							Y = ghpt.Value.Y'  							Z = ghpt.Value.Z  						};  						RevitObject ro = new RevitObject {  							Origin = point'  							FamilyName = familyName'  							TypeName = typeName'  							Category = category'  							CategoryId = categoryId'  							GHPath = origPoints.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  					obj = tempObjs;  				} else {  					// Inform the user they need to graft their inputs.  Only one point per branch  					System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  				}  			}   			#endregion  			#region AdaptiveComponents  			else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  				// generate adaptive components  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < adaptPoints.Branches.Count; i++) {  					RevitObject ro = new RevitObject ();  					List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  					for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  						LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  						points.Add (point);  					}  					ro.AdaptivePoints = points;  					ro.FamilyName = familyName;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.GHPath = adaptPoints.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}   			#endregion  			#region Curve Based  			else if (curves != null && curves.Branches.Count > 0) {  				// Get curves for curve based components  				// Determine if we're profile or line based  				if (curves.Branches.Count == curves.DataCount) {  					// Determine if the curve is a closed planar curve  					Curve tempCrv = curves.Branches [0] [0].Value;  					if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  						// Closed planar curve  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve crv = curves [i] [0].Value;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' crv' true);  							if (rCurves.Count > 0) {  								// Check if they're planar in the XY Plane  								List<double> endPointElevations = new List<double> ();  								foreach (Curve crvSegment in rCurves) {  									if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  										if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  											endPointElevations.Add (crvSegment.PointAtEnd.Z);  									}  								}  								if (endPointElevations.Count != 1) {  									// curves are planar in the XY plane  									foreach (Curve rCurveSegment in rCurves) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  								} else {  									RevitObject ro = new RevitObject ();  									List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  									for (int j = 0; j < rCurves.Count; j++) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rCurves [j]);  										lbCurves.Add (lbc);  									}  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							}  						}  						obj = tempObjs;  					} else if (!tempCrv.IsClosed) {  						// Line based.  Can only be arc or linear curves  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < curves.Branches.Count; i++) {  							Curve ghc = curves.Branches [i] [0].Value;  							// Test that there is only one curve segment  							PolyCurve polycurve = ghc as PolyCurve;  							if (polycurve != null) {  								Curve[] segments = polycurve.Explode ();  								if (segments.Count () != 1) {  									foreach (Curve rCurveSegment in segments) {  										RevitObject ro = new RevitObject ();  										LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  										List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  											lbc  										};  										ro.Curves = lbcurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = curves.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										tempObjs.Add (ro);  									}  									//break;  								}  							}  							if (ghc != null) {  								//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  								LyrebirdCurve lbc = GetLBCurve (ghc);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								RevitObject ro = new RevitObject {  									Curves = lbcurves'  									FamilyName = familyName'  									Category = category'  									CategoryId = categoryId'  									TypeName = typeName'  									Origin = null'  									GHPath = curves.Paths [i].ToString ()'  									GHScaleFactor = scale.ScaleFactor'  									GHScaleName = scale.ScaleName  								};  								tempObjs.Add (ro);  							}  						}  						obj = tempObjs;  					}  				} else {  					// Make sure all of the curves in each branch are closed  					bool allClosed = true;  					DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						List<GH_Curve> ghCrvs = curves.Branches [i];  						List<CurveCheck> checkedcurves = new List<CurveCheck> ();  						GH_Path path = new GH_Path (i);  						for (int j = 0; j < ghCrvs.Count; j++) {  							Curve c = ghCrvs [j].Value;  							if (c.IsClosed) {  								AreaMassProperties amp = AreaMassProperties.Compute (c);  								if (amp != null) {  									double area = amp.Area;  									CurveCheck cc = new CurveCheck (c' area);  									checkedcurves.Add (cc);  								}  							} else {  								allClosed = false;  							}  						}  						if (allClosed) {  							// Sort the curves by area  							checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  							checkedcurves.Reverse ();  							foreach (CurveCheck cc in checkedcurves) {  								crvTree.Add (cc' path);  							}  						}  					}  					if (allClosed) {  						// Determine if the smaller profiles are within the larger  						bool allInterior = true;  						List<RevitObject> tempObjs = new List<RevitObject> ();  						for (int i = 0; i < crvTree.Branches.Count; i++) {  							try {  								List<int> crvSegmentIds = new List<int> ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								List<CurveCheck> checkedCrvs = crvTree.Branches [i];  								Curve outerProfile = checkedCrvs [0].Curve;  								double outerArea = checkedCrvs [0].Area;  								List<Curve> planarCurves = new List<Curve> ();  								planarCurves.Add (outerProfile);  								double innerArea = 0.0;  								for (int j = 1; j < checkedCrvs.Count; j++) {  									planarCurves.Add (checkedCrvs [j].Curve);  									innerArea += checkedCrvs [j].Area;  								}  								// Try to create a planar surface  								IEnumerable<Curve> surfCurves = planarCurves;  								Brep[] b = Brep.CreatePlanarBreps (surfCurves);  								if (b.Count () == 1) {  									// Test the areas  									double brepArea = b [0].GetArea ();  									double calcArea = outerArea - innerArea;  									double diff = (brepArea - calcArea) / calcArea;  									if (diff < 0.1) {  										// The profiles probably are all interior  										foreach (CurveCheck cc in checkedCrvs) {  											Curve c = cc.Curve;  											List<Curve> rCurves = new List<Curve> ();  											bool getCrvs = CurveSegments (rCurves' c' true);  											if (rCurves.Count > 0) {  												int crvSeg = rCurves.Count;  												crvSegmentIds.Add (crvSeg);  												foreach (Curve rc in rCurves) {  													LyrebirdCurve lbc;  													lbc = GetLBCurve (rc);  													lbCurves.Add (lbc);  												}  											}  										}  										RevitObject ro = new RevitObject ();  										ro.Curves = lbCurves;  										ro.FamilyName = familyName;  										ro.Category = category;  										ro.CategoryId = categoryId;  										ro.TypeName = typeName;  										ro.Origin = null;  										ro.GHPath = crvTree.Paths [i].ToString ();  										ro.GHScaleFactor = scale.ScaleFactor;  										ro.GHScaleName = scale.ScaleName;  										ro.CurveIds = crvSegmentIds;  										tempObjs.Add (ro);  									}  								} else {  									allInterior = false;  									message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  								}  							} catch {  								allInterior = false;  								// Inform the user they need to graft their inputs.  Only one curve per branch  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						}  						if (tempObjs.Count > 0) {  							obj = tempObjs;  						}  					}  				}  			}  			#endregion  			// Orientation  			if (orientations != null && orientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignOrientation (obj' orientations);  				obj = tempList;  			}  			// face orientation  			if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  				List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  				obj = tempList;  			}  			// Parameters...  			if (Params.Input.Count > 6) {  				List<RevitObject> currentObjs = obj;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int r = 0; r < currentObjs.Count; r++) {  					RevitObject ro = currentObjs [r];  					List<RevitParameter> revitParams = new List<RevitParameter> ();  					for (int i = 6; i < Params.Input.Count; i++) {  						RevitParameter rp = new RevitParameter ();  						IGH_Param param = Params.Input [i];  						string paramInfo = param.Description;  						string[] pi = paramInfo.Split (new[] {  							"\n"'  							":"  						}' StringSplitOptions.None);  						string paramName = null;  						try {  							paramName = pi [1].Substring (1);  							string paramStorageType = pi [5].Substring (1);  							rp.ParameterName = paramName;  							rp.StorageType = paramStorageType;  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (paramName != null) {  							GH_Structure<IGH_Goo> data = null;  							try {  								DA.GetDataTree (i' out data);  							} catch (Exception ex) {  								Debug.WriteLine (ex.Message);  							}  							if (data != null) {  								string value = null;  								try {  									value = data [r] [0].ToString ();  								} catch (Exception) {  									if (data.DataCount > 0)  										value = data [data.Branches.Count - 1] [0].ToString ();  								}  								//System.Windows.Forms.MessageBox.Show("Got the Value");  								if (value != null) {  									if (rp.StorageType == "ElementId") {  										string[] values = value.Split (new char[] {  											'''  										}' StringSplitOptions.None);  										rp.Value = values [values.Count () - 1];  									} else {  										rp.Value = value;  									}  									revitParams.Add (rp);  								}  							}  						}  					}  					ro.Parameters = revitParams;  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			}  			// Send the data to Revit to create and/or modify family instances.  			if (obj != null && obj.Count > 0) {  				try {  					string docName = channel.DocumentName ();  					if (docName == null || docName == string.Empty) {  						message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  					} else {  						string nn = NickName;  						if (nn == null || nn.Length == 0) {  							nn = "LBOut";  						}  						channel.CreateOrModify (obj' InstanceGuid' NickName);  						message = obj.Count.ToString () + " objects sent to the lyrebird server.";  					}  				} catch {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				}  			}  			channel.Dispose ();  			try {  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		} else {  			message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  		}  	}  } else {  	message = null;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (channel != null) {  	string documentName = channel.DocumentName ();  	if (documentName != null) {  		// Create RevitObjects  		List<RevitObject> obj = new List<RevitObject> ();  		#region OriginPoint Based  		if (origPoints != null && origPoints.Branches.Count > 0) {  			List<RevitObject> tempObjs = new List<RevitObject> ();  			// make sure the branches match the datacount  			if (origPoints.Branches.Count == origPoints.DataCount) {  				for (int i = 0; i < origPoints.Branches.Count; i++) {  					GH_Point ghpt = origPoints [i] [0];  					LyrebirdPoint point = new LyrebirdPoint {  						X = ghpt.Value.X'  						Y = ghpt.Value.Y'  						Z = ghpt.Value.Z  					};  					RevitObject ro = new RevitObject {  						Origin = point'  						FamilyName = familyName'  						TypeName = typeName'  						Category = category'  						CategoryId = categoryId'  						GHPath = origPoints.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			} else {  				// Inform the user they need to graft their inputs.  Only one point per branch  				System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  			}  		}   		#endregion  		#region AdaptiveComponents  		else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  			// generate adaptive components  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < adaptPoints.Branches.Count; i++) {  				RevitObject ro = new RevitObject ();  				List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  				for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  					LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  					points.Add (point);  				}  				ro.AdaptivePoints = points;  				ro.FamilyName = familyName;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.GHPath = adaptPoints.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}   		#endregion  		#region Curve Based  		else if (curves != null && curves.Branches.Count > 0) {  			// Get curves for curve based components  			// Determine if we're profile or line based  			if (curves.Branches.Count == curves.DataCount) {  				// Determine if the curve is a closed planar curve  				Curve tempCrv = curves.Branches [0] [0].Value;  				if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  					// Closed planar curve  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve crv = curves [i] [0].Value;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' crv' true);  						if (rCurves.Count > 0) {  							// Check if they're planar in the XY Plane  							List<double> endPointElevations = new List<double> ();  							foreach (Curve crvSegment in rCurves) {  								if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  									if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  										endPointElevations.Add (crvSegment.PointAtEnd.Z);  								}  							}  							if (endPointElevations.Count != 1) {  								// curves are planar in the XY plane  								foreach (Curve rCurveSegment in rCurves) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							} else {  								RevitObject ro = new RevitObject ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								for (int j = 0; j < rCurves.Count; j++) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rCurves [j]);  									lbCurves.Add (lbc);  								}  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						}  					}  					obj = tempObjs;  				} else if (!tempCrv.IsClosed) {  					// Line based.  Can only be arc or linear curves  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve ghc = curves.Branches [i] [0].Value;  						// Test that there is only one curve segment  						PolyCurve polycurve = ghc as PolyCurve;  						if (polycurve != null) {  							Curve[] segments = polycurve.Explode ();  							if (segments.Count () != 1) {  								foreach (Curve rCurveSegment in segments) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  								//break;  							}  						}  						if (ghc != null) {  							//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  							LyrebirdCurve lbc = GetLBCurve (ghc);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							RevitObject ro = new RevitObject {  								Curves = lbcurves'  								FamilyName = familyName'  								Category = category'  								CategoryId = categoryId'  								TypeName = typeName'  								Origin = null'  								GHPath = curves.Paths [i].ToString ()'  								GHScaleFactor = scale.ScaleFactor'  								GHScaleName = scale.ScaleName  							};  							tempObjs.Add (ro);  						}  					}  					obj = tempObjs;  				}  			} else {  				// Make sure all of the curves in each branch are closed  				bool allClosed = true;  				DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					List<GH_Curve> ghCrvs = curves.Branches [i];  					List<CurveCheck> checkedcurves = new List<CurveCheck> ();  					GH_Path path = new GH_Path (i);  					for (int j = 0; j < ghCrvs.Count; j++) {  						Curve c = ghCrvs [j].Value;  						if (c.IsClosed) {  							AreaMassProperties amp = AreaMassProperties.Compute (c);  							if (amp != null) {  								double area = amp.Area;  								CurveCheck cc = new CurveCheck (c' area);  								checkedcurves.Add (cc);  							}  						} else {  							allClosed = false;  						}  					}  					if (allClosed) {  						// Sort the curves by area  						checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  						checkedcurves.Reverse ();  						foreach (CurveCheck cc in checkedcurves) {  							crvTree.Add (cc' path);  						}  					}  				}  				if (allClosed) {  					// Determine if the smaller profiles are within the larger  					bool allInterior = true;  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < crvTree.Branches.Count; i++) {  						try {  							List<int> crvSegmentIds = new List<int> ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							List<CurveCheck> checkedCrvs = crvTree.Branches [i];  							Curve outerProfile = checkedCrvs [0].Curve;  							double outerArea = checkedCrvs [0].Area;  							List<Curve> planarCurves = new List<Curve> ();  							planarCurves.Add (outerProfile);  							double innerArea = 0.0;  							for (int j = 1; j < checkedCrvs.Count; j++) {  								planarCurves.Add (checkedCrvs [j].Curve);  								innerArea += checkedCrvs [j].Area;  							}  							// Try to create a planar surface  							IEnumerable<Curve> surfCurves = planarCurves;  							Brep[] b = Brep.CreatePlanarBreps (surfCurves);  							if (b.Count () == 1) {  								// Test the areas  								double brepArea = b [0].GetArea ();  								double calcArea = outerArea - innerArea;  								double diff = (brepArea - calcArea) / calcArea;  								if (diff < 0.1) {  									// The profiles probably are all interior  									foreach (CurveCheck cc in checkedCrvs) {  										Curve c = cc.Curve;  										List<Curve> rCurves = new List<Curve> ();  										bool getCrvs = CurveSegments (rCurves' c' true);  										if (rCurves.Count > 0) {  											int crvSeg = rCurves.Count;  											crvSegmentIds.Add (crvSeg);  											foreach (Curve rc in rCurves) {  												LyrebirdCurve lbc;  												lbc = GetLBCurve (rc);  												lbCurves.Add (lbc);  											}  										}  									}  									RevitObject ro = new RevitObject ();  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = crvTree.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									ro.CurveIds = crvSegmentIds;  									tempObjs.Add (ro);  								}  							} else {  								allInterior = false;  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						} catch {  							allInterior = false;  							// Inform the user they need to graft their inputs.  Only one curve per branch  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					}  					if (tempObjs.Count > 0) {  						obj = tempObjs;  					}  				}  			}  		}  		#endregion  		// Orientation  		if (orientations != null && orientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignOrientation (obj' orientations);  			obj = tempList;  		}  		// face orientation  		if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  			obj = tempList;  		}  		// Parameters...  		if (Params.Input.Count > 6) {  			List<RevitObject> currentObjs = obj;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int r = 0; r < currentObjs.Count; r++) {  				RevitObject ro = currentObjs [r];  				List<RevitParameter> revitParams = new List<RevitParameter> ();  				for (int i = 6; i < Params.Input.Count; i++) {  					RevitParameter rp = new RevitParameter ();  					IGH_Param param = Params.Input [i];  					string paramInfo = param.Description;  					string[] pi = paramInfo.Split (new[] {  						"\n"'  						":"  					}' StringSplitOptions.None);  					string paramName = null;  					try {  						paramName = pi [1].Substring (1);  						string paramStorageType = pi [5].Substring (1);  						rp.ParameterName = paramName;  						rp.StorageType = paramStorageType;  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (paramName != null) {  						GH_Structure<IGH_Goo> data = null;  						try {  							DA.GetDataTree (i' out data);  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (data != null) {  							string value = null;  							try {  								value = data [r] [0].ToString ();  							} catch (Exception) {  								if (data.DataCount > 0)  									value = data [data.Branches.Count - 1] [0].ToString ();  							}  							//System.Windows.Forms.MessageBox.Show("Got the Value");  							if (value != null) {  								if (rp.StorageType == "ElementId") {  									string[] values = value.Split (new char[] {  										'''  									}' StringSplitOptions.None);  									rp.Value = values [values.Count () - 1];  								} else {  									rp.Value = value;  								}  								revitParams.Add (rp);  							}  						}  					}  				}  				ro.Parameters = revitParams;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}  		// Send the data to Revit to create and/or modify family instances.  		if (obj != null && obj.Count > 0) {  			try {  				string docName = channel.DocumentName ();  				if (docName == null || docName == string.Empty) {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				} else {  					string nn = NickName;  					if (nn == null || nn.Length == 0) {  						nn = "LBOut";  					}  					channel.CreateOrModify (obj' InstanceGuid' NickName);  					message = obj.Count.ToString () + " objects sent to the lyrebird server.";  				}  			} catch {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			}  		}  		channel.Dispose ();  		try {  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  	} else {  		message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (channel != null) {  	string documentName = channel.DocumentName ();  	if (documentName != null) {  		// Create RevitObjects  		List<RevitObject> obj = new List<RevitObject> ();  		#region OriginPoint Based  		if (origPoints != null && origPoints.Branches.Count > 0) {  			List<RevitObject> tempObjs = new List<RevitObject> ();  			// make sure the branches match the datacount  			if (origPoints.Branches.Count == origPoints.DataCount) {  				for (int i = 0; i < origPoints.Branches.Count; i++) {  					GH_Point ghpt = origPoints [i] [0];  					LyrebirdPoint point = new LyrebirdPoint {  						X = ghpt.Value.X'  						Y = ghpt.Value.Y'  						Z = ghpt.Value.Z  					};  					RevitObject ro = new RevitObject {  						Origin = point'  						FamilyName = familyName'  						TypeName = typeName'  						Category = category'  						CategoryId = categoryId'  						GHPath = origPoints.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			} else {  				// Inform the user they need to graft their inputs.  Only one point per branch  				System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  			}  		}   		#endregion  		#region AdaptiveComponents  		else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  			// generate adaptive components  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < adaptPoints.Branches.Count; i++) {  				RevitObject ro = new RevitObject ();  				List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  				for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  					LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  					points.Add (point);  				}  				ro.AdaptivePoints = points;  				ro.FamilyName = familyName;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.GHPath = adaptPoints.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}   		#endregion  		#region Curve Based  		else if (curves != null && curves.Branches.Count > 0) {  			// Get curves for curve based components  			// Determine if we're profile or line based  			if (curves.Branches.Count == curves.DataCount) {  				// Determine if the curve is a closed planar curve  				Curve tempCrv = curves.Branches [0] [0].Value;  				if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  					// Closed planar curve  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve crv = curves [i] [0].Value;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' crv' true);  						if (rCurves.Count > 0) {  							// Check if they're planar in the XY Plane  							List<double> endPointElevations = new List<double> ();  							foreach (Curve crvSegment in rCurves) {  								if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  									if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  										endPointElevations.Add (crvSegment.PointAtEnd.Z);  								}  							}  							if (endPointElevations.Count != 1) {  								// curves are planar in the XY plane  								foreach (Curve rCurveSegment in rCurves) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							} else {  								RevitObject ro = new RevitObject ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								for (int j = 0; j < rCurves.Count; j++) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rCurves [j]);  									lbCurves.Add (lbc);  								}  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						}  					}  					obj = tempObjs;  				} else if (!tempCrv.IsClosed) {  					// Line based.  Can only be arc or linear curves  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve ghc = curves.Branches [i] [0].Value;  						// Test that there is only one curve segment  						PolyCurve polycurve = ghc as PolyCurve;  						if (polycurve != null) {  							Curve[] segments = polycurve.Explode ();  							if (segments.Count () != 1) {  								foreach (Curve rCurveSegment in segments) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  								//break;  							}  						}  						if (ghc != null) {  							//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  							LyrebirdCurve lbc = GetLBCurve (ghc);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							RevitObject ro = new RevitObject {  								Curves = lbcurves'  								FamilyName = familyName'  								Category = category'  								CategoryId = categoryId'  								TypeName = typeName'  								Origin = null'  								GHPath = curves.Paths [i].ToString ()'  								GHScaleFactor = scale.ScaleFactor'  								GHScaleName = scale.ScaleName  							};  							tempObjs.Add (ro);  						}  					}  					obj = tempObjs;  				}  			} else {  				// Make sure all of the curves in each branch are closed  				bool allClosed = true;  				DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					List<GH_Curve> ghCrvs = curves.Branches [i];  					List<CurveCheck> checkedcurves = new List<CurveCheck> ();  					GH_Path path = new GH_Path (i);  					for (int j = 0; j < ghCrvs.Count; j++) {  						Curve c = ghCrvs [j].Value;  						if (c.IsClosed) {  							AreaMassProperties amp = AreaMassProperties.Compute (c);  							if (amp != null) {  								double area = amp.Area;  								CurveCheck cc = new CurveCheck (c' area);  								checkedcurves.Add (cc);  							}  						} else {  							allClosed = false;  						}  					}  					if (allClosed) {  						// Sort the curves by area  						checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  						checkedcurves.Reverse ();  						foreach (CurveCheck cc in checkedcurves) {  							crvTree.Add (cc' path);  						}  					}  				}  				if (allClosed) {  					// Determine if the smaller profiles are within the larger  					bool allInterior = true;  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < crvTree.Branches.Count; i++) {  						try {  							List<int> crvSegmentIds = new List<int> ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							List<CurveCheck> checkedCrvs = crvTree.Branches [i];  							Curve outerProfile = checkedCrvs [0].Curve;  							double outerArea = checkedCrvs [0].Area;  							List<Curve> planarCurves = new List<Curve> ();  							planarCurves.Add (outerProfile);  							double innerArea = 0.0;  							for (int j = 1; j < checkedCrvs.Count; j++) {  								planarCurves.Add (checkedCrvs [j].Curve);  								innerArea += checkedCrvs [j].Area;  							}  							// Try to create a planar surface  							IEnumerable<Curve> surfCurves = planarCurves;  							Brep[] b = Brep.CreatePlanarBreps (surfCurves);  							if (b.Count () == 1) {  								// Test the areas  								double brepArea = b [0].GetArea ();  								double calcArea = outerArea - innerArea;  								double diff = (brepArea - calcArea) / calcArea;  								if (diff < 0.1) {  									// The profiles probably are all interior  									foreach (CurveCheck cc in checkedCrvs) {  										Curve c = cc.Curve;  										List<Curve> rCurves = new List<Curve> ();  										bool getCrvs = CurveSegments (rCurves' c' true);  										if (rCurves.Count > 0) {  											int crvSeg = rCurves.Count;  											crvSegmentIds.Add (crvSeg);  											foreach (Curve rc in rCurves) {  												LyrebirdCurve lbc;  												lbc = GetLBCurve (rc);  												lbCurves.Add (lbc);  											}  										}  									}  									RevitObject ro = new RevitObject ();  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = crvTree.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									ro.CurveIds = crvSegmentIds;  									tempObjs.Add (ro);  								}  							} else {  								allInterior = false;  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						} catch {  							allInterior = false;  							// Inform the user they need to graft their inputs.  Only one curve per branch  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					}  					if (tempObjs.Count > 0) {  						obj = tempObjs;  					}  				}  			}  		}  		#endregion  		// Orientation  		if (orientations != null && orientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignOrientation (obj' orientations);  			obj = tempList;  		}  		// face orientation  		if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  			obj = tempList;  		}  		// Parameters...  		if (Params.Input.Count > 6) {  			List<RevitObject> currentObjs = obj;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int r = 0; r < currentObjs.Count; r++) {  				RevitObject ro = currentObjs [r];  				List<RevitParameter> revitParams = new List<RevitParameter> ();  				for (int i = 6; i < Params.Input.Count; i++) {  					RevitParameter rp = new RevitParameter ();  					IGH_Param param = Params.Input [i];  					string paramInfo = param.Description;  					string[] pi = paramInfo.Split (new[] {  						"\n"'  						":"  					}' StringSplitOptions.None);  					string paramName = null;  					try {  						paramName = pi [1].Substring (1);  						string paramStorageType = pi [5].Substring (1);  						rp.ParameterName = paramName;  						rp.StorageType = paramStorageType;  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (paramName != null) {  						GH_Structure<IGH_Goo> data = null;  						try {  							DA.GetDataTree (i' out data);  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (data != null) {  							string value = null;  							try {  								value = data [r] [0].ToString ();  							} catch (Exception) {  								if (data.DataCount > 0)  									value = data [data.Branches.Count - 1] [0].ToString ();  							}  							//System.Windows.Forms.MessageBox.Show("Got the Value");  							if (value != null) {  								if (rp.StorageType == "ElementId") {  									string[] values = value.Split (new char[] {  										'''  									}' StringSplitOptions.None);  									rp.Value = values [values.Count () - 1];  								} else {  									rp.Value = value;  								}  								revitParams.Add (rp);  							}  						}  					}  				}  				ro.Parameters = revitParams;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}  		// Send the data to Revit to create and/or modify family instances.  		if (obj != null && obj.Count > 0) {  			try {  				string docName = channel.DocumentName ();  				if (docName == null || docName == string.Empty) {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				} else {  					string nn = NickName;  					if (nn == null || nn.Length == 0) {  						nn = "LBOut";  					}  					channel.CreateOrModify (obj' InstanceGuid' NickName);  					message = obj.Count.ToString () + " objects sent to the lyrebird server.";  				}  			} catch {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			}  		}  		channel.Dispose ();  		try {  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  	} else {  		message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (channel != null) {  	string documentName = channel.DocumentName ();  	if (documentName != null) {  		// Create RevitObjects  		List<RevitObject> obj = new List<RevitObject> ();  		#region OriginPoint Based  		if (origPoints != null && origPoints.Branches.Count > 0) {  			List<RevitObject> tempObjs = new List<RevitObject> ();  			// make sure the branches match the datacount  			if (origPoints.Branches.Count == origPoints.DataCount) {  				for (int i = 0; i < origPoints.Branches.Count; i++) {  					GH_Point ghpt = origPoints [i] [0];  					LyrebirdPoint point = new LyrebirdPoint {  						X = ghpt.Value.X'  						Y = ghpt.Value.Y'  						Z = ghpt.Value.Z  					};  					RevitObject ro = new RevitObject {  						Origin = point'  						FamilyName = familyName'  						TypeName = typeName'  						Category = category'  						CategoryId = categoryId'  						GHPath = origPoints.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			} else {  				// Inform the user they need to graft their inputs.  Only one point per branch  				System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  			}  		}   		#endregion  		#region AdaptiveComponents  		else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  			// generate adaptive components  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < adaptPoints.Branches.Count; i++) {  				RevitObject ro = new RevitObject ();  				List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  				for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  					LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  					points.Add (point);  				}  				ro.AdaptivePoints = points;  				ro.FamilyName = familyName;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.GHPath = adaptPoints.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}   		#endregion  		#region Curve Based  		else if (curves != null && curves.Branches.Count > 0) {  			// Get curves for curve based components  			// Determine if we're profile or line based  			if (curves.Branches.Count == curves.DataCount) {  				// Determine if the curve is a closed planar curve  				Curve tempCrv = curves.Branches [0] [0].Value;  				if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  					// Closed planar curve  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve crv = curves [i] [0].Value;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' crv' true);  						if (rCurves.Count > 0) {  							// Check if they're planar in the XY Plane  							List<double> endPointElevations = new List<double> ();  							foreach (Curve crvSegment in rCurves) {  								if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  									if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  										endPointElevations.Add (crvSegment.PointAtEnd.Z);  								}  							}  							if (endPointElevations.Count != 1) {  								// curves are planar in the XY plane  								foreach (Curve rCurveSegment in rCurves) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							} else {  								RevitObject ro = new RevitObject ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								for (int j = 0; j < rCurves.Count; j++) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rCurves [j]);  									lbCurves.Add (lbc);  								}  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						}  					}  					obj = tempObjs;  				} else if (!tempCrv.IsClosed) {  					// Line based.  Can only be arc or linear curves  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve ghc = curves.Branches [i] [0].Value;  						// Test that there is only one curve segment  						PolyCurve polycurve = ghc as PolyCurve;  						if (polycurve != null) {  							Curve[] segments = polycurve.Explode ();  							if (segments.Count () != 1) {  								foreach (Curve rCurveSegment in segments) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  								//break;  							}  						}  						if (ghc != null) {  							//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  							LyrebirdCurve lbc = GetLBCurve (ghc);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							RevitObject ro = new RevitObject {  								Curves = lbcurves'  								FamilyName = familyName'  								Category = category'  								CategoryId = categoryId'  								TypeName = typeName'  								Origin = null'  								GHPath = curves.Paths [i].ToString ()'  								GHScaleFactor = scale.ScaleFactor'  								GHScaleName = scale.ScaleName  							};  							tempObjs.Add (ro);  						}  					}  					obj = tempObjs;  				}  			} else {  				// Make sure all of the curves in each branch are closed  				bool allClosed = true;  				DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					List<GH_Curve> ghCrvs = curves.Branches [i];  					List<CurveCheck> checkedcurves = new List<CurveCheck> ();  					GH_Path path = new GH_Path (i);  					for (int j = 0; j < ghCrvs.Count; j++) {  						Curve c = ghCrvs [j].Value;  						if (c.IsClosed) {  							AreaMassProperties amp = AreaMassProperties.Compute (c);  							if (amp != null) {  								double area = amp.Area;  								CurveCheck cc = new CurveCheck (c' area);  								checkedcurves.Add (cc);  							}  						} else {  							allClosed = false;  						}  					}  					if (allClosed) {  						// Sort the curves by area  						checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  						checkedcurves.Reverse ();  						foreach (CurveCheck cc in checkedcurves) {  							crvTree.Add (cc' path);  						}  					}  				}  				if (allClosed) {  					// Determine if the smaller profiles are within the larger  					bool allInterior = true;  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < crvTree.Branches.Count; i++) {  						try {  							List<int> crvSegmentIds = new List<int> ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							List<CurveCheck> checkedCrvs = crvTree.Branches [i];  							Curve outerProfile = checkedCrvs [0].Curve;  							double outerArea = checkedCrvs [0].Area;  							List<Curve> planarCurves = new List<Curve> ();  							planarCurves.Add (outerProfile);  							double innerArea = 0.0;  							for (int j = 1; j < checkedCrvs.Count; j++) {  								planarCurves.Add (checkedCrvs [j].Curve);  								innerArea += checkedCrvs [j].Area;  							}  							// Try to create a planar surface  							IEnumerable<Curve> surfCurves = planarCurves;  							Brep[] b = Brep.CreatePlanarBreps (surfCurves);  							if (b.Count () == 1) {  								// Test the areas  								double brepArea = b [0].GetArea ();  								double calcArea = outerArea - innerArea;  								double diff = (brepArea - calcArea) / calcArea;  								if (diff < 0.1) {  									// The profiles probably are all interior  									foreach (CurveCheck cc in checkedCrvs) {  										Curve c = cc.Curve;  										List<Curve> rCurves = new List<Curve> ();  										bool getCrvs = CurveSegments (rCurves' c' true);  										if (rCurves.Count > 0) {  											int crvSeg = rCurves.Count;  											crvSegmentIds.Add (crvSeg);  											foreach (Curve rc in rCurves) {  												LyrebirdCurve lbc;  												lbc = GetLBCurve (rc);  												lbCurves.Add (lbc);  											}  										}  									}  									RevitObject ro = new RevitObject ();  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = crvTree.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									ro.CurveIds = crvSegmentIds;  									tempObjs.Add (ro);  								}  							} else {  								allInterior = false;  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						} catch {  							allInterior = false;  							// Inform the user they need to graft their inputs.  Only one curve per branch  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					}  					if (tempObjs.Count > 0) {  						obj = tempObjs;  					}  				}  			}  		}  		#endregion  		// Orientation  		if (orientations != null && orientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignOrientation (obj' orientations);  			obj = tempList;  		}  		// face orientation  		if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  			obj = tempList;  		}  		// Parameters...  		if (Params.Input.Count > 6) {  			List<RevitObject> currentObjs = obj;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int r = 0; r < currentObjs.Count; r++) {  				RevitObject ro = currentObjs [r];  				List<RevitParameter> revitParams = new List<RevitParameter> ();  				for (int i = 6; i < Params.Input.Count; i++) {  					RevitParameter rp = new RevitParameter ();  					IGH_Param param = Params.Input [i];  					string paramInfo = param.Description;  					string[] pi = paramInfo.Split (new[] {  						"\n"'  						":"  					}' StringSplitOptions.None);  					string paramName = null;  					try {  						paramName = pi [1].Substring (1);  						string paramStorageType = pi [5].Substring (1);  						rp.ParameterName = paramName;  						rp.StorageType = paramStorageType;  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (paramName != null) {  						GH_Structure<IGH_Goo> data = null;  						try {  							DA.GetDataTree (i' out data);  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (data != null) {  							string value = null;  							try {  								value = data [r] [0].ToString ();  							} catch (Exception) {  								if (data.DataCount > 0)  									value = data [data.Branches.Count - 1] [0].ToString ();  							}  							//System.Windows.Forms.MessageBox.Show("Got the Value");  							if (value != null) {  								if (rp.StorageType == "ElementId") {  									string[] values = value.Split (new char[] {  										'''  									}' StringSplitOptions.None);  									rp.Value = values [values.Count () - 1];  								} else {  									rp.Value = value;  								}  								revitParams.Add (rp);  							}  						}  					}  				}  				ro.Parameters = revitParams;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}  		// Send the data to Revit to create and/or modify family instances.  		if (obj != null && obj.Count > 0) {  			try {  				string docName = channel.DocumentName ();  				if (docName == null || docName == string.Empty) {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				} else {  					string nn = NickName;  					if (nn == null || nn.Length == 0) {  						nn = "LBOut";  					}  					channel.CreateOrModify (obj' InstanceGuid' NickName);  					message = obj.Count.ToString () + " objects sent to the lyrebird server.";  				}  			} catch {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			}  		}  		channel.Dispose ();  		try {  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  	} else {  		message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (channel != null) {  	string documentName = channel.DocumentName ();  	if (documentName != null) {  		// Create RevitObjects  		List<RevitObject> obj = new List<RevitObject> ();  		#region OriginPoint Based  		if (origPoints != null && origPoints.Branches.Count > 0) {  			List<RevitObject> tempObjs = new List<RevitObject> ();  			// make sure the branches match the datacount  			if (origPoints.Branches.Count == origPoints.DataCount) {  				for (int i = 0; i < origPoints.Branches.Count; i++) {  					GH_Point ghpt = origPoints [i] [0];  					LyrebirdPoint point = new LyrebirdPoint {  						X = ghpt.Value.X'  						Y = ghpt.Value.Y'  						Z = ghpt.Value.Z  					};  					RevitObject ro = new RevitObject {  						Origin = point'  						FamilyName = familyName'  						TypeName = typeName'  						Category = category'  						CategoryId = categoryId'  						GHPath = origPoints.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			} else {  				// Inform the user they need to graft their inputs.  Only one point per branch  				System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  			}  		}   		#endregion  		#region AdaptiveComponents  		else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  			// generate adaptive components  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < adaptPoints.Branches.Count; i++) {  				RevitObject ro = new RevitObject ();  				List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  				for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  					LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  					points.Add (point);  				}  				ro.AdaptivePoints = points;  				ro.FamilyName = familyName;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.GHPath = adaptPoints.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}   		#endregion  		#region Curve Based  		else if (curves != null && curves.Branches.Count > 0) {  			// Get curves for curve based components  			// Determine if we're profile or line based  			if (curves.Branches.Count == curves.DataCount) {  				// Determine if the curve is a closed planar curve  				Curve tempCrv = curves.Branches [0] [0].Value;  				if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  					// Closed planar curve  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve crv = curves [i] [0].Value;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' crv' true);  						if (rCurves.Count > 0) {  							// Check if they're planar in the XY Plane  							List<double> endPointElevations = new List<double> ();  							foreach (Curve crvSegment in rCurves) {  								if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  									if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  										endPointElevations.Add (crvSegment.PointAtEnd.Z);  								}  							}  							if (endPointElevations.Count != 1) {  								// curves are planar in the XY plane  								foreach (Curve rCurveSegment in rCurves) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							} else {  								RevitObject ro = new RevitObject ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								for (int j = 0; j < rCurves.Count; j++) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rCurves [j]);  									lbCurves.Add (lbc);  								}  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						}  					}  					obj = tempObjs;  				} else if (!tempCrv.IsClosed) {  					// Line based.  Can only be arc or linear curves  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve ghc = curves.Branches [i] [0].Value;  						// Test that there is only one curve segment  						PolyCurve polycurve = ghc as PolyCurve;  						if (polycurve != null) {  							Curve[] segments = polycurve.Explode ();  							if (segments.Count () != 1) {  								foreach (Curve rCurveSegment in segments) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  								//break;  							}  						}  						if (ghc != null) {  							//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  							LyrebirdCurve lbc = GetLBCurve (ghc);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							RevitObject ro = new RevitObject {  								Curves = lbcurves'  								FamilyName = familyName'  								Category = category'  								CategoryId = categoryId'  								TypeName = typeName'  								Origin = null'  								GHPath = curves.Paths [i].ToString ()'  								GHScaleFactor = scale.ScaleFactor'  								GHScaleName = scale.ScaleName  							};  							tempObjs.Add (ro);  						}  					}  					obj = tempObjs;  				}  			} else {  				// Make sure all of the curves in each branch are closed  				bool allClosed = true;  				DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					List<GH_Curve> ghCrvs = curves.Branches [i];  					List<CurveCheck> checkedcurves = new List<CurveCheck> ();  					GH_Path path = new GH_Path (i);  					for (int j = 0; j < ghCrvs.Count; j++) {  						Curve c = ghCrvs [j].Value;  						if (c.IsClosed) {  							AreaMassProperties amp = AreaMassProperties.Compute (c);  							if (amp != null) {  								double area = amp.Area;  								CurveCheck cc = new CurveCheck (c' area);  								checkedcurves.Add (cc);  							}  						} else {  							allClosed = false;  						}  					}  					if (allClosed) {  						// Sort the curves by area  						checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  						checkedcurves.Reverse ();  						foreach (CurveCheck cc in checkedcurves) {  							crvTree.Add (cc' path);  						}  					}  				}  				if (allClosed) {  					// Determine if the smaller profiles are within the larger  					bool allInterior = true;  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < crvTree.Branches.Count; i++) {  						try {  							List<int> crvSegmentIds = new List<int> ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							List<CurveCheck> checkedCrvs = crvTree.Branches [i];  							Curve outerProfile = checkedCrvs [0].Curve;  							double outerArea = checkedCrvs [0].Area;  							List<Curve> planarCurves = new List<Curve> ();  							planarCurves.Add (outerProfile);  							double innerArea = 0.0;  							for (int j = 1; j < checkedCrvs.Count; j++) {  								planarCurves.Add (checkedCrvs [j].Curve);  								innerArea += checkedCrvs [j].Area;  							}  							// Try to create a planar surface  							IEnumerable<Curve> surfCurves = planarCurves;  							Brep[] b = Brep.CreatePlanarBreps (surfCurves);  							if (b.Count () == 1) {  								// Test the areas  								double brepArea = b [0].GetArea ();  								double calcArea = outerArea - innerArea;  								double diff = (brepArea - calcArea) / calcArea;  								if (diff < 0.1) {  									// The profiles probably are all interior  									foreach (CurveCheck cc in checkedCrvs) {  										Curve c = cc.Curve;  										List<Curve> rCurves = new List<Curve> ();  										bool getCrvs = CurveSegments (rCurves' c' true);  										if (rCurves.Count > 0) {  											int crvSeg = rCurves.Count;  											crvSegmentIds.Add (crvSeg);  											foreach (Curve rc in rCurves) {  												LyrebirdCurve lbc;  												lbc = GetLBCurve (rc);  												lbCurves.Add (lbc);  											}  										}  									}  									RevitObject ro = new RevitObject ();  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = crvTree.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									ro.CurveIds = crvSegmentIds;  									tempObjs.Add (ro);  								}  							} else {  								allInterior = false;  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						} catch {  							allInterior = false;  							// Inform the user they need to graft their inputs.  Only one curve per branch  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					}  					if (tempObjs.Count > 0) {  						obj = tempObjs;  					}  				}  			}  		}  		#endregion  		// Orientation  		if (orientations != null && orientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignOrientation (obj' orientations);  			obj = tempList;  		}  		// face orientation  		if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  			obj = tempList;  		}  		// Parameters...  		if (Params.Input.Count > 6) {  			List<RevitObject> currentObjs = obj;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int r = 0; r < currentObjs.Count; r++) {  				RevitObject ro = currentObjs [r];  				List<RevitParameter> revitParams = new List<RevitParameter> ();  				for (int i = 6; i < Params.Input.Count; i++) {  					RevitParameter rp = new RevitParameter ();  					IGH_Param param = Params.Input [i];  					string paramInfo = param.Description;  					string[] pi = paramInfo.Split (new[] {  						"\n"'  						":"  					}' StringSplitOptions.None);  					string paramName = null;  					try {  						paramName = pi [1].Substring (1);  						string paramStorageType = pi [5].Substring (1);  						rp.ParameterName = paramName;  						rp.StorageType = paramStorageType;  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (paramName != null) {  						GH_Structure<IGH_Goo> data = null;  						try {  							DA.GetDataTree (i' out data);  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (data != null) {  							string value = null;  							try {  								value = data [r] [0].ToString ();  							} catch (Exception) {  								if (data.DataCount > 0)  									value = data [data.Branches.Count - 1] [0].ToString ();  							}  							//System.Windows.Forms.MessageBox.Show("Got the Value");  							if (value != null) {  								if (rp.StorageType == "ElementId") {  									string[] values = value.Split (new char[] {  										'''  									}' StringSplitOptions.None);  									rp.Value = values [values.Count () - 1];  								} else {  									rp.Value = value;  								}  								revitParams.Add (rp);  							}  						}  					}  				}  				ro.Parameters = revitParams;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}  		// Send the data to Revit to create and/or modify family instances.  		if (obj != null && obj.Count > 0) {  			try {  				string docName = channel.DocumentName ();  				if (docName == null || docName == string.Empty) {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				} else {  					string nn = NickName;  					if (nn == null || nn.Length == 0) {  						nn = "LBOut";  					}  					channel.CreateOrModify (obj' InstanceGuid' NickName);  					message = obj.Count.ToString () + " objects sent to the lyrebird server.";  				}  			} catch {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			}  		}  		channel.Dispose ();  		try {  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  	} else {  		message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (channel != null) {  	string documentName = channel.DocumentName ();  	if (documentName != null) {  		// Create RevitObjects  		List<RevitObject> obj = new List<RevitObject> ();  		#region OriginPoint Based  		if (origPoints != null && origPoints.Branches.Count > 0) {  			List<RevitObject> tempObjs = new List<RevitObject> ();  			// make sure the branches match the datacount  			if (origPoints.Branches.Count == origPoints.DataCount) {  				for (int i = 0; i < origPoints.Branches.Count; i++) {  					GH_Point ghpt = origPoints [i] [0];  					LyrebirdPoint point = new LyrebirdPoint {  						X = ghpt.Value.X'  						Y = ghpt.Value.Y'  						Z = ghpt.Value.Z  					};  					RevitObject ro = new RevitObject {  						Origin = point'  						FamilyName = familyName'  						TypeName = typeName'  						Category = category'  						CategoryId = categoryId'  						GHPath = origPoints.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  				obj = tempObjs;  			} else {  				// Inform the user they need to graft their inputs.  Only one point per branch  				System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  			}  		}   		#endregion  		#region AdaptiveComponents  		else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  			// generate adaptive components  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < adaptPoints.Branches.Count; i++) {  				RevitObject ro = new RevitObject ();  				List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  				for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  					LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  					points.Add (point);  				}  				ro.AdaptivePoints = points;  				ro.FamilyName = familyName;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.GHPath = adaptPoints.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}   		#endregion  		#region Curve Based  		else if (curves != null && curves.Branches.Count > 0) {  			// Get curves for curve based components  			// Determine if we're profile or line based  			if (curves.Branches.Count == curves.DataCount) {  				// Determine if the curve is a closed planar curve  				Curve tempCrv = curves.Branches [0] [0].Value;  				if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  					// Closed planar curve  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve crv = curves [i] [0].Value;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' crv' true);  						if (rCurves.Count > 0) {  							// Check if they're planar in the XY Plane  							List<double> endPointElevations = new List<double> ();  							foreach (Curve crvSegment in rCurves) {  								if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  									if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  										endPointElevations.Add (crvSegment.PointAtEnd.Z);  								}  							}  							if (endPointElevations.Count != 1) {  								// curves are planar in the XY plane  								foreach (Curve rCurveSegment in rCurves) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  							} else {  								RevitObject ro = new RevitObject ();  								List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  								for (int j = 0; j < rCurves.Count; j++) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rCurves [j]);  									lbCurves.Add (lbc);  								}  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						}  					}  					obj = tempObjs;  				} else if (!tempCrv.IsClosed) {  					// Line based.  Can only be arc or linear curves  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < curves.Branches.Count; i++) {  						Curve ghc = curves.Branches [i] [0].Value;  						// Test that there is only one curve segment  						PolyCurve polycurve = ghc as PolyCurve;  						if (polycurve != null) {  							Curve[] segments = polycurve.Explode ();  							if (segments.Count () != 1) {  								foreach (Curve rCurveSegment in segments) {  									RevitObject ro = new RevitObject ();  									LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  									List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  										lbc  									};  									ro.Curves = lbcurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = curves.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									tempObjs.Add (ro);  								}  								//break;  							}  						}  						if (ghc != null) {  							//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  							LyrebirdCurve lbc = GetLBCurve (ghc);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							RevitObject ro = new RevitObject {  								Curves = lbcurves'  								FamilyName = familyName'  								Category = category'  								CategoryId = categoryId'  								TypeName = typeName'  								Origin = null'  								GHPath = curves.Paths [i].ToString ()'  								GHScaleFactor = scale.ScaleFactor'  								GHScaleName = scale.ScaleName  							};  							tempObjs.Add (ro);  						}  					}  					obj = tempObjs;  				}  			} else {  				// Make sure all of the curves in each branch are closed  				bool allClosed = true;  				DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					List<GH_Curve> ghCrvs = curves.Branches [i];  					List<CurveCheck> checkedcurves = new List<CurveCheck> ();  					GH_Path path = new GH_Path (i);  					for (int j = 0; j < ghCrvs.Count; j++) {  						Curve c = ghCrvs [j].Value;  						if (c.IsClosed) {  							AreaMassProperties amp = AreaMassProperties.Compute (c);  							if (amp != null) {  								double area = amp.Area;  								CurveCheck cc = new CurveCheck (c' area);  								checkedcurves.Add (cc);  							}  						} else {  							allClosed = false;  						}  					}  					if (allClosed) {  						// Sort the curves by area  						checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  						checkedcurves.Reverse ();  						foreach (CurveCheck cc in checkedcurves) {  							crvTree.Add (cc' path);  						}  					}  				}  				if (allClosed) {  					// Determine if the smaller profiles are within the larger  					bool allInterior = true;  					List<RevitObject> tempObjs = new List<RevitObject> ();  					for (int i = 0; i < crvTree.Branches.Count; i++) {  						try {  							List<int> crvSegmentIds = new List<int> ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							List<CurveCheck> checkedCrvs = crvTree.Branches [i];  							Curve outerProfile = checkedCrvs [0].Curve;  							double outerArea = checkedCrvs [0].Area;  							List<Curve> planarCurves = new List<Curve> ();  							planarCurves.Add (outerProfile);  							double innerArea = 0.0;  							for (int j = 1; j < checkedCrvs.Count; j++) {  								planarCurves.Add (checkedCrvs [j].Curve);  								innerArea += checkedCrvs [j].Area;  							}  							// Try to create a planar surface  							IEnumerable<Curve> surfCurves = planarCurves;  							Brep[] b = Brep.CreatePlanarBreps (surfCurves);  							if (b.Count () == 1) {  								// Test the areas  								double brepArea = b [0].GetArea ();  								double calcArea = outerArea - innerArea;  								double diff = (brepArea - calcArea) / calcArea;  								if (diff < 0.1) {  									// The profiles probably are all interior  									foreach (CurveCheck cc in checkedCrvs) {  										Curve c = cc.Curve;  										List<Curve> rCurves = new List<Curve> ();  										bool getCrvs = CurveSegments (rCurves' c' true);  										if (rCurves.Count > 0) {  											int crvSeg = rCurves.Count;  											crvSegmentIds.Add (crvSeg);  											foreach (Curve rc in rCurves) {  												LyrebirdCurve lbc;  												lbc = GetLBCurve (rc);  												lbCurves.Add (lbc);  											}  										}  									}  									RevitObject ro = new RevitObject ();  									ro.Curves = lbCurves;  									ro.FamilyName = familyName;  									ro.Category = category;  									ro.CategoryId = categoryId;  									ro.TypeName = typeName;  									ro.Origin = null;  									ro.GHPath = crvTree.Paths [i].ToString ();  									ro.GHScaleFactor = scale.ScaleFactor;  									ro.GHScaleName = scale.ScaleName;  									ro.CurveIds = crvSegmentIds;  									tempObjs.Add (ro);  								}  							} else {  								allInterior = false;  								message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  							}  						} catch {  							allInterior = false;  							// Inform the user they need to graft their inputs.  Only one curve per branch  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					}  					if (tempObjs.Count > 0) {  						obj = tempObjs;  					}  				}  			}  		}  		#endregion  		// Orientation  		if (orientations != null && orientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignOrientation (obj' orientations);  			obj = tempList;  		}  		// face orientation  		if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  			List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  			obj = tempList;  		}  		// Parameters...  		if (Params.Input.Count > 6) {  			List<RevitObject> currentObjs = obj;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int r = 0; r < currentObjs.Count; r++) {  				RevitObject ro = currentObjs [r];  				List<RevitParameter> revitParams = new List<RevitParameter> ();  				for (int i = 6; i < Params.Input.Count; i++) {  					RevitParameter rp = new RevitParameter ();  					IGH_Param param = Params.Input [i];  					string paramInfo = param.Description;  					string[] pi = paramInfo.Split (new[] {  						"\n"'  						":"  					}' StringSplitOptions.None);  					string paramName = null;  					try {  						paramName = pi [1].Substring (1);  						string paramStorageType = pi [5].Substring (1);  						rp.ParameterName = paramName;  						rp.StorageType = paramStorageType;  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (paramName != null) {  						GH_Structure<IGH_Goo> data = null;  						try {  							DA.GetDataTree (i' out data);  						} catch (Exception ex) {  							Debug.WriteLine (ex.Message);  						}  						if (data != null) {  							string value = null;  							try {  								value = data [r] [0].ToString ();  							} catch (Exception) {  								if (data.DataCount > 0)  									value = data [data.Branches.Count - 1] [0].ToString ();  							}  							//System.Windows.Forms.MessageBox.Show("Got the Value");  							if (value != null) {  								if (rp.StorageType == "ElementId") {  									string[] values = value.Split (new char[] {  										'''  									}' StringSplitOptions.None);  									rp.Value = values [values.Count () - 1];  								} else {  									rp.Value = value;  								}  								revitParams.Add (rp);  							}  						}  					}  				}  				ro.Parameters = revitParams;  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		}  		// Send the data to Revit to create and/or modify family instances.  		if (obj != null && obj.Count > 0) {  			try {  				string docName = channel.DocumentName ();  				if (docName == null || docName == string.Empty) {  					message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  				} else {  					string nn = NickName;  					if (nn == null || nn.Length == 0) {  						nn = "LBOut";  					}  					channel.CreateOrModify (obj' InstanceGuid' NickName);  					message = obj.Count.ToString () + " objects sent to the lyrebird server.";  				}  			} catch {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			}  		}  		channel.Dispose ();  		try {  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  	} else {  		message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (documentName != null) {  	// Create RevitObjects  	List<RevitObject> obj = new List<RevitObject> ();  	#region OriginPoint Based  	if (origPoints != null && origPoints.Branches.Count > 0) {  		List<RevitObject> tempObjs = new List<RevitObject> ();  		// make sure the branches match the datacount  		if (origPoints.Branches.Count == origPoints.DataCount) {  			for (int i = 0; i < origPoints.Branches.Count; i++) {  				GH_Point ghpt = origPoints [i] [0];  				LyrebirdPoint point = new LyrebirdPoint {  					X = ghpt.Value.X'  					Y = ghpt.Value.Y'  					Z = ghpt.Value.Z  				};  				RevitObject ro = new RevitObject {  					Origin = point'  					FamilyName = familyName'  					TypeName = typeName'  					Category = category'  					CategoryId = categoryId'  					GHPath = origPoints.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		} else {  			// Inform the user they need to graft their inputs.  Only one point per branch  			System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  		}  	}   	#endregion  	#region AdaptiveComponents  	else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  		// generate adaptive components  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < adaptPoints.Branches.Count; i++) {  			RevitObject ro = new RevitObject ();  			List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  			for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  				LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  				points.Add (point);  			}  			ro.AdaptivePoints = points;  			ro.FamilyName = familyName;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.GHPath = adaptPoints.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}   	#endregion  	#region Curve Based  	else if (curves != null && curves.Branches.Count > 0) {  		// Get curves for curve based components  		// Determine if we're profile or line based  		if (curves.Branches.Count == curves.DataCount) {  			// Determine if the curve is a closed planar curve  			Curve tempCrv = curves.Branches [0] [0].Value;  			if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  				// Closed planar curve  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve crv = curves [i] [0].Value;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' crv' true);  					if (rCurves.Count > 0) {  						// Check if they're planar in the XY Plane  						List<double> endPointElevations = new List<double> ();  						foreach (Curve crvSegment in rCurves) {  							if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  								if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  									endPointElevations.Add (crvSegment.PointAtEnd.Z);  							}  						}  						if (endPointElevations.Count != 1) {  							// curves are planar in the XY plane  							foreach (Curve rCurveSegment in rCurves) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						} else {  							RevitObject ro = new RevitObject ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							for (int j = 0; j < rCurves.Count; j++) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rCurves [j]);  								lbCurves.Add (lbc);  							}  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					}  				}  				obj = tempObjs;  			} else if (!tempCrv.IsClosed) {  				// Line based.  Can only be arc or linear curves  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve ghc = curves.Branches [i] [0].Value;  					// Test that there is only one curve segment  					PolyCurve polycurve = ghc as PolyCurve;  					if (polycurve != null) {  						Curve[] segments = polycurve.Explode ();  						if (segments.Count () != 1) {  							foreach (Curve rCurveSegment in segments) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  							//break;  						}  					}  					if (ghc != null) {  						//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  						LyrebirdCurve lbc = GetLBCurve (ghc);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						RevitObject ro = new RevitObject {  							Curves = lbcurves'  							FamilyName = familyName'  							Category = category'  							CategoryId = categoryId'  							TypeName = typeName'  							Origin = null'  							GHPath = curves.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  				}  				obj = tempObjs;  			}  		} else {  			// Make sure all of the curves in each branch are closed  			bool allClosed = true;  			DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				List<GH_Curve> ghCrvs = curves.Branches [i];  				List<CurveCheck> checkedcurves = new List<CurveCheck> ();  				GH_Path path = new GH_Path (i);  				for (int j = 0; j < ghCrvs.Count; j++) {  					Curve c = ghCrvs [j].Value;  					if (c.IsClosed) {  						AreaMassProperties amp = AreaMassProperties.Compute (c);  						if (amp != null) {  							double area = amp.Area;  							CurveCheck cc = new CurveCheck (c' area);  							checkedcurves.Add (cc);  						}  					} else {  						allClosed = false;  					}  				}  				if (allClosed) {  					// Sort the curves by area  					checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  					checkedcurves.Reverse ();  					foreach (CurveCheck cc in checkedcurves) {  						crvTree.Add (cc' path);  					}  				}  			}  			if (allClosed) {  				// Determine if the smaller profiles are within the larger  				bool allInterior = true;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < crvTree.Branches.Count; i++) {  					try {  						List<int> crvSegmentIds = new List<int> ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						List<CurveCheck> checkedCrvs = crvTree.Branches [i];  						Curve outerProfile = checkedCrvs [0].Curve;  						double outerArea = checkedCrvs [0].Area;  						List<Curve> planarCurves = new List<Curve> ();  						planarCurves.Add (outerProfile);  						double innerArea = 0.0;  						for (int j = 1; j < checkedCrvs.Count; j++) {  							planarCurves.Add (checkedCrvs [j].Curve);  							innerArea += checkedCrvs [j].Area;  						}  						// Try to create a planar surface  						IEnumerable<Curve> surfCurves = planarCurves;  						Brep[] b = Brep.CreatePlanarBreps (surfCurves);  						if (b.Count () == 1) {  							// Test the areas  							double brepArea = b [0].GetArea ();  							double calcArea = outerArea - innerArea;  							double diff = (brepArea - calcArea) / calcArea;  							if (diff < 0.1) {  								// The profiles probably are all interior  								foreach (CurveCheck cc in checkedCrvs) {  									Curve c = cc.Curve;  									List<Curve> rCurves = new List<Curve> ();  									bool getCrvs = CurveSegments (rCurves' c' true);  									if (rCurves.Count > 0) {  										int crvSeg = rCurves.Count;  										crvSegmentIds.Add (crvSeg);  										foreach (Curve rc in rCurves) {  											LyrebirdCurve lbc;  											lbc = GetLBCurve (rc);  											lbCurves.Add (lbc);  										}  									}  								}  								RevitObject ro = new RevitObject ();  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = crvTree.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								ro.CurveIds = crvSegmentIds;  								tempObjs.Add (ro);  							}  						} else {  							allInterior = false;  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					} catch {  						allInterior = false;  						// Inform the user they need to graft their inputs.  Only one curve per branch  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				}  				if (tempObjs.Count > 0) {  					obj = tempObjs;  				}  			}  		}  	}  	#endregion  	// Orientation  	if (orientations != null && orientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignOrientation (obj' orientations);  		obj = tempList;  	}  	// face orientation  	if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  		obj = tempList;  	}  	// Parameters...  	if (Params.Input.Count > 6) {  		List<RevitObject> currentObjs = obj;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int r = 0; r < currentObjs.Count; r++) {  			RevitObject ro = currentObjs [r];  			List<RevitParameter> revitParams = new List<RevitParameter> ();  			for (int i = 6; i < Params.Input.Count; i++) {  				RevitParameter rp = new RevitParameter ();  				IGH_Param param = Params.Input [i];  				string paramInfo = param.Description;  				string[] pi = paramInfo.Split (new[] {  					"\n"'  					":"  				}' StringSplitOptions.None);  				string paramName = null;  				try {  					paramName = pi [1].Substring (1);  					string paramStorageType = pi [5].Substring (1);  					rp.ParameterName = paramName;  					rp.StorageType = paramStorageType;  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (paramName != null) {  					GH_Structure<IGH_Goo> data = null;  					try {  						DA.GetDataTree (i' out data);  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (data != null) {  						string value = null;  						try {  							value = data [r] [0].ToString ();  						} catch (Exception) {  							if (data.DataCount > 0)  								value = data [data.Branches.Count - 1] [0].ToString ();  						}  						//System.Windows.Forms.MessageBox.Show("Got the Value");  						if (value != null) {  							if (rp.StorageType == "ElementId") {  								string[] values = value.Split (new char[] {  									'''  								}' StringSplitOptions.None);  								rp.Value = values [values.Count () - 1];  							} else {  								rp.Value = value;  							}  							revitParams.Add (rp);  						}  					}  				}  			}  			ro.Parameters = revitParams;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}  	// Send the data to Revit to create and/or modify family instances.  	if (obj != null && obj.Count > 0) {  		try {  			string docName = channel.DocumentName ();  			if (docName == null || docName == string.Empty) {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			} else {  				string nn = NickName;  				if (nn == null || nn.Length == 0) {  					nn = "LBOut";  				}  				channel.CreateOrModify (obj' InstanceGuid' NickName);  				message = obj.Count.ToString () + " objects sent to the lyrebird server.";  			}  		} catch {  			message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  		}  	}  	channel.Dispose ();  	try {  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  } else {  	message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (documentName != null) {  	// Create RevitObjects  	List<RevitObject> obj = new List<RevitObject> ();  	#region OriginPoint Based  	if (origPoints != null && origPoints.Branches.Count > 0) {  		List<RevitObject> tempObjs = new List<RevitObject> ();  		// make sure the branches match the datacount  		if (origPoints.Branches.Count == origPoints.DataCount) {  			for (int i = 0; i < origPoints.Branches.Count; i++) {  				GH_Point ghpt = origPoints [i] [0];  				LyrebirdPoint point = new LyrebirdPoint {  					X = ghpt.Value.X'  					Y = ghpt.Value.Y'  					Z = ghpt.Value.Z  				};  				RevitObject ro = new RevitObject {  					Origin = point'  					FamilyName = familyName'  					TypeName = typeName'  					Category = category'  					CategoryId = categoryId'  					GHPath = origPoints.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		} else {  			// Inform the user they need to graft their inputs.  Only one point per branch  			System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  		}  	}   	#endregion  	#region AdaptiveComponents  	else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  		// generate adaptive components  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < adaptPoints.Branches.Count; i++) {  			RevitObject ro = new RevitObject ();  			List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  			for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  				LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  				points.Add (point);  			}  			ro.AdaptivePoints = points;  			ro.FamilyName = familyName;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.GHPath = adaptPoints.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}   	#endregion  	#region Curve Based  	else if (curves != null && curves.Branches.Count > 0) {  		// Get curves for curve based components  		// Determine if we're profile or line based  		if (curves.Branches.Count == curves.DataCount) {  			// Determine if the curve is a closed planar curve  			Curve tempCrv = curves.Branches [0] [0].Value;  			if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  				// Closed planar curve  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve crv = curves [i] [0].Value;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' crv' true);  					if (rCurves.Count > 0) {  						// Check if they're planar in the XY Plane  						List<double> endPointElevations = new List<double> ();  						foreach (Curve crvSegment in rCurves) {  							if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  								if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  									endPointElevations.Add (crvSegment.PointAtEnd.Z);  							}  						}  						if (endPointElevations.Count != 1) {  							// curves are planar in the XY plane  							foreach (Curve rCurveSegment in rCurves) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						} else {  							RevitObject ro = new RevitObject ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							for (int j = 0; j < rCurves.Count; j++) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rCurves [j]);  								lbCurves.Add (lbc);  							}  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					}  				}  				obj = tempObjs;  			} else if (!tempCrv.IsClosed) {  				// Line based.  Can only be arc or linear curves  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve ghc = curves.Branches [i] [0].Value;  					// Test that there is only one curve segment  					PolyCurve polycurve = ghc as PolyCurve;  					if (polycurve != null) {  						Curve[] segments = polycurve.Explode ();  						if (segments.Count () != 1) {  							foreach (Curve rCurveSegment in segments) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  							//break;  						}  					}  					if (ghc != null) {  						//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  						LyrebirdCurve lbc = GetLBCurve (ghc);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						RevitObject ro = new RevitObject {  							Curves = lbcurves'  							FamilyName = familyName'  							Category = category'  							CategoryId = categoryId'  							TypeName = typeName'  							Origin = null'  							GHPath = curves.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  				}  				obj = tempObjs;  			}  		} else {  			// Make sure all of the curves in each branch are closed  			bool allClosed = true;  			DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				List<GH_Curve> ghCrvs = curves.Branches [i];  				List<CurveCheck> checkedcurves = new List<CurveCheck> ();  				GH_Path path = new GH_Path (i);  				for (int j = 0; j < ghCrvs.Count; j++) {  					Curve c = ghCrvs [j].Value;  					if (c.IsClosed) {  						AreaMassProperties amp = AreaMassProperties.Compute (c);  						if (amp != null) {  							double area = amp.Area;  							CurveCheck cc = new CurveCheck (c' area);  							checkedcurves.Add (cc);  						}  					} else {  						allClosed = false;  					}  				}  				if (allClosed) {  					// Sort the curves by area  					checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  					checkedcurves.Reverse ();  					foreach (CurveCheck cc in checkedcurves) {  						crvTree.Add (cc' path);  					}  				}  			}  			if (allClosed) {  				// Determine if the smaller profiles are within the larger  				bool allInterior = true;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < crvTree.Branches.Count; i++) {  					try {  						List<int> crvSegmentIds = new List<int> ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						List<CurveCheck> checkedCrvs = crvTree.Branches [i];  						Curve outerProfile = checkedCrvs [0].Curve;  						double outerArea = checkedCrvs [0].Area;  						List<Curve> planarCurves = new List<Curve> ();  						planarCurves.Add (outerProfile);  						double innerArea = 0.0;  						for (int j = 1; j < checkedCrvs.Count; j++) {  							planarCurves.Add (checkedCrvs [j].Curve);  							innerArea += checkedCrvs [j].Area;  						}  						// Try to create a planar surface  						IEnumerable<Curve> surfCurves = planarCurves;  						Brep[] b = Brep.CreatePlanarBreps (surfCurves);  						if (b.Count () == 1) {  							// Test the areas  							double brepArea = b [0].GetArea ();  							double calcArea = outerArea - innerArea;  							double diff = (brepArea - calcArea) / calcArea;  							if (diff < 0.1) {  								// The profiles probably are all interior  								foreach (CurveCheck cc in checkedCrvs) {  									Curve c = cc.Curve;  									List<Curve> rCurves = new List<Curve> ();  									bool getCrvs = CurveSegments (rCurves' c' true);  									if (rCurves.Count > 0) {  										int crvSeg = rCurves.Count;  										crvSegmentIds.Add (crvSeg);  										foreach (Curve rc in rCurves) {  											LyrebirdCurve lbc;  											lbc = GetLBCurve (rc);  											lbCurves.Add (lbc);  										}  									}  								}  								RevitObject ro = new RevitObject ();  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = crvTree.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								ro.CurveIds = crvSegmentIds;  								tempObjs.Add (ro);  							}  						} else {  							allInterior = false;  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					} catch {  						allInterior = false;  						// Inform the user they need to graft their inputs.  Only one curve per branch  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				}  				if (tempObjs.Count > 0) {  					obj = tempObjs;  				}  			}  		}  	}  	#endregion  	// Orientation  	if (orientations != null && orientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignOrientation (obj' orientations);  		obj = tempList;  	}  	// face orientation  	if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  		obj = tempList;  	}  	// Parameters...  	if (Params.Input.Count > 6) {  		List<RevitObject> currentObjs = obj;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int r = 0; r < currentObjs.Count; r++) {  			RevitObject ro = currentObjs [r];  			List<RevitParameter> revitParams = new List<RevitParameter> ();  			for (int i = 6; i < Params.Input.Count; i++) {  				RevitParameter rp = new RevitParameter ();  				IGH_Param param = Params.Input [i];  				string paramInfo = param.Description;  				string[] pi = paramInfo.Split (new[] {  					"\n"'  					":"  				}' StringSplitOptions.None);  				string paramName = null;  				try {  					paramName = pi [1].Substring (1);  					string paramStorageType = pi [5].Substring (1);  					rp.ParameterName = paramName;  					rp.StorageType = paramStorageType;  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (paramName != null) {  					GH_Structure<IGH_Goo> data = null;  					try {  						DA.GetDataTree (i' out data);  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (data != null) {  						string value = null;  						try {  							value = data [r] [0].ToString ();  						} catch (Exception) {  							if (data.DataCount > 0)  								value = data [data.Branches.Count - 1] [0].ToString ();  						}  						//System.Windows.Forms.MessageBox.Show("Got the Value");  						if (value != null) {  							if (rp.StorageType == "ElementId") {  								string[] values = value.Split (new char[] {  									'''  								}' StringSplitOptions.None);  								rp.Value = values [values.Count () - 1];  							} else {  								rp.Value = value;  							}  							revitParams.Add (rp);  						}  					}  				}  			}  			ro.Parameters = revitParams;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}  	// Send the data to Revit to create and/or modify family instances.  	if (obj != null && obj.Count > 0) {  		try {  			string docName = channel.DocumentName ();  			if (docName == null || docName == string.Empty) {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			} else {  				string nn = NickName;  				if (nn == null || nn.Length == 0) {  					nn = "LBOut";  				}  				channel.CreateOrModify (obj' InstanceGuid' NickName);  				message = obj.Count.ToString () + " objects sent to the lyrebird server.";  			}  		} catch {  			message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  		}  	}  	channel.Dispose ();  	try {  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  } else {  	message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (documentName != null) {  	// Create RevitObjects  	List<RevitObject> obj = new List<RevitObject> ();  	#region OriginPoint Based  	if (origPoints != null && origPoints.Branches.Count > 0) {  		List<RevitObject> tempObjs = new List<RevitObject> ();  		// make sure the branches match the datacount  		if (origPoints.Branches.Count == origPoints.DataCount) {  			for (int i = 0; i < origPoints.Branches.Count; i++) {  				GH_Point ghpt = origPoints [i] [0];  				LyrebirdPoint point = new LyrebirdPoint {  					X = ghpt.Value.X'  					Y = ghpt.Value.Y'  					Z = ghpt.Value.Z  				};  				RevitObject ro = new RevitObject {  					Origin = point'  					FamilyName = familyName'  					TypeName = typeName'  					Category = category'  					CategoryId = categoryId'  					GHPath = origPoints.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		} else {  			// Inform the user they need to graft their inputs.  Only one point per branch  			System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  		}  	}   	#endregion  	#region AdaptiveComponents  	else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  		// generate adaptive components  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < adaptPoints.Branches.Count; i++) {  			RevitObject ro = new RevitObject ();  			List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  			for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  				LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  				points.Add (point);  			}  			ro.AdaptivePoints = points;  			ro.FamilyName = familyName;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.GHPath = adaptPoints.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}   	#endregion  	#region Curve Based  	else if (curves != null && curves.Branches.Count > 0) {  		// Get curves for curve based components  		// Determine if we're profile or line based  		if (curves.Branches.Count == curves.DataCount) {  			// Determine if the curve is a closed planar curve  			Curve tempCrv = curves.Branches [0] [0].Value;  			if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  				// Closed planar curve  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve crv = curves [i] [0].Value;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' crv' true);  					if (rCurves.Count > 0) {  						// Check if they're planar in the XY Plane  						List<double> endPointElevations = new List<double> ();  						foreach (Curve crvSegment in rCurves) {  							if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  								if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  									endPointElevations.Add (crvSegment.PointAtEnd.Z);  							}  						}  						if (endPointElevations.Count != 1) {  							// curves are planar in the XY plane  							foreach (Curve rCurveSegment in rCurves) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						} else {  							RevitObject ro = new RevitObject ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							for (int j = 0; j < rCurves.Count; j++) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rCurves [j]);  								lbCurves.Add (lbc);  							}  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					}  				}  				obj = tempObjs;  			} else if (!tempCrv.IsClosed) {  				// Line based.  Can only be arc or linear curves  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve ghc = curves.Branches [i] [0].Value;  					// Test that there is only one curve segment  					PolyCurve polycurve = ghc as PolyCurve;  					if (polycurve != null) {  						Curve[] segments = polycurve.Explode ();  						if (segments.Count () != 1) {  							foreach (Curve rCurveSegment in segments) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  							//break;  						}  					}  					if (ghc != null) {  						//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  						LyrebirdCurve lbc = GetLBCurve (ghc);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						RevitObject ro = new RevitObject {  							Curves = lbcurves'  							FamilyName = familyName'  							Category = category'  							CategoryId = categoryId'  							TypeName = typeName'  							Origin = null'  							GHPath = curves.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  				}  				obj = tempObjs;  			}  		} else {  			// Make sure all of the curves in each branch are closed  			bool allClosed = true;  			DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				List<GH_Curve> ghCrvs = curves.Branches [i];  				List<CurveCheck> checkedcurves = new List<CurveCheck> ();  				GH_Path path = new GH_Path (i);  				for (int j = 0; j < ghCrvs.Count; j++) {  					Curve c = ghCrvs [j].Value;  					if (c.IsClosed) {  						AreaMassProperties amp = AreaMassProperties.Compute (c);  						if (amp != null) {  							double area = amp.Area;  							CurveCheck cc = new CurveCheck (c' area);  							checkedcurves.Add (cc);  						}  					} else {  						allClosed = false;  					}  				}  				if (allClosed) {  					// Sort the curves by area  					checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  					checkedcurves.Reverse ();  					foreach (CurveCheck cc in checkedcurves) {  						crvTree.Add (cc' path);  					}  				}  			}  			if (allClosed) {  				// Determine if the smaller profiles are within the larger  				bool allInterior = true;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < crvTree.Branches.Count; i++) {  					try {  						List<int> crvSegmentIds = new List<int> ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						List<CurveCheck> checkedCrvs = crvTree.Branches [i];  						Curve outerProfile = checkedCrvs [0].Curve;  						double outerArea = checkedCrvs [0].Area;  						List<Curve> planarCurves = new List<Curve> ();  						planarCurves.Add (outerProfile);  						double innerArea = 0.0;  						for (int j = 1; j < checkedCrvs.Count; j++) {  							planarCurves.Add (checkedCrvs [j].Curve);  							innerArea += checkedCrvs [j].Area;  						}  						// Try to create a planar surface  						IEnumerable<Curve> surfCurves = planarCurves;  						Brep[] b = Brep.CreatePlanarBreps (surfCurves);  						if (b.Count () == 1) {  							// Test the areas  							double brepArea = b [0].GetArea ();  							double calcArea = outerArea - innerArea;  							double diff = (brepArea - calcArea) / calcArea;  							if (diff < 0.1) {  								// The profiles probably are all interior  								foreach (CurveCheck cc in checkedCrvs) {  									Curve c = cc.Curve;  									List<Curve> rCurves = new List<Curve> ();  									bool getCrvs = CurveSegments (rCurves' c' true);  									if (rCurves.Count > 0) {  										int crvSeg = rCurves.Count;  										crvSegmentIds.Add (crvSeg);  										foreach (Curve rc in rCurves) {  											LyrebirdCurve lbc;  											lbc = GetLBCurve (rc);  											lbCurves.Add (lbc);  										}  									}  								}  								RevitObject ro = new RevitObject ();  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = crvTree.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								ro.CurveIds = crvSegmentIds;  								tempObjs.Add (ro);  							}  						} else {  							allInterior = false;  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					} catch {  						allInterior = false;  						// Inform the user they need to graft their inputs.  Only one curve per branch  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				}  				if (tempObjs.Count > 0) {  					obj = tempObjs;  				}  			}  		}  	}  	#endregion  	// Orientation  	if (orientations != null && orientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignOrientation (obj' orientations);  		obj = tempList;  	}  	// face orientation  	if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  		obj = tempList;  	}  	// Parameters...  	if (Params.Input.Count > 6) {  		List<RevitObject> currentObjs = obj;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int r = 0; r < currentObjs.Count; r++) {  			RevitObject ro = currentObjs [r];  			List<RevitParameter> revitParams = new List<RevitParameter> ();  			for (int i = 6; i < Params.Input.Count; i++) {  				RevitParameter rp = new RevitParameter ();  				IGH_Param param = Params.Input [i];  				string paramInfo = param.Description;  				string[] pi = paramInfo.Split (new[] {  					"\n"'  					":"  				}' StringSplitOptions.None);  				string paramName = null;  				try {  					paramName = pi [1].Substring (1);  					string paramStorageType = pi [5].Substring (1);  					rp.ParameterName = paramName;  					rp.StorageType = paramStorageType;  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (paramName != null) {  					GH_Structure<IGH_Goo> data = null;  					try {  						DA.GetDataTree (i' out data);  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (data != null) {  						string value = null;  						try {  							value = data [r] [0].ToString ();  						} catch (Exception) {  							if (data.DataCount > 0)  								value = data [data.Branches.Count - 1] [0].ToString ();  						}  						//System.Windows.Forms.MessageBox.Show("Got the Value");  						if (value != null) {  							if (rp.StorageType == "ElementId") {  								string[] values = value.Split (new char[] {  									'''  								}' StringSplitOptions.None);  								rp.Value = values [values.Count () - 1];  							} else {  								rp.Value = value;  							}  							revitParams.Add (rp);  						}  					}  				}  			}  			ro.Parameters = revitParams;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}  	// Send the data to Revit to create and/or modify family instances.  	if (obj != null && obj.Count > 0) {  		try {  			string docName = channel.DocumentName ();  			if (docName == null || docName == string.Empty) {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			} else {  				string nn = NickName;  				if (nn == null || nn.Length == 0) {  					nn = "LBOut";  				}  				channel.CreateOrModify (obj' InstanceGuid' NickName);  				message = obj.Count.ToString () + " objects sent to the lyrebird server.";  			}  		} catch {  			message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  		}  	}  	channel.Dispose ();  	try {  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  } else {  	message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (documentName != null) {  	// Create RevitObjects  	List<RevitObject> obj = new List<RevitObject> ();  	#region OriginPoint Based  	if (origPoints != null && origPoints.Branches.Count > 0) {  		List<RevitObject> tempObjs = new List<RevitObject> ();  		// make sure the branches match the datacount  		if (origPoints.Branches.Count == origPoints.DataCount) {  			for (int i = 0; i < origPoints.Branches.Count; i++) {  				GH_Point ghpt = origPoints [i] [0];  				LyrebirdPoint point = new LyrebirdPoint {  					X = ghpt.Value.X'  					Y = ghpt.Value.Y'  					Z = ghpt.Value.Z  				};  				RevitObject ro = new RevitObject {  					Origin = point'  					FamilyName = familyName'  					TypeName = typeName'  					Category = category'  					CategoryId = categoryId'  					GHPath = origPoints.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		} else {  			// Inform the user they need to graft their inputs.  Only one point per branch  			System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  		}  	}   	#endregion  	#region AdaptiveComponents  	else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  		// generate adaptive components  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < adaptPoints.Branches.Count; i++) {  			RevitObject ro = new RevitObject ();  			List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  			for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  				LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  				points.Add (point);  			}  			ro.AdaptivePoints = points;  			ro.FamilyName = familyName;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.GHPath = adaptPoints.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}   	#endregion  	#region Curve Based  	else if (curves != null && curves.Branches.Count > 0) {  		// Get curves for curve based components  		// Determine if we're profile or line based  		if (curves.Branches.Count == curves.DataCount) {  			// Determine if the curve is a closed planar curve  			Curve tempCrv = curves.Branches [0] [0].Value;  			if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  				// Closed planar curve  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve crv = curves [i] [0].Value;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' crv' true);  					if (rCurves.Count > 0) {  						// Check if they're planar in the XY Plane  						List<double> endPointElevations = new List<double> ();  						foreach (Curve crvSegment in rCurves) {  							if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  								if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  									endPointElevations.Add (crvSegment.PointAtEnd.Z);  							}  						}  						if (endPointElevations.Count != 1) {  							// curves are planar in the XY plane  							foreach (Curve rCurveSegment in rCurves) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						} else {  							RevitObject ro = new RevitObject ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							for (int j = 0; j < rCurves.Count; j++) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rCurves [j]);  								lbCurves.Add (lbc);  							}  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					}  				}  				obj = tempObjs;  			} else if (!tempCrv.IsClosed) {  				// Line based.  Can only be arc or linear curves  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve ghc = curves.Branches [i] [0].Value;  					// Test that there is only one curve segment  					PolyCurve polycurve = ghc as PolyCurve;  					if (polycurve != null) {  						Curve[] segments = polycurve.Explode ();  						if (segments.Count () != 1) {  							foreach (Curve rCurveSegment in segments) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  							//break;  						}  					}  					if (ghc != null) {  						//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  						LyrebirdCurve lbc = GetLBCurve (ghc);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						RevitObject ro = new RevitObject {  							Curves = lbcurves'  							FamilyName = familyName'  							Category = category'  							CategoryId = categoryId'  							TypeName = typeName'  							Origin = null'  							GHPath = curves.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  				}  				obj = tempObjs;  			}  		} else {  			// Make sure all of the curves in each branch are closed  			bool allClosed = true;  			DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				List<GH_Curve> ghCrvs = curves.Branches [i];  				List<CurveCheck> checkedcurves = new List<CurveCheck> ();  				GH_Path path = new GH_Path (i);  				for (int j = 0; j < ghCrvs.Count; j++) {  					Curve c = ghCrvs [j].Value;  					if (c.IsClosed) {  						AreaMassProperties amp = AreaMassProperties.Compute (c);  						if (amp != null) {  							double area = amp.Area;  							CurveCheck cc = new CurveCheck (c' area);  							checkedcurves.Add (cc);  						}  					} else {  						allClosed = false;  					}  				}  				if (allClosed) {  					// Sort the curves by area  					checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  					checkedcurves.Reverse ();  					foreach (CurveCheck cc in checkedcurves) {  						crvTree.Add (cc' path);  					}  				}  			}  			if (allClosed) {  				// Determine if the smaller profiles are within the larger  				bool allInterior = true;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < crvTree.Branches.Count; i++) {  					try {  						List<int> crvSegmentIds = new List<int> ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						List<CurveCheck> checkedCrvs = crvTree.Branches [i];  						Curve outerProfile = checkedCrvs [0].Curve;  						double outerArea = checkedCrvs [0].Area;  						List<Curve> planarCurves = new List<Curve> ();  						planarCurves.Add (outerProfile);  						double innerArea = 0.0;  						for (int j = 1; j < checkedCrvs.Count; j++) {  							planarCurves.Add (checkedCrvs [j].Curve);  							innerArea += checkedCrvs [j].Area;  						}  						// Try to create a planar surface  						IEnumerable<Curve> surfCurves = planarCurves;  						Brep[] b = Brep.CreatePlanarBreps (surfCurves);  						if (b.Count () == 1) {  							// Test the areas  							double brepArea = b [0].GetArea ();  							double calcArea = outerArea - innerArea;  							double diff = (brepArea - calcArea) / calcArea;  							if (diff < 0.1) {  								// The profiles probably are all interior  								foreach (CurveCheck cc in checkedCrvs) {  									Curve c = cc.Curve;  									List<Curve> rCurves = new List<Curve> ();  									bool getCrvs = CurveSegments (rCurves' c' true);  									if (rCurves.Count > 0) {  										int crvSeg = rCurves.Count;  										crvSegmentIds.Add (crvSeg);  										foreach (Curve rc in rCurves) {  											LyrebirdCurve lbc;  											lbc = GetLBCurve (rc);  											lbCurves.Add (lbc);  										}  									}  								}  								RevitObject ro = new RevitObject ();  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = crvTree.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								ro.CurveIds = crvSegmentIds;  								tempObjs.Add (ro);  							}  						} else {  							allInterior = false;  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					} catch {  						allInterior = false;  						// Inform the user they need to graft their inputs.  Only one curve per branch  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				}  				if (tempObjs.Count > 0) {  					obj = tempObjs;  				}  			}  		}  	}  	#endregion  	// Orientation  	if (orientations != null && orientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignOrientation (obj' orientations);  		obj = tempList;  	}  	// face orientation  	if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  		obj = tempList;  	}  	// Parameters...  	if (Params.Input.Count > 6) {  		List<RevitObject> currentObjs = obj;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int r = 0; r < currentObjs.Count; r++) {  			RevitObject ro = currentObjs [r];  			List<RevitParameter> revitParams = new List<RevitParameter> ();  			for (int i = 6; i < Params.Input.Count; i++) {  				RevitParameter rp = new RevitParameter ();  				IGH_Param param = Params.Input [i];  				string paramInfo = param.Description;  				string[] pi = paramInfo.Split (new[] {  					"\n"'  					":"  				}' StringSplitOptions.None);  				string paramName = null;  				try {  					paramName = pi [1].Substring (1);  					string paramStorageType = pi [5].Substring (1);  					rp.ParameterName = paramName;  					rp.StorageType = paramStorageType;  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (paramName != null) {  					GH_Structure<IGH_Goo> data = null;  					try {  						DA.GetDataTree (i' out data);  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (data != null) {  						string value = null;  						try {  							value = data [r] [0].ToString ();  						} catch (Exception) {  							if (data.DataCount > 0)  								value = data [data.Branches.Count - 1] [0].ToString ();  						}  						//System.Windows.Forms.MessageBox.Show("Got the Value");  						if (value != null) {  							if (rp.StorageType == "ElementId") {  								string[] values = value.Split (new char[] {  									'''  								}' StringSplitOptions.None);  								rp.Value = values [values.Count () - 1];  							} else {  								rp.Value = value;  							}  							revitParams.Add (rp);  						}  					}  				}  			}  			ro.Parameters = revitParams;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}  	// Send the data to Revit to create and/or modify family instances.  	if (obj != null && obj.Count > 0) {  		try {  			string docName = channel.DocumentName ();  			if (docName == null || docName == string.Empty) {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			} else {  				string nn = NickName;  				if (nn == null || nn.Length == 0) {  					nn = "LBOut";  				}  				channel.CreateOrModify (obj' InstanceGuid' NickName);  				message = obj.Count.ToString () + " objects sent to the lyrebird server.";  			}  		} catch {  			message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  		}  	}  	channel.Dispose ();  	try {  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  } else {  	message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (documentName != null) {  	// Create RevitObjects  	List<RevitObject> obj = new List<RevitObject> ();  	#region OriginPoint Based  	if (origPoints != null && origPoints.Branches.Count > 0) {  		List<RevitObject> tempObjs = new List<RevitObject> ();  		// make sure the branches match the datacount  		if (origPoints.Branches.Count == origPoints.DataCount) {  			for (int i = 0; i < origPoints.Branches.Count; i++) {  				GH_Point ghpt = origPoints [i] [0];  				LyrebirdPoint point = new LyrebirdPoint {  					X = ghpt.Value.X'  					Y = ghpt.Value.Y'  					Z = ghpt.Value.Z  				};  				RevitObject ro = new RevitObject {  					Origin = point'  					FamilyName = familyName'  					TypeName = typeName'  					Category = category'  					CategoryId = categoryId'  					GHPath = origPoints.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  			obj = tempObjs;  		} else {  			// Inform the user they need to graft their inputs.  Only one point per branch  			System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  		}  	}   	#endregion  	#region AdaptiveComponents  	else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  		// generate adaptive components  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < adaptPoints.Branches.Count; i++) {  			RevitObject ro = new RevitObject ();  			List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  			for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  				LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  				points.Add (point);  			}  			ro.AdaptivePoints = points;  			ro.FamilyName = familyName;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.GHPath = adaptPoints.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}   	#endregion  	#region Curve Based  	else if (curves != null && curves.Branches.Count > 0) {  		// Get curves for curve based components  		// Determine if we're profile or line based  		if (curves.Branches.Count == curves.DataCount) {  			// Determine if the curve is a closed planar curve  			Curve tempCrv = curves.Branches [0] [0].Value;  			if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  				// Closed planar curve  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve crv = curves [i] [0].Value;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' crv' true);  					if (rCurves.Count > 0) {  						// Check if they're planar in the XY Plane  						List<double> endPointElevations = new List<double> ();  						foreach (Curve crvSegment in rCurves) {  							if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  								if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  									endPointElevations.Add (crvSegment.PointAtEnd.Z);  							}  						}  						if (endPointElevations.Count != 1) {  							// curves are planar in the XY plane  							foreach (Curve rCurveSegment in rCurves) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  						} else {  							RevitObject ro = new RevitObject ();  							List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  							for (int j = 0; j < rCurves.Count; j++) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rCurves [j]);  								lbCurves.Add (lbc);  							}  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					}  				}  				obj = tempObjs;  			} else if (!tempCrv.IsClosed) {  				// Line based.  Can only be arc or linear curves  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < curves.Branches.Count; i++) {  					Curve ghc = curves.Branches [i] [0].Value;  					// Test that there is only one curve segment  					PolyCurve polycurve = ghc as PolyCurve;  					if (polycurve != null) {  						Curve[] segments = polycurve.Explode ();  						if (segments.Count () != 1) {  							foreach (Curve rCurveSegment in segments) {  								RevitObject ro = new RevitObject ();  								LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  								List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  									lbc  								};  								ro.Curves = lbcurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = curves.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								tempObjs.Add (ro);  							}  							//break;  						}  					}  					if (ghc != null) {  						//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  						LyrebirdCurve lbc = GetLBCurve (ghc);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						RevitObject ro = new RevitObject {  							Curves = lbcurves'  							FamilyName = familyName'  							Category = category'  							CategoryId = categoryId'  							TypeName = typeName'  							Origin = null'  							GHPath = curves.Paths [i].ToString ()'  							GHScaleFactor = scale.ScaleFactor'  							GHScaleName = scale.ScaleName  						};  						tempObjs.Add (ro);  					}  				}  				obj = tempObjs;  			}  		} else {  			// Make sure all of the curves in each branch are closed  			bool allClosed = true;  			DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				List<GH_Curve> ghCrvs = curves.Branches [i];  				List<CurveCheck> checkedcurves = new List<CurveCheck> ();  				GH_Path path = new GH_Path (i);  				for (int j = 0; j < ghCrvs.Count; j++) {  					Curve c = ghCrvs [j].Value;  					if (c.IsClosed) {  						AreaMassProperties amp = AreaMassProperties.Compute (c);  						if (amp != null) {  							double area = amp.Area;  							CurveCheck cc = new CurveCheck (c' area);  							checkedcurves.Add (cc);  						}  					} else {  						allClosed = false;  					}  				}  				if (allClosed) {  					// Sort the curves by area  					checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  					checkedcurves.Reverse ();  					foreach (CurveCheck cc in checkedcurves) {  						crvTree.Add (cc' path);  					}  				}  			}  			if (allClosed) {  				// Determine if the smaller profiles are within the larger  				bool allInterior = true;  				List<RevitObject> tempObjs = new List<RevitObject> ();  				for (int i = 0; i < crvTree.Branches.Count; i++) {  					try {  						List<int> crvSegmentIds = new List<int> ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						List<CurveCheck> checkedCrvs = crvTree.Branches [i];  						Curve outerProfile = checkedCrvs [0].Curve;  						double outerArea = checkedCrvs [0].Area;  						List<Curve> planarCurves = new List<Curve> ();  						planarCurves.Add (outerProfile);  						double innerArea = 0.0;  						for (int j = 1; j < checkedCrvs.Count; j++) {  							planarCurves.Add (checkedCrvs [j].Curve);  							innerArea += checkedCrvs [j].Area;  						}  						// Try to create a planar surface  						IEnumerable<Curve> surfCurves = planarCurves;  						Brep[] b = Brep.CreatePlanarBreps (surfCurves);  						if (b.Count () == 1) {  							// Test the areas  							double brepArea = b [0].GetArea ();  							double calcArea = outerArea - innerArea;  							double diff = (brepArea - calcArea) / calcArea;  							if (diff < 0.1) {  								// The profiles probably are all interior  								foreach (CurveCheck cc in checkedCrvs) {  									Curve c = cc.Curve;  									List<Curve> rCurves = new List<Curve> ();  									bool getCrvs = CurveSegments (rCurves' c' true);  									if (rCurves.Count > 0) {  										int crvSeg = rCurves.Count;  										crvSegmentIds.Add (crvSeg);  										foreach (Curve rc in rCurves) {  											LyrebirdCurve lbc;  											lbc = GetLBCurve (rc);  											lbCurves.Add (lbc);  										}  									}  								}  								RevitObject ro = new RevitObject ();  								ro.Curves = lbCurves;  								ro.FamilyName = familyName;  								ro.Category = category;  								ro.CategoryId = categoryId;  								ro.TypeName = typeName;  								ro.Origin = null;  								ro.GHPath = crvTree.Paths [i].ToString ();  								ro.GHScaleFactor = scale.ScaleFactor;  								ro.GHScaleName = scale.ScaleName;  								ro.CurveIds = crvSegmentIds;  								tempObjs.Add (ro);  							}  						} else {  							allInterior = false;  							message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  						}  					} catch {  						allInterior = false;  						// Inform the user they need to graft their inputs.  Only one curve per branch  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				}  				if (tempObjs.Count > 0) {  					obj = tempObjs;  				}  			}  		}  	}  	#endregion  	// Orientation  	if (orientations != null && orientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignOrientation (obj' orientations);  		obj = tempList;  	}  	// face orientation  	if (faceOrientations != null && faceOrientations.Branches.Count > 0) {  		List<RevitObject> tempList = AssignFaceOrientation (obj' faceOrientations);  		obj = tempList;  	}  	// Parameters...  	if (Params.Input.Count > 6) {  		List<RevitObject> currentObjs = obj;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int r = 0; r < currentObjs.Count; r++) {  			RevitObject ro = currentObjs [r];  			List<RevitParameter> revitParams = new List<RevitParameter> ();  			for (int i = 6; i < Params.Input.Count; i++) {  				RevitParameter rp = new RevitParameter ();  				IGH_Param param = Params.Input [i];  				string paramInfo = param.Description;  				string[] pi = paramInfo.Split (new[] {  					"\n"'  					":"  				}' StringSplitOptions.None);  				string paramName = null;  				try {  					paramName = pi [1].Substring (1);  					string paramStorageType = pi [5].Substring (1);  					rp.ParameterName = paramName;  					rp.StorageType = paramStorageType;  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (paramName != null) {  					GH_Structure<IGH_Goo> data = null;  					try {  						DA.GetDataTree (i' out data);  					} catch (Exception ex) {  						Debug.WriteLine (ex.Message);  					}  					if (data != null) {  						string value = null;  						try {  							value = data [r] [0].ToString ();  						} catch (Exception) {  							if (data.DataCount > 0)  								value = data [data.Branches.Count - 1] [0].ToString ();  						}  						//System.Windows.Forms.MessageBox.Show("Got the Value");  						if (value != null) {  							if (rp.StorageType == "ElementId") {  								string[] values = value.Split (new char[] {  									'''  								}' StringSplitOptions.None);  								rp.Value = values [values.Count () - 1];  							} else {  								rp.Value = value;  							}  							revitParams.Add (rp);  						}  					}  				}  			}  			ro.Parameters = revitParams;  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	}  	// Send the data to Revit to create and/or modify family instances.  	if (obj != null && obj.Count > 0) {  		try {  			string docName = channel.DocumentName ();  			if (docName == null || docName == string.Empty) {  				message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  			} else {  				string nn = NickName;  				if (nn == null || nn.Length == 0) {  					nn = "LBOut";  				}  				channel.CreateOrModify (obj' InstanceGuid' NickName);  				message = obj.Count.ToString () + " objects sent to the lyrebird server.";  			}  		} catch {  			message = "Could not contact the lyrebird server.  Make sure it's running and try again.";  		}  	}  	channel.Dispose ();  	try {  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  } else {  	message = "Error\n" + "The Lyrebird Service could not be found.  Ensure Revit is running' the Lyrebird server plugin is installed' and the server is active.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (origPoints != null && origPoints.Branches.Count > 0) {  	List<RevitObject> tempObjs = new List<RevitObject> ();  	// make sure the branches match the datacount  	if (origPoints.Branches.Count == origPoints.DataCount) {  		for (int i = 0; i < origPoints.Branches.Count; i++) {  			GH_Point ghpt = origPoints [i] [0];  			LyrebirdPoint point = new LyrebirdPoint {  				X = ghpt.Value.X'  				Y = ghpt.Value.Y'  				Z = ghpt.Value.Z  			};  			RevitObject ro = new RevitObject {  				Origin = point'  				FamilyName = familyName'  				TypeName = typeName'  				Category = category'  				CategoryId = categoryId'  				GHPath = origPoints.Paths [i].ToString ()'  				GHScaleFactor = scale.ScaleFactor'  				GHScaleName = scale.ScaleName  			};  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	} else {  		// Inform the user they need to graft their inputs.  Only one point per branch  		System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  	}  }   #endregion  #region AdaptiveComponents  else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  	// generate adaptive components  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < adaptPoints.Branches.Count; i++) {  		RevitObject ro = new RevitObject ();  		List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  		for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  			LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  			points.Add (point);  		}  		ro.AdaptivePoints = points;  		ro.FamilyName = familyName;  		ro.TypeName = typeName;  		ro.Origin = null;  		ro.Category = category;  		ro.CategoryId = categoryId;  		ro.GHPath = adaptPoints.Paths [i].ToString ();  		ro.GHScaleFactor = scale.ScaleFactor;  		ro.GHScaleName = scale.ScaleName;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }   #endregion  #region Curve Based  else if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (origPoints != null && origPoints.Branches.Count > 0) {  	List<RevitObject> tempObjs = new List<RevitObject> ();  	// make sure the branches match the datacount  	if (origPoints.Branches.Count == origPoints.DataCount) {  		for (int i = 0; i < origPoints.Branches.Count; i++) {  			GH_Point ghpt = origPoints [i] [0];  			LyrebirdPoint point = new LyrebirdPoint {  				X = ghpt.Value.X'  				Y = ghpt.Value.Y'  				Z = ghpt.Value.Z  			};  			RevitObject ro = new RevitObject {  				Origin = point'  				FamilyName = familyName'  				TypeName = typeName'  				Category = category'  				CategoryId = categoryId'  				GHPath = origPoints.Paths [i].ToString ()'  				GHScaleFactor = scale.ScaleFactor'  				GHScaleName = scale.ScaleName  			};  			tempObjs.Add (ro);  		}  		obj = tempObjs;  	} else {  		// Inform the user they need to graft their inputs.  Only one point per branch  		System.Windows.Forms.MessageBox.Show ("Warning:\n\nEach Branch represents an object' " + "so origin point based elements should be grafted so that each point is on it's own branch.");  	}  }   #endregion  #region AdaptiveComponents  else if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  	// generate adaptive components  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < adaptPoints.Branches.Count; i++) {  		RevitObject ro = new RevitObject ();  		List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  		for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  			LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  			points.Add (point);  		}  		ro.AdaptivePoints = points;  		ro.FamilyName = familyName;  		ro.TypeName = typeName;  		ro.Origin = null;  		ro.Category = category;  		ro.CategoryId = categoryId;  		ro.GHPath = adaptPoints.Paths [i].ToString ();  		ro.GHScaleFactor = scale.ScaleFactor;  		ro.GHScaleName = scale.ScaleName;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }   #endregion  #region Curve Based  else if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  	// generate adaptive components  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < adaptPoints.Branches.Count; i++) {  		RevitObject ro = new RevitObject ();  		List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  		for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  			LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  			points.Add (point);  		}  		ro.AdaptivePoints = points;  		ro.FamilyName = familyName;  		ro.TypeName = typeName;  		ro.Origin = null;  		ro.Category = category;  		ro.CategoryId = categoryId;  		ro.GHPath = adaptPoints.Paths [i].ToString ();  		ro.GHScaleFactor = scale.ScaleFactor;  		ro.GHScaleName = scale.ScaleName;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }   #endregion  #region Curve Based  else if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (adaptPoints != null && adaptPoints.Branches.Count > 0) {  	// generate adaptive components  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < adaptPoints.Branches.Count; i++) {  		RevitObject ro = new RevitObject ();  		List<LyrebirdPoint> points = new List<LyrebirdPoint> ();  		for (int j = 0; j < adaptPoints.Branches [i].Count; j++) {  			LyrebirdPoint point = new LyrebirdPoint (adaptPoints.Branches [i] [j].Value.X' adaptPoints.Branches [i] [j].Value.Y' adaptPoints.Branches [i] [j].Value.Z);  			points.Add (point);  		}  		ro.AdaptivePoints = points;  		ro.FamilyName = familyName;  		ro.TypeName = typeName;  		ro.Origin = null;  		ro.Category = category;  		ro.CategoryId = categoryId;  		ro.GHPath = adaptPoints.Paths [i].ToString ();  		ro.GHScaleFactor = scale.ScaleFactor;  		ro.GHScaleName = scale.ScaleName;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }   #endregion  #region Curve Based  else if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (curves != null && curves.Branches.Count > 0) {  	// Get curves for curve based components  	// Determine if we're profile or line based  	if (curves.Branches.Count == curves.DataCount) {  		// Determine if the curve is a closed planar curve  		Curve tempCrv = curves.Branches [0] [0].Value;  		if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  			// Closed planar curve  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve crv = curves [i] [0].Value;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' crv' true);  				if (rCurves.Count > 0) {  					// Check if they're planar in the XY Plane  					List<double> endPointElevations = new List<double> ();  					foreach (Curve crvSegment in rCurves) {  						if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  							if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  								endPointElevations.Add (crvSegment.PointAtEnd.Z);  						}  					}  					if (endPointElevations.Count != 1) {  						// curves are planar in the XY plane  						foreach (Curve rCurveSegment in rCurves) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  					} else {  						RevitObject ro = new RevitObject ();  						List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  						for (int j = 0; j < rCurves.Count; j++) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rCurves [j]);  							lbCurves.Add (lbc);  						}  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				}  			}  			obj = tempObjs;  		} else if (!tempCrv.IsClosed) {  			// Line based.  Can only be arc or linear curves  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < curves.Branches.Count; i++) {  				Curve ghc = curves.Branches [i] [0].Value;  				// Test that there is only one curve segment  				PolyCurve polycurve = ghc as PolyCurve;  				if (polycurve != null) {  					Curve[] segments = polycurve.Explode ();  					if (segments.Count () != 1) {  						foreach (Curve rCurveSegment in segments) {  							RevitObject ro = new RevitObject ();  							LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  							List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  								lbc  							};  							ro.Curves = lbcurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = curves.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							tempObjs.Add (ro);  						}  						//break;  					}  				}  				if (ghc != null) {  					//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  					LyrebirdCurve lbc = GetLBCurve (ghc);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					RevitObject ro = new RevitObject {  						Curves = lbcurves'  						FamilyName = familyName'  						Category = category'  						CategoryId = categoryId'  						TypeName = typeName'  						Origin = null'  						GHPath = curves.Paths [i].ToString ()'  						GHScaleFactor = scale.ScaleFactor'  						GHScaleName = scale.ScaleName  					};  					tempObjs.Add (ro);  				}  			}  			obj = tempObjs;  		}  	} else {  		// Make sure all of the curves in each branch are closed  		bool allClosed = true;  		DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			List<GH_Curve> ghCrvs = curves.Branches [i];  			List<CurveCheck> checkedcurves = new List<CurveCheck> ();  			GH_Path path = new GH_Path (i);  			for (int j = 0; j < ghCrvs.Count; j++) {  				Curve c = ghCrvs [j].Value;  				if (c.IsClosed) {  					AreaMassProperties amp = AreaMassProperties.Compute (c);  					if (amp != null) {  						double area = amp.Area;  						CurveCheck cc = new CurveCheck (c' area);  						checkedcurves.Add (cc);  					}  				} else {  					allClosed = false;  				}  			}  			if (allClosed) {  				// Sort the curves by area  				checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  				checkedcurves.Reverse ();  				foreach (CurveCheck cc in checkedcurves) {  					crvTree.Add (cc' path);  				}  			}  		}  		if (allClosed) {  			// Determine if the smaller profiles are within the larger  			bool allInterior = true;  			List<RevitObject> tempObjs = new List<RevitObject> ();  			for (int i = 0; i < crvTree.Branches.Count; i++) {  				try {  					List<int> crvSegmentIds = new List<int> ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					List<CurveCheck> checkedCrvs = crvTree.Branches [i];  					Curve outerProfile = checkedCrvs [0].Curve;  					double outerArea = checkedCrvs [0].Area;  					List<Curve> planarCurves = new List<Curve> ();  					planarCurves.Add (outerProfile);  					double innerArea = 0.0;  					for (int j = 1; j < checkedCrvs.Count; j++) {  						planarCurves.Add (checkedCrvs [j].Curve);  						innerArea += checkedCrvs [j].Area;  					}  					// Try to create a planar surface  					IEnumerable<Curve> surfCurves = planarCurves;  					Brep[] b = Brep.CreatePlanarBreps (surfCurves);  					if (b.Count () == 1) {  						// Test the areas  						double brepArea = b [0].GetArea ();  						double calcArea = outerArea - innerArea;  						double diff = (brepArea - calcArea) / calcArea;  						if (diff < 0.1) {  							// The profiles probably are all interior  							foreach (CurveCheck cc in checkedCrvs) {  								Curve c = cc.Curve;  								List<Curve> rCurves = new List<Curve> ();  								bool getCrvs = CurveSegments (rCurves' c' true);  								if (rCurves.Count > 0) {  									int crvSeg = rCurves.Count;  									crvSegmentIds.Add (crvSeg);  									foreach (Curve rc in rCurves) {  										LyrebirdCurve lbc;  										lbc = GetLBCurve (rc);  										lbCurves.Add (lbc);  									}  								}  							}  							RevitObject ro = new RevitObject ();  							ro.Curves = lbCurves;  							ro.FamilyName = familyName;  							ro.Category = category;  							ro.CategoryId = categoryId;  							ro.TypeName = typeName;  							ro.Origin = null;  							ro.GHPath = crvTree.Paths [i].ToString ();  							ro.GHScaleFactor = scale.ScaleFactor;  							ro.GHScaleName = scale.ScaleName;  							ro.CurveIds = crvSegmentIds;  							tempObjs.Add (ro);  						}  					} else {  						allInterior = false;  						message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  					}  				} catch {  					allInterior = false;  					// Inform the user they need to graft their inputs.  Only one curve per branch  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			}  			if (tempObjs.Count > 0) {  				obj = tempObjs;  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (curves.Branches.Count == curves.DataCount) {  	// Determine if the curve is a closed planar curve  	Curve tempCrv = curves.Branches [0] [0].Value;  	if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  		// Closed planar curve  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			Curve crv = curves [i] [0].Value;  			List<Curve> rCurves = new List<Curve> ();  			bool getCrvs = CurveSegments (rCurves' crv' true);  			if (rCurves.Count > 0) {  				// Check if they're planar in the XY Plane  				List<double> endPointElevations = new List<double> ();  				foreach (Curve crvSegment in rCurves) {  					if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  						if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  							endPointElevations.Add (crvSegment.PointAtEnd.Z);  					}  				}  				if (endPointElevations.Count != 1) {  					// curves are planar in the XY plane  					foreach (Curve rCurveSegment in rCurves) {  						RevitObject ro = new RevitObject ();  						LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						ro.Curves = lbcurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				} else {  					RevitObject ro = new RevitObject ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					for (int j = 0; j < rCurves.Count; j++) {  						LyrebirdCurve lbc;  						lbc = GetLBCurve (rCurves [j]);  						lbCurves.Add (lbc);  					}  					ro.Curves = lbCurves;  					ro.FamilyName = familyName;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.GHPath = curves.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  			}  		}  		obj = tempObjs;  	} else if (!tempCrv.IsClosed) {  		// Line based.  Can only be arc or linear curves  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			Curve ghc = curves.Branches [i] [0].Value;  			// Test that there is only one curve segment  			PolyCurve polycurve = ghc as PolyCurve;  			if (polycurve != null) {  				Curve[] segments = polycurve.Explode ();  				if (segments.Count () != 1) {  					foreach (Curve rCurveSegment in segments) {  						RevitObject ro = new RevitObject ();  						LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						ro.Curves = lbcurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  					//break;  				}  			}  			if (ghc != null) {  				//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  				LyrebirdCurve lbc = GetLBCurve (ghc);  				List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  					lbc  				};  				RevitObject ro = new RevitObject {  					Curves = lbcurves'  					FamilyName = familyName'  					Category = category'  					CategoryId = categoryId'  					TypeName = typeName'  					Origin = null'  					GHPath = curves.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  		}  		obj = tempObjs;  	}  } else {  	// Make sure all of the curves in each branch are closed  	bool allClosed = true;  	DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  	for (int i = 0; i < curves.Branches.Count; i++) {  		List<GH_Curve> ghCrvs = curves.Branches [i];  		List<CurveCheck> checkedcurves = new List<CurveCheck> ();  		GH_Path path = new GH_Path (i);  		for (int j = 0; j < ghCrvs.Count; j++) {  			Curve c = ghCrvs [j].Value;  			if (c.IsClosed) {  				AreaMassProperties amp = AreaMassProperties.Compute (c);  				if (amp != null) {  					double area = amp.Area;  					CurveCheck cc = new CurveCheck (c' area);  					checkedcurves.Add (cc);  				}  			} else {  				allClosed = false;  			}  		}  		if (allClosed) {  			// Sort the curves by area  			checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  			checkedcurves.Reverse ();  			foreach (CurveCheck cc in checkedcurves) {  				crvTree.Add (cc' path);  			}  		}  	}  	if (allClosed) {  		// Determine if the smaller profiles are within the larger  		bool allInterior = true;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < crvTree.Branches.Count; i++) {  			try {  				List<int> crvSegmentIds = new List<int> ();  				List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  				List<CurveCheck> checkedCrvs = crvTree.Branches [i];  				Curve outerProfile = checkedCrvs [0].Curve;  				double outerArea = checkedCrvs [0].Area;  				List<Curve> planarCurves = new List<Curve> ();  				planarCurves.Add (outerProfile);  				double innerArea = 0.0;  				for (int j = 1; j < checkedCrvs.Count; j++) {  					planarCurves.Add (checkedCrvs [j].Curve);  					innerArea += checkedCrvs [j].Area;  				}  				// Try to create a planar surface  				IEnumerable<Curve> surfCurves = planarCurves;  				Brep[] b = Brep.CreatePlanarBreps (surfCurves);  				if (b.Count () == 1) {  					// Test the areas  					double brepArea = b [0].GetArea ();  					double calcArea = outerArea - innerArea;  					double diff = (brepArea - calcArea) / calcArea;  					if (diff < 0.1) {  						// The profiles probably are all interior  						foreach (CurveCheck cc in checkedCrvs) {  							Curve c = cc.Curve;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' c' true);  							if (rCurves.Count > 0) {  								int crvSeg = rCurves.Count;  								crvSegmentIds.Add (crvSeg);  								foreach (Curve rc in rCurves) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rc);  									lbCurves.Add (lbc);  								}  							}  						}  						RevitObject ro = new RevitObject ();  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = crvTree.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						ro.CurveIds = crvSegmentIds;  						tempObjs.Add (ro);  					}  				} else {  					allInterior = false;  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			} catch {  				allInterior = false;  				// Inform the user they need to graft their inputs.  Only one curve per branch  				message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  			}  		}  		if (tempObjs.Count > 0) {  			obj = tempObjs;  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (curves.Branches.Count == curves.DataCount) {  	// Determine if the curve is a closed planar curve  	Curve tempCrv = curves.Branches [0] [0].Value;  	if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  		// Closed planar curve  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			Curve crv = curves [i] [0].Value;  			List<Curve> rCurves = new List<Curve> ();  			bool getCrvs = CurveSegments (rCurves' crv' true);  			if (rCurves.Count > 0) {  				// Check if they're planar in the XY Plane  				List<double> endPointElevations = new List<double> ();  				foreach (Curve crvSegment in rCurves) {  					if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  						if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  							endPointElevations.Add (crvSegment.PointAtEnd.Z);  					}  				}  				if (endPointElevations.Count != 1) {  					// curves are planar in the XY plane  					foreach (Curve rCurveSegment in rCurves) {  						RevitObject ro = new RevitObject ();  						LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						ro.Curves = lbcurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  				} else {  					RevitObject ro = new RevitObject ();  					List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  					for (int j = 0; j < rCurves.Count; j++) {  						LyrebirdCurve lbc;  						lbc = GetLBCurve (rCurves [j]);  						lbCurves.Add (lbc);  					}  					ro.Curves = lbCurves;  					ro.FamilyName = familyName;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.GHPath = curves.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  			}  		}  		obj = tempObjs;  	} else if (!tempCrv.IsClosed) {  		// Line based.  Can only be arc or linear curves  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < curves.Branches.Count; i++) {  			Curve ghc = curves.Branches [i] [0].Value;  			// Test that there is only one curve segment  			PolyCurve polycurve = ghc as PolyCurve;  			if (polycurve != null) {  				Curve[] segments = polycurve.Explode ();  				if (segments.Count () != 1) {  					foreach (Curve rCurveSegment in segments) {  						RevitObject ro = new RevitObject ();  						LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  						List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  							lbc  						};  						ro.Curves = lbcurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = curves.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						tempObjs.Add (ro);  					}  					//break;  				}  			}  			if (ghc != null) {  				//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  				LyrebirdCurve lbc = GetLBCurve (ghc);  				List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  					lbc  				};  				RevitObject ro = new RevitObject {  					Curves = lbcurves'  					FamilyName = familyName'  					Category = category'  					CategoryId = categoryId'  					TypeName = typeName'  					Origin = null'  					GHPath = curves.Paths [i].ToString ()'  					GHScaleFactor = scale.ScaleFactor'  					GHScaleName = scale.ScaleName  				};  				tempObjs.Add (ro);  			}  		}  		obj = tempObjs;  	}  } else {  	// Make sure all of the curves in each branch are closed  	bool allClosed = true;  	DataTree<CurveCheck> crvTree = new DataTree<CurveCheck> ();  	for (int i = 0; i < curves.Branches.Count; i++) {  		List<GH_Curve> ghCrvs = curves.Branches [i];  		List<CurveCheck> checkedcurves = new List<CurveCheck> ();  		GH_Path path = new GH_Path (i);  		for (int j = 0; j < ghCrvs.Count; j++) {  			Curve c = ghCrvs [j].Value;  			if (c.IsClosed) {  				AreaMassProperties amp = AreaMassProperties.Compute (c);  				if (amp != null) {  					double area = amp.Area;  					CurveCheck cc = new CurveCheck (c' area);  					checkedcurves.Add (cc);  				}  			} else {  				allClosed = false;  			}  		}  		if (allClosed) {  			// Sort the curves by area  			checkedcurves.Sort ((x' y) => x.Area.CompareTo (y.Area));  			checkedcurves.Reverse ();  			foreach (CurveCheck cc in checkedcurves) {  				crvTree.Add (cc' path);  			}  		}  	}  	if (allClosed) {  		// Determine if the smaller profiles are within the larger  		bool allInterior = true;  		List<RevitObject> tempObjs = new List<RevitObject> ();  		for (int i = 0; i < crvTree.Branches.Count; i++) {  			try {  				List<int> crvSegmentIds = new List<int> ();  				List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  				List<CurveCheck> checkedCrvs = crvTree.Branches [i];  				Curve outerProfile = checkedCrvs [0].Curve;  				double outerArea = checkedCrvs [0].Area;  				List<Curve> planarCurves = new List<Curve> ();  				planarCurves.Add (outerProfile);  				double innerArea = 0.0;  				for (int j = 1; j < checkedCrvs.Count; j++) {  					planarCurves.Add (checkedCrvs [j].Curve);  					innerArea += checkedCrvs [j].Area;  				}  				// Try to create a planar surface  				IEnumerable<Curve> surfCurves = planarCurves;  				Brep[] b = Brep.CreatePlanarBreps (surfCurves);  				if (b.Count () == 1) {  					// Test the areas  					double brepArea = b [0].GetArea ();  					double calcArea = outerArea - innerArea;  					double diff = (brepArea - calcArea) / calcArea;  					if (diff < 0.1) {  						// The profiles probably are all interior  						foreach (CurveCheck cc in checkedCrvs) {  							Curve c = cc.Curve;  							List<Curve> rCurves = new List<Curve> ();  							bool getCrvs = CurveSegments (rCurves' c' true);  							if (rCurves.Count > 0) {  								int crvSeg = rCurves.Count;  								crvSegmentIds.Add (crvSeg);  								foreach (Curve rc in rCurves) {  									LyrebirdCurve lbc;  									lbc = GetLBCurve (rc);  									lbCurves.Add (lbc);  								}  							}  						}  						RevitObject ro = new RevitObject ();  						ro.Curves = lbCurves;  						ro.FamilyName = familyName;  						ro.Category = category;  						ro.CategoryId = categoryId;  						ro.TypeName = typeName;  						ro.Origin = null;  						ro.GHPath = crvTree.Paths [i].ToString ();  						ro.GHScaleFactor = scale.ScaleFactor;  						ro.GHScaleName = scale.ScaleName;  						ro.CurveIds = crvSegmentIds;  						tempObjs.Add (ro);  					}  				} else {  					allInterior = false;  					message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  				}  			} catch {  				allInterior = false;  				// Inform the user they need to graft their inputs.  Only one curve per branch  				message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  			}  		}  		if (tempObjs.Count > 0) {  			obj = tempObjs;  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (tempCrv.IsPlanar (0.00000001) && tempCrv.IsClosed) {  	// Closed planar curve  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < curves.Branches.Count; i++) {  		Curve crv = curves [i] [0].Value;  		List<Curve> rCurves = new List<Curve> ();  		bool getCrvs = CurveSegments (rCurves' crv' true);  		if (rCurves.Count > 0) {  			// Check if they're planar in the XY Plane  			List<double> endPointElevations = new List<double> ();  			foreach (Curve crvSegment in rCurves) {  				if (crvSegment.PointAtStart.Z == crvSegment.PointAtEnd.Z) {  					if (!endPointElevations.Contains (crvSegment.PointAtEnd.Z))  						endPointElevations.Add (crvSegment.PointAtEnd.Z);  				}  			}  			if (endPointElevations.Count != 1) {  				// curves are planar in the XY plane  				foreach (Curve rCurveSegment in rCurves) {  					RevitObject ro = new RevitObject ();  					LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					ro.Curves = lbcurves;  					ro.FamilyName = familyName;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.GHPath = curves.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  			} else {  				RevitObject ro = new RevitObject ();  				List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  				for (int j = 0; j < rCurves.Count; j++) {  					LyrebirdCurve lbc;  					lbc = GetLBCurve (rCurves [j]);  					lbCurves.Add (lbc);  				}  				ro.Curves = lbCurves;  				ro.FamilyName = familyName;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.GHPath = curves.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				tempObjs.Add (ro);  			}  		}  	}  	obj = tempObjs;  } else if (!tempCrv.IsClosed) {  	// Line based.  Can only be arc or linear curves  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < curves.Branches.Count; i++) {  		Curve ghc = curves.Branches [i] [0].Value;  		// Test that there is only one curve segment  		PolyCurve polycurve = ghc as PolyCurve;  		if (polycurve != null) {  			Curve[] segments = polycurve.Explode ();  			if (segments.Count () != 1) {  				foreach (Curve rCurveSegment in segments) {  					RevitObject ro = new RevitObject ();  					LyrebirdCurve lbc = GetLBCurve (rCurveSegment);  					List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  						lbc  					};  					ro.Curves = lbcurves;  					ro.FamilyName = familyName;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.GHPath = curves.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					tempObjs.Add (ro);  				}  				//break;  			}  		}  		if (ghc != null) {  			//List<LyrebirdPoint> points = new List<LyrebirdPoint>();  			LyrebirdCurve lbc = GetLBCurve (ghc);  			List<LyrebirdCurve> lbcurves = new List<LyrebirdCurve> {  				lbc  			};  			RevitObject ro = new RevitObject {  				Curves = lbcurves'  				FamilyName = familyName'  				Category = category'  				CategoryId = categoryId'  				TypeName = typeName'  				Origin = null'  				GHPath = curves.Paths [i].ToString ()'  				GHScaleFactor = scale.ScaleFactor'  				GHScaleName = scale.ScaleName  			};  			tempObjs.Add (ro);  		}  	}  	obj = tempObjs;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (allClosed) {  	// Determine if the smaller profiles are within the larger  	bool allInterior = true;  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int i = 0; i < crvTree.Branches.Count; i++) {  		try {  			List<int> crvSegmentIds = new List<int> ();  			List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  			List<CurveCheck> checkedCrvs = crvTree.Branches [i];  			Curve outerProfile = checkedCrvs [0].Curve;  			double outerArea = checkedCrvs [0].Area;  			List<Curve> planarCurves = new List<Curve> ();  			planarCurves.Add (outerProfile);  			double innerArea = 0.0;  			for (int j = 1; j < checkedCrvs.Count; j++) {  				planarCurves.Add (checkedCrvs [j].Curve);  				innerArea += checkedCrvs [j].Area;  			}  			// Try to create a planar surface  			IEnumerable<Curve> surfCurves = planarCurves;  			Brep[] b = Brep.CreatePlanarBreps (surfCurves);  			if (b.Count () == 1) {  				// Test the areas  				double brepArea = b [0].GetArea ();  				double calcArea = outerArea - innerArea;  				double diff = (brepArea - calcArea) / calcArea;  				if (diff < 0.1) {  					// The profiles probably are all interior  					foreach (CurveCheck cc in checkedCrvs) {  						Curve c = cc.Curve;  						List<Curve> rCurves = new List<Curve> ();  						bool getCrvs = CurveSegments (rCurves' c' true);  						if (rCurves.Count > 0) {  							int crvSeg = rCurves.Count;  							crvSegmentIds.Add (crvSeg);  							foreach (Curve rc in rCurves) {  								LyrebirdCurve lbc;  								lbc = GetLBCurve (rc);  								lbCurves.Add (lbc);  							}  						}  					}  					RevitObject ro = new RevitObject ();  					ro.Curves = lbCurves;  					ro.FamilyName = familyName;  					ro.Category = category;  					ro.CategoryId = categoryId;  					ro.TypeName = typeName;  					ro.Origin = null;  					ro.GHPath = crvTree.Paths [i].ToString ();  					ro.GHScaleFactor = scale.ScaleFactor;  					ro.GHScaleName = scale.ScaleName;  					ro.CurveIds = crvSegmentIds;  					tempObjs.Add (ro);  				}  			} else {  				allInterior = false;  				message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  			}  		} catch {  			allInterior = false;  			// Inform the user they need to graft their inputs.  Only one curve per branch  			message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  		}  	}  	if (tempObjs.Count > 0) {  		obj = tempObjs;  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: for (int i = 0; i < crvTree.Branches.Count; i++) {  	try {  		List<int> crvSegmentIds = new List<int> ();  		List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  		List<CurveCheck> checkedCrvs = crvTree.Branches [i];  		Curve outerProfile = checkedCrvs [0].Curve;  		double outerArea = checkedCrvs [0].Area;  		List<Curve> planarCurves = new List<Curve> ();  		planarCurves.Add (outerProfile);  		double innerArea = 0.0;  		for (int j = 1; j < checkedCrvs.Count; j++) {  			planarCurves.Add (checkedCrvs [j].Curve);  			innerArea += checkedCrvs [j].Area;  		}  		// Try to create a planar surface  		IEnumerable<Curve> surfCurves = planarCurves;  		Brep[] b = Brep.CreatePlanarBreps (surfCurves);  		if (b.Count () == 1) {  			// Test the areas  			double brepArea = b [0].GetArea ();  			double calcArea = outerArea - innerArea;  			double diff = (brepArea - calcArea) / calcArea;  			if (diff < 0.1) {  				// The profiles probably are all interior  				foreach (CurveCheck cc in checkedCrvs) {  					Curve c = cc.Curve;  					List<Curve> rCurves = new List<Curve> ();  					bool getCrvs = CurveSegments (rCurves' c' true);  					if (rCurves.Count > 0) {  						int crvSeg = rCurves.Count;  						crvSegmentIds.Add (crvSeg);  						foreach (Curve rc in rCurves) {  							LyrebirdCurve lbc;  							lbc = GetLBCurve (rc);  							lbCurves.Add (lbc);  						}  					}  				}  				RevitObject ro = new RevitObject ();  				ro.Curves = lbCurves;  				ro.FamilyName = familyName;  				ro.Category = category;  				ro.CategoryId = categoryId;  				ro.TypeName = typeName;  				ro.Origin = null;  				ro.GHPath = crvTree.Paths [i].ToString ();  				ro.GHScaleFactor = scale.ScaleFactor;  				ro.GHScaleName = scale.ScaleName;  				ro.CurveIds = crvSegmentIds;  				tempObjs.Add (ro);  			}  		} else {  			allInterior = false;  			message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  		}  	} catch {  		allInterior = false;  		// Inform the user they need to graft their inputs.  Only one curve per branch  		message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: try {  	List<int> crvSegmentIds = new List<int> ();  	List<LyrebirdCurve> lbCurves = new List<LyrebirdCurve> ();  	List<CurveCheck> checkedCrvs = crvTree.Branches [i];  	Curve outerProfile = checkedCrvs [0].Curve;  	double outerArea = checkedCrvs [0].Area;  	List<Curve> planarCurves = new List<Curve> ();  	planarCurves.Add (outerProfile);  	double innerArea = 0.0;  	for (int j = 1; j < checkedCrvs.Count; j++) {  		planarCurves.Add (checkedCrvs [j].Curve);  		innerArea += checkedCrvs [j].Area;  	}  	// Try to create a planar surface  	IEnumerable<Curve> surfCurves = planarCurves;  	Brep[] b = Brep.CreatePlanarBreps (surfCurves);  	if (b.Count () == 1) {  		// Test the areas  		double brepArea = b [0].GetArea ();  		double calcArea = outerArea - innerArea;  		double diff = (brepArea - calcArea) / calcArea;  		if (diff < 0.1) {  			// The profiles probably are all interior  			foreach (CurveCheck cc in checkedCrvs) {  				Curve c = cc.Curve;  				List<Curve> rCurves = new List<Curve> ();  				bool getCrvs = CurveSegments (rCurves' c' true);  				if (rCurves.Count > 0) {  					int crvSeg = rCurves.Count;  					crvSegmentIds.Add (crvSeg);  					foreach (Curve rc in rCurves) {  						LyrebirdCurve lbc;  						lbc = GetLBCurve (rc);  						lbCurves.Add (lbc);  					}  				}  			}  			RevitObject ro = new RevitObject ();  			ro.Curves = lbCurves;  			ro.FamilyName = familyName;  			ro.Category = category;  			ro.CategoryId = categoryId;  			ro.TypeName = typeName;  			ro.Origin = null;  			ro.GHPath = crvTree.Paths [i].ToString ();  			ro.GHScaleFactor = scale.ScaleFactor;  			ro.GHScaleName = scale.ScaleName;  			ro.CurveIds = crvSegmentIds;  			tempObjs.Add (ro);  		}  	} else {  		allInterior = false;  		message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  	}  } catch {  	allInterior = false;  	// Inform the user they need to graft their inputs.  Only one curve per branch  	message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (b.Count () == 1) {  	// Test the areas  	double brepArea = b [0].GetArea ();  	double calcArea = outerArea - innerArea;  	double diff = (brepArea - calcArea) / calcArea;  	if (diff < 0.1) {  		// The profiles probably are all interior  		foreach (CurveCheck cc in checkedCrvs) {  			Curve c = cc.Curve;  			List<Curve> rCurves = new List<Curve> ();  			bool getCrvs = CurveSegments (rCurves' c' true);  			if (rCurves.Count > 0) {  				int crvSeg = rCurves.Count;  				crvSegmentIds.Add (crvSeg);  				foreach (Curve rc in rCurves) {  					LyrebirdCurve lbc;  					lbc = GetLBCurve (rc);  					lbCurves.Add (lbc);  				}  			}  		}  		RevitObject ro = new RevitObject ();  		ro.Curves = lbCurves;  		ro.FamilyName = familyName;  		ro.Category = category;  		ro.CategoryId = categoryId;  		ro.TypeName = typeName;  		ro.Origin = null;  		ro.GHPath = crvTree.Paths [i].ToString ();  		ro.GHScaleFactor = scale.ScaleFactor;  		ro.GHScaleName = scale.ScaleName;  		ro.CurveIds = crvSegmentIds;  		tempObjs.Add (ro);  	}  } else {  	allInterior = false;  	message = "Warning:\n\nEach Branch represents an object' " + "so curve based elements should be grafted so that each curve is on it's own branch' or all curves on a branch should " + "be interior to the largest' outer boundary.";  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (diff < 0.1) {  	// The profiles probably are all interior  	foreach (CurveCheck cc in checkedCrvs) {  		Curve c = cc.Curve;  		List<Curve> rCurves = new List<Curve> ();  		bool getCrvs = CurveSegments (rCurves' c' true);  		if (rCurves.Count > 0) {  			int crvSeg = rCurves.Count;  			crvSegmentIds.Add (crvSeg);  			foreach (Curve rc in rCurves) {  				LyrebirdCurve lbc;  				lbc = GetLBCurve (rc);  				lbCurves.Add (lbc);  			}  		}  	}  	RevitObject ro = new RevitObject ();  	ro.Curves = lbCurves;  	ro.FamilyName = familyName;  	ro.Category = category;  	ro.CategoryId = categoryId;  	ro.TypeName = typeName;  	ro.Origin = null;  	ro.GHPath = crvTree.Paths [i].ToString ();  	ro.GHScaleFactor = scale.ScaleFactor;  	ro.GHScaleName = scale.ScaleName;  	ro.CurveIds = crvSegmentIds;  	tempObjs.Add (ro);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (Params.Input.Count > 6) {  	List<RevitObject> currentObjs = obj;  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int r = 0; r < currentObjs.Count; r++) {  		RevitObject ro = currentObjs [r];  		List<RevitParameter> revitParams = new List<RevitParameter> ();  		for (int i = 6; i < Params.Input.Count; i++) {  			RevitParameter rp = new RevitParameter ();  			IGH_Param param = Params.Input [i];  			string paramInfo = param.Description;  			string[] pi = paramInfo.Split (new[] {  				"\n"'  				":"  			}' StringSplitOptions.None);  			string paramName = null;  			try {  				paramName = pi [1].Substring (1);  				string paramStorageType = pi [5].Substring (1);  				rp.ParameterName = paramName;  				rp.StorageType = paramStorageType;  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  			if (paramName != null) {  				GH_Structure<IGH_Goo> data = null;  				try {  					DA.GetDataTree (i' out data);  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (data != null) {  					string value = null;  					try {  						value = data [r] [0].ToString ();  					} catch (Exception) {  						if (data.DataCount > 0)  							value = data [data.Branches.Count - 1] [0].ToString ();  					}  					//System.Windows.Forms.MessageBox.Show("Got the Value");  					if (value != null) {  						if (rp.StorageType == "ElementId") {  							string[] values = value.Split (new char[] {  								'''  							}' StringSplitOptions.None);  							rp.Value = values [values.Count () - 1];  						} else {  							rp.Value = value;  						}  						revitParams.Add (rp);  					}  				}  			}  		}  		ro.Parameters = revitParams;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (Params.Input.Count > 6) {  	List<RevitObject> currentObjs = obj;  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int r = 0; r < currentObjs.Count; r++) {  		RevitObject ro = currentObjs [r];  		List<RevitParameter> revitParams = new List<RevitParameter> ();  		for (int i = 6; i < Params.Input.Count; i++) {  			RevitParameter rp = new RevitParameter ();  			IGH_Param param = Params.Input [i];  			string paramInfo = param.Description;  			string[] pi = paramInfo.Split (new[] {  				"\n"'  				":"  			}' StringSplitOptions.None);  			string paramName = null;  			try {  				paramName = pi [1].Substring (1);  				string paramStorageType = pi [5].Substring (1);  				rp.ParameterName = paramName;  				rp.StorageType = paramStorageType;  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  			if (paramName != null) {  				GH_Structure<IGH_Goo> data = null;  				try {  					DA.GetDataTree (i' out data);  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (data != null) {  					string value = null;  					try {  						value = data [r] [0].ToString ();  					} catch (Exception) {  						if (data.DataCount > 0)  							value = data [data.Branches.Count - 1] [0].ToString ();  					}  					//System.Windows.Forms.MessageBox.Show("Got the Value");  					if (value != null) {  						if (rp.StorageType == "ElementId") {  							string[] values = value.Split (new char[] {  								'''  							}' StringSplitOptions.None);  							rp.Value = values [values.Count () - 1];  						} else {  							rp.Value = value;  						}  						revitParams.Add (rp);  					}  				}  			}  		}  		ro.Parameters = revitParams;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: if (Params.Input.Count > 6) {  	List<RevitObject> currentObjs = obj;  	List<RevitObject> tempObjs = new List<RevitObject> ();  	for (int r = 0; r < currentObjs.Count; r++) {  		RevitObject ro = currentObjs [r];  		List<RevitParameter> revitParams = new List<RevitParameter> ();  		for (int i = 6; i < Params.Input.Count; i++) {  			RevitParameter rp = new RevitParameter ();  			IGH_Param param = Params.Input [i];  			string paramInfo = param.Description;  			string[] pi = paramInfo.Split (new[] {  				"\n"'  				":"  			}' StringSplitOptions.None);  			string paramName = null;  			try {  				paramName = pi [1].Substring (1);  				string paramStorageType = pi [5].Substring (1);  				rp.ParameterName = paramName;  				rp.StorageType = paramStorageType;  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  			if (paramName != null) {  				GH_Structure<IGH_Goo> data = null;  				try {  					DA.GetDataTree (i' out data);  				} catch (Exception ex) {  					Debug.WriteLine (ex.Message);  				}  				if (data != null) {  					string value = null;  					try {  						value = data [r] [0].ToString ();  					} catch (Exception) {  						if (data.DataCount > 0)  							value = data [data.Branches.Count - 1] [0].ToString ();  					}  					//System.Windows.Forms.MessageBox.Show("Got the Value");  					if (value != null) {  						if (rp.StorageType == "ElementId") {  							string[] values = value.Split (new char[] {  								'''  							}' StringSplitOptions.None);  							rp.Value = values [values.Count () - 1];  						} else {  							rp.Value = value;  						}  						revitParams.Add (rp);  					}  				}  			}  		}  		ro.Parameters = revitParams;  		tempObjs.Add (ro);  	}  	obj = tempObjs;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: for (int r = 0; r < currentObjs.Count; r++) {  	RevitObject ro = currentObjs [r];  	List<RevitParameter> revitParams = new List<RevitParameter> ();  	for (int i = 6; i < Params.Input.Count; i++) {  		RevitParameter rp = new RevitParameter ();  		IGH_Param param = Params.Input [i];  		string paramInfo = param.Description;  		string[] pi = paramInfo.Split (new[] {  			"\n"'  			":"  		}' StringSplitOptions.None);  		string paramName = null;  		try {  			paramName = pi [1].Substring (1);  			string paramStorageType = pi [5].Substring (1);  			rp.ParameterName = paramName;  			rp.StorageType = paramStorageType;  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  		if (paramName != null) {  			GH_Structure<IGH_Goo> data = null;  			try {  				DA.GetDataTree (i' out data);  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  			if (data != null) {  				string value = null;  				try {  					value = data [r] [0].ToString ();  				} catch (Exception) {  					if (data.DataCount > 0)  						value = data [data.Branches.Count - 1] [0].ToString ();  				}  				//System.Windows.Forms.MessageBox.Show("Got the Value");  				if (value != null) {  					if (rp.StorageType == "ElementId") {  						string[] values = value.Split (new char[] {  							'''  						}' StringSplitOptions.None);  						rp.Value = values [values.Count () - 1];  					} else {  						rp.Value = value;  					}  					revitParams.Add (rp);  				}  			}  		}  	}  	ro.Parameters = revitParams;  	tempObjs.Add (ro);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: for (int r = 0; r < currentObjs.Count; r++) {  	RevitObject ro = currentObjs [r];  	List<RevitParameter> revitParams = new List<RevitParameter> ();  	for (int i = 6; i < Params.Input.Count; i++) {  		RevitParameter rp = new RevitParameter ();  		IGH_Param param = Params.Input [i];  		string paramInfo = param.Description;  		string[] pi = paramInfo.Split (new[] {  			"\n"'  			":"  		}' StringSplitOptions.None);  		string paramName = null;  		try {  			paramName = pi [1].Substring (1);  			string paramStorageType = pi [5].Substring (1);  			rp.ParameterName = paramName;  			rp.StorageType = paramStorageType;  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  		if (paramName != null) {  			GH_Structure<IGH_Goo> data = null;  			try {  				DA.GetDataTree (i' out data);  			} catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  			if (data != null) {  				string value = null;  				try {  					value = data [r] [0].ToString ();  				} catch (Exception) {  					if (data.DataCount > 0)  						value = data [data.Branches.Count - 1] [0].ToString ();  				}  				//System.Windows.Forms.MessageBox.Show("Got the Value");  				if (value != null) {  					if (rp.StorageType == "ElementId") {  						string[] values = value.Split (new char[] {  							'''  						}' StringSplitOptions.None);  						rp.Value = values [values.Count () - 1];  					} else {  						rp.Value = value;  					}  					revitParams.Add (rp);  				}  			}  		}  	}  	ro.Parameters = revitParams;  	tempObjs.Add (ro);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: for (int i = 6; i < Params.Input.Count; i++) {  	RevitParameter rp = new RevitParameter ();  	IGH_Param param = Params.Input [i];  	string paramInfo = param.Description;  	string[] pi = paramInfo.Split (new[] {  		"\n"'  		":"  	}' StringSplitOptions.None);  	string paramName = null;  	try {  		paramName = pi [1].Substring (1);  		string paramStorageType = pi [5].Substring (1);  		rp.ParameterName = paramName;  		rp.StorageType = paramStorageType;  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  	if (paramName != null) {  		GH_Structure<IGH_Goo> data = null;  		try {  			DA.GetDataTree (i' out data);  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  		if (data != null) {  			string value = null;  			try {  				value = data [r] [0].ToString ();  			} catch (Exception) {  				if (data.DataCount > 0)  					value = data [data.Branches.Count - 1] [0].ToString ();  			}  			//System.Windows.Forms.MessageBox.Show("Got the Value");  			if (value != null) {  				if (rp.StorageType == "ElementId") {  					string[] values = value.Split (new char[] {  						'''  					}' StringSplitOptions.None);  					rp.Value = values [values.Count () - 1];  				} else {  					rp.Value = value;  				}  				revitParams.Add (rp);  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: for (int i = 6; i < Params.Input.Count; i++) {  	RevitParameter rp = new RevitParameter ();  	IGH_Param param = Params.Input [i];  	string paramInfo = param.Description;  	string[] pi = paramInfo.Split (new[] {  		"\n"'  		":"  	}' StringSplitOptions.None);  	string paramName = null;  	try {  		paramName = pi [1].Substring (1);  		string paramStorageType = pi [5].Substring (1);  		rp.ParameterName = paramName;  		rp.StorageType = paramStorageType;  	} catch (Exception ex) {  		Debug.WriteLine (ex.Message);  	}  	if (paramName != null) {  		GH_Structure<IGH_Goo> data = null;  		try {  			DA.GetDataTree (i' out data);  		} catch (Exception ex) {  			Debug.WriteLine (ex.Message);  		}  		if (data != null) {  			string value = null;  			try {  				value = data [r] [0].ToString ();  			} catch (Exception) {  				if (data.DataCount > 0)  					value = data [data.Branches.Count - 1] [0].ToString ();  			}  			//System.Windows.Forms.MessageBox.Show("Got the Value");  			if (value != null) {  				if (rp.StorageType == "ElementId") {  					string[] values = value.Split (new char[] {  						'''  					}' StringSplitOptions.None);  					rp.Value = values [values.Count () - 1];  				} else {  					rp.Value = value;  				}  				revitParams.Add (rp);  			}  		}  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SolveInstance,The following statement contains a magic number: try {  	paramName = pi [1].Substring (1);  	string paramStorageType = pi [5].Substring (1);  	rp.ParameterName = paramName;  	rp.StorageType = paramStorageType;  } catch (Exception ex) {  	Debug.WriteLine (ex.Message);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,Menu_R2015Clicked,The following statement contains a magic number: appVersion = 2;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,Menu_R2016Clicked,The following statement contains a magic number: appVersion = 3;  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count == Params.Input.Count - 6) {  	// Parameters quantities match up with inputs' do nothing  	RefreshParameters ();  	return;  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count > Params.Input.Count - 6) {  	for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  		Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  			Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  			Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  			Optional = true'  			Access = GH_ParamAccess.tree  		};  		Params.RegisterInputParam (param);  	}  } // Remove unnecessay inputs  else if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: for (int i = Params.Input.Count + 1; i <= inputParameters.Count + 6; i++) {  	Grasshopper.Kernel.Parameters.Param_GenericObject param = new Grasshopper.Kernel.Parameters.Param_GenericObject {  		Name = "Parameter" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		NickName = "P" + (i - 6).ToString (CultureInfo.InvariantCulture)'  		Description = "Parameter Name: " + inputParameters [i - 7].ParameterName + "\nIs Type: " + inputParameters [i - 7].IsType.ToString () + "\nStorageType: " + inputParameters [i - 7].StorageType'  		Optional = true'  		Access = GH_ParamAccess.tree  	};  	Params.RegisterInputParam (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: if (inputParameters.Count < Params.Input.Count - 6) {  	while (Params.Input.Count > inputParameters.Count + 6) {  		IGH_Param param = Params.Input [Params.Input.Count - 1];  		Params.UnregisterInputParameter (param);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,SyncInputs,The following statement contains a magic number: while (Params.Input.Count > inputParameters.Count + 6) {  	IGH_Param param = Params.Input [Params.Input.Count - 1];  	Params.UnregisterInputParameter (param);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: for (int i = 0; i < inputParameters.Count; i++) {  	try {  		IGH_Param param = Params.Input [i + 6];  		if (paramNamesEnabled) {  			param.NickName = inputParameters [i].ParameterName;  		} else {  			bool renamed = false;  			try {  				int x = Convert.ToInt32 (param.NickName.Substring (1' 1));  			} catch {  				renamed = true;  			}  			if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  				param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  			}  		}  		param.Name = "Parameter" + (i + 1).ToString (CultureInfo.InvariantCulture);  		//param.NickName = "P" + (i + 1).ToString();  		param.Description = "Parameter Name: " + inputParameters [i].ParameterName + "\nIs Type: " + inputParameters [i].IsType.ToString () + "\nStorageType: " + inputParameters [i].StorageType;  		Params.RegisterInputParam (param);  	} catch (Exception ex) {  		System.Windows.Forms.MessageBox.Show (ex.Message);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: for (int i = 0; i < inputParameters.Count; i++) {  	try {  		IGH_Param param = Params.Input [i + 6];  		if (paramNamesEnabled) {  			param.NickName = inputParameters [i].ParameterName;  		} else {  			bool renamed = false;  			try {  				int x = Convert.ToInt32 (param.NickName.Substring (1' 1));  			} catch {  				renamed = true;  			}  			if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  				param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  			}  		}  		param.Name = "Parameter" + (i + 1).ToString (CultureInfo.InvariantCulture);  		//param.NickName = "P" + (i + 1).ToString();  		param.Description = "Parameter Name: " + inputParameters [i].ParameterName + "\nIs Type: " + inputParameters [i].IsType.ToString () + "\nStorageType: " + inputParameters [i].StorageType;  		Params.RegisterInputParam (param);  	} catch (Exception ex) {  		System.Windows.Forms.MessageBox.Show (ex.Message);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: try {  	IGH_Param param = Params.Input [i + 6];  	if (paramNamesEnabled) {  		param.NickName = inputParameters [i].ParameterName;  	} else {  		bool renamed = false;  		try {  			int x = Convert.ToInt32 (param.NickName.Substring (1' 1));  		} catch {  			renamed = true;  		}  		if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  			param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  		}  	}  	param.Name = "Parameter" + (i + 1).ToString (CultureInfo.InvariantCulture);  	//param.NickName = "P" + (i + 1).ToString();  	param.Description = "Parameter Name: " + inputParameters [i].ParameterName + "\nIs Type: " + inputParameters [i].IsType.ToString () + "\nStorageType: " + inputParameters [i].StorageType;  	Params.RegisterInputParam (param);  } catch (Exception ex) {  	System.Windows.Forms.MessageBox.Show (ex.Message);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: try {  	IGH_Param param = Params.Input [i + 6];  	if (paramNamesEnabled) {  		param.NickName = inputParameters [i].ParameterName;  	} else {  		bool renamed = false;  		try {  			int x = Convert.ToInt32 (param.NickName.Substring (1' 1));  		} catch {  			renamed = true;  		}  		if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  			param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  		}  	}  	param.Name = "Parameter" + (i + 1).ToString (CultureInfo.InvariantCulture);  	//param.NickName = "P" + (i + 1).ToString();  	param.Description = "Parameter Name: " + inputParameters [i].ParameterName + "\nIs Type: " + inputParameters [i].IsType.ToString () + "\nStorageType: " + inputParameters [i].StorageType;  	Params.RegisterInputParam (param);  } catch (Exception ex) {  	System.Windows.Forms.MessageBox.Show (ex.Message);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: if (paramNamesEnabled) {  	param.NickName = inputParameters [i].ParameterName;  } else {  	bool renamed = false;  	try {  		int x = Convert.ToInt32 (param.NickName.Substring (1' 1));  	} catch {  		renamed = true;  	}  	if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  		param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,RefreshParameters,The following statement contains a magic number: if (param.NickName.Length == 2 && param.NickName.Substring (0' 1) == "P" && !renamed) {  	param.NickName = "P" + (i + 1).ToString (CultureInfo.InvariantCulture);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsLinear ()) {  	// standard linear element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Line");  } else if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsCircle ()) {  	crv.Domain = new Interval (0' 1);  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Circle");  } else if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.25).X' crv.PointAt (0.25).Y' crv.PointAt (0.25).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.75).X' crv.PointAt (0.75).Y' crv.PointAt (0.75).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.IsArc ()) {  	crv.Domain = new Interval (0' 1);  	// standard arc element  	points.Add (new LyrebirdPoint (crv.PointAtStart.X' crv.PointAtStart.Y' crv.PointAtStart.Z));  	points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  	points.Add (new LyrebirdPoint (crv.PointAtEnd.X' crv.PointAtEnd.Y' crv.PointAtEnd.Z));  	lbc = new LyrebirdCurve (points' "Arc");  } else {  	// Spline  	// Old line: if (crv.Degree >= 3)  	if (crv.Degree == 3) {  		NurbsCurve nc = crv as NurbsCurve;  		if (nc != null) {  			List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  			List<double> weights = new List<double> ();  			List<double> knots = new List<double> ();  			foreach (ControlPoint cp in nc.Points) {  				LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  				double weight = cp.Weight;  				lbPoints.Add (pt);  				weights.Add (weight);  			}  			for (int k = 0; k < nc.Knots.Count; k++) {  				double knot = nc.Knots [k];  				// Add a duplicate knot for the first and last knot in the Rhino curve.  				// Revit needs 2 more knots than Rhino to define a spline.  				if (k == 0 || k == nc.Knots.Count - 1) {  					knots.Add (knot);  				}  				knots.Add (knot);  			}  			lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  				CurveType = "Spline"  			};  		}  	} else {  		const double incr = 1.0 / 100;  		List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		for (int i = 0; i <= 100; i++) {  			Point3d pt = crv.PointAtNormalizedLength (i * incr);  			LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  			weights.Add (1.0);  			pts.Add (lbp);  		}  		lbc = new LyrebirdCurve (pts' "Spline") {  			Weights = weights'  			Degree = crv.Degree  		};  	}  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: points.Add (new LyrebirdPoint (crv.PointAt (0.5).X' crv.PointAt (0.5).Y' crv.PointAt (0.5).Z));  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.Degree == 3) {  	NurbsCurve nc = crv as NurbsCurve;  	if (nc != null) {  		List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		List<double> knots = new List<double> ();  		foreach (ControlPoint cp in nc.Points) {  			LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  			double weight = cp.Weight;  			lbPoints.Add (pt);  			weights.Add (weight);  		}  		for (int k = 0; k < nc.Knots.Count; k++) {  			double knot = nc.Knots [k];  			// Add a duplicate knot for the first and last knot in the Rhino curve.  			// Revit needs 2 more knots than Rhino to define a spline.  			if (k == 0 || k == nc.Knots.Count - 1) {  				knots.Add (knot);  			}  			knots.Add (knot);  		}  		lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  			CurveType = "Spline"  		};  	}  } else {  	const double incr = 1.0 / 100;  	List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  	List<double> weights = new List<double> ();  	for (int i = 0; i <= 100; i++) {  		Point3d pt = crv.PointAtNormalizedLength (i * incr);  		LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  		weights.Add (1.0);  		pts.Add (lbp);  	}  	lbc = new LyrebirdCurve (pts' "Spline") {  		Weights = weights'  		Degree = crv.Degree  	};  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.Degree == 3) {  	NurbsCurve nc = crv as NurbsCurve;  	if (nc != null) {  		List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		List<double> knots = new List<double> ();  		foreach (ControlPoint cp in nc.Points) {  			LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  			double weight = cp.Weight;  			lbPoints.Add (pt);  			weights.Add (weight);  		}  		for (int k = 0; k < nc.Knots.Count; k++) {  			double knot = nc.Knots [k];  			// Add a duplicate knot for the first and last knot in the Rhino curve.  			// Revit needs 2 more knots than Rhino to define a spline.  			if (k == 0 || k == nc.Knots.Count - 1) {  				knots.Add (knot);  			}  			knots.Add (knot);  		}  		lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  			CurveType = "Spline"  		};  	}  } else {  	const double incr = 1.0 / 100;  	List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  	List<double> weights = new List<double> ();  	for (int i = 0; i <= 100; i++) {  		Point3d pt = crv.PointAtNormalizedLength (i * incr);  		LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  		weights.Add (1.0);  		pts.Add (lbp);  	}  	lbc = new LyrebirdCurve (pts' "Spline") {  		Weights = weights'  		Degree = crv.Degree  	};  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: if (crv.Degree == 3) {  	NurbsCurve nc = crv as NurbsCurve;  	if (nc != null) {  		List<LyrebirdPoint> lbPoints = new List<LyrebirdPoint> ();  		List<double> weights = new List<double> ();  		List<double> knots = new List<double> ();  		foreach (ControlPoint cp in nc.Points) {  			LyrebirdPoint pt = new LyrebirdPoint (cp.Location.X' cp.Location.Y' cp.Location.Z);  			double weight = cp.Weight;  			lbPoints.Add (pt);  			weights.Add (weight);  		}  		for (int k = 0; k < nc.Knots.Count; k++) {  			double knot = nc.Knots [k];  			// Add a duplicate knot for the first and last knot in the Rhino curve.  			// Revit needs 2 more knots than Rhino to define a spline.  			if (k == 0 || k == nc.Knots.Count - 1) {  				knots.Add (knot);  			}  			knots.Add (knot);  		}  		lbc = new LyrebirdCurve (lbPoints' weights' knots' nc.Degree' nc.IsPeriodic) {  			CurveType = "Spline"  		};  	}  } else {  	const double incr = 1.0 / 100;  	List<LyrebirdPoint> pts = new List<LyrebirdPoint> ();  	List<double> weights = new List<double> ();  	for (int i = 0; i <= 100; i++) {  		Point3d pt = crv.PointAtNormalizedLength (i * incr);  		LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  		weights.Add (1.0);  		pts.Add (lbp);  	}  	lbc = new LyrebirdCurve (pts' "Spline") {  		Weights = weights'  		Degree = crv.Degree  	};  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,GetLBCurve,The following statement contains a magic number: for (int i = 0; i <= 100; i++) {  	Point3d pt = crv.PointAtNormalizedLength (i * incr);  	LyrebirdPoint lbp = new LyrebirdPoint (pt.X' pt.Y' pt.Z);  	weights.Add (1.0);  	pts.Add (lbp);  }  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,CurveSegments,The following statement contains a magic number: do {  	double t;  	if (!nurbs.GetNextDiscontinuity (Continuity.C1_locus_continuous' t0' t1' out t)) {  		break;  	}  	Interval trim = new Interval (t0' t);  	if (trim.Length < 1e-10) {  		t0 = t;  		continue;  	}  	Curve M = nurbs.DuplicateCurve ();  	M = M.Trim (trim);  	if (M.IsValid) {  		L.Add (M);  	}  	t0 = t;  } while (true);  
Magic Number,LMNA.Lyrebird.GH,GHClient,F:\newReposMay17\logant_Lyrebird\GHClient\GHClient.cs,CurveSegments,The following statement contains a magic number: if (trim.Length < 1e-10) {  	t0 = t;  	continue;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: switch (units) {  case "None":  	scale = 1;  	break;  case "Microns":  	scale = 1000000;  	break;  case "Millimeters":  	scale = 1000;  	break;  case "Centimeters":  	scale = 100;  	break;  case "Meters":  	scale = 1;  	break;  case "Kilometers":  	scale = 0.001;  	break;  case "Microinches":  	scale = 39370100;  	break;  case "Mils":  	scale = 39370.0787;  	break;  case "Inches":  	scale = 39.3701;  	break;  case "Feet":  	scale = 3.28084;  	break;  case "Miles":  	scale = 0.000621371;  	break;  case "Angstroms":  	scale = 10000000000;  	break;  case "Nanometers":  	scale = 1000000000;  	break;  case "Decimeters":  	scale = 10;  	break;  case "Dekameters":  	scale = 0.1;  	break;  case "Hectometers":  	scale = 0.01;  	break;  case "Megameters":  	scale = 0.000001;  	break;  case "Gigameters":  	scale = 0.000000001;  	break;  case "Yards":  	scale = 1.09361;  	break;  case "PrinterPoint":  	scale = 1;  	break;  case "PrinterPica":  	scale = 1;  	break;  case "NauticalMile":  	scale = 0.000539957;  	break;  case "Astronomical":  	scale = 0.00000000000668458712;  	break;  case "Lightyears":  	scale = 0.000000000000000105702341;  	break;  case "Parsecs":  	scale = 0.0000000000000000324077929;  	break;  default:  	break;  }  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 1000000;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 1000;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 100;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.001;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 39370100;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 39370.0787;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 39.3701;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 3.28084;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.000621371;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 10000000000;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 1000000000;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 10;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.1;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.01;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.000001;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.000000001;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 1.09361;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.000539957;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.00000000000668458712;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.000000000000000105702341;  
Magic Number,LMNA.Lyrebird.GH,GHInfo,F:\newReposMay17\logant_Lyrebird\GHClient\GHInfo.cs,GetScale,The following statement contains a magic number: scale = 0.0000000000000000324077929;  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RevitCategoryElemComp,The following statement contains a magic number: if (appVersion == 1) {  	r2014 = true;  	r2015 = false;  	r2016 = false;  } else if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RevitCategoryElemComp,The following statement contains a magic number: if (appVersion == 1) {  	r2014 = true;  	r2015 = false;  	r2016 = false;  } else if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RevitCategoryElemComp,The following statement contains a magic number: if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RevitCategoryElemComp,The following statement contains a magic number: if (appVersion == 2) {  	r2014 = false;  	r2015 = true;  	r2016 = false;  } else if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RevitCategoryElemComp,The following statement contains a magic number: if (appVersion == 3) {  	r2014 = false;  	r2015 = false;  	r2016 = true;  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: pManager.AddIntegerParameter ("Category"' "C"' "1 = Images\n2 = Levels\n3 = Materials\n4 = Phases"' GH_ParamAccess.item' 3);  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: if (paramInt != null) {  	//paramInt.AddNamedValue("Design Options"' 0);  	paramInt.AddNamedValue ("Images"' 1);  	paramInt.AddNamedValue ("Levels"' 2);  	paramInt.AddNamedValue ("Materials"' 3);  	paramInt.AddNamedValue ("Phases"' 4);  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: if (paramInt != null) {  	//paramInt.AddNamedValue("Design Options"' 0);  	paramInt.AddNamedValue ("Images"' 1);  	paramInt.AddNamedValue ("Levels"' 2);  	paramInt.AddNamedValue ("Materials"' 3);  	paramInt.AddNamedValue ("Phases"' 4);  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: if (paramInt != null) {  	//paramInt.AddNamedValue("Design Options"' 0);  	paramInt.AddNamedValue ("Images"' 1);  	paramInt.AddNamedValue ("Levels"' 2);  	paramInt.AddNamedValue ("Materials"' 3);  	paramInt.AddNamedValue ("Phases"' 4);  }  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: paramInt.AddNamedValue ("Levels"' 2);  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: paramInt.AddNamedValue ("Materials"' 3);  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,RegisterInputParams,The following statement contains a magic number: paramInt.AddNamedValue ("Phases"' 4);  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,Menu_R2015Clicked,The following statement contains a magic number: appVersion = 2;  
Magic Number,LMNA.Lyrebird.GH,RevitCategoryElemComp,F:\newReposMay17\logant_Lyrebird\GHClient\RevitCategoryElements.cs,Menu_R2016Clicked,The following statement contains a magic number: appVersion = 3;  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SelectParameterForm,F:\newReposMay17\logant_Lyrebird\GHClient\SelectParameterForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,addButton_MouseEnter,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 180' 180' 180)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,SetRevitDataForm,F:\newReposMay17\logant_Lyrebird\GHClient\SetRevitDataForm.xaml.cs,EnterBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (255' 232' 232' 232)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 195' 195' 195)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 195' 195' 195)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 195' 195' 195)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 195' 195' 195)' 0.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 245' 245' 245)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 245' 245' 245)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 245' 245' 245)' 1.0));  
Magic Number,LMNA.Lyrebird.GH,UISettingsForm,F:\newReposMay17\logant_Lyrebird\GHClient\UISettingsForm.xaml.cs,EnterBrush,The following statement contains a magic number: b.GradientStops.Add (new GradientStop (System.Windows.Media.Color.FromArgb (255' 245' 245' 245)' 1.0));  
